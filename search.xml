<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多线程-AQS</title>
    <url>/2020/12/05/AQS/</url>
    <content><![CDATA[<h2 id="AQS-AbstractQueuedSynchronizer-抽象的队列式同步器"><a href="#AQS-AbstractQueuedSynchronizer-抽象的队列式同步器" class="headerlink" title="AQS (AbstractQueuedSynchronizer)抽象的队列式同步器"></a>AQS (AbstractQueuedSynchronizer)抽象的队列式同步器</h2><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E7%B1%BB%E4%B8%8Eaqs%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt=""></p>
<p>其中Sync及其子类NonfairSync、FairSync和node均为ReentrantLock的静态内部类</p>
<a id="more"></a>

<h3 id="一、AQS内部结构"><a href="#一、AQS内部结构" class="headerlink" title="一、AQS内部结构"></a>一、AQS内部结构</h3><h4 id="state："><a href="#state：" class="headerlink" title="state："></a>state：</h4><p>​        同步器状态，被volatile修饰，通过cas争抢状态</p>
<h4 id="exclusiveOwnerThread："><a href="#exclusiveOwnerThread：" class="headerlink" title="exclusiveOwnerThread："></a>exclusiveOwnerThread：</h4><p>​        互斥锁持有的线程（AbstractOwnableSynchronizer的属性，aqs的父类）</p>
<h4 id="head："><a href="#head：" class="headerlink" title="head："></a>head：</h4><p>​        同步等待队列的头部，被volatile修饰</p>
<h4 id="tail："><a href="#tail：" class="headerlink" title="tail："></a>tail：</h4><p>​        同步等待队列的尾部，被volatile修饰</p>
<h4 id="node："><a href="#node：" class="headerlink" title="node："></a>node：</h4><p>​        AQS的静态内部类，CLH的基础节点</p>
<h3 id="二、Node内部结构"><a href="#二、Node内部结构" class="headerlink" title="二、Node内部结构"></a>二、Node内部结构</h3><h4 id="prev："><a href="#prev：" class="headerlink" title="prev："></a>prev：</h4><p>​        指向前一个node节点，被volatile修饰</p>
<h4 id="next："><a href="#next：" class="headerlink" title="next："></a>next：</h4><p>​        指向后一个node节点，被volatile修饰</p>
<h4 id="waitStatus："><a href="#waitStatus：" class="headerlink" title="waitStatus："></a>waitStatus：</h4><p>​        信号状态，默认是0，被volatile修饰</p>
<h5 id="CANCELLED-1："><a href="#CANCELLED-1：" class="headerlink" title="CANCELLED = 1："></a>CANCELLED = 1：</h5><p>​                        取消状态，当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后，节点将不会再变化</p>
<h5 id="SIGNAL-1："><a href="#SIGNAL-1：" class="headerlink" title="SIGNAL = -1："></a>SIGNAL = -1：</h5><p>​                        等待触发状态，后继节点在等待当前节点唤醒。后继节点入队后，会将前继节点的状态更新为SGNAL</p>
<h5 id="CONDITION-2："><a href="#CONDITION-2：" class="headerlink" title="CONDITION = -2："></a>CONDITION = -2：</h5><p>​                        节点等待在confition上，当其他线程调用confition的signal()方法后，CONDITION状态的节点将从等待队列转移到同步队列中</p>
<h5 id="PROPAGATE-3："><a href="#PROPAGATE-3：" class="headerlink" title="PROPAGATE = -3："></a>PROPAGATE = -3：</h5><p>​                        共享模式下，前继节点不仅会唤醒后继节点，同时也可能会唤醒后继节点的后继节点</p>
<h4 id="thread：当前节点关联的客户线程，被volatile修饰"><a href="#thread：当前节点关联的客户线程，被volatile修饰" class="headerlink" title="thread：当前节点关联的客户线程，被volatile修饰"></a>thread：当前节点关联的客户线程，被volatile修饰</h4><h3 id="三、执行流程"><a href="#三、执行流程" class="headerlink" title="三、执行流程"></a>三、执行流程</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="/images/多线程/AQS.png" style="zoom:200%;" />

<h4 id="lock-流程"><a href="#lock-流程" class="headerlink" title="lock()流程"></a>lock()流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sync的lock()</span><br><span class="line">	1 NonfairSync.lock() 非公平锁</span><br><span class="line">		2 调用父类aqs的compareAndSetState（第一次）cas争抢同步器状态，</span><br><span class="line">			1.1 成功，调用父类aos的setExclusiveOwnerThread(Thread.currentThread())，修改exclusiveOwnerThread为当前线程</span><br><span class="line">			1.2 失败，调用aqs的acquire()尝试争抢和排队  if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">				2.1 调用aqs的tryAcquire，进入子类reentrantLock的tryAcquire(arg)</span><br><span class="line">					2.1.1 调用NonfairSync的tryAcquire里面的nonfairTryAcquire(acquires)，尝试获取同步器状态</span><br><span class="line">						2.1.1.1 同步器状态为0，（第二次）cas争抢同步器状态</span><br><span class="line">							2.1.1.1.1 成功，设置AOS的exclusiveOwnerThread为当前线程，返回true，不进行排队</span><br><span class="line">							2.1.1.1.2 失败，返回false，进入排队</span><br><span class="line">						2.1.1.2 同步器状态不为0，AOS的exclusiveOwnerThread等于当前线程（一般为重入）</span><br><span class="line">							2.1.1.2.1 符合，同步器状态加1，返回true，不进行排队</span><br><span class="line">							2.1.1.2.2 不符合，返回false，进行排队</span><br><span class="line">				2.2 调用父类aqs的addWaiter(Node mode)，为当前线程创建排他的node节点</span><br><span class="line">					2.2.1 （旧）尾结点是否为空</span><br><span class="line">						2.2.1.1 （旧）尾结点不为空，当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">							2.2.1.1.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">								2.2.1.1.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点，等待加入队列</span><br><span class="line">								2.2.1.1.1.2 失败，往下执行，进入aqs的enq(node)</span><br><span class="line">						2.2.1.2 （旧）尾结点为空，往下执行，进入aqs的enq(node)</span><br><span class="line">					2.2.2 进入父类aqs的enq(node)，死循环</span><br><span class="line">						2.2.2.1 （旧）尾结点为空（说明该队列还没有初始化）</span><br><span class="line">							2.2.2.1.1 新创建node节点，cas设置为头结点</span><br><span class="line">								2.2.2.1.1 设置成功，尾结点等于头结点，相互指向，形成哨兵节点</span><br><span class="line">								2.2.2.1.2 设置失败，重新循环，进入2.2.2</span><br><span class="line">							2.2.2.1.2 （旧）尾结点不为空</span><br><span class="line">								2.2.2.1.2.1 当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">								2.2.2.1.2.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">									2.2.2.1.2.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点的上一节点（旧的尾结点），这里的返回只是为了退出2.2.2，等待加入队列</span><br><span class="line">									2.2.2.1.2.1.2 失败，重新循环，进入2.2.2</span><br><span class="line">									</span><br><span class="line">					2.2.3 返回当前线程节点，等待加入队列	</span><br><span class="line">				2.3 调用父类aqs的acquireQueued()，死循环</span><br><span class="line">					2.3.1 获取当前节点的前置节点</span><br><span class="line">					2.3.2 前置节点为头节点 &amp;&amp; 当前节点再次尝试获取同步器状态，tryAcquire(arg)参见2.1</span><br><span class="line">						2.3.2.1 成功，</span><br><span class="line">							2.3.2.1.1 调用父类aqs的setHead(node)当前节点设置为头节点，当前节点关联的线程赋值null，上一节点赋值null</span><br><span class="line">							2.3.2.1.2 前置节点的下一节点赋值null，辅助gc回收； 不执行finally &#123;if (failed)&#123;cancelAcquire(node);&#125;&#125;，返回false（也就是不中断），退出2.3</span><br><span class="line">					2.3.3 调用父类aqs的shouldParkAfterFailedAcquire(p, node)和parkAndCheckInterrupt()</span><br><span class="line">						2.3.3.1 shouldParkAfterFailedAcquire(p, node) 获取失败后park之前重置等待状态的方法</span><br><span class="line">							2.3.3.1.1 获取前置节点（当前节点的上一节点）的等待状态</span><br><span class="line">							2.3.3.1.2 等待状态等于-1时，返回true，前置节点还没有被触发，当前节点可以被park</span><br><span class="line">							2.3.3.1.3等待状态大于0时，前置节点处于取消状态，获取前置节点的上一节点作为当前节点的上一节点，再次判断状态，重复循环，等待状态不大于0是，此时的前置节点的下一节点为当前线程节点，返回false，继续2.3</span><br><span class="line">							2.3.3.1.4 等待状态不为以上两种时，cas将状态置为signal也就是-1，返回false，继续2.3</span><br><span class="line">						2.3.3.2 前者返回true，进入parkAndCheckInterrupt()</span><br><span class="line">							2.3.3.2.1 LockSupport.park(this);阻塞当前线程，等待唤醒，正式入队</span><br><span class="line">							2.3.3.2.2 return Thread.interrupted(); 检查被唤醒的线程有没有被中断</span><br><span class="line">								2.3.3.2.2.1 返回false，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">								2.3.3.2.2.2 返回true，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">				2.4 最终：当2.3.3.2.2之后的流程进入2.3.2尝试获取锁成功时，返回值决定是否调用selfInterrupt();</span><br></pre></td></tr></table></figure>



<h3 id="四、CLH双向队列"><a href="#四、CLH双向队列" class="headerlink" title="四、CLH双向队列"></a>四、CLH双向队列</h3><img src="/images/多线程/CLH.png" style="zoom:150%;" />

<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>AQS主要实现了一个状态和两个队列（等待队列、条件队列）</p>
<h4 id="5-1、状态变量state"><a href="#5-1、状态变量state" class="headerlink" title="5.1、状态变量state"></a>5.1、状态变量state</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-1、互斥锁"><a href="#5-1-1、互斥锁" class="headerlink" title="5.1.1、互斥锁"></a>5.1.1、互斥锁</h5><p>当AQS只实现互斥锁的时候，每次只要原子更新state的值从0为1成功，即获取到锁，可重入是通过不断把state原子更新加1实现的。</p>
<h5 id="5-1-2、互斥锁和共享锁"><a href="#5-1-2、互斥锁和共享锁" class="headerlink" title="5.1.2、互斥锁和共享锁"></a>5.1.2、互斥锁和共享锁</h5><p>当AQS需要同时实现互斥锁+共享锁的时候，低16位存储互斥锁状态，高16位存储共享锁的状态，主要用于实现读写锁。<br>互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其他线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁。<br>共享锁同时允许多个线程占有，只要有一个线程占有共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁。</p>
<h4 id="5-2、等待队列"><a href="#5-2、等待队列" class="headerlink" title="5.2、等待队列"></a>5.2、等待队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment">            +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">       head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">            +------+       +-----+       +-----+ </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>AQS中维护了一个等待队列，获取锁失败（非tryLock()）的线程都将进入这个队列中排队，等待锁释放后唤醒下一个排队的线程（互斥锁模式）。</p>
<h4 id="5-3、条件队列"><a href="#5-3、条件队列" class="headerlink" title="5.3、条件队列"></a>5.3、条件队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>AQS中还有另外一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。<br>ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，其他线程将signal这个队列的元素，将其移动到AQS的队列中，等待占有锁的线程释放锁后被唤醒<br>Condition典型的运用场景是在BlockingQueue中实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/05/30/ELK/</url>
    <content><![CDATA[<h2 id="一、什么是ELK？"><a href="#一、什么是ELK？" class="headerlink" title="一、什么是ELK？"></a>一、什么是ELK？</h2><ul>
<li>E：Elasticsearch-数据存储、分析</li>
<li>L：LogStash-数据采集</li>
<li>K：Kibana-数据展示</li>
</ul>
<p>由于Logstash在数据采集方面性能堪忧，所以一般来说在传统的ELK基础上还会引入Beats相关组件，用于采集信息，之后再传输给Logstash进行操作；</p>
<img src="/images/elk/elk-logstash/elk-03.png" style="zoom:67%;" />

<a id="more"></a>

<p>为何不直接将Beats采集的数据存入es呢？直接存入es使用其过滤功能有点大材小用，浪费es性能，所以仍需要Logstash作为数据的过滤层，同时Logstash中集成了很多第三方的插件。</p>
<hr>
<h2 id="二、elastic产品下载"><a href="#二、elastic产品下载" class="headerlink" title="二、elastic产品下载"></a>二、<a href="https://www.elastic.co/cn/downloads/" target="_blank" rel="noopener">elastic产品下载</a></h2><p>​    elasticsearch的安装部署参见-<a href="/2021/05/26/elasticsearch%EF%BC%88%E5%85%AB%EF%BC%89%E9%9B%86%E7%BE%A4/">elasticsearch(八)-集群</a>不在本文重新介绍，主要介绍ELK其余组件的安装部署</p>
<h2 id="三、Beats"><a href="#三、Beats" class="headerlink" title="三、Beats"></a>三、<a href="https://www.elastic.co/cn/beats/" target="_blank" rel="noopener">Beats</a></h2><p>基于golang语言开发，开源的、轻量级的日志收集器的统称。</p>
<h3 id="3-1、Filebeat"><a href="#3-1、Filebeat" class="headerlink" title="3.1、Filebeat"></a>3.1、<a href="https://www.elastic.co/cn/beats/filebeat" target="_blank" rel="noopener">Filebeat</a></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>文件日志监控采集 ，主要用于收集日志数据</p>
<img src="/images/elk/elk-logstash/elk-02.png" style="zoom: 67%;" />

<p>语法：yaml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">	<span class="string">-input_type:log</span></span><br><span class="line">	<span class="attr">paths:</span></span><br><span class="line">		<span class="string">-/var/log/apache/httpd-*.log</span></span><br><span class="line">	<span class="string">-input_type:log</span></span><br><span class="line">	<span class="attr">paths:</span></span><br><span class="line">		<span class="string">-var/log/messages</span></span><br><span class="line">		<span class="string">-var/log/*.log</span></span><br></pre></td></tr></table></figure>

<p> 支持的输入配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Azure Event Hub</span><br><span class="line">Cloud Foundry</span><br><span class="line">Container</span><br><span class="line">Docker</span><br><span class="line">Google Pub&#x2F;Sub</span><br><span class="line">HTTP JSON</span><br><span class="line">Kafka</span><br><span class="line">Log</span><br><span class="line">MQTT</span><br><span class="line">NetFlow</span><br><span class="line">Office 365 Management Activity API</span><br><span class="line">Redis</span><br><span class="line">S3</span><br><span class="line">Stdin</span><br><span class="line">Syslog</span><br><span class="line">TCP</span><br><span class="line">UDP</span><br></pre></td></tr></table></figure>

<p>输出配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a)支持的输出类型：</span><br><span class="line">Console</span><br><span class="line">Elasticsearch</span><br><span class="line">Logstash</span><br><span class="line">Kafka</span><br><span class="line">Redis</span><br><span class="line">File</span><br><span class="line">Elastic Cloud</span><br><span class="line"></span><br><span class="line">b)输出到Elasticsearch:</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;myEShost:9200&quot;]</span><br><span class="line">  username: &quot;filebeat_internal&quot;</span><br><span class="line">  password: &quot;YOUR_PASSWORD&quot; </span><br><span class="line">setup.kibana:</span><br><span class="line">  host: &quot;mykibanahost:5601&quot;</span><br><span class="line">  username: &quot;my_kibana_user&quot;  </span><br><span class="line">  password: &quot;YOUR_PASSWORD&quot;</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf filebeat-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">mv filebeat-7.7.0-linux-x86_64 filebeat-7.7.0</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#=========================== Filebeat inputs =============================</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="comment">#定义输入类型是log</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="comment"># 开启输入配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#配置输入log的来源路径,多个文件用-来分割</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line">  <span class="comment">#自定义当前采集的type的标签，可以用于logstash中进行逻辑归类输出到不同的目的地</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["test_tag"]</span></span><br><span class="line">  <span class="comment">#排除空行</span></span><br><span class="line">  <span class="attr">exclude_lines:</span> <span class="string">['^$']</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span> <span class="string">/usr/local/nginx/logs/access.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["nginx-tag"]</span></span><br><span class="line">  <span class="comment">#json的所有key都在一个大括号里</span></span><br><span class="line">  <span class="comment">#json.keys_under_root: true</span></span><br><span class="line">  <span class="comment">#当采集错误时增加一个error_key</span></span><br><span class="line">  <span class="comment">#json.add_error_key: true</span></span><br><span class="line">  <span class="comment">#当key值和系统key重复时覆盖</span></span><br><span class="line">  <span class="comment">#json.overwrite_keys: true</span></span><br><span class="line">  <span class="comment">#以json的格式输入日志</span></span><br><span class="line">  <span class="comment">#json.message_key: log</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span> <span class="string">/usr/local/mylog.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["mylog-tag"]</span></span><br><span class="line">  <span class="comment"># Multiline options</span></span><br><span class="line">  <span class="comment">#配置组合 1</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">pattern</span></span><br><span class="line">    <span class="comment">#非匹配到的内容往后追加  可选:before</span></span><br><span class="line">    <span class="attr">match:</span> <span class="string">after</span></span><br><span class="line">    <span class="comment">#配置组合 1</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">'^\['</span></span><br><span class="line">    <span class="comment"># true表示和正则表达式匹配的作为第一行，false表示和正则不匹配的作为第一行</span></span><br><span class="line">    <span class="attr">negate:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#配置组合2</span></span><br><span class="line">    <span class="comment">#匹配以空格开头的内容</span></span><br><span class="line">    <span class="comment">#pattern: '^[[:space:]]'</span></span><br><span class="line">    <span class="comment">#negate: false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#================================ Outputs =====================================</span></span><br><span class="line"><span class="comment">#-------------------------- Elasticsearch output ------------------------------</span></span><br><span class="line"><span class="comment"># 第一种输出方式：将采集结果输出到elasticsearch</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.131:9200"]</span></span><br><span class="line">  <span class="comment">#动态索引名称</span></span><br><span class="line">  <span class="comment">#index: "%&#123;[fields.log_type]&#125;-%&#123;[agent.version]&#125;-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  <span class="attr">indices:</span></span><br><span class="line">  	<span class="comment">#按照日志输出的级别归档到不同的index中</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"warning-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">	  <span class="attr">when.contains:</span></span><br><span class="line">	  <span class="attr">message:</span> <span class="string">"WARN"</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"error-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">"ERR"</span></span><br><span class="line">  <span class="comment">#protocol: "https"</span></span><br><span class="line">  <span class="comment">#api_key: "id:api_key"</span></span><br><span class="line">  <span class="comment">#username: "elastic"</span></span><br><span class="line">  <span class="comment">#password: "changeme"</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#----------------------------- Logstash output --------------------------------</span></span><br><span class="line"><span class="comment"># 第二种输出方式（优先）：将采集结果输出到logstash</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.133:5044"]</span></span><br><span class="line">  <span class="comment">#有多节点则开启负载均衡</span></span><br><span class="line">  <span class="comment">#loadbalance: true</span></span><br><span class="line">  <span class="comment">#索引名称</span></span><br><span class="line">  <span class="comment">#index: filebeat</span></span><br><span class="line">  <span class="comment"># Optional SSL. By default is off.</span></span><br><span class="line">  <span class="comment"># List of root certificates for HTTPS server verifications</span></span><br><span class="line">  <span class="comment">#ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Certificate for SSL client authentication</span></span><br><span class="line">  <span class="comment">#ssl.certificate: "/etc/pki/client/cert.pem"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Client Certificate Key</span></span><br><span class="line">  <span class="comment">#ssl.key: "/etc/pki/client/cert.key"</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/elk/filebeat-01.jpg" alt=""></p>
<p><img src="/images/elk/filebeat-02.jpg" alt=""></p>
<p>Filebeat是读取日志是会记录到读取日志的行号，当重启或者删除es的索引，他依旧会从记录的那一行之后开始读，曾经读取过的数据不会再次读取，若想要重新全量读取，则需要去把<code>data</code>文件夹的数据删除。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前台启动</span></span><br><span class="line">./filebeat -e -c ./filebeat.yml</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h4 id="问题-自动关闭"><a href="#问题-自动关闭" class="headerlink" title="问题-自动关闭"></a>问题-自动关闭</h4><p>通过后台启动命令来启动filebeat,第二天早上发现filebeat自动关闭</p>
<blockquote>
<p>在当shell中执行<code>后台启动命令</code>成功后，还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；如果在<code>后台启动命令</code>执行成功后直接点关闭程序按钮关闭终端的话，这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown，起不到关掉终端后调用程序继续后台运行的作用。</p>
<p>解决方案：通过exit命令退出shell客户端。在启动完filebeat之后，在crt输入exit退出，此时filebeat不会随着客户端的关闭而退出</p>
</blockquote>
<h3 id="3-2、Metricbeat"><a href="#3-2、Metricbeat" class="headerlink" title="3.2、Metricbeat"></a>3.2、<a href="https://www.elastic.co/products/beats/metricbeat" target="_blank" rel="noopener">Metricbeat</a></h3><p>进行指标采集，指标可以是系统的，也可以是众多中间件产品的，主要用于监控系统和软件的性能</p>
<h3 id="3-3、Packetbeat"><a href="#3-3、Packetbeat" class="headerlink" title="3.3、Packetbeat"></a>3.3、<a href="https://www.elastic.co/products/beats/packetbeat" target="_blank" rel="noopener">Packetbeat</a></h3><p>通过网络抓包、协议分析，基于协议和端口对一些系统通信进行监控和数据收集。是一个实时网络数据包分析器，可以将其与Elasticsearch一起使用，以提供应用程序监视和性能分析系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ICMP (v4 and v6)</span><br><span class="line">DHCP (v4)</span><br><span class="line">DNS</span><br><span class="line">HTTP</span><br><span class="line">AMQP 0.9.1</span><br><span class="line">Cassandra</span><br><span class="line">Mysql</span><br><span class="line">PostgreSQL</span><br><span class="line">Redis</span><br><span class="line">Thrift-RPC</span><br><span class="line">MongoDB</span><br><span class="line">Memcache</span><br><span class="line">NFS</span><br><span class="line">TLS</span><br></pre></td></tr></table></figure>

<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf packetbeat-7.12.1-linux-x86_64.tar.gz</span><br><span class="line">mv packetbeat-7.12.1-linux-x86_64 packetbeat-7.12.1</span><br></pre></td></tr></table></figure>

<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># =========================== Transaction protocols ============================</span></span><br><span class="line"><span class="attr">packetbeat.protocols:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">icmp</span> <span class="comment"># Enable ICMPv4 and ICMPv6 monitoring. The default is true.</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">amqp</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5672]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">cassandra</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[9042]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dhcpv4</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[67,</span> <span class="number">68</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dns</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[53]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[80,</span> <span class="number">8080</span><span class="string">,</span> <span class="number">8000</span><span class="string">,</span> <span class="number">5000</span><span class="string">,</span> <span class="number">8002</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">memcache</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[11211]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[3306,3307]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">pgsql</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5432]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[6379]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">thrift</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[9090]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[27017]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[2049]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">443</span>   <span class="comment"># HTTPS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">993</span>   <span class="comment"># IMAPS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">995</span>   <span class="comment"># POP3S</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5223</span>  <span class="comment"># XMPP over SSL</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8883</span>  <span class="comment"># Secure MQTT</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9243</span>  <span class="comment"># Elasticsearch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">sip</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5060]</span></span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># ---------------------------- Elasticsearch Output ----------------------------</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="comment"># Array of hosts to connect to.</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.131:9200"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Protocol - either `http` (default) or `https`.</span></span><br><span class="line">  <span class="comment">#protocol: "https"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Authentication credentials - either API key or username/password.</span></span><br><span class="line">  <span class="comment">#api_key: "id:api_key"</span></span><br><span class="line">  <span class="comment">#username: "elastic"</span></span><br><span class="line">  <span class="comment">#password: "changeme"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------ Logstash Output -------------------------------</span></span><br><span class="line"><span class="comment">#output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="comment">#hosts: ["localhost:5044"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Optional SSL. By default is off.</span></span><br><span class="line">  <span class="comment"># List of root certificates for HTTPS server verifications</span></span><br><span class="line">  <span class="comment">#ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Certificate for SSL client authentication</span></span><br><span class="line">  <span class="comment">#ssl.certificate: "/etc/pki/client/cert.pem"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Client Certificate Key</span></span><br><span class="line">  <span class="comment">#ssl.key: "/etc/pki/client/cert.key"</span></span><br></pre></td></tr></table></figure>

<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./packetbeat -e -c packetbeat.yml -strict.perms=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Logstash"><a href="#四、Logstash" class="headerlink" title="四、Logstash"></a>四、<a href="https://www.elastic.co/cn/downloads/past-releases#logstash" target="_blank" rel="noopener">Logstash</a></h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Logstash是开源的流数据处理、转换（解析）和发送引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源。</p>
<p>Logstash的数据处理过程主要包括：<strong>Inputs</strong>, <strong>Filters</strong>, <strong>Outputs</strong> 三部分</p>
<p><img src="/images/elk/elk-logstash/elk-01.png" alt=""></p>
<h4 id="Inputs"><a href="#Inputs" class="headerlink" title="Inputs"></a><strong>Inputs</strong></h4><p>用于从数据源获取数据，常见的插件如beats、file、kafka、rabbitmq、log4j、redis等。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a><strong>Filters</strong></h4><p>筛选器是Logstash管道中的数据处理器，input时会触发事件，触发filter对数据进行transport，即转换解析各种格式的数据，常见的过滤器插件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grok：解析和构造任意文本。是Logstash过滤器的基础，广泛用于从非结构化数据中导出结构，当前，Grok是Logstash中将非结构化日志数据解析为结构化和可查询内容的最佳方法。</span><br><span class="line">mutate：对事件字段执行常规转换。支持对事件中字段进行重命名，删除，替换和修改。</span><br><span class="line">date：把字符串类型的时间字段转换成时间戳类型</span><br><span class="line">drop：完全删除事件，例如调试事件。</span><br><span class="line">clone：复制事件，可能会添加或删除字段。</span><br><span class="line">geoip：添加有关IP地址地理位置的信息。</span><br></pre></td></tr></table></figure>

<h4 id="Outputs"><a href="#Outputs" class="headerlink" title="Outputs"></a><strong>Outputs</strong></h4><p>用于数据输出，常见的插件如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch：最高效、方便、易于查询的存储器，最有选择，官方推荐！</span><br><span class="line">file：将输出数据以文件的形式写入磁盘。stupid</span><br><span class="line">graphite：将事件数据发送到graphite，graphite是一种流行的开源工具，用于存储和绘制指标。http:&#x2F;&#x2F;graphite.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</span><br><span class="line">statsd：将事件数据发送到statsd，该服务“通过UDP侦听统计信息（如计数器和计时器），并将聚合发送到一个或多个可插拔后端服务”。</span><br></pre></td></tr></table></figure>

<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf logstash-7.12.1-linux-x86_64.tar.gz -C logstash-7.12.1</span><br><span class="line"></span><br><span class="line">vi config/jvm.option</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure>

<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sample Logstash configuration for creating a simple</span></span><br><span class="line"><span class="comment"># Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span></span><br><span class="line"><span class="comment"># ================================== input ===================================</span></span><br><span class="line"><span class="string">input</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">beats</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># ================================== output ===================================</span></span><br><span class="line"><span class="string">output</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="comment">#方式一</span></span><br><span class="line">  <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">    <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%&#123;[@metadata][beat]&#125;</span>-<span class="template-variable">%&#123;[@metadata][version]&#125;</span>-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="comment">#user =&gt; "elastic"</span></span><br><span class="line">    <span class="comment">#password =&gt; "changeme"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#方式二</span></span><br><span class="line">  <span class="comment">#除了输出到es中，还输出到控制台</span></span><br><span class="line">  <span class="string">stdout</span> <span class="string">&#123;codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span> <span class="string">&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#方式三</span></span><br><span class="line">  <span class="comment">#根据 beat中输入的数据携带的【tags】进行分类输出</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"test-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">  		<span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">    	<span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-test_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"nginx-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-nginx_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"mylog-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-mylog_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span> </span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================================== filter ===================================</span></span><br><span class="line"><span class="string">filter</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">grok</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="comment"># IP:grok提供的正则 client：提取数据后作为key</span></span><br><span class="line">    <span class="string">match</span> <span class="string">=&gt;</span> <span class="string">&#123;</span> <span class="string">"message"</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%&#123;IP:client&#125;</span> <span class="template-variable">%&#123;WORD:method&#125;</span> <span class="template-variable">%&#123;URIPATHPARAM:request&#125;</span> <span class="template-variable">%&#123;NUMBER:bytes&#125;</span> <span class="template-variable">%&#123;NUMBER:duration&#125;</span>"</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./logstash -f ../config/logstash-test.conf</span><br><span class="line">nohup ./logstash -f ../config/logstash-test.conf&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<h2 id="五、Kibana"><a href="#五、Kibana" class="headerlink" title="五、Kibana"></a>五、<a href="https://www.elastic.co/cn/downloads/past-releases#kibana" target="_blank" rel="noopener">Kibana</a></h2><p>对 Elasticsearch 数据进行可视化，进行高效的搜索、可视化、分析等各种操作。</p>
<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"192.168.243.131"</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line"><span class="comment">#elasticsearch.username: "kibana_system"</span></span><br><span class="line"><span class="comment">#elasticsearch.password: "pass"</span></span><br></pre></td></tr></table></figure>

<h3 id="启动错误"><a href="#启动错误" class="headerlink" title="启动错误"></a>启动错误</h3><p>当使用root账户执行启动命令<code>./kibana</code>会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kibana should not be run as root.  Use --allow-root to continue.</span><br></pre></td></tr></table></figure>

<p>因为Kibana与es一样，不能使用root用户启动，因为需要向es一样需要切换子账户启动，此时会报权限问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> log   [22:28:17.934] [fatal][root] Error: Unable to write Kibana UUID file, please check the uuid.server configuration value in kibana.yml and ensure Kibana has sufficient permissions to read &#x2F; write to this file. Error was: EACCES</span><br><span class="line">   at writeUuidToFile (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;resolve_uuid.js:101:11)</span><br><span class="line">   at resolveInstanceUuid (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;resolve_uuid.js:66:5)</span><br><span class="line">   at EnvironmentService.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;environment_service.js:51:17)</span><br><span class="line">   at Server.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;server.js:167:30)</span><br><span class="line">   at Root.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;root&#x2F;index.js:47:14)</span><br><span class="line">   at bootstrap (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;bootstrap.js:99:5)</span><br><span class="line">   at Command.&lt;anonymous&gt; (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;cli&#x2F;serve&#x2F;serve.js:169:5)</span><br><span class="line"></span><br><span class="line">FATAL  Error: Unable to write Kibana UUID file, please check the uuid.server configuration value in kibana.yml and ensure Kibana has sufficient permissions to read &#x2F; write to this file. Error was: EACCES</span><br></pre></td></tr></table></figure>

<p>需要切换root账户对子账户进行授权<code>chown -R elasticsearch kibana</code>，再切换子账户启动</p>
<h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nohup ./kibana &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="杀死程序"><a href="#杀死程序" class="headerlink" title="杀死程序"></a>杀死程序</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lsof -i:端口</span><br><span class="line"><span class="built_in">kill</span> -9  进程号</span><br></pre></td></tr></table></figure>

<h2 id="六、Head插件"><a href="#六、Head插件" class="headerlink" title="六、Head插件"></a>六、<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">Head插件</a></h2><h3 id="安装head"><a href="#安装head" class="headerlink" title="安装head"></a>安装head</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.git</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head&#x2F;archive&#x2F;master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure>

<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/latest-v14.x/node-v14.6.0-linux-x64.tar.gz</span><br><span class="line">tar -zxvf  node-v14.6.0-linux-x64.tar.gz</span><br><span class="line">mv node-v10.14.1node-v14.6.0-linux-x64 node-v14.6.0</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/node-v14.6.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NODE_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><p>添加<code>hostname:&#39;*&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vi Gruntfile.js</span><br><span class="line">connect: &#123;</span><br><span class="line">	server: &#123;</span><br><span class="line">		options: &#123;</span><br><span class="line">			hostname:<span class="string">'*'</span>,</span><br><span class="line">			port: <span class="number">9100</span>,</span><br><span class="line">			base: <span class="string">'.'</span>,</span><br><span class="line">			keepalive: <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-head/</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 前台运行</span></span><br><span class="line">npm run start</span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">nohup npm run start&gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p><code>npm install</code>出错</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! phantomjs-prebuilt@2.1.16 install: `node install.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the phantomjs-prebuilt@2.1.16 install script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2021-05-31T15_13_24_681Z-debug.log</span><br></pre></td></tr></table></figure>

<p>执行<code>npm install phantomjs-prebuilt@2.1.14 --ignore-scripts</code>之后再重新<code>npm install</code></p>
<h3 id="登录问题"><a href="#登录问题" class="headerlink" title="登录问题"></a>登录问题</h3><p>当es集群配置了密码访问时，需要执行以下操作：</p>
<ul>
<li>在es的master节点config/elasticsearch.yml上增加以下配置<br><code>http.cors.allow-headers:&quot;Authorization,X-Requested-With,Content-Length,Content-Type&quot;</code></li>
<li>在访问head插件页面的路径上加上<code>?auth_user=elastic&amp;auth_password=pwd</code></li>
</ul>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot国际化（i18n）</title>
    <url>/2020/12/12/Spring%20Boot%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88i18n%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>i18n是internationalization（国际化单词的缩写，i和n之间有18个字母）</p>
<a id="more"></a>

<h3 id="二、依赖"><a href="#二、依赖" class="headerlink" title="二、依赖"></a>二、依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只需要导入web包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三、语言配置文件"><a href="#三、语言配置文件" class="headerlink" title="三、语言配置文件"></a>三、语言配置文件</h3><p>创建配置文件存放不同语言的消息文本:</p>
<p><img src="/images/spring/message%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<h4 id="message-properties（此默认配置是必须的，兜底的配置）："><a href="#message-properties（此默认配置是必须的，兜底的配置）：" class="headerlink" title="message.properties（此默认配置是必须的，兜底的配置）："></a>message.properties（此默认配置是必须的，兜底的配置）：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">默认</span></span><br><span class="line"><span class="attr">abc</span>=<span class="string">默认abc</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">默认第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<h4 id="message-en-US-properties-英文配置-："><a href="#message-en-US-properties-英文配置-：" class="headerlink" title="message_en_US.properties(英文配置)："></a>message_en_US.properties(英文配置)：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">test&#123;0&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="message-zh-CN-properties-中文配置"><a href="#message-zh-CN-properties-中文配置" class="headerlink" title="message_zh_CN.properties(中文配置):"></a>message_zh_CN.properties(中文配置):</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">中文</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<p>当指定的语言文件中找不到对应的key时，会查询默认文件，如abc找到默认abc；默认文件也不存在时，会报<code>org.springframework.context.NoSuchMessageException: No message found under code &#39;a&#39; for locale &#39;&#39;.</code>这里的a就是操作的key</p>
<h3 id="四、yml配置"><a href="#四、yml配置" class="headerlink" title="四、yml配置"></a>四、yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-i18n</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">static/i18n/message</span> <span class="comment">#语言配置文件的基础名称（注意，message为语言配置文件的前缀）</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<h3 id="五、session默认解析器-指定默认的locale"><a href="#五、session默认解析器-指定默认的locale" class="headerlink" title="五、session默认解析器(指定默认的locale)"></a>五、session默认解析器(指定默认的locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	默认解析器 其中locale表示默认语言,当请求中未包含语种信息，则设置默认语种</span></span><br><span class="line"><span class="comment">     *	当前默认为CHINA,zh_CN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionLocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.CHINA);</span><br><span class="line">        <span class="keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、拦截器-设置客户端语言locale"><a href="#六、拦截器-设置客户端语言locale" class="headerlink" title="六、拦截器(设置客户端语言locale)"></a>六、拦截器(设置客户端语言locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String lang = request.getHeader(<span class="string">"lang"</span>);</span><br><span class="line">        <span class="comment">//拦截客户端传送的语言标识，获取对应的语言locale，没有传送则走默认</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(lang))&#123;</span><br><span class="line">            LocaleContextHolder.setLocale(<span class="keyword">new</span> Locale(lang));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、注册拦截器"><a href="#七、注册拦截器" class="headerlink" title="七、注册拦截器"></a>七、注册拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、控制器"><a href="#八、控制器" class="headerlink" title="八、控制器"></a>八、控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I18nController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/in"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数是语言配置的key、第二个参数是对象数组，对应语言包中的变量如&#123;0&#125;进行填充、第三个参数是语言区域对象</span></span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(param,<span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、工具类"><a href="#九、工具类" class="headerlink" title="九、工具类"></a>九、工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleMessageUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前区域上下文对应的语言</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前环境语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLanguage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocaleContextHolder.getLocale().getLanguage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h3><p>通过拦截器截取客户端放入head中的语言标识，生成对应的locale放入LocaleContextHolder中，线程走对应方法操作时，通过LocaleContextHolder.getLocale()可以获取其对应的语言区域，再从对应的语言配置文件获取文本。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>i18n</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>JackJson和FastJson常见操作</title>
    <url>/2020/11/29/JackJson%E5%92%8CFastJson%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="Jackjson"><a href="#Jackjson" class="headerlink" title="Jackjson"></a>Jackjson</h3><a id="more"></a>

<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//Include.ALWAYS  是序列化对像所有属性</span></span><br><span class="line"><span class="comment">//Include.NON_NULL 只有不为null的字段才被序列化</span></span><br><span class="line"><span class="comment">//Include.NON_EMPTY 如果为null或者 空字符串和空集合都不会被序列化</span></span><br><span class="line">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line"><span class="comment">//取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式</span></span><br><span class="line">objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//如果是空对象的时候,设置为false不抛异常,也就是对应的属性没有get方法,默认是true,即会抛异常</span></span><br><span class="line">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//反序列化的时候如果多了其他属性,不抛出异常  </span></span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">      <span class="comment"># 设置属性命名策略,对应jackson下PropertyNamingStrategy中的常量值，SNAKE_CASE-返回的json驼峰式转下划线，json body下划线传到后端自动转驼峰式</span></span><br><span class="line">      <span class="attr">property-naming-strategy:</span> <span class="string">SNAKE_CASE</span></span><br><span class="line">      <span class="comment"># 全局设置@JsonFormat的格式pattern</span></span><br><span class="line">      <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">      <span class="comment"># 当地时区</span></span><br><span class="line">      <span class="attr">locale:</span> <span class="string">zh</span></span><br><span class="line">      <span class="comment"># 设置全局时区</span></span><br><span class="line">      <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">      <span class="comment"># 常用，全局设置pojo或被@JsonInclude注解的属性的序列化方式</span></span><br><span class="line">      <span class="attr">default-property-inclusion:</span> <span class="string">NON_NULL</span> <span class="comment">#不为空的属性才会序列化,具体属性可看JsonInclude.Include</span></span><br><span class="line">      <span class="comment"># 常规默认,枚举类SerializationFeature中的枚举属性为key，值为boolean设置jackson序列化特性,具体key请看SerializationFeature源码</span></span><br><span class="line">      <span class="attr">serialization:</span></span><br><span class="line">        <span class="attr">WRITE_DATES_AS_TIMESTAMPS:</span> <span class="literal">true</span> <span class="comment"># 返回的java.util.date转换成timestamp</span></span><br><span class="line">        <span class="attr">FAIL_ON_EMPTY_BEANS:</span> <span class="literal">true</span> <span class="comment"># 对象为空时是否报错，默认true</span></span><br><span class="line">      <span class="comment"># 枚举类DeserializationFeature中的枚举属性为key，值为boolean设置jackson反序列化特性,具体key请看DeserializationFeature源码</span></span><br><span class="line">      <span class="attr">deserialization:</span></span><br><span class="line">        <span class="comment"># 常用,json中含pojo不存在属性时是否失败报错,默认true</span></span><br><span class="line">        <span class="attr">FAIL_ON_UNKNOWN_PROPERTIES:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 枚举类MapperFeature中的枚举属性为key，值为boolean设置jackson ObjectMapper特性</span></span><br><span class="line">      <span class="comment"># ObjectMapper在jackson中负责json的读写、json与pojo的互转、json tree的互转,具体特性请看MapperFeature,常规默认即可</span></span><br><span class="line">      <span class="attr">mapper:</span></span><br><span class="line">        <span class="comment"># 使用getter取代setter探测属性，如类中含getName()但不包含name属性与setName()，传输的vo json格式模板中依旧含name属性</span></span><br><span class="line">        <span class="attr">USE_GETTERS_AS_SETTERS:</span> <span class="literal">true</span> <span class="comment">#默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonParser.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonParser特性</span></span><br><span class="line">      <span class="comment"># JsonParser在jackson中负责json内容的读取,具体特性请看JsonParser.Feature，一般无需设置默认即可</span></span><br><span class="line">      <span class="attr">parser:</span></span><br><span class="line">        <span class="attr">ALLOW_SINGLE_QUOTES:</span> <span class="literal">true</span> <span class="comment"># 是否允许出现单引号,默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonGenerator特性，一般无需设置默认即可</span></span><br><span class="line">      <span class="comment"># JsonGenerator在jackson中负责编写json内容,具体特性请看JsonGenerator.Feature</span></span><br></pre></td></tr></table></figure>



<p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map转对象</span></span><br><span class="line">System.out.println(<span class="string">"====  map-&gt;对象 ====="</span>);</span><br><span class="line">User user = objectMapper.convertValue(map, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将对象写成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map);</span><br><span class="line">System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//json串转换成json节点对象</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;json节点对象  ====="</span>);</span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(jsonStr);</span><br><span class="line">System.out.println(jsonNode);</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"name"</span>).asText());</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"age"</span>).asInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Map param = objectMapper.readValue(jsonStr, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Person person = objectMapper.readValue(jsonStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(param);</span><br><span class="line">System.out.println(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line">String listStr = objectMapper.writeValueAsString(list);</span><br><span class="line"><span class="comment">//no.1</span></span><br><span class="line">JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List<span class="class">.<span class="keyword">class</span>, <span class="title">Person</span>.<span class="title">class</span>)</span>;</span><br><span class="line">List&lt;Person&gt; persons =  (List&lt;Person&gt;)objectMapper.readValue(listStr, javaType);</span><br><span class="line">System.out.println(persons);</span><br><span class="line"><span class="comment">//no.2</span></span><br><span class="line">List&lt;Person&gt; persons2 = objectMapper.readValue(listStr, <span class="keyword">new</span> TypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//xml转成对象</span></span><br><span class="line"><span class="comment">//对象需加上注解映射@JacksonXmlRootElement、@JacksonXmlProperty、@JacksonXmlElementWrapper、@JacksonXmlCData、@JacksonXmlText</span></span><br><span class="line">System.out.println(<span class="string">"==== xml串 --&gt; 对象 ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">User user = xmlMapper.readValue(xml, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//对象转成xml</span></span><br><span class="line">System.out.println(<span class="string">"==== 对象 --&gt; xml ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">String xmlStr = xmlMapper.writeValueAsString(user)</span><br></pre></td></tr></table></figure>

<h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将对象转换成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">24</span>);</span><br><span class="line">String jsonString = JSON.toJSONString(p);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Person person = JSON.parseObject(jsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Map map = JSON.parseObject(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonString);</span><br><span class="line">System.out.println(person);</span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(jsonObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(p);</span><br><span class="line">String listStr = JSON.toJSONString(list);</span><br><span class="line">List&lt;Person&gt; peoples = JSON.parseArray(listStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONArray jsonArray = JSON.parseArray(listStr);</span><br><span class="line">System.out.println(peoples);</span><br><span class="line">System.out.println(jsonArray);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConverterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">fastJsonHttpMessageConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.定义一个converters转换消息的对象</span></span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="comment">// 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据</span></span><br><span class="line">        FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</span><br><span class="line">        <span class="comment">// 3.在converter中添加配置信息</span></span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        <span class="comment">// 4.将converter赋值给HttpMessageConverter</span></span><br><span class="line">        HttpMessageConverter&lt;?&gt; converter = fastConverter;</span><br><span class="line">        <span class="comment">// 5.返回HttpMessageConverters对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jackson2HashMapper"><a href="#Jackson2HashMapper" class="headerlink" title="Jackson2HashMapper"></a>Jackson2HashMapper</h3><p>org.springframework.data.redis.hash</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jackson2HashMapper jackson2HashMapper = <span class="keyword">new</span> Jackson2HashMapper(objectMapper,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//对象转map</span></span><br><span class="line">Map&lt;String, Object&gt; map = jackson2HashMapper.toHash(user);</span><br><span class="line"><span class="comment">//map转对象</span></span><br><span class="line">Object o = jackson2HashMapper.fromHash(map);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>json</category>
      </categories>
  </entry>
  <entry>
    <title>JDK8新特性——时间类</title>
    <url>/2021/03/13/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<p><font size='6.5px'>JDK8新特性——时间类</font></p>
<h1 id="为什么需要使用新的时间类"><a href="#为什么需要使用新的时间类" class="headerlink" title="为什么需要使用新的时间类"></a>为什么需要使用新的时间类</h1><p>1、Date如果不格式化，打印出的日期可读性差【Tue Sep 10 09:34:04 CST 2019】；</p>
<p>2、使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的；</p>
<p>3、获取时间一些参数需要转换为calendar类获取……</p>
<a id="more"></a>

<h1 id="JDK8新特性提供的时间操作类"><a href="#JDK8新特性提供的时间操作类" class="headerlink" title="JDK8新特性提供的时间操作类"></a>JDK8新特性提供的时间操作类</h1><p>1、LocalDate    【日期】</p>
<p>2、LocalTime    【时间】</p>
<p>3、LocalDateTime    【日期时间】</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的年月日"><a href="#构造指定的年月日" class="headerlink" title="构造指定的年月日"></a>构造指定的年月日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时分秒"><a href="#构造指定的时分秒" class="headerlink" title="构造指定的时分秒"></a>构造指定的时分秒</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">12</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时日"><a href="#获取当前时日" class="headerlink" title="获取当前时日"></a>获取当前时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时日"><a href="#构造指定的时日" class="headerlink" title="构造指定的时日"></a>构造指定的时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2019</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取时间的某一个值"><a href="#获取时间的某一个值" class="headerlink" title="获取时间的某一个值"></a>获取时间的某一个值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDateTime1.getYear();   <span class="comment">//2020  年份</span></span><br><span class="line">Month month = localDateTime1.getMonth();   <span class="comment">//JUNE  月份</span></span><br><span class="line"><span class="keyword">int</span> monthValue = localDateTime1.getMonthValue();   <span class="comment">//6  月份数值</span></span><br><span class="line"><span class="keyword">int</span> day = localDateTime1.getDayOfMonth();   <span class="comment">//28  日期</span></span><br><span class="line">DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek();   <span class="comment">//SUNDAY  周</span></span><br><span class="line"><span class="keyword">int</span> dayOfYear = localDateTime1.getDayOfYear();   <span class="comment">//180  年的第几天</span></span><br><span class="line"><span class="keyword">int</span> hour = localDateTime1.getHour();   <span class="comment">//13 小时</span></span><br><span class="line"><span class="keyword">int</span> minute = localDateTime1.getMinute();   <span class="comment">//51  分钟</span></span><br><span class="line"><span class="keyword">int</span> second = localDateTime1.getSecond();   <span class="comment">//19  秒</span></span><br></pre></td></tr></table></figure>

<h2 id="LocalDateTime、LocalDate、LocalTime的转换"><a href="#LocalDateTime、LocalDate、LocalTime的转换" class="headerlink" title="LocalDateTime、LocalDate、LocalTime的转换"></a>LocalDateTime、LocalDate、LocalTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime = localTime.atDate(localDate);</span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<h2 id="将某个时间增加"><a href="#将某个时间增加" class="headerlink" title="将某个时间增加"></a>将某个时间增加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.plus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//增加2年</span></span><br><span class="line">localDateTime = localDateTime.plusYears(<span class="number">2</span>);  <span class="comment">//增加2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间减少"><a href="#将某个时间减少" class="headerlink" title="将某个时间减少"></a>将某个时间减少</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.minus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//减少2年</span></span><br><span class="line">localDateTime = localDateTime.minusYears(<span class="number">2</span>);  <span class="comment">//减少2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间参数指定"><a href="#将某个时间参数指定" class="headerlink" title="将某个时间参数指定"></a>将某个时间参数指定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime1 = localDateTime1.with(ChronoField.MONTH_OF_YEAR,<span class="number">1</span>);  <span class="comment">//指定月份为1月</span></span><br><span class="line">localDateTime1 = localDateTime1.withHour(<span class="number">2</span>);  <span class="comment">//指定小时为2时</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime.with(firstDayOfYear());  <span class="comment">//获取当年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfMonth());  <span class="comment">//获取当月的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextYear());  <span class="comment">//获取下年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextMonth());  <span class="comment">//获取下月的第一天</span></span><br><span class="line">localDateTime.with(firstInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月第一个星期一的时间</span></span><br><span class="line">localDateTime.with(lastDayOfYear());  <span class="comment">//获取上年的第一天</span></span><br><span class="line">localDateTime.with(lastDayOfMonth());  <span class="comment">//获取上月的第一天</span></span><br><span class="line">localDateTime.with(lastInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月最后一个星期一的时间</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认提供了几种格式时间的方式【一般不用】</span></span><br><span class="line">String s1 = localDateTime.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDateTime.format(DateTimeFormatter.ISO_DATE_TIME);</span><br><span class="line"><span class="comment">//自定义格式化时间的方式</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy/hh/mm/ss"</span>);</span><br><span class="line">String s3 = localDateTime.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="字符串解析时间"><a href="#字符串解析时间" class="headerlink" title="字符串解析时间"></a>字符串解析时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 &#x3D; LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 &#x3D; LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&#x2F;hh&#x2F;mm&#x2F;ss&quot;);</span><br><span class="line">LocalDate localDate3 &#x3D; LocalDate.parse(&quot;28&#x2F;06&#x2F;2020&#x2F;02&#x2F;28&#x2F;46&quot;, dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="Timestamp与LocalDateTime的转换"><a href="#Timestamp与LocalDateTime的转换" class="headerlink" title="Timestamp与LocalDateTime的转换"></a>Timestamp与LocalDateTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toLocalDateTime();</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime与Long（时间戳）的转换"><a href="#LocalDateTime与Long（时间戳）的转换" class="headerlink" title="LocalDateTime与Long（时间戳）的转换"></a>LocalDateTime与Long（时间戳）的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = (<span class="keyword">new</span> Timestamp(System.currentTimeMillis())).toLocalDateTime();</span><br><span class="line"><span class="keyword">long</span> time = localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br></pre></td></tr></table></figure>

<h2 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.isBefore(localDateTime4));</span><br><span class="line">System.out.println(localDateTime.isAfter(localDateTime4));</span><br></pre></td></tr></table></figure>

<h2 id="计算时间间隔（Duration类和Period类）"><a href="#计算时间间隔（Duration类和Period类）" class="headerlink" title="计算时间间隔（Duration类和Period类）"></a>计算时间间隔（Duration类和Period类）</h2><p>使用场景【计算年龄、合同时间等。。。】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">Duration duration = Duration.between(localDateTime,localDateTime4);</span><br><span class="line"><span class="comment">//间隔多少天</span></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();</span><br><span class="line"><span class="comment">//间隔多少小时</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line"><span class="comment">//间隔多少分钟</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">Period period2 = Period.between(localDateTime.toLocalDate(),localDateTime4.toLocalDate());</span><br><span class="line"><span class="comment">//间隔多少年</span></span><br><span class="line"><span class="keyword">int</span> years = period2.getYears();</span><br><span class="line"><span class="comment">//间隔多少月（只计算月份，不计年）</span></span><br><span class="line"><span class="keyword">int</span> months = period2.getMonths();</span><br><span class="line"><span class="comment">//间隔多少月（计算年）</span></span><br><span class="line"><span class="keyword">long</span> toTotalMonths = period2.toTotalMonths();</span><br></pre></td></tr></table></figure>

<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter YEAR_MONTH_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter LONG_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss SSS"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyMMddHHmmss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDateTime</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">       LocalDateTime localDateTime = LocalDateTime.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDateTime.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDate</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDate.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将字符串日期转换成date类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">dateStrConvertDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(dateStr, dateTimeFormatter);</span><br><span class="line">        <span class="comment">// 获得 Instant</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(parse.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将date类型转换成字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateConvertDateStr</span><span class="params">(Date date,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localdate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">dateConvertLocalDate</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">dateConvertLocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localdate转换成date(时分秒为零)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateConvertDate</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        Instant instant = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localDateTime转换成date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTimeConvertDate</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">getCurrentLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">getCurrentLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getCurrentLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM-dd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyMMdd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(SHORT_DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentMonthStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(YEAR_MONTH_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss SSS”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentLongDateTimeStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(LONG_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyMMddHHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(SHORT_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间字符串以“HHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now().format(TIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间日期字符串以指定的字符串格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String dateStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String dateTimeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">parseLocalTime</span><span class="params">(String timeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate date, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime datetime, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datetime.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalTime</span><span class="params">(LocalTime time, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">formatLocalDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">formatLocalDateTime</span><span class="params">(String dateTimeStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">formatLocalTime</span><span class="params">(String longDateTimeStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(longDateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodHours</span><span class="params">(LocalDateTime startDateTime,LocalDateTime endDateTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Duration.between(startDateTime, endDateTime).get(ChronoUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodDays</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔周数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodWeeks</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.WEEKS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔月数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodMonths</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.MONTHS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔年数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodYears</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.YEARS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCurrentLocalDate().equals(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取时间日期的毫秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">localDateTimeToEpochMilli</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间毫秒数获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">epochMilliToLocalDateTime</span><span class="params">(Long timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Timestamp(timeMillis)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取Timestamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">localDateTimeToTimestamp</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Timestamp(dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Timestamp获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">localDateTimeToTimestamp</span><span class="params">(Timestamp timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp.toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为闰年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate.isLeapYear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBefore</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isBefore(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAfter</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isAfter(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间（整数年）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByYear</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusYears(years).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间(非整数年)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByMonth</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> monthValues)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusMonths(monthValues).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间相应注解"><a href="#时间相应注解" class="headerlink" title="时间相应注解"></a>时间相应注解</h1><h2 id="将返回时间转为指定字符串格式"><a href="#将返回时间转为指定字符串格式" class="headerlink" title="将返回时间转为指定字符串格式"></a>将返回时间转为指定字符串格式</h2><p>@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”, timezone = “GMT+8”)</p>
<h2 id="时间入参格式化"><a href="#时间入参格式化" class="headerlink" title="时间入参格式化"></a>时间入参格式化</h2><p>@DateTimeFormat(pattern = “yyyy-MM-dd”)</p>
<p>@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)</p>
]]></content>
      <categories>
        <category>JDK8新特性</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>TiDB数据迁移</title>
    <url>/2022/11/14/TiDB%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p><img src="images/TiDB/migration-tools.png" alt="migration-tools"></p>
<a id="more"></a>



<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">使用场景</th>
<th align="left">上游（或输入源文件）</th>
<th align="left">下游（或输出文件）</th>
<th align="left">主要优势</th>
<th align="left">使用限制</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/dm-overview" target="_blank" rel="noopener">TiDB DM</a></td>
<td align="left">用于将数据从与 MySQL 协议兼容的数据库迁移到 TiDB。</td>
<td align="left">MySQL，MariaDB，Aurora，MySQL</td>
<td align="left">TiDB</td>
<td align="left">一体化的数据迁移任务管理工具，支持全量迁移和增量同步；支持对表与操作进行过滤；支持分库分表的合并迁移。</td>
<td align="left">建议用于 1TB 以内的存量数据迁移。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/dumpling-overview" target="_blank" rel="noopener">Dumpling</a></td>
<td align="left">用于将数据从 MySQL/TiDB 进行全量导出。</td>
<td align="left">MySQL，TiDB</td>
<td align="left">SQL，CSV</td>
<td align="left">支持全新的 table-filter，筛选数据更加方便；支持导出到 Amazon S3 云盘</td>
<td align="left">如果导出后计划往非 TiDB 的数据库恢复，建议使用 Dumpling；如果是往另一个 TiDB 恢复，建议使用 BR。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/tidb-lightning-overview" target="_blank" rel="noopener">TiDB Lightning</a></td>
<td align="left">用于将数据全量导入到 TiDB。</td>
<td align="left">Dumpling 输出的文件；CSV 文件；从本地盘或 Amazon S3 云盘读取数据。</td>
<td align="left">TiDB</td>
<td align="left">支持迅速导入大量新数据，实现快速初始化 TiDB 集群的指定表；支持断点续传；支持数据过滤。</td>
<td align="left">如果使用 Local-backend 进行数据导入，TiDB Lightning 运行后，TiDB 集群将无法正常对外提供服务。如果你不希望 TiDB 集群的对外服务受到影响，可以参考 TiDB Lightning TiDB-backend 中的硬件需求与部署方式进行数据导入。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/backup-and-restore-tool" target="_blank" rel="noopener">Backup &amp; Restore (BR)</a></td>
<td align="left">通过对大数据量的 TiDB 集群进行数据备份和恢复，实现数据迁移。</td>
<td align="left">TiDB</td>
<td align="left">SST；backup.meta 文件；backup.lock 文件</td>
<td align="left">适用于向另一个 TiDB 迁移数据。支持数据冷备份到外部存储，可以用于灾备恢复。</td>
<td align="left">BR 恢复到 TiCDC / Drainer 的上游集群时，恢复数据无法由 TiCDC / Drainer 同步到下游。BR 只支持在 new_collations_enabled_on_first_bootstrap 开关值相同的集群之间进行操作。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/ticdc-overview" target="_blank" rel="noopener">TiCDC</a></td>
<td align="left">通过拉取 TiKV 变更日志实现的 TiDB 增量数据同步工具，具有将数据还原到与上游任意 TSO 一致状态的能力，支持其他系统订阅数据变更。</td>
<td align="left">TiDB</td>
<td align="left">TiDB，MySQL，Apache Pulsar，Kafka，Confluent</td>
<td align="left">提供开放数据协议 (TiCDC Open Protocol)。</td>
<td align="left">TiCDC 只能同步至少存在一个有效索引的表。暂不支持以下场景：暂不支持单独使用 RawKV 的 TiKV 集群。暂不支持在 TiDB 中创建 SEQUENCE 的 DDL 操作和 SEQUENCE 函数。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/tidb-binlog-overview" target="_blank" rel="noopener">TiDB Binlog</a></td>
<td align="left">用于 TiDB 集群间的增量数据同步，如将其中一个 TiDB 集群作为另一个 TiDB 集群的从集群。</td>
<td align="left">TiDB</td>
<td align="left">TiDB，MySQL，Kafka，增量备份文件</td>
<td align="left">支持实时备份和恢复。备份 TiDB 集群数据，同时可以用于 TiDB 集群故障时恢复。</td>
<td align="left">与部分 TiDB 版本不兼容，不能一起使用。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.pingcap.com/zh/tidb/v5.4/sync-diff-inspector-overview" target="_blank" rel="noopener">sync-diff-inspector</a></td>
<td align="left">用于校验 MySQL/TiDB 中两份数据的一致性。</td>
<td align="left">TiDB，MySQL</td>
<td align="left">TiDB，MySQL</td>
<td align="left">提供了修复数据的功能，适用于修复少量不一致的数据。</td>
<td align="left">对于 MySQL 和 TiDB 之间的数据同步不支持在线校验。不支持 JSON、BIT、BINARY、BLOB 等类型的数据。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>中间件</category>
        <category>TiDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>mysql</tag>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title>TiDB概念</title>
    <url>/2022/11/14/TiDB%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TiDB 是PingCAP公司设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。TiDB 适合高可用、强一致要求较高、数据规模较大等各种应用场景。</p>
<blockquote>
<p><a href="https://docs.pingcap.com/zh/tidb" target="_blank" rel="noopener">点击跳转官方文档</a></p>
</blockquote>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/TiDB/tidb-architecture-v3.1.png" alt="tidb-architecture-v3.1"></p>
<a id="more"></a>

<ul>
<li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-computing" target="_blank" rel="noopener">TiDB Server</a><ul>
<li>SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。</li>
<li>TiDB 层本身是无状态的，实践中可以启动多个 TiDB 实例，通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址，客户端的连接可以均匀地分摊在多个 TiDB 实例上以达到负载均衡的效果。</li>
<li>TiDB Server 本身并不存储数据，只是解析 SQL，将实际的数据读取请求转发给底层的存储节点 TiKV（或 TiFlash）。</li>
</ul>
</li>
<li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-scheduling" target="_blank" rel="noopener">PD (Placement Driver) Server</a><ul>
<li>整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。</li>
<li>PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。</li>
<li>此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</li>
</ul>
</li>
<li>存储节点<ul>
<li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-storage" target="_blank" rel="noopener">TiKV Server</a><ul>
<li>负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。</li>
<li>存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。</li>
<li>TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别，这也是 TiDB 在 SQL 层面支持分布式事务的核心。TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。另外，TiKV 中的数据都会自动维护多副本（默认为三副本），天然支持高可用和自动故障转移。</li>
</ul>
</li>
<li><a href="https://docs.pingcap.com/zh/tidb/stable/tiflash-overview" target="_blank" rel="noopener">TiFlash</a><ul>
<li>TiFlash 是一类特殊的存储节点。和普通 TiKV 节点不一样的是，在 TiFlash 内部，数据是以列式的形式进行存储，主要的功能是为分析型的场景加速。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/TiDB/%E5%9B%BE%E7%89%8719.png" alt="图片19"></p>
<h1 id="TiKV-Server-存储"><a href="#TiKV-Server-存储" class="headerlink" title="TiKV Server-存储"></a>TiKV Server-存储</h1><p>TiKV负责行数据存储，使用key-value的存储模型。</p>
<p>基于Facebook开源的RocksDB，进行单机KV存储，因此可以将TiKV看成一个巨大且有序的KV Map。</p>
<h2 id="Key-Value"><a href="#Key-Value" class="headerlink" title="Key-Value"></a>Key-Value</h2><p>TiDB 会为每个表分配一个表 ID，用 <code>TableID</code>表示。</p>
<p>TiDB 会为表中每行数据分配一个行 ID，用 <code>RowID</code> 表示，如果某个表有整数型的主键，TiDB 会使用主键的值当做这一行数据的行 ID。</p>
<p>每行数据按照以下结构编码成键值对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Key:   tablePrefix&#123;TableID&#125;_recordPrefixSep&#123;RowID&#125;</span><br><span class="line">Value: [col1, col2, col3, col4]</span><br><span class="line"></span><br><span class="line">-- 主键和唯一索引</span><br><span class="line">Key:   tablePrefix&#123;tableID&#125;_indexPrefixSep&#123;indexID&#125;_indexedColumnsValue</span><br><span class="line">Value: RowID</span><br><span class="line"></span><br><span class="line">-- 非唯一的普通二级索引</span><br><span class="line">Key:   tablePrefix&#123;TableID&#125;_indexPrefixSep&#123;IndexID&#125;_indexedColumnsValue_&#123;RowID&#125;</span><br><span class="line">Value: null</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表结构</span><br><span class="line">CREATE TABLE User (</span><br><span class="line">    ID int,</span><br><span class="line">    Name varchar(20),</span><br><span class="line">    Role varchar(20),</span><br><span class="line">    Age int,</span><br><span class="line">    PRIMARY KEY (ID),</span><br><span class="line">    KEY idxAge (Age)</span><br><span class="line">);</span><br><span class="line">-- 数据</span><br><span class="line">1, &quot;TiDB&quot;, &quot;SQL Layer&quot;, 10</span><br><span class="line">2, &quot;TiKV&quot;, &quot;KV Engine&quot;, 20</span><br><span class="line">3, &quot;PD&quot;, &quot;Manager&quot;, 30</span><br><span class="line"></span><br><span class="line">-- 假设该表的 TableID 为 10，则其存储在 TiKV 上的表数据为：</span><br><span class="line">t10_r1 --&gt; [&quot;TiDB&quot;, &quot;SQL Layer&quot;, 10]</span><br><span class="line">t10_r2 --&gt; [&quot;TiKV&quot;, &quot;KV Engine&quot;, 20]</span><br><span class="line">t10_r3 --&gt; [&quot;PD&quot;, &quot;Manager&quot;, 30]</span><br><span class="line"></span><br><span class="line">-- 除了主键外，该表还有一个非唯一的普通二级索引 idxAge，假设这个索引的 IndexID 为 1，则其存储在 TiKV 上的索引数据为：</span><br><span class="line">t10_i1_10_1 --&gt; null</span><br><span class="line">t10_i1_20_2 --&gt; null</span><br><span class="line">t10_i1_30_3 --&gt; null</span><br></pre></td></tr></table></figure>



<h2 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h2><p>为了实现水平扩展，将数据分散到多台机器上，TiKV使用range方式切分数据，将整个Key-Value空间分成很多段，每个段叫做一个region。</p>
<img src="/images/TiDB/图片23.png" alt="图片23" style="zoom:50%;" />

<p>每个region默认不超过96MB，使用[startkey，endkey)这样左闭右开的区间来描述数据。</p>
<p>TiKV会以region为单位，将数据分散到多个节点上，尽量保证每个节点上region数量差不多。PD负责将region均匀的调度到所有节点上，且维护region的路由信息，方便查询。</p>
<img src="/images/TiDB/ac18c4b8106d41a79ceab42bf87ffe64.gif" alt="ac18c4b8106d41a79ceab42bf87ffe64" style="zoom:50%;" />

<p>以region为单位做raft数据复制和成员管理。</p>
<p>一个region会有多个副本，多个replica组成一个raft group，其中一个replica作为这个raft group的leader，其他replica作为follower。</p>
<img src="/images/TiDB/tidb-storage-3.png" alt="tidb-storage-3" style="zoom:55%;" />



<p>replica之间通过raft协议保持数据一致性，默认所有的复写操作都在leader上进行，写操作由leader复制给follower。</p>
<img src="/images/TiDB/图片21.png" alt="图片21" style="zoom: 67%;" />



<p>以 Region 为单位做数据的分散和复制，TiKV 就成为了一个分布式的具备一定容灾能力的 KeyValue 系统，不用再担心数据存不下，或者是磁盘故障丢失数据的问题。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>TiKV 的 MVCC 实现是通过在 Key 后面添加版本号来实现。</p>
<p>没有MVCC的KV数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Key1 -&gt; Value</span><br><span class="line">Key2 -&gt; Value</span><br><span class="line">……</span><br><span class="line">KeyN -&gt; Value</span><br></pre></td></tr></table></figure>

<p>有MVCC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Key1_Version3 -&gt; Value</span><br><span class="line">Key1_Version2 -&gt; Value</span><br><span class="line">Key1_Version1 -&gt; Value</span><br><span class="line">……</span><br><span class="line">Key2_Version4 -&gt; Value</span><br><span class="line">Key2_Version3 -&gt; Value</span><br><span class="line">Key2_Version2 -&gt; Value</span><br><span class="line">Key2_Version1 -&gt; Value</span><br><span class="line">……</span><br><span class="line">KeyN_Version2 -&gt; Value</span><br><span class="line">KeyN_Version1 -&gt; Value</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>对于同一个 Key 的多个版本，版本号较大的会被放在前面，版本号小的会被放在后面。</p>
<p>这样当用户通过一个 Key + Version 来获取 Value 的时候，可以通过 Key 和 Version 构造出 MVCC 的 Key，也就是 Key_Version。</p>
<p>也可以直接通过 RocksDB 的 SeekPrefix(Key_Version) API，定位到第一个大于等于这个 Key_Version 的位置。</p>
<h1 id="TiDB-Server-SQL层"><a href="#TiDB-Server-SQL层" class="headerlink" title="TiDB Server-SQL层"></a>TiDB Server-SQL层</h1><p>TiDB 的 SQL 层，即 TiDB Server，负责将 SQL 翻译成 Key-Value 操作，将其转发给共用的分布式 Key-Value 存储层 TiKV，然后组装 TiKV 返回的结果，最终将查询结果返回给客户端。</p>
<p>这一层的节点都是无状态的，节点本身并不存储数据，节点之间完全对等。</p>
<h2 id="分布式-SQL-运算"><a href="#分布式-SQL-运算" class="headerlink" title="分布式 SQL 运算"></a>分布式 SQL 运算</h2><p>TiDB Server通过RPC从TiKV读取数据，因此为了减少不必要的RPC开销，会将条件带入TiKV查询计算，各个TiKV节点返回运算后的数据，统一处理，提升性能。</p>
<img src="/images/TiDB/tidb-computing-dist-sql-flow.png" alt="tidb-computing-dist-sql-flow" style="zoom:67%;" />

<p>用户的 SQL 请求会直接或者通过 <code>Load Balancer</code> 发送到 TiDB Server，TiDB Server 会解析 <code>MySQL Protocol Packet</code>，获取请求内容，对 SQL 进行语法解析和语义分析，制定和优化查询计划，执行查询计划并获取和处理数据。数据全部存储在 TiKV 集群中，所以在这个过程中 TiDB Server 需要和 TiKV 交互，获取数据。最后 TiDB Server 需要将查询结果返回给用户。</p>
<p><img src="/images/TiDB/tidb-computing-tidb-sql-layer.png" alt="tidb-computing-tidb-sql-layer"></p>
<h1 id="PD-调度"><a href="#PD-调度" class="headerlink" title="PD-调度"></a>PD-调度</h1><p>PD(Placement Driver) 是 TiDB 集群的管理模块，同时也负责集群数据的实时调度。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>调度依赖于整个集群信息的收集，简单来说，调度需要知道每个 TiKV 节点的状态以及每个 Region 的状态。TiKV 集群会向 PD 汇报两类消息，TiKV 节点信息和 Region 信息。</p>
<ul>
<li>TiKV 节点信息：TiKV 节点 (Store) 与 PD 之间存在心跳包，一方面 PD 通过心跳包检测每个 Store 是否存活，以及是否有新加入的 Store；另一方面，心跳包中也会携带这个 Store 的状态信息<ul>
<li>总磁盘容量</li>
<li>可用磁盘容量</li>
<li>承载的 Region 数量</li>
<li>数据写入/读取速度</li>
<li>发送/接受的 Snapshot 数量（副本之间可能会通过 Snapshot 同步数据）</li>
<li>是否过载</li>
<li>labels 标签信息</li>
</ul>
</li>
<li>Region 信息：每个 Raft Group 的 Leader 和 PD 之间存在心跳包，用于汇报这个 Region 的状态<ul>
<li>Leader 的位置</li>
<li>Followers 的位置</li>
<li>掉线副本的个数</li>
<li>数据写入/读取的速度</li>
</ul>
</li>
</ul>
<p>PD 不断的通过这两类心跳消息收集整个集群的信息，再以这些信息作为决策的依据。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>TiDB</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>mysql</tag>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware创建centos7虚拟机</title>
    <url>/2020/11/29/VMware%E5%88%9B%E5%BB%BAcentos7%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<img src="/images/linux/centos/1.png" style="zoom:75%;" />

<a id="more"></a>

<img src="/images/linux/centos/2.png" style="zoom:75%;" />

<img src="/images/linux/centos/3.png" style="zoom:75%;" />

<img src="/images/linux/centos/4.jpg" style="zoom:75%;" />

<img src="/images/linux/centos/5.jpg" style="zoom:75%;" />

<img src="/images/linux/centos/6.jpg" style="zoom:55%;" />

<img src="/images/linux/centos/7.jpg" style="zoom:65%;" />

<img src="/images/linux/centos/8.jpg" style="zoom:65%;" />

<img src="/images/linux/centos/9.jpg" style="zoom:65%;" />

<img src="/images/linux/centos/10.jpg" style="zoom:65%;" />

<img src="/images/linux/centos/11.jpg" style="zoom:60%;" />

<img src="/images/linux/centos/12.jpg" style="zoom:50%;" />

<img src="/images/linux/centos/13.jpg" style="zoom:60%;" />

<img src="/images/linux/centos/14.jpg" style="zoom:67%;" />

<img src="/images/linux/centos/15.jpg" style="zoom:60%;" />

<img src="/images/linux/centos/16.jpg" style="zoom:60%;" />

<img src="/images/linux/centos/17.jpg" style="zoom:67%;" />

<img src="/images/linux/centos/18.jpg" style="zoom:60%;" />

<img src="/images/linux/centos/19.jpg" style="zoom:75%;" />]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>admin监控</title>
    <url>/2020/12/06/admin/</url>
    <content><![CDATA[<h2 id="admin服务端"><a href="#admin服务端" class="headerlink" title="admin服务端"></a>admin服务端</h2><a id="more"></a>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">       &lt;spring-boot-admin.version&gt;2.3.1&lt;&#x2F;spring-boot-admin.version&gt;</span><br><span class="line">       &lt;spring-cloud.version&gt;Hoxton.SR9&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">   &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-starter-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--admin--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-server-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--健康检查--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">      </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 邮件--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 加入密码认证 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;&#x2F;exclusion&gt;</span><br><span class="line">           &lt;&#x2F;exclusions&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-admin-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;&#x2F;dependencies&gt;</span><br><span class="line">   &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br><span class="line">       &lt;&#x2F;plugins&gt;</span><br><span class="line">   &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9304</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-admin</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">        <span class="attr">mail:</span></span><br><span class="line">          <span class="comment">#收邮件</span></span><br><span class="line">          <span class="attr">to:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">          <span class="comment"># 发件邮箱（要与邮件配置的username相同）</span></span><br><span class="line">          <span class="attr">from:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="comment"># 邮件设置</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">619876453</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">abc</span> <span class="comment">#授权码</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smpt:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka:eureka@localhost:9999/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不注册到eureka</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#服务监控</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">show-components:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="security安全认证"><a href="#security安全认证" class="headerlink" title="security安全认证"></a>security安全认证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSecurityConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">        successHandler.setTargetUrlParameter( <span class="string">"redirectTo"</span> );</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/assets/**"</span> ).permitAll()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/login"</span> ).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().loginPage( adminContextPath + <span class="string">"/login"</span> ).successHandler( successHandler ).and()</span><br><span class="line">                .logout().logoutUrl( adminContextPath + <span class="string">"/logout"</span> ).and()</span><br><span class="line">                .httpBasic().and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span><br><span class="line">                .ignoringAntMatchers(</span><br><span class="line">                        adminContextPath + <span class="string">"/instances"</span>,</span><br><span class="line">                        adminContextPath + <span class="string">"/actuator/**"</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="admin客户端（eureka服务端）"><a href="#admin客户端（eureka服务端）" class="headerlink" title="admin客户端（eureka服务端）"></a>admin客户端（eureka服务端）</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Admin 服务 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://admin:admin@localhost:9304</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="安全认证，放行健康检查"><a href="#安全认证，放行健康检查" class="headerlink" title="安全认证，放行健康检查"></a>安全认证，放行健康检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().antMatchers(<span class="string">"/actuator/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><img src="/images/cloud/admin/admin%E7%9B%91%E6%8E%A7.jpg" alt=""></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><h3 id="邮件通知，查看上面配置"><a href="#邮件通知，查看上面配置" class="headerlink" title="邮件通知，查看上面配置"></a>邮件通知，查看上面配置</h3><h3 id="钉钉通知"><a href="#钉钉通知" class="headerlink" title="钉钉通知"></a>钉钉通知</h3><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DingDingNotifier <span class="title">dingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DingDingNotifier(repository);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String serviceName = instance.getRegistration().getName();</span><br><span class="line">        String serviceUrl = instance.getRegistration().getServiceUrl();</span><br><span class="line">        String status = instance.getStatusInfo().getStatus();</span><br><span class="line">        Map&lt;String, Object&gt; details = instance.getStatusInfo().getDetails();</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.append(<span class="string">"系统警告 : 【"</span> + serviceName + <span class="string">"】"</span>);</span><br><span class="line">        str.append(<span class="string">"【服务地址】"</span> + serviceUrl);</span><br><span class="line">        str.append(<span class="string">"【状态】"</span> + status);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str.append(<span class="string">"【详情】"</span> + objectMapper.writeValueAsString(details));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            DingDingMessageUtil.sendTextMessage(str.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送工具类"><a href="#发送工具类" class="headerlink" title="发送工具类"></a>发送工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingMessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String access_token = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setMsgtype(<span class="string">"text"</span>);</span><br><span class="line">            message.setText(<span class="keyword">new</span> MessageInfo(msg));</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"https://oapi.dingtalk.com/robot/send?access_token="</span> + access_token);</span><br><span class="line">            <span class="comment">// 建立 http 连接</span></span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">            conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/Json; charset=UTF-8"</span>);</span><br><span class="line">            conn.connect();</span><br><span class="line">            OutputStream out = conn.getOutputStream();</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            String textMessage = objectMapper.writeValueAsString(message);</span><br><span class="line">            <span class="keyword">byte</span>[] data = textMessage.getBytes();</span><br><span class="line">            out.write(data);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            InputStream in = conn.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] data1 = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data1);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data1));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息类"><a href="#消息类" class="headerlink" title="消息类"></a>消息类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageInfo</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msgtype;</span><br><span class="line">    <span class="keyword">private</span> MessageInfo text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgtype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgtype</span><span class="params">(String msgtype)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgtype = msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageInfo <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(MessageInfo text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钉钉群配置机器人"><a href="#钉钉群配置机器人" class="headerlink" title="钉钉群配置机器人"></a>钉钉群配置机器人</h4><p><img src="/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA.jpg" alt=""></p>
<p><img src="/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA2.jpg" alt=""></p>
<p><img src="/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA3.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>admin</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2021/11/17/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/images/docker/%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><code>systemctl start docker</code></p>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p><code>systemctl stop docker</code></p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p><code>systemctl restart docker</code></p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>systemctl status docker</code></p>
<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p><code>systemctl enable docker</code></p>
<h3 id="关闭开机自启"><a href="#关闭开机自启" class="headerlink" title="关闭开机自启"></a>关闭开机自启</h3><p><code>systemctl disable docker</code></p>
<hr>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p>查看当前拥有的镜像</p>
<p><code>docker images</code></p>
<p><img src="/images/docker/images.jpg" alt=""></p>
<blockquote>
<p>REPOSITORY：镜像名称<br>TAG：镜像标签<br>IMAGE ID：镜像ID<br>CREATED：镜像的创建日期（不是获取该镜像的日期）<br>SIZE：镜像大小</p>
</blockquote>
<h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a><a href="[https://hub.docker.com](https://links.jianshu.com/go?to=https%3A%2F%2Fhub.docker.com%2F)">搜索镜像</a></h3><p><code>docker search 镜像名称</code></p>
<p>可以从网络中查找需要的镜像，可以通过以下命令搜索</p>
<p><img src="/images/docker/search.jpg" alt=""></p>
<blockquote>
<p>NAME：仓库名称<br>DESCRIPTION：镜像描述<br>STARS：用户评价，反应一个镜像的受欢迎程度<br>OFFICIAL：是否官方<br>AUTOMATED：自动构建，表示该镜像由 Docker Hub自动构建流程创建的</p>
</blockquote>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p><code>docker pull 镜像名称</code> 默认拉取最新版本</p>
<p><code>docker pull 镜像名称:版本</code>拉取指定版本</p>
<p>从中央仓库中下载镜像到本地</p>
<p><img src="/images/docker/pull.jpg" alt=""></p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>docker rmi 镜像名称/ID</code></p>
<p><img src="/images/docker/rmi.jpg" alt=""></p>
<hr>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><p><code>docker ps</code></p>
<h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><p><code>docker ps -a</code></p>
<h3 id="查看最后一次运行的容器"><a href="#查看最后一次运行的容器" class="headerlink" title="查看最后一次运行的容器"></a>查看最后一次运行的容器</h3><p><code>docker ps -l</code></p>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><code>docker run 参数</code></p>
<blockquote>
<p>-i：表示运行容器<br>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>–name :为创建的容器命名。<br>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用 多个－v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到 容器上。<br>-d：在 run 后面加上-d 参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自 动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器）。<br>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多 个端口映射</p>
</blockquote>
<h4 id="交互式创建"><a href="#交互式创建" class="headerlink" title="交互式创建"></a>交互式创建</h4><p><code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code></p>
<p>退出当前容器  <code>exit</code></p>
<p>不关闭容器方式退出交互式容器 ctrl+p+q</p>
<h4 id="守护式创建"><a href="#守护式创建" class="headerlink" title="守护式创建"></a>守护式创建</h4><p><code>docker run -di --name=容器名称 镜像名称:标签</code></p>
<p>登录守护容器方式</p>
<p><code>docker exec -it 容器名称/ID /bin/bash</code></p>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><code>docker exec</code>进入容器</p>
<p><code>docker attach</code>此方式进入容器，在退出容器终端后会导致容器终止，不建议使用</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p><code>docker stop 容器名称/ID</code></p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p><code>docker start 容器名称/ID</code></p>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>拷贝文件到容器中</p>
<p><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></p>
<p>从容器拷贝文件出来</p>
<p><code>docker cp 容器名称:容器目录 存放路径</code></p>
<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通 过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v 参数 后边为 宿主机目录: 容器目录</p>
<p><code>docker run -di -v 宿主机目录:容器目录 --name=容器名称</code></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>​    <code>docker rm 容器名称/ID</code></p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p><code>dokcer logs 容器名称/ID</code></p>
<hr>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新 的镜像。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FROM image_name:tag</td>
<td align="left">义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td align="left">MAINTAINER user_name</td>
<td align="left">声明镜像的创建者</td>
</tr>
<tr>
<td align="left">ENV key value</td>
<td align="left">设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td align="left">RUN command</td>
<td align="left">是 Dockerfile 的核心部分(可以写多条)</td>
</tr>
<tr>
<td align="left">ADD source_dir/file dest_dir/file</td>
<td align="left">将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td align="left">COPY source_dir/file dest_dir/file</td>
<td align="left">和 ADD 相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td align="left">WORKDIR path_dir</td>
<td align="left">设置工作目录</td>
</tr>
<tr>
<td align="left">EXPOSE</td>
<td align="left">开发容器端口</td>
</tr>
<tr>
<td align="left">VOLUME</td>
<td align="left">挂载卷</td>
</tr>
<tr>
<td align="left">USER</td>
<td align="left">运行的用户</td>
</tr>
</tbody></table>
<p>创建镜像</p>
<p>创建目录</p>
<p><code>mkdir –p /root/dockerdata/dockerjdk8</code></p>
<p>上传<code>jdk-8u181-linux-x64.tar.gz</code>到该目录下</p>
<p>创建Dockerfile文件<code>vim Dockerfile</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依赖镜像名称和ID</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="comment">#指定镜像创建者信息</span></span><br><span class="line">MAINTAINER YRL</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir /usr/<span class="built_in">local</span>/java</span><br><span class="line"><span class="comment">#将相对路径的jdk加到容器中</span></span><br><span class="line">ADD jdk-8u181-linux-x64.tar.gz /usr/<span class="built_in">local</span>/java/</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_181</span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>构建镜像</p>
<p><code>docker build -t=&#39;jdk1.8&#39; .</code> 需注意后面的空格和点，不要省略</p>
<p><img src="/images/docker/dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F.jpg" alt=""></p>
<p>查看镜像</p>
<p><code>docker images</code></p>
<p><img src="/images/docker/dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F02.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用软件安装</title>
    <url>/2021/11/17/docker%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="mysq"><a href="#mysq" class="headerlink" title="mysq"></a>mysq</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="comment">#创建挂载目录</span></span><br><span class="line">mkdir -p ~/dockerdata/mysql/conf ~/dockerdata/mysql/logs ~/dockerdata/mysql/data</span><br><span class="line"><span class="comment">#守护模式启动容器</span></span><br><span class="line">docker run -di --name myMsql -p 33306:3306 -v ~/dockerdata/mysql/conf:/etc/mysql/conf.d -v ~/dockerdata/mysql/logs:/logs -v ~/dockerdata/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>p 代表端口映射，格式为 宿主机映射端口:容器运行端口 </p>
<p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是 root 用户的登陆密码</p>
<p>-v ~/dockerdata/mysql/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf<br>-v ~/dockerdata/mysql/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs<br>-v ~/dockerdata/mysql/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql</p>
</blockquote>
<a id="more"></a>

<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索镜像</span></span><br><span class="line">docker search tomcat</span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">dokcer pull tomcat</span><br><span class="line"><span class="comment">#创建挂载目录</span></span><br><span class="line">mkdir -p ~/dockerdata/tomcat/webapps ~/dockerdata/tomcat/logs ~/dockerdata/tomcat/conf</span><br><span class="line"><span class="comment">#从现有的tomcat中拷贝server.xml，没有此操作的话容器启动时挂载 -v ~/dockerdata/tomcat/conf:/usr/local/tomcat/conf会报错</span></span><br><span class="line">docker cp 6dd4380ba708:/usr/<span class="built_in">local</span>/tomcat/conf/server.xml ~/dockerdata/tomcat/conf</span><br><span class="line"><span class="comment">#守护方式运行镜像</span></span><br><span class="line">docker run -di --name myTomcat -p 9000:8080 -v ~/dockerdata/tomcat/webapps:/usr/<span class="built_in">local</span>/tomcat/webapps -v ~/dockerdata/tomcat/logs:/usr/<span class="built_in">local</span>/tomcat/logs  tomcat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-v ~/dockerdata/tomcat/conf:/usr/local/tomcat/conf</p>
</blockquote>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索镜像</span></span><br><span class="line">docker nginx</span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="comment">#守护方式运行镜像</span></span><br><span class="line">docker -di --name=myNginx -p 90:80 nginx</span><br></pre></td></tr></table></figure>

<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索镜像</span></span><br><span class="line">docker search redis</span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="comment">#创建挂载目录</span></span><br><span class="line">mkdir -p ~/dockerdata/redis/data</span><br><span class="line"><span class="comment">#守护方式运行镜像</span></span><br><span class="line">docker run -di --name=myRedis -p 33306:3306 -v ~/dockerdata/redis/data:/data redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>redis-server –appendonly yes :</strong> 在容器执行redis-server启动命令，并打开redis持久化配置</p>
</blockquote>
]]></content>
      <categories>
        <category>devops</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker私有仓库</title>
    <url>/2021/11/17/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h3 id="创建私有仓库-registry"><a href="#创建私有仓库-registry" class="headerlink" title="创建私有仓库-registry"></a>创建私有仓库-registry</h3><p>1、拉取私有仓库镜像</p>
<p><code>docker pull registry</code></p>
<p>2、启动私有仓库容器</p>
<p><code>docker run -di --name=registry -p 5000:5000 registry</code></p>
<p>3、访问私有仓库</p>
<p>访问<code>http://192.168.1.18:5000/v2/_catalog</code>看到 <code>{&quot;repositories&quot;:[]}</code>表示私有仓库搭建成功并且内容为空 </p>
<a id="more"></a>

<p><img src="/images/docker/%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.jpg" alt=""></p>
<p>4、修改daemon.json</p>
<p><code>vim /etc/docker/daemon.json</code> 添加<code>{&quot;insecure-registries&quot;:[&quot;192.168.1.18:5000&quot;]}</code>保存退出，此步骤是为了让docker信任私有仓库地址</p>
<p>5、重启docker服务</p>
<p><code>systemctl restart docker</code></p>
<p><img src="/images/docker/dockerinfo.jpg" alt=""></p>
<h3 id="创建私有仓库-harbor"><a href="#创建私有仓库-harbor" class="headerlink" title="创建私有仓库-harbor"></a>创建私有仓库-harbor</h3><p>1、上传<code>docker-compose-Linux-x86_64</code>、<code>harbor-offline-installer-v1.9.4.tgz</code> 到服务器</p>
<p>2、docker-compose</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -r docker-compose-Linux-x86_64 /usr/<span class="built_in">local</span>/bin/docker-commpose</span><br><span class="line"><span class="comment">#授权</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-commpose</span><br><span class="line"><span class="comment">#查看是否成功</span></span><br><span class="line">docker-commpose --version</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker/docker-compose.jpg" alt=""></p>
<p>3、harbor</p>
<p>3.1、编译<code>/images/docker/prepare</code></p>
<p>3.2、修改配置<code>vim harbor.yml</code></p>
<p><img src="/images/docker/harbor%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<p>3.3、安装<code>/images/docker/install.sh</code></p>
<blockquote>
<p>注意：docker中不能存在名称registry的容器，会在安装时失败</p>
</blockquote>
<p>3.4、浏览器输入<code>192.168.1.18</code>访问harbor管理页，账号：admin、密码（配置文件中）: Harbor12345</p>
<p><img src="/images/docker/harbor%E7%99%BB%E5%BD%95%E9%A1%B5.jpg" alt=""></p>
<p>4、制作systemctl服务</p>
<p><code>vim /lib/systemd/system/harbor.service</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Harbor</span><br><span class="line">After=docker.service systemd-networkd.service systemd-resolved.service</span><br><span class="line">Requires=docker.service</span><br><span class="line">Documentation=http://github.com/vmware/harbor</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/docker-compose -f /opt/harbor/docker-compose.yml up</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/bin/docker-compose -f /opt/harbor/docker-compose.yml down</span><br></pre></td></tr></table></figure>

<p>可通过<code>systemctl start/status/stop harbor</code>等命令操作</p>
<p>5、修改daemon.json</p>
<p><code>vim /etc/docker/daemon.json</code> 添加<code>{&quot;insecure-registries&quot;:[&quot;192.168.1.18&quot;]}</code>保存退出，此步骤是为了让docker信任私有仓库地址</p>
<p>6、重启<code>systemctl daemon-reload</code>、<code>systemctl restart docker</code></p>
<p>7、登录私有仓库<code>docker login 192.168.1.18</code></p>
<p><img src="/images/docker/dockerlogin.jpg" alt=""></p>
<h3 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h3><p>标记此镜像为私有仓库的镜像 <code>tag jdk1.8 192.168.1.18:5000/jdk1.8</code></p>
<p>上传标记的镜像 <code>docker push 192.168.1.18:5000/jdk1.8</code></p>
<p><img src="/images/docker/%E4%B8%8A%E4%BC%A0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%9301.jpg" alt=""></p>
<p><img src="/images/docker/%E4%B8%8A%E4%BC%A0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.jpg" alt=""></p>
<h3 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h3><p><code>docker pull 192.168.1.18:5000/jdk1.8</code></p>
<p><img src="/images/docker/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%8B%89%E5%8F%96.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装部署</title>
    <url>/2021/11/17/docker%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>一、确保内核版本在3.8以上</p>
<p><code>uname -a</code></p>
<p><img src="/images/docker/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC.jpg" alt=""></p>
<p>二、更新组件</p>
<p><code>yum update</code></p>
<a id="more"></a>

<p>三、安装相关依赖</p>
<p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
<p>四、指定阿里源</p>
<p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p>
<p>五、查看指定的安装源docker信息</p>
<p><code>yum list docker-ce --showduplicates | sort -r</code></p>
<p>六、安装</p>
<p>最新版本安装<code>yum install -y docker-ce</code>、制定版本安装<code>yum install -y docker-ce-18.03.1.ce</code></p>
<p>七、启动服务</p>
<p><code>systemctl start docker</code></p>
<p>八、docker版本信息</p>
<p><code>docker version</code></p>
<p><img src="/images/docker/%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 集群优化</title>
    <url>/2021/07/03/elasticsearch%20%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一、慢日志"><a href="#一、慢日志" class="headerlink" title="一、慢日志"></a>一、慢日志</h2><p>分片级别，针对于data node。</p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ul>
<li>连接大量被拒绝</li>
<li>CPU居高不下</li>
<li>查询超时</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>软件配置不合理</li>
<li>硬件资源不够</li>
</ul>
<a id="more"></a>

<h3 id="慢查询和写入配置"><a href="#慢查询和写入配置" class="headerlink" title="慢查询和写入配置"></a>慢查询和写入配置</h3><h4 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">PUT</span> <span class="string">/index/_settings</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.query.warn"</span><span class="string">:"10s",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.query.info"</span><span class="string">:"5s",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.query.debug"</span><span class="string">:"2s",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.query.trace"</span><span class="string">:"500ms",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.fetch.warn"</span><span class="string">:"1s",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.fetch.info"</span><span class="string">:"800ms",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.fetch.debug"</span><span class="string">:"500ms",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.threshold.fetch.trace"</span><span class="string">:"200ms",</span></span><br><span class="line">	<span class="string">"index.search.slowlog.level"</span><span class="string">:"info"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="慢写入配置"><a href="#慢写入配置" class="headerlink" title="慢写入配置"></a>慢写入配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">"index.indexing.slowlog.threshold.index.warn"</span><span class="string">:"10s",</span></span><br><span class="line"><span class="string">"index.indexing.slowlog.threshold.index.info"</span><span class="string">:"5s",</span></span><br><span class="line"><span class="string">"index.indexing.slowlog.threshold.index.debug"</span><span class="string">:"2s",</span></span><br><span class="line"><span class="string">"index.indexing.slowlog.threshold.index.trace"</span><span class="string">:"500ms",</span></span><br><span class="line"><span class="string">"index.indexing.slowlog.level"</span><span class="string">:"info"</span></span><br><span class="line"><span class="string">"index.indexing.slowlog.source"</span><span class="string">:1000</span></span><br></pre></td></tr></table></figure>

<h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><h3 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h3><ul>
<li>减小page size：搜索结果不要返回过大的结果集，每页搜索数据控制在1000以内。</li>
<li>避免deeping：如果需要深度分页，建议使用scroll search，如果一定要使用深查询，考虑使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.11/paginate-search-results.html#search-after" target="_blank" rel="noopener">search after</a></li>
<li>聚合查询避免过多分桶：对于桶数过多的聚合，应将数据切片：比如按时间、按地理位置等分词请求。</li>
<li>能用filter的地方不要使用query，filter不参与评分效率较query高</li>
<li>避免过多使用agg嵌套</li>
<li>尽量避免使用fuzzy、前缀和正则，可用使用suggest做迷糊搜索</li>
</ul>
<h3 id="写入优化"><a href="#写入优化" class="headerlink" title="写入优化"></a>写入优化</h3><ul>
<li>用bulk批量写入</li>
<li>使用多线程将数据写入es </li>
<li>大量数据一次性写入es：如果需要一次性写入大量数据，可以先禁止refresh和replica复制，将<code>index.refresd_interval</code>设置为-1，将<code>index.number_of_replicas</code>设置为0。此时es不需要创建segment file文件，也不需要项副本同步数据，相对来水写入速度会非常快，等数据写入完成之后，再将这两个参数设置回来。</li>
<li>增加buffer缓冲区大小：<code>indices.memory.index_buffer_size</code>，一般来说<code>indices.memory.index_buffer_size</code> / <code>total_shards</code>  &lt; jvm heap的10%，增大buffer的大小可以大大提高写入速度</li>
<li>把更多内存留给OS Cache：可能有人认为应该把jvm heap调大来增加性能，这都是想当然的操作，我们不仅不应该增大jvm heap，反而应该把更多的内存留给OS Cache，因为lucene底层读写都是基于OS Cache的，需要大量的内存。</li>
</ul>
<h3 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h3><ul>
<li>尽量使用手工mapping，尽量手动指定string字段类型</li>
<li>避免稀疏数据结构：会产生磁盘浪费，同时降低读写性能</li>
<li>避免将没有任何关联性的数据写入同一个索引</li>
<li>检索和聚合解耦：避免把大量用于检索的数据和用于聚合的数据放在同一个index</li>
<li>仅用于检索的字段关闭doc value，仅用于聚合的字段关闭index</li>
<li>避免使用fielddata</li>
<li>禁用norms：对于不需要参与评分的字段，可以设置为false，常见的比如filter和agg的字段</li>
<li>禁用index_options</li>
<li>禁用_all field</li>
<li>source和store分离（es会将所有字段放入source字段中，每次查询会将整个source返回交给客户端解析；store方式则将每个字段单独存储）</li>
<li>使用最小的数据类型：能用short的不要用long，这一点在es中尤为重要</li>
<li>scripting查询参数化：script脚本会触发编译行为，并且产生缓存，使用不当会造成查询巨慢，甚至OOM</li>
<li>id：对于某些id字段，不需要我们做全文检索，可以使用keyword，会比数据类型获得更好的性能</li>
<li>业务框架解耦：避免业务对es过多的功能依赖，es本身是一个搜索、存储、分析引擎，尽量把功能依赖放在这三个点上，有些功能虽然es提供了，但是能用其他方案取代就尽量不用es，让es有更多的资源专注于搜索和聚合。即便es提供的解决方案更好，但是代价却是占用了主要的资源，比如智能推荐、模糊查询等</li>
</ul>
<h3 id="集群优化"><a href="#集群优化" class="headerlink" title="集群优化"></a>集群优化</h3><ul>
<li>冷热分离：高频数据使用性能更好的硬件，HDD &lt; SSD &lt; RAM</li>
<li>单一职责：关闭master节点的data node设置，集群越大，数据节点和master节点越要分开</li>
<li>增加<code>协调节点</code>的数据：稳定的master节点对于集群健康非常重要。理论上讲，应该尽可能减轻master节点的压力，分片数据越多，master节点维护管理shard的任务越重，并且节点可能就要承担更多的数据转发任务，但增加<code>仅协调节点(node.master = false和node.data=false)</code>会增加整个集群的负担，因为选择master需要等待集群每个节点的集群状态确认</li>
<li>高可用集群至少需要三个主节点，其中至少两个不是<code>仅投票节点(Node.voting_only = true)</code>。即使其中一个节点发生故障，集群也能够选举一个主节点。生产环境最好设置三台<code>仅master候选节点</code>（node.master=true node.data=false）</li>
<li>为了确保集群仍然可用，集群不能同时停止投票配置中的一半或更多节点。只要有一半以上的<code>投票节点</code>可用，集群仍可以正常工作。这意味着，如果有两个或更少的主机资格节点，则他们必须保持高可用</li>
<li>禁用swapping：swapping会大大降低性能</li>
</ul>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul>
<li>控制分片数量：每台节点的shard数据越少，每个shard分配的cpu、内存和io资源更多，单个shard的性能越好。当一台机器一个shard时，该shard的性能最好。分片越少，分页查询速度越快。但如果相同资源分片相同的前提下，shard数量越少，单个shard的体积越大，查询性能越低，速度越慢，这个取舍应该根据实际集群状况和结合应用场景等因素总和考虑。单个分片不要太大尽量不要超过20-40G</li>
<li>搜索日志：统计高频词汇，对于命中率极高的关键词添加应用层缓存</li>
<li>冷热分离：把冷热数据放在不同的索引</li>
</ul>
<p>硬件优化</p>
<ul>
<li><p>全能型：数据节点处理与数据相关的操作，例如CRUD、搜索和聚合。这些操作时IO、内存和CPU密集型的，所以他们需要更高配置的服务器以及更高的带宽，并且集群的性能冗余非常重要</p>
</li>
<li><p>带宽：由于仅投票节点不参与master竞选，所以和真正的master节点相比，它需要的内存和CPU较少。但是所有候选节点以及仅投票节点都可能是数据及诶单，所以他们都需要快速稳定低延迟的网络</p>
</li>
</ul>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>docker迁移备份</title>
    <url>/2021/11/17/docker%E8%BF%81%E7%A7%BB%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="迁移备份"><a href="#迁移备份" class="headerlink" title="迁移备份"></a>迁移备份</h2><h3 id="容器转镜像"><a href="#容器转镜像" class="headerlink" title="容器转镜像"></a>容器转镜像</h3><p><code>docker commit 容器名称 镜像名称</code></p>
<p><img src="/images/docker/%E5%AE%B9%E5%99%A8%E8%BD%AC%E9%95%9C%E5%83%8F.jpg" alt=""></p>
<blockquote>
<p>镜像名称不能大写</p>
</blockquote>
<a id="more"></a>

<h3 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h3><p><code>docker save -o xxx.tar 镜像名称</code></p>
<p><img src="/images/docker/%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD.jpg" alt=""></p>
<h3 id="镜像恢复"><a href="#镜像恢复" class="headerlink" title="镜像恢复"></a>镜像恢复</h3><p><code>docker load -i xxx.tar</code></p>
<p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D.jpg" alt=""></p>
<p><code>docker load &lt; xxx.tar</code></p>
<p><img src="/images/docker/%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D02.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 面试题</title>
    <url>/2021/06/28/elasticsearch%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1、为什么要使用ElasticSearch？"><a href="#1、为什么要使用ElasticSearch？" class="headerlink" title="1、为什么要使用ElasticSearch？"></a>1、为什么要使用ElasticSearch？</h2><p>  系统中的数据，随着业务的发展和时间的推移， 将会<strong>非常多</strong>， 而业务中往往采用<strong>模糊查询</strong>进行数据的搜索，而模糊查询会导致<strong>查询引擎放弃索引</strong>，从而导致系统查询数据时都是<strong>全表扫描</strong>，在百万级别的数据库中查询<strong>效率是非常低下</strong>的，而我们使用ElasticSearch做一个全文索引，将经常查询的系统功能中的某些字段放入 ElasticSearch索引库里，可以<strong>提高查询速度</strong>。</p>
<h2 id="2、ElasticSearch-的-master-选举流程是怎样的"><a href="#2、ElasticSearch-的-master-选举流程是怎样的" class="headerlink" title="2、ElasticSearch 的 master 选举流程是怎样的"></a>2、ElasticSearch 的 master 选举流程是怎样的</h2><p>  ElasticSearch 的选举是 ZenDiscovery 模块负责的，主要包含 Ping （节点之间通过这个 RPC 来发现彼此）和 Unicast （单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分</p>
<p>1、对所有可以成为 master 的节点（<strong>node.master: true</strong>）根据 nodeId 字典排序，每次选举每个节点都把自<br>己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p>
<p>2、如果对某个节点的投票数达到一定的值（可以成为 master需要的节点数为： <strong>n/2+1</strong> ）并且该节点<strong>自己也选举自己</strong>，如果都符合，那这个节点就是 master ，否则重新选举一直到满足上述条件。</p>
<p>  master节点的职责主要包括<strong>集群、节点和索引的管理</strong>，<strong>不负责文档级别的管理</strong>，此时master节点可以关闭node.data功能。</p>
<a id="more"></a>

<h2 id="3、ElasticSearch集群的脑裂问题"><a href="#3、ElasticSearch集群的脑裂问题" class="headerlink" title="3、ElasticSearch集群的脑裂问题"></a>3、ElasticSearch集群的脑裂问题</h2><h3 id="3-1、出现原因"><a href="#3-1、出现原因" class="headerlink" title="3.1、出现原因"></a>3.1、出现原因</h3><ul>
<li><p><strong>网络问题</strong>：集群间的<strong>网络延迟</strong>导致一些节点访问不到master，认为master挂掉了从而选举出新的master；</p>
</li>
<li><p><strong>节点负载</strong>：主节点的角色<strong>既是master又是data</strong>，当<strong>访问量大</strong>时可能会导致ElasticSearch<strong>停止响应造成大面积延迟</strong>，其他节点<strong>得不到master的响应</strong>从而认为master挂掉了从而选举出新的master；</p>
</li>
<li><p><strong>内存回收</strong>：data节点上的ES进程<strong>占用的内存</strong>较大，从而引发JVM的规模的<strong>内存回收</strong>，造成ES失去响应。</p>
</li>
</ul>
<h3 id="3-2、解决方案"><a href="#3-2、解决方案" class="headerlink" title="3.2、解决方案"></a>3.2、解决方案</h3><ul>
<li><p><strong>减少误判</strong>：可以设置 <code>discovery.zen.ping_timeout</code> 节点状态的响应时间，该参数的意思是，如果master在该响应时间内没有做出响应，则判断该节点宕机，默认为 3s。可以适当<strong>增大响应时间</strong>来减少其他节点对<strong>master状态的误判</strong>；</p>
</li>
<li><p><strong>选举触发</strong> : 可以设置<code>discovery.zen.minimum_master_nodes</code>，该参数是用于<strong>控制选举行为发生的最小集群主节点数量</strong>。当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。默认值是1，官方建议为（ n/2）+1 个，其中n为主节点个数（即有资格成为主节点的节点个数）；</p>
</li>
<li><p><strong>角色分离</strong>：即将<strong>master节点和data节点分离</strong>，限制角色。</p>
<p>​    主节点配置为：<code>node.master: true</code> 、<code>node.data: false</code></p>
<p> 从节点配置为：<code>node.master: false</code> 、<code>node.data: true</code></p>
</li>
</ul>
<h2 id="4、Elasticsearch索引文档的流程？"><a href="#4、Elasticsearch索引文档的流程？" class="headerlink" title="4、Elasticsearch索引文档的流程？"></a>4、Elasticsearch索引文档的流程？</h2><p>1、一个文档请求发送到任意集群节点上；</p>
<p>2、获得请求的节点成为协调节点默认使用文档ID参与计算，以便为路由提供合适的分片；</p>
<p>      <strong>shard = hash(document_id) % (num_of_primary_shards)</strong></p>
<p>3、当分片所在节点接收来自协调节点的请求后，会将请求的文档写入到Memory Buffer中，然后定时（默认是1s）写入FileSystem Cache，这个过程称为refresh；</p>
<p>4、在某些情况中，Memory Buffer 和 FileSystem Cache 中的数据可能会丢失，ElasticSearch通过translog的机制来保证数据的可靠性。它的机制是：接收到请求后，同时写入到translog中，只有当FileSystem cache的数据写如此盘中时，才会将translog清除掉，这个过程称为flush；</p>
<p>注：在flush的过程中，内存中的缓存将会被清除掉内容被写入一个新段，段的 fsync 将创建一个新的提交点， 并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。flush触发的时机是定时触发（默认30min）或者translog文件太大（默认512M）。</p>
<h2 id="5、ElasticSearch更新和删除文档的流程"><a href="#5、ElasticSearch更新和删除文档的流程" class="headerlink" title="5、ElasticSearch更新和删除文档的流程"></a>5、ElasticSearch更新和删除文档的流程</h2><p>  虽然删除和更新文档也是写操作，但是由于ElasticSearch的文档不可变性，所以不能通过删除或修改文档来执行变更操作。</p>
<p>  当执行删除请求时，我们的文档本质并没有被删除，而是由于磁盘上的每一个段都有对应的一个.del文件，删除的文档会在.del文件中被标记为删除。此时，虽然文档还是能够在查询过程中被匹配出来，但是他会在结果中被过滤掉。</p>
<p>  当执行更新请求时，由于我们ElasticSearch中存在一个版本号，所以此时旧版本的文档会在.del文件上被标记为删除，而新版本的文档则会被索引到一个新段。此时，我们能够同时查询到两个版本的文档，但是在结果中，旧版本的文档会被过滤掉，只会返回最新版本的文档。</p>
<p>  当执行段合并时，此时会真的将.del文件中被标记删除的文档执行物理删除。</p>
<h2 id="6、ElasticSearch的搜索流程"><a href="#6、ElasticSearch的搜索流程" class="headerlink" title="6、ElasticSearch的搜索流程"></a>6、ElasticSearch的搜索流程</h2><p>搜索被执行成一个两阶段过程，称为 Query Then Fetch；</p>
<p>1、在初始查询阶段，查询会<strong>广播到索引中每一个分片拷贝（主分片或者副本分片）</strong>。 每个分片在本地执行搜索并构建一个匹配文档的大小为 <strong>from + size 的优先队列</strong>。PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</p>
<p>2、每个分片返回各自优先队列中<strong>所有文档的 ID 和排序值 给协调节点</strong>，协调节点合并这些值到自己的优先队列中来产生一个<strong>全局排序后的结果列表</strong>。</p>
<p>3、接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向<strong>相关的分片提交多个 GET 请求</strong>。每个分片<strong>加载并丰富文档</strong>，接着返回文档给协调节点。一旦所有的文档都被取回了， 协调节点返回结果给客户端。</p>
<p>  Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少 的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</p>
<h2 id="7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？"><a href="#7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？" class="headerlink" title="7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？"></a>7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？</h2><p>1、使用内存更高的机器部署ElasticSearch（64G最优，不要少于8G）；</p>
<p>2、选择更多核心数的机器；</p>
<p>3、负担得起的话，使用SSD会远远超过任何旋转介质，查询和索引性能都会有所提升；</p>
<p>4、确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用Java的本地序列化；</p>
<p>5、通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟；</p>
<p>6、不要随意修改垃圾回收器（CMS）和各个线程池的大小；</p>
<p>7、把内存的（少于）一半给 Lucene（但不要超过 32 GB！），可以通过 ES_HEAP_SIZE 环境变量设置。</p>
<h3 id="补充：在索引阶段性能提升的方法："><a href="#补充：在索引阶段性能提升的方法：" class="headerlink" title="补充：在索引阶段性能提升的方法："></a>补充：在索引阶段性能提升的方法：</h3><p>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点；</p>
<p>2、使用SSD；</p>
<p>3、段和合并：ElasticSearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD， 可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。 另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段；</p>
<p>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的 index.refresh_interval （刷新到文件系统缓存）由1s改到 30s；</p>
<p>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副本。</p>
<h2 id="8、在GC方面，在使用-ElasticSearch-时要注意什么？"><a href="#8、在GC方面，在使用-ElasticSearch-时要注意什么？" class="headerlink" title="8、在GC方面，在使用 ElasticSearch 时要注意什么？"></a>8、在GC方面，在使用 ElasticSearch 时要注意什么？</h2><p>1、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势；</p>
<p>2、field cache, filter cache, indexing cache, bulk queue 等等各类缓存，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，避免采用 clear cache 等“自欺欺人”的方式来释放内存；</p>
<p>3、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p>
<h2 id="9、-对于大数据量（上亿量级）的聚合如何实现？"><a href="#9、-对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="9、 对于大数据量（上亿量级）的聚合如何实现？"></a>9、 对于大数据量（上亿量级）的聚合如何实现？</h2><p>  ElasticSearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h2 id="10、在并发情况下，ElasticSearch-如果保证读写一致？"><a href="#10、在并发情况下，ElasticSearch-如果保证读写一致？" class="headerlink" title="10、在并发情况下，ElasticSearch 如果保证读写一致？"></a>10、在并发情况下，ElasticSearch 如果保证读写一致？</h2><p>  可以通过<strong>版本号使用乐观锁</strong>并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>  对于写操作，一致性级别支持 quorum[半数]/one[主分片]/all[所有分片]，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>  对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回； 如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片， 确保文档是最新版本。</p>
<h2 id="11、Elasticsearch-中的集群、节点、索引、文档是什么？"><a href="#11、Elasticsearch-中的集群、节点、索引、文档是什么？" class="headerlink" title="11、Elasticsearch 中的集群、节点、索引、文档是什么？"></a>11、Elasticsearch 中的集群、节点、索引、文档是什么？</h2><p>1、集群是<strong>一个或多个节点（服务器）的集合</strong>，它们<strong>共同保存您的整个数据</strong>，并提供<strong>跨所有节点的联合索引和搜索</strong>功能。群集由唯一名称标识，默认情况下为 “elasticsearch“ 。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是集群的一部分；</p>
<p>2、节点是属于<strong>集群一部分（单个服务器）</strong>。它用来<strong>存储数据并参与群集索引和搜索功能</strong>；</p>
<p>3、索引就像关系数据库中的<strong>数据库</strong>。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。 <strong>旧版本的索引相当于MySQL 的数据库，新版本对标的是数据库表</strong>；</p>
<p>4、文档类似于关系数据库中的<strong>每一行数据</strong>。不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于<strong>通用字段应该具有相同的数据类型</strong>。 </p>
<h2 id="12、Elasticsearch-中的倒排索引是什么？"><a href="#12、Elasticsearch-中的倒排索引是什么？" class="headerlink" title="12、Elasticsearch 中的倒排索引是什么？"></a>12、Elasticsearch 中的倒排索引是什么？</h2><p>  倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。 ES中的倒排索引 其实就是 <strong>Lucene 的倒排索引</strong>，区别于传统的正向索引，倒排索引会<strong>再存储数据时将关键词和数据进行关联</strong>，保存到倒排表中，然后在查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。</p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(一)-基本概念</title>
    <url>/2021/05/24/elasticsearch%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>ES是基于Lucene分布式搜索服务，可以存储整个对象或文档，分布式的实时文件存储，每个字段都被索引并可被搜索，分布式的实时分析搜索引擎，可以扩展到上百台服务器，处理PB级结构化或非结构化数据。</p>
<h3 id="与传统数据库的对比"><a href="#与传统数据库的对比" class="headerlink" title="与传统数据库的对比"></a>与传统数据库的对比</h3><p><img src="/images/elk/elastic-search/es-01.png" alt=""></p>
<a id="more"></a>

<h3 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h3><p>索引是ES的一个逻辑存储，对应关系型数据库中的库，ES可以把索引数据存放到服务器中，也可以sharding(分片)后存储到多台服务器上。每个索引有一个或多个分片，每个分片可以有多个副本。</p>
<h3 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h3><p>ES中，一个索引可以存储多个用于不同用途的对象，可以通过类型来区分索引中的不同对象，对应关系型数据库中表的概念。但是在ES6.0开始，类型的概念被废弃，ES7中将它完全删除。删除type的原因：</p>
<p>我们一直认为ES中的“index”类似于关系型数据库的“database”，而“type”相当于一个数据表。ES的开发者们认为这是一个糟糕的认识。例如：关系型数据库中两个数据表示是独立的，即使他们里面有相同名称的列也不影响使用，但ES中不是这样的。</p>
<p>我们都知道elasticsearch是基于Lucene开发的搜索引擎，而ES中不同type下名称相同的filed最终在Lucene中的处理方式是一样的。举个例子，两个不同type下的两个user_name，在ES同一个索引下其实被认为是同一个filed，你必须在两个不同的type中定义相同的filed映射。否则，不同type中的相同字段名称就会在处理中出现冲突的情况，导致Lucene处理效率下降。</p>
<p>去掉type能够使数据存储在独立的index中，这样即使有相同的字段名称也不会出现冲突，就像ElasticSearch出现的第一句话一样“你知道的，为了搜索····”，去掉type就是为了提高ES处理数据的效率。</p>
<p>除此之外，在同一个索引的不同type下存储字段数不一样的实体会导致存储中出现稀疏数据，影响Lucene压缩文档的能力，导致ES查询效率的降低。</p>
<h3 id="文档（document）"><a href="#文档（document）" class="headerlink" title="文档（document）"></a>文档（document）</h3><p>存储在ES中的主要实体叫文档，可以理解为关系型数据库中表的一行数据记录。每个文档由多个<strong>字段（field）</strong>组成。区别于关系型数据库的是，ES是一个非结构化的数据库，每个文档可以有不同的字段，并且有一个唯一标识。</p>
<h3 id="映射（mapping）"><a href="#映射（mapping）" class="headerlink" title="映射（mapping）"></a>映射（mapping）</h3><p>mapping是对索引库中的索引字段及其数据类型进行定义，类似于关系型数据库中的表结构。ES默认动态创建索引和索引类型的mapping，这就像是关系型数据中的，无需定义表机构，更不用指定字段的数据类型。当然也可以手动指定mapping类型。</p>
<h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><h3 id="分片（shard）"><a href="#分片（shard）" class="headerlink" title="分片（shard）"></a>分片（shard）</h3><p>如果我们的索引数据量很大，超过硬件存放单个文件的限制，就会影响查询请求的速度，Es引入了分片技术。一个分片本身就是一个完成的搜索引擎，文档存储在分片中，而分片会被分配到集群中的各个节点中，随着集群的扩大和缩小，ES会自动的将分片在节点之间进行迁移，以保证集群能保持一种平衡。分片有以下特点：</p>
<ol>
<li>ES的一个索引可以包含多个分片（shard）；</li>
<li>每一个分片（shard）都是一个最小的工作单元，承载部分数据；</li>
<li>每个shard都是一个lucene实例，有完整的简历索引和处理请求的能力；</li>
<li>增减节点时，shard会自动在nodes中负载均衡；</li>
<li>一个文档只能完整的存放在一个shard上（主节点）</li>
<li>一个索引中含有shard的数量，默认值为5，在索引创建后这个值是不能被更改的。</li>
<li>优点：水平分割和扩展我们存放的内容索引；分发和并行跨碎片操作提高性能/吞吐量；</li>
<li>每一个shard关联的副本分片（replica shard）的数量，默认值为1，这个设置在任何时候都可以修改。</li>
<li>primary shard和对应的replica shard<strong>不能同时存在于同一个节点</strong>，所以最低的可用配置是两个节点，互为主备。</li>
<li><strong>primary shard是可读可写的，而replica shard是只读的。</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分片的好处：</span><br><span class="line">1.当某一台服务器宕机，可以保证其他数据的完整性（非最优方案）</span><br><span class="line">2.横向扩容：当数据量增大时，只需要添加一个新的结点，然后创建新的索引，操作非常简单</span><br><span class="line">3.看似占用了更多的服务器资源，实际上replica shard带来了性能和集群吞吐量的提升，这点和横向扩容是相同的。</span><br><span class="line">不同的是，横向扩容是可以承载更多的数据，而replica shard是单纯的增加数据的副本，带来的是性能和高可用。</span><br></pre></td></tr></table></figure>

<h3 id="副本（replica）"><a href="#副本（replica）" class="headerlink" title="副本（replica）"></a>副本（replica）</h3><p>副本（replica shard）就是shard的冗余备份，它的主要作用：</p>
<ol>
<li>冗余备份，防止数据丢失；</li>
<li>shard异常时负责容错和负载均衡；</li>
</ol>
<h2 id="ES的特性"><a href="#ES的特性" class="headerlink" title="ES的特性"></a>ES的特性</h2><p>分布式、高性能、高可用、可伸缩、易维护、速度快、弹性、灵活、操作简单、多语言客户端、X-Pack、hadoop/spark强强联手、开箱即用。</p>
<ul>
<li><strong>分布式：</strong>横向扩展非常灵活</li>
<li><strong>全文检索：</strong>基于lucene的强大的全文检索能力；</li>
<li><strong>近实时搜索和分析：</strong>数据进入ES，可达到近实时搜索，还可进行聚合分析</li>
<li><strong>高可用：</strong>容错机制，自动发现新的或失败的节点，重组和重新平衡数据</li>
<li><strong>模式自由：</strong>ES的动态mapping机制可以自动检测数据的结构和类型，创建索引并使数据可搜索。</li>
<li><strong>RESTful API：</strong>JSON + HTTP</li>
</ul>
<p><strong>应用领域：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.百度（全文检索、高亮、搜索推荐）</span><br><span class="line">2.各大网站的用户行为日志（用户点击、浏览、收藏、评论）</span><br><span class="line">3.BI（Business Intelligence商业智能），数据分析：数据挖掘统计。</span><br><span class="line">4.Github：代码托管平台，几千亿行代码</span><br><span class="line">5.ELK：Elasticsearch（数据存储）、Logstash（日志采集）、Kibana（可视化）</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.面向开发者友好，屏蔽了Lucene的复杂特性，集群自动发现（cluster discovery）</span><br><span class="line">2.自动维护数据在多个节点上的建立</span><br><span class="line">3.会帮我做搜索请求的负载均衡</span><br><span class="line">4.自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</span><br><span class="line">5.ES基于Lucene提供了很多高级功能：复合查询、聚合分析、基于地理位置等。</span><br><span class="line">6.对于大公司，可以构建几百台服务器的大型分布式集群，处理PB级别数据；对于小公司，开箱即用，门槛低上手简单。</span><br><span class="line">7.相遇传统数据库，提供了全文检索，同义词处理（美丽的cls&gt;漂亮的cls），相关度排名。聚合分析以及海量数据的近实时（NTR）处理，这些传统数据库完全做不到。</span><br></pre></td></tr></table></figure>

<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引（Inverted Index）也叫反向索引，有反向索引必有正向索引。通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据结构：</span><br><span class="line">1、包含这个关键词的document list</span><br><span class="line">2、关键词在每个doc中出现的次数 TF term frequency</span><br><span class="line">3、关键词在整个索引中出现的次数 IDF inverse doc frequency</span><br><span class="line">4、关键词在当前doc中出现的次数</span><br><span class="line">5、每个doc的长度，越长相关度越低</span><br><span class="line">6、包含这个关键词的所有doc的平均长度</span><br></pre></td></tr></table></figure>

<p><strong>Term（单词）</strong>：一段文本经过分析器分析以后就会输出一串单词，这一个一个的就叫做Term（直译为：单词）</p>
<p><strong>Term Dictionary（单词字典）</strong>：顾名思义，它里面维护的是Term，可以理解为Term的集合</p>
<p><strong>Term Index（单词索引）</strong>：为了更快的找到某个单词，我们为单词建立索引</p>
<p><strong>Posting List（倒排列表）</strong>：倒排列表记录了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。（PS：实际的倒排列表中并不只是存了文档ID这么简单，还有一些其它的信息，比如：词频（Term出现的次数）、偏移量（offset）等，可以想象成是Python中的元组，或者Java中的对象）</p>
<p>（PS：如果类比现代汉语词典的话，那么Term就相当于词语，Term Dictionary相当于汉语词典本身，Term Index相当于词典的目录索引）</p>
<p>每个文档都有一个ID，如果插入的时候没有指定的话，Elasticsearch会自动生成一个。</p>
<p><img src="/images/elk/elastic-search/es-02.png" alt="es"></p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上。但是，实际情况取决于集群拥有的分片和索引的数量以及它们的大小，不一定总是能均匀地分布。</p>
<p>ES不允许Primary和它的Replica放在同一个节点中，并且同一个节点不接受完全相同的两个Replica</p>
<p>同一个节点允许多个索引的分片同时存在。</p>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>在局部出错异常的情况下，保证服务正常运行并且有自行恢复能力。</p>
<p><img src="/images/elk/elastic-search/es-03-01.jpg" alt=""></p>
<p><img src="/images/elk/elastic-search/es-03-02.jpg" alt=""></p>
<p><strong>Master节点会尝试重启故障机，故障机启动后将作为Slave节点</strong></p>
<p>数据同步，Master会将宕机期间丢失的数据<strong>增量同步</strong>到重启机器对应的分片上去。</p>
<p><strong>主节点的Shard分片和副本shard分片不能同时存在于同一个节点，横向扩容新节点时，ES会自动进行分片重新均衡。</strong></p>
<blockquote>
<p>如何提高ES分布式系统的可用性以及性能最大化？</p>
</blockquote>
<p>（1）每台节点的Shard数量越少，每个shard分配的CPU、内存和IO资源越多，单个Shard的性能越好，当一台机器一个Shard时，单个Shard性能最好。</p>
<p>（2）<strong>稳定的Master节点对于群集健康非常重要</strong>！理论上讲，应该尽可能的减轻Master节点的压力，分片数量越多，Master节点维护管理shard的任务越重，并且节点可能就要承担更多的数据转发任务，可增加“仅协调”节点来缓解Master节点和Data节点的压力，但是在集群中添加过多的仅协调节点会增加整个集群的负担，因为选择的主节点必须等待每个节点的集群状态更新确认。</p>
<p>（3）反过来说，如果相同资源分配相同的前提下，shard数量越少，单个shard的体积越大，查询性能越低，速度越慢，这个取舍应根据实际集群状况和结合应用场景等因素综合考虑。</p>
<p>（4）数据节点和Master节点一定要分开，集群规模越大，这样做的意义也就越大。</p>
<p>（5）数据节点处理与数据相关的操作，例如CRUD，搜索和聚合。这些操作是I / O，内存和CPU密集型的，所以他们需要更高配置的服务器以及更高的带宽，并且集群的性能冗余非常重要。</p>
<p>（6）由于仅投票节不参与Master竞选，所以和真正的Master节点相比，它需要的内存和CPU较少。但是，所有候选节点以及仅投票节点都可能是数据节点，所以他们都需要快速稳定低延迟的网络。</p>
<p>（7）高可用性（HA）群集至少需要三个主节点，其中<strong>至少两个不是仅投票</strong>节点。即使其中一个节点发生故障，这样的群集也将能够选举一个主节点。生产环境最好设置3台仅Master候选节点（node.master = true     node.data = true）</p>
<p> （8）为确保群集仍然可用，集群<strong>不能同时停止投票配置中的一半或更多节点</strong>。只要有一半以上的投票节点可用，群集仍可以正常工作。这意味着，如果存在三个或四个主节点合格的节点，则群集可以容忍其中一个节点不可用。如果有两个或更少的主机资格节点，则它们必须都保持可用</p>
<h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p>每个节点都会不定期的在集群做广播，ping所有节点</p>
<p><img src="/images/elk/elastic-search/es-06.jpg" alt=""></p>
<p><img src="/images/elk/elastic-search/es-07.png" alt="es"></p>
<img src="/images/elk/elastic-search/es-08.jpg" alt="es" style="zoom:67%;" />

<p><strong>如果是偶数节点，Elasticsearch会将其中一个排除在投票配置之外，确保其大小为奇数。</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">下载地址</a> ES的启动需要JDK环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window版本启动：</span><br><span class="line">  elasticsearch.bat</span><br><span class="line"></span><br><span class="line">linux版本启动：</span><br><span class="line">  .&#x2F;elasticsearch -d</span><br><span class="line">  </span><br><span class="line">验证：</span><br><span class="line">  http:&#x2F;&#x2F;localhost:9200&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，可以进行各种操作，从跟踪查询负载，到理解请求如何流经整个应用，都能轻松完成。</p>
<p><a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINUX启动：</span><br><span class="line">.&#x2F;kibana</span><br><span class="line"></span><br><span class="line">WINDOW启动</span><br><span class="line">kibana.bat</span><br><span class="line"></span><br><span class="line">验证：</span><br><span class="line">http:&#x2F;&#x2F;localhost:5601</span><br></pre></td></tr></table></figure>

<h3 id="Head插件"><a href="#Head插件" class="headerlink" title="Head插件"></a>Head插件</h3><p>提供可视化的操作页面对<code>ElasticSearch</code>搜索引擎进行各种设置和数据检索功能，可以很直观的查看集群的健康状况，索引分配情况，还可以管理索引和集群以及提供方便快捷的搜索功能等等。</p>
<p>依赖于node 和 grunt管理工具    <a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">下载地址</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">安装grunt环境：</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install -g grunt-cli</span></span><br><span class="line"><span class="attr">检查：</span></span><br><span class="line"><span class="attr">grunt</span> <span class="string">-version</span></span><br></pre></td></tr></table></figure>

<p>解压下载的压缩包，打开<code>glasticsearch-head-master</code>文件夹，修改<code>Gruntfile.js</code>文件，添加<code>hostname:&#39;*&#39;</code></p>
<p><img src="/images/elk/elastic-search/es-05.png" alt="es"></p>
<p>在当前目录输入<code>npm install</code>，     <code>npm run start</code>启动</p>
<p>验证：<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a> 安装成功</p>
<p>如果无法发现ES节点，尝试在ES配置文件中设置允许跨域</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<h3 id="ES节点"><a href="#ES节点" class="headerlink" title="ES节点"></a>ES节点</h3><p><code>Master：主节点</code></p>
<p>每个集群都有且只有一个，尽量避免Master节点中配置node.data ＝ true； Master节点的主要职责是和集群操作相关的内容，例如创建或删除索引、跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点。</p>
<p><code>voting：投票节点</code></p>
<p>需配置 Node.voting_only = true（仅投票节点，即使配置了node.master = true，也不会参选, 但是仍然可以作为数据节点）</p>
<p><code>coordinating：协调节点</code></p>
<p>每一个节点都隐式的是一个协调节点，如果同时设置了node.master = false和node.data=false，那么此节点将成为仅协调节点，该节点只能处理路由请求，处理搜索，分发索引操作</p>
<p><code>Master-eligible node：候选节点</code></p>
<p>设置node.master = true即是候选节点，具备竞选master的资格。</p>
<p><code>Data node：数据节点</code></p>
<p>数据节点主要是存储索引数据的节点，<strong>主要对文档进行增删改查操作，聚合操作</strong>等。</p>
<p><code>Ingest node：预处理节点</code></p>
<p>可以在实际的 <strong>indexing</strong>（索引）发生之前使用 <strong>ingest</strong> <strong>node</strong> 来预处理 <strong>documents</strong>（文档）通过node.ingest: true设置</p>
<p><code>Machine learning node：机器学习节点</code></p>
<p>相关配置参数如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.node.master</span> = <span class="string">true	 node.data = true</span></span><br><span class="line"><span class="attr">这是ES节点默认配置，既作为候选节点又作为数据节点，这样的节点一旦被选举为Master，压力是比较大的</span></span><br><span class="line"><span class="attr">通常来说Master节点应该只承担较为轻量级的任务，比如创建删除索引，分片均衡等。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.node.master</span> = <span class="string">true	 node.data = false</span></span><br><span class="line"><span class="attr">只作为候选节点，不作为数据节点，可参选Master节点，当选后成为真正的Master节点。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.node.master</span> = <span class="string">false	 node.data = false</span></span><br><span class="line"><span class="attr">既不当候选节点，也不作为数据节点，那就是仅协调节点，负责负载均衡</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.node.master</span>=<span class="string">false		node.data=true</span></span><br><span class="line"><span class="attr">不作为候选节点，但是作为数据节点，这样的节点主要负责数据存储和查询服务。</span></span><br></pre></td></tr></table></figure>

<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL:</span><br><span class="line">  _cat&#x2F;health</span><br><span class="line">  _cluster&#x2F;health</span><br></pre></td></tr></table></figure>

<blockquote>
<p>健康值状态</p>
</blockquote>
<p>① <strong>Green</strong>：所有Primary shard和Replica shard均为active，集群健康</p>
<p>② <strong>Yellow</strong>：至少一个Replica shard不可用，但是所有Primary shard均为active，数据仍然是可以保证完整性的。</p>
<p>③ <strong>Red</strong>：至少有一个Primary shard为不可用状态，数据不完整，集群不可用。</p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><strong>elasticearch.yml配置</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">my-application</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#集群名字 同一个集群的节点要设置在同一个集群名称</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">csdemo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#节点名字 同一集群的节点名称不能相同</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#指定节点的部落属性，这是一个比集群更大的范围。</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment"># 数据存放目录</span></span><br><span class="line"><span class="comment">#path.data: /path/to/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#锁定物理内存地址，防止elasticsearch内存被交换出去,也就是避免es使用swap交换分区</span></span><br><span class="line"><span class="meta">bootstrap.memory_lock</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#当系统进行内存交换的时候，es的性能很差</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#设置ip绑定</span></span><br><span class="line"><span class="meta">network.host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#自定义端口号</span></span><br><span class="line"><span class="meta">http.port</span>: <span class="string">9202</span></span><br><span class="line"><span class="meta">transport.tcp.port</span>: <span class="string">9302</span></span><br><span class="line"><span class="comment"># 是否启用TCP保持活动状态，默认为true</span></span><br><span class="line"><span class="meta">network.tcp.keep_alive</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#是否启用tcp无延迟，true为启用tcp不延迟，默认为false启用tcp延迟</span></span><br><span class="line"><span class="meta">network.tcp.no_delay</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#设置是否压缩tcp传输时的数据，默认为false，不压缩。</span></span><br><span class="line"><span class="meta">transport.tcp.compress</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#设置成主服务</span></span><br><span class="line"><span class="meta">node.master</span>: <span class="string">false</span></span><br><span class="line"><span class="comment"># 时候进行数据存贮</span></span><br><span class="line"><span class="meta">node.data</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#集群节点列表</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is ["127.0.0.1", "[::1]"]</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="meta">discovery.seed_hosts</span>: <span class="string">["127.0.0.1:9301", "127.0.0.1:9302", "127.0.0.1:9303"]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="meta">cluster.initial_master_nodes</span>: <span class="string">["node-1", "node-2", "node-3"]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#每个节点在选中的主节点的检查之间等待的时间。默认为1秒</span></span><br><span class="line"><span class="meta">cluster.fault_detection.leader_check.interval</span>: <span class="string">15s </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置主节点等待每个集群状态完全更新后发布到所有节点的时间，默认为30秒</span></span><br><span class="line"><span class="meta">cluster.publish.timeout</span>: <span class="string">90s</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#集群内同时启动的数据任务个数，默认是2个</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.cluster_concurrent_rebalance: 2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#添加或删除节点及负载均衡时并发恢复的线程个数，默认4个</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.node_concurrent_recoveries: 4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#集群中的N个节点启动后,才允许进行数据恢复处理</span></span><br><span class="line"><span class="meta">gateway.recover_after_nodes</span>: <span class="string">3</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">gateway.expected_nodes</span>: <span class="string">3</span></span><br><span class="line"><span class="comment">#配置限制了单节点上可以开启的ES存储实例的个数</span></span><br><span class="line"><span class="meta">node.max_local_storage_nodes</span>: <span class="string">3</span></span><br><span class="line"><span class="meta">gateway.auto_import_dangling_indices</span>: <span class="string">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#删除索引必须要索引名称</span></span><br><span class="line"><span class="meta">action.destructive_requires_name</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许跨域</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#master 和 data 的四种组合</span></span><br><span class="line"><span class="comment">#1.master=true &amp; data = true 生产环境不推荐使用</span></span><br><span class="line"><span class="comment">#2.master=true &amp; data = false 生产环境推荐使用，master不进行数据存储</span></span><br><span class="line"><span class="comment">#3.master=false &amp; data = true 备机存储数据</span></span><br><span class="line"><span class="comment">#4.master = false &amp; data = false 充当协调节点，类似nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="meta">node.master</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="meta">node.data</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记投票节点</span></span><br><span class="line"><span class="meta">Node.voting_only</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>切记，如果拷贝了单点程序做集群节点，一定要把原有的data数据清除，否则多分Master节点数据会导致集群搭建失败。</strong></p>
</blockquote>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>ElasticSearch是基于Rest风格的操作</p>
<p>Rest风格是一种软件架构风格，而不是标准，它只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>通过文档id查询文档</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称/_search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建索引  index是索引名称</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">/index?pretty</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">/product?pretty</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询所有索引</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">_cat/indices?v</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除索引  index是索引名称</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/index?pretty</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/product?pretty</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入数据 /index/type/id   若无索引会自动创建,   type被弱化，统一使用 "_doc" </span></span><br><span class="line">PUT /index/type/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">3999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新数据---全量更新---再次执行插入数据即可</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">13999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据---增量更新</span></span><br><span class="line">PUT /index/type/id/_update</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">       <span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增量更新案例</span></span><br><span class="line">PUT /product/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span> :  <span class="number">3999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除数据</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/index/type/id</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/product/_doc/1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(三)-倒排索引和写入原理</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%B8%89%EF%BC%89%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><blockquote>
<p>正排索引（doc values ）VS 倒排索引</p>
</blockquote>
<p><strong>概念</strong>：从广义来说，<code>正排索引（doc values ）</code> 本质上是一个序列化的列式存储。列式存储 适用于聚合、排序、脚本等操作，所有的数字、地理坐标、日期、IP 和不分析（ not_analyzed ）字符类型都会默认开启。</p>
<p>而<code>倒排索引</code>的优势在于查找包含某个项的文档，相反，也可以用它确定哪些项是否存在单个文档里。</p>
<p><strong>优化</strong>：es官方是建议，es大量是基于os cache来进行缓存和提升性能的，不建议用jvm内存来进行缓存，那样会导致一定的gc开销和oom问题，给jvm更少的内存，给os cache更大的内存。比如64g服务器，给jvm最多4 ~ 16g（1/16 ~ 1/4），os cache可以提升doc value和倒排索引的缓存和查询效率。</p>
<p><strong>总结：全文搜索需要用倒排索引，而排序和聚合则需要使用 正排索引。</strong></p>
<a id="more"></a>



<p><strong>在Mappings中有两个相关配置</strong></p>
<p><code>doc_values：true/false</code><br>为该字段创建正排索引，默认true，不支持text类型（不分词的field默认true，text类型为false）<br>提升聚合统计性能，为false时可以节省磁盘空间，但当需要使用聚合操作，需要将fielddata设置为true，可以在内存中创建临时的正排索引</p>
<p><code>index:true/false</code><br>为该字段创建倒排索引，默认为true</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;  </span><br><span class="line">            <span class="attr">"tags"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"true"</span></span><br><span class="line">                <span class="comment">//"doc_values": "true" text类型不支持</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用es自带的keyword时，它字段值是一个整体的精确匹配，并不会对字段值的内容进行分词</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而<code>doc_values</code>正排索引不支持<code>text</code>字段，那<code>text</code>字段怎么进行聚合操作呢？</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当直接使用tags进行聚合操作，想要聚合tags中的分词后的terms词项，会报错</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text fields are not optimised for operations that require per-document field data like aggregations and sorting, </span><br><span class="line">so these operations are disabled by default. Please use a keyword field instead. </span><br><span class="line">Alternatively, set fielddata&#x3D;true on [tags] in order to load field data by uninverting the inverted index. </span><br><span class="line">Note that this can use significant memory.</span><br></pre></td></tr></table></figure>

<p>大概的意思是，必须要打开<code>fielddata=true</code>，然后将正排索引数据加载到内存中，才可以对分词的field执行聚合操作，而且会消耗很大的内存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改Mapping结构：开启tags字段 在使用聚合操作时使用 正排索引进行计算</span></span><br><span class="line">PUT /product/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再次执行上文的tags的聚合操作，就不会报错了，<strong>那么<code>fielddata</code>和<code>doc_values</code>都是开启正排索引，他们之间有什么区别呢？</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>doc_values</th>
<th>fielddata</th>
</tr>
</thead>
<tbody><tr>
<td>创建时间</td>
<td>index时创建</td>
<td>使用时动态创建</td>
</tr>
<tr>
<td>创建位置</td>
<td>磁盘</td>
<td>内存(jvm heap)</td>
</tr>
<tr>
<td>优点</td>
<td>不占用内存空间</td>
<td>不占用磁盘空间</td>
</tr>
<tr>
<td>缺点</td>
<td>索引速度稍低</td>
<td>文档很多时，动态创建开销比较大，而且占内存</td>
</tr>
<tr>
<td>默认值</td>
<td><strong>true</strong></td>
<td><strong>false</strong></td>
</tr>
</tbody></table>
<p><code>doc_values</code>速度稍低，这个是相对于fielddata方案的，其实仔细想想也可以理解。拿排序举例，相对于一个在磁盘排序，一个在内存排序。谁的速度快自然不用多说。</p>
<p>与 doc values 不同，fielddata 构建和管理 100% 在内存中，常驻于 JVM 内存堆。这意味着它本质上是不可扩展的。</p>
<p>fielddata可能会消耗大量的堆空间，尤其是在加载高基数（high cardinality）text字段时。一旦fielddata已加载到堆中，它将在该段的生命周期内保留。此外，加载fielddata是一个昂贵的过程，可能会导致用户遇到延迟命中。这就是默认情况下禁用fielddata的原因。</p>
<p><code>doc_values</code>虽然速度稍慢，但doc_values的优势还是非常明显的。一个很显著的点就是他不会随着文档的增多引起<code>OOM</code>问题。正如前面说的，doc_values在磁盘创建排序和聚合所需的正排索引。这样我们就避免了在生产环境给ES设置一个很大的<code>HEAP_SIZE</code>，也使得JVM的GC更加高效，这个又为其它的操作带来了间接的好处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.当没有文档的value字段需要聚合，而doc_values为false时，需要打开fielddata，然后临时在内存中建立正排索引，fielddata的构建和管理发生在JVM heap中。</span><br><span class="line"></span><br><span class="line">2.Fielddata默认是不启用的，因为text字段比较长，一般只做关键字分词和搜索，很少拿来进行全文匹配和聚合还有排序。</span><br><span class="line"></span><br><span class="line">3.ES采用了circuit breaker(熔断)机制避免fielddata一次性超过物理内存大小而导致内存溢出，如果发生熔断，查询会被终止并返回异常。</span><br><span class="line"></span><br><span class="line">4.fielddata使用的是jvm内存，doc value在内存不足时会静静的待在磁盘中，而当内存充足时，会蹦到内存里提升性能。</span><br></pre></td></tr></table></figure>

<p><img src="/images/elk/elasticsearch-index/es-01.png" alt="es"></p>
<p><img src="/images/elk/elasticsearch-index/es-02.png" alt="es"></p>
<blockquote>
<p>为什么不可以用倒排索引计算聚合？</p>
<p>对于聚合部分，我们需要找到匹配的doc里所有唯一的词项（term）。需要遍历每个doc获取所有trem词项，然后再一个个去倒排索引表中进行查找，是一个 n x m 的操作，做这件事情性能很低，很有可能会造成全表遍历。</p>
<p><strong>因此通过正排索引来解决聚合问题</strong>。</p>
</blockquote>
<p><img src="/images/elk/elasticsearch-index/es-03.png" alt="es"></p>
<hr>
<h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索被执行成一个两阶段过程，称为 Query Then Fetch；</span><br><span class="line"></span><br><span class="line">1、在初始查询阶段，查询会**广播到索引中每一个分片拷贝（主分片或者副本分片）**。 每个分片在本地执行搜索并构建一个匹配文档的大小为 **from + size 的优先队列**。PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</span><br><span class="line"></span><br><span class="line">2、每个分片返回各自优先队列中**所有文档的 ID 和排序值 给协调节点**，协调节点合并这些值到自己的优先队列中来产生一个**全局排序后的结果列表**。</span><br><span class="line"></span><br><span class="line">3、接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向**相关的分片提交多个 GET 请求**。每个分片**加载并丰富文档**，接着返回文档给协调节点。一旦所有的文档都被取回了， 协调节点返回结果给客户端。</span><br><span class="line"></span><br><span class="line">  Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少 的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</span><br></pre></td></tr></table></figure>

<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p><img src="/images/elasticsearch%EF%BC%88%E4%B8%89%EF%BC%89%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/%E5%86%99%E6%93%8D%E4%BD%9C.jpg" alt=""></p>
<p><img src="/images/elasticsearch%EF%BC%88%E4%B8%89%EF%BC%89%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/es%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86-03.jpg" alt=""></p>
<p><img src="/images/elasticsearch%EF%BC%88%E4%B8%89%EF%BC%89%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/es-01.jpg" alt=""></p>
<p>当有写入请求时，数据会先写到内存的Buffer中（Buffer专门用于写入操作，默认占jvm的10%），每间隔1S会创建一个<code>index segment</code>的<code>file</code>，然后<code>segment</code>会同步到<code>OS cache</code>中，<code>OS cache</code>会返回一个<code>status = Open</code>，<strong>这时候的<code>segment</code>就能对外提供搜索操作。</strong></p>
<p><strong>读写操作进行了异步分离操作，segment对外提供读搜索操作，OS cache后台异步写入数据。</strong></p>
<blockquote>
<p>在这种方式下，如果宕机会造成少部分数据的丢失，ES是怎么避免的？</p>
</blockquote>
<p>ES在写入索引时，并没有实时落盘到索引文件，而是先双写到内存和translog文件，假如节点挂了，重启节点时就会重放日志，这样相当于把用户的操作模拟了一遍。保证了数据的不丢失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当OS cache中的数据达到一定大小之后或者一定时间后，触发Flush：</span><br><span class="line">1.执行 commit操作，把内存中的Buffer、Segment数据同步到OS cache</span><br><span class="line">2.把OS cache的数据fsync到 磁盘中</span><br><span class="line">3.清空translog</span><br></pre></td></tr></table></figure>

<p><code>Commit Point</code>用于存储可用的segment，每当创建一个segment时，都会往<code>Commit point</code>中做登记，<code>segment</code>文件并不是无限制地创建的，当达到一定的操作/大小时，会执行segment合并操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.选择一些体积小的segment，然后将其合并成一个更大的segment</span><br><span class="line">2.执行flush操作，讲OS cache的数据落地到磁盘中</span><br><span class="line">3.创建新的commit point，并且登记新的segment，然后将旧的segment标记成删除状态</span><br><span class="line">4.将新的segment搜索状态&#96;status&#x3D;open&#96;打开</span><br><span class="line">5.将删除状态的segment文件删除</span><br></pre></td></tr></table></figure>

<p><code>segment</code>维护了一个<code>.del</code>的文件，当有数据执行删除/更新操作时，它会先将数据在segment中标记成删除的状态，这时候没有物理删除，然后在查询的时候，会将删除状态的数据进行过滤。</p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch（九）常用CRUD操作汇总</title>
    <url>/2021/06/06/elasticsearch%EF%BC%88%E4%B9%9D%EF%BC%89%E5%B8%B8%E7%94%A8CRUD%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="一、Rest风格的操作"><a href="#一、Rest风格的操作" class="headerlink" title="一、Rest风格的操作"></a>一、Rest风格的操作</h2><p>ElasticSearch是基于Rest风格的操作，而Rest风格是一种软件架构风格，而不是标准，它只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档（过时）</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/_update/文档id</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>ip:9200/索引名称/类型名称/文档id</td>
<td>通过文档id查询文档</td>
</tr>
<tr>
<td>POST</td>
<td>ip:9200/索引名称/类型名称/_search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h3 id="2-1、添加索引"><a href="#2-1、添加索引" class="headerlink" title="2.1、添加索引"></a>2.1、添加索引</h3><h4 id="添加文档方式-gt-自动创建索引"><a href="#添加文档方式-gt-自动创建索引" class="headerlink" title="添加文档方式 =&gt; 自动创建索引"></a>添加文档方式 =&gt; 自动创建索引</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"测试名称"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/elk/crud/create_index01.jpg" style="zoom:67%;" />

<h4 id="手动定Mapping-gt-手动创建索引"><a href="#手动定Mapping-gt-手动创建索引" class="headerlink" title="手动定Mapping  =&gt; 手动创建索引"></a>手动定Mapping  =&gt; 手动创建索引</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"age"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/elk/crud/create_index02.jpg" style="zoom:67%;" />



<h3 id="2-2、查看索引"><a href="#2-2、查看索引" class="headerlink" title="2.2、查看索引"></a>2.2、查看索引</h3><h4 id="查看所有索引"><a href="#查看所有索引" class="headerlink" title="查看所有索引"></a>查看所有索引</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_cat/indices</span><br><span class="line">GET /_cat/indices?v</span><br></pre></td></tr></table></figure>

<img src="/images/elk/crud/all_index.jpg" style="zoom:67%;" />

<h4 id="查看单个索引的mapping结构"><a href="#查看单个索引的mapping结构" class="headerlink" title="查看单个索引的mapping结构"></a>查看单个索引的mapping结构</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /person/_mapping</span><br></pre></td></tr></table></figure>

<h3 id="2-3、删除索引"><a href="#2-3、删除索引" class="headerlink" title="2.3、删除索引"></a>2.3、删除索引</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /person</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、分词器"><a href="#三、分词器" class="headerlink" title="三、分词器"></a>三、分词器</h2><h3 id="指定分词器"><a href="#指定分词器" class="headerlink" title="指定分词器"></a>指定分词器</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建索引mapping指定分词器</span><br><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>:&#123;</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">        <span class="attr">"search_analyzer"</span>:<span class="string">"ik_max_word"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"age"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"des"</span>:&#123;</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定内容分词"><a href="#指定内容分词" class="headerlink" title="指定内容分词"></a>指定内容分词</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: [<span class="string">"测试描述"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、文档"><a href="#四、文档" class="headerlink" title="四、文档"></a>四、文档</h2><h3 id="4-1、创建文档"><a href="#4-1、创建文档" class="headerlink" title="4.1、创建文档"></a>4.1、创建文档</h3><h4 id="单文档创建"><a href="#单文档创建" class="headerlink" title="单文档创建"></a>单文档创建</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#不指定id创建，_id由es自动创建，此方式只能使用POST请求</span><br><span class="line">POST /person/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"测试名称2"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">#指定id方式创建，接受POST和PUT两种方式</span><br><span class="line">POST /person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"测试名称1"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">#创建复杂类型，查询时只有匹配到goods_list数组下任意name或price的值就会被查询出来，如需匹配数组下单个元素，需要指定该复杂类型为Nested</span><br><span class="line">PUT /order/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"order_name"</span>: <span class="string">"小米10 Pro订单"</span>,</span><br><span class="line">  <span class="attr">"desc"</span>: <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">  <span class="attr">"goods_count"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"total_price"</span>: <span class="number">12699</span>,</span><br><span class="line">  <span class="attr">"goods_list"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小米10 PRO MAX 5G"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">4999</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"钢化膜"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">19</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"手机壳"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">199</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量创建文档"><a href="#批量创建文档" class="headerlink" title="批量创建文档"></a>批量创建文档</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#条件和数据分两行编写，不可以将&#123;&#125;进行换行操作；create、update、delete等条件指令可以同批次执行</span><br><span class="line">#retry_on_conflict=&gt;当出现冲突时尝试三次，三次失败后就放弃</span><br><span class="line">#filter_path=items.*.error  只显示失败的，返回从操作失败的数据信息</span><br><span class="line">POST /_bulk?filter_path=items.*.error</span><br><span class="line">&#123;<span class="attr">"create"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"person"</span>,<span class="attr">"_id"</span>:<span class="number">2</span>,<span class="attr">"retry_on_conflict"</span> : <span class="string">"3"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"批量创建"</span>,<span class="attr">"age"</span>:<span class="number">123</span>&#125;</span><br><span class="line">&#123;<span class="attr">"create"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"person"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"批量创建2"</span>,<span class="attr">"age"</span>:<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2、更新文档"><a href="#4-2、更新文档" class="headerlink" title="4.2、更新文档"></a>4.2、更新文档</h3><h4 id="单文档更新"><a href="#单文档更新" class="headerlink" title="单文档更新"></a>单文档更新</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#全量更新 POST与PUT都支持</span><br><span class="line">#version=2&amp;&amp;version_type=external 通过版本更新数据，避免并发覆盖---CAS</span><br><span class="line">PUT /person/_doc/1?version=2&amp;&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"测试名称1"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#局部更新 仅支持POST</span><br><span class="line">#旧版局部更新方式</span><br><span class="line">##! [types removal] Specifying types in document update requests is deprecated, use the endpoint /&#123;index&#125;/_update/&#123;id&#125; instead.</span><br><span class="line">POST /person/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"更新测试a"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#新版局部更新方式</span><br><span class="line">POST /person/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"更新测试123"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#局部更新 </span><br><span class="line">#retry_on_conflict=&gt;当出现冲突时尝试三次，三次失败后就放弃</span><br><span class="line">#filter_path=items.*.error  只显示失败的，返回从操作失败的数据信息</span><br><span class="line">POST /_bulk?filter_path=items.*.error</span><br><span class="line">&#123;"update":&#123;"_index":"person","_id":2&#125;,"retry_on_conflict" : "3"&#125; &#125;</span><br><span class="line">&#123;<span class="attr">"doc"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"批量创建2a"</span>,<span class="attr">"age"</span>:<span class="number">123</span>&#125;</span><br><span class="line"> &#123;<span class="attr">"update"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"person"</span>,<span class="attr">"_id"</span>:<span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123;<span class="attr">"doc"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"批量创建3a"</span>,<span class="attr">"age"</span>:<span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、删除文档"><a href="#4-3、删除文档" class="headerlink" title="4.3、删除文档"></a>4.3、删除文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /person/_doc/1</span><br></pre></td></tr></table></figure>

<h3 id="4-4、查询文档"><a href="#4-4、查询文档" class="headerlink" title="4.4、查询文档"></a>4.4、查询文档</h3><h4 id="Query-String"><a href="#Query-String" class="headerlink" title="Query_String"></a>Query_String</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">#查询所有</span><br><span class="line">GET /person/_search</span><br><span class="line">#超时查询 默认没有timeout，如果设置了timeout，那么会执行timeout机制。</span><br><span class="line">GET /person/_search?timeout=1s</span><br><span class="line">#带参查询</span><br><span class="line">GET /person/_search?q=age:21</span><br><span class="line">#分页排序 使用排序的话，相关度分数将_score = null</span><br><span class="line">GET /person/_search?from=0&amp;size=2&amp;sort=age:asc</span><br></pre></td></tr></table></figure>

<h4 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query_DSL"></a>Query_DSL</h4><h5 id="查询全部-match-all"><a href="#查询全部-match-all" class="headerlink" title="查询全部-match_all"></a>查询全部-match_all</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指定条件查询-match"><a href="#指定条件查询-match" class="headerlink" title="指定条件查询-match"></a>指定条件查询-match</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"批量"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#复杂条件查询，查询时只有匹配到goods_list数组下任意name或price的值就会被查询出来，如需匹配数组下单个元素，需要指定该复杂类型为Nested</span><br><span class="line">GET /order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"goods_list.name"</span>: <span class="string">"小米"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"goods_list.price"</span>: <span class="string">"19"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多条件查询-multi-match"><a href="#多条件查询-multi-match" class="headerlink" title="多条件查询-multi_match"></a>多条件查询-multi_match</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"测试"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"des"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序-sort"></a>排序-sort</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"age"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指定返回字段-source"><a href="#指定返回字段-source" class="headerlink" title="指定返回字段-_source"></a>指定返回字段-_source</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#查询指定字段，默认为includes</span><br><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"age"</span>]</span><br><span class="line">&#125;</span><br><span class="line">#排除某些字段，查询剩下字段</span><br><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"excludes"</span>: <span class="string">"age"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/2021/05/24/elasticsearch%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/">查看更多<strong>基本查询</strong>语法请点击跳转</a></p>
<p><a href="/2021/05/25/elasticsearch%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">查看更多<strong>规则匹配</strong>查询请点击跳转</a></p>
<p><a href="/2021/05/25/elasticsearch%EF%BC%88%E5%9B%9B%EF%BC%89painless/"><strong>脚本语言</strong>点击跳转</a></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(七)-JAVA API</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%B8%83%EF%BC%89JAVA%20API/</url>
    <content><![CDATA[<h2 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a>JAVA API</h2><p><strong>Transport Client</strong>：TransportClient不推荐使用，而推荐使用Java High Level REST Client，并将在Elasticsearch 8.0中删除。<br><strong>Java Low Level REST Client</strong>：低级别的REST客户端，通过http与集群交互，用户需自己编组请求JSON串，及解析响应JSON串。兼容所有ES版本<br><strong>Java High Level REST Client</strong>：高级别的REST客户端，基于低级别的REST客户端，增加了编组请求JSON串、解析响应JSON串等相关api。使用的版本需要保持和ES服务端的版本一致，否则会有版本问题。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--ES transport client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--high-level-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置集群名称</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="comment">//TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</span></span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>))<span class="comment">//通讯端口  而不是服务端口</span></span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9301</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据</span></span><br><span class="line">    create(client);</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    List&lt;Product&gt; list = service.list();</span><br><span class="line">    <span class="keyword">for</span> (Product item : list) &#123;</span><br><span class="line">       	<span class="comment">//固定语法</span></span><br><span class="line">        IndexResponse response = client.prepareIndex(<span class="string">"product2"</span>, <span class="string">"_doc"</span>, item.getId().toString())</span><br><span class="line">            .setSource(XContentFactory.jsonBuilder()</span><br><span class="line">                       .startObject()</span><br><span class="line">                       .field(<span class="string">"name"</span>, item.getName())</span><br><span class="line">                       .field(<span class="string">"desc"</span>, item.getDesc())</span><br><span class="line">                       .field(<span class="string">"price"</span>, item.getPrice())</span><br><span class="line">                       .field(<span class="string">"date"</span>, item.getCreateTime().toLocalDateTime().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>)))</span><br><span class="line">                       .field(<span class="string">"tags"</span>, item.getTags().split(<span class="string">","</span>))</span><br><span class="line">                       .endObject())</span><br><span class="line">            .get();</span><br><span class="line">        System.out.println(response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询一条数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    GetResponse response = client.prepareGet(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"1"</span>).get();</span><br><span class="line">    String index = response.getIndex();<span class="comment">//获取索引名称</span></span><br><span class="line">    String type = response.getType();<span class="comment">//获取索引类型</span></span><br><span class="line">    String id = response.getId();<span class="comment">//获取索引id</span></span><br><span class="line">    System.out.println(<span class="string">"index:"</span> + index);</span><br><span class="line">    System.out.println(<span class="string">"type:"</span> + type);</span><br><span class="line">    System.out.println(<span class="string">"id:"</span> + id);</span><br><span class="line">    System.out.println(response.getSourceAsString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量查询</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product"</span>)</span><br><span class="line">        .get();</span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        String res = hit.getSourceAsString();</span><br><span class="line">        System.out.println(<span class="string">"res"</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增量更新</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    UpdateResponse response = client.prepareUpdate(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"2"</span>)</span><br><span class="line">        .setDoc(XContentFactory.jsonBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                .field(<span class="string">"name"</span>, <span class="string">"update name"</span>)</span><br><span class="line">                .endObject())</span><br><span class="line">        .get();</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    DeleteResponse response = client.prepareDelete(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"2"</span>).get();</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多条件查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSearch</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SearchResponse：返回的结果集</span></span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product2"</span>)</span><br><span class="line">        .setQuery(QueryBuilders.termQuery(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>))                 <span class="comment">// Query</span></span><br><span class="line">        .setPostFilter(QueryBuilders.rangeQuery(<span class="string">"price"</span>).from(<span class="number">0</span>).to(<span class="number">4000</span>))</span><br><span class="line">        .setFrom(<span class="number">1</span>).setSize(<span class="number">3</span>)</span><br><span class="line">        .get();</span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        String res = hit.getSourceAsString();</span><br><span class="line">        System.out.println(<span class="string">"res"</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个月份的tags中每个词项term的平均价格</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_by_month"</span>: &#123;</span><br><span class="line">            <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"date"</span>,</span><br><span class="line">                <span class="attr">"calendar_interval"</span>: <span class="string">"month"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"by_tags"</span>: &#123;</span><br><span class="line">                    <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                        <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                            <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggregations"</span> : &#123;</span><br><span class="line">        <span class="attr">"group_by_month"</span> : &#123;</span><br><span class="line">            <span class="attr">"buckets"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span> : <span class="string">"2020-04-01T00:00:00.000Z"</span>,</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="number">1585699200000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"by_tags"</span> : &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span> : [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"bufangshui"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">999.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"fashao"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">2999.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span> : <span class="string">"2020-05-01T00:00:00.000Z"</span>,</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="number">1588291200000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"by_tags"</span> : &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span> : [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"fashao"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">4499.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"xingjiabi"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">4499.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Java代码实现上面案例的聚合查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggSearch</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//region 1-&gt;计算并返回聚合分析response对象</span></span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product"</span>)</span><br><span class="line">        .addAggregation(</span><br><span class="line">        AggregationBuilders.dateHistogram(<span class="string">"group_by_month"</span>)</span><br><span class="line">        .field(<span class="string">"date"</span>)</span><br><span class="line">        .calendarInterval(DateHistogramInterval.MONTH)</span><br><span class="line">        <span class="comment">//.dateHistogramInterval(DateHistogramInterval.MONTH)</span></span><br><span class="line">        .subAggregation(</span><br><span class="line">            AggregationBuilders</span><br><span class="line">            .terms(<span class="string">"by_tag"</span>)</span><br><span class="line">            .field(<span class="string">"tags.keyword"</span>)</span><br><span class="line">            .subAggregation(</span><br><span class="line">                AggregationBuilders</span><br><span class="line">                .avg(<span class="string">"avg_price"</span>)</span><br><span class="line">                .field(<span class="string">"price"</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">        .execute().actionGet();  <span class="comment">//执行查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//region 2-&gt;输出结果信息</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="comment">//获取aggregations结果</span></span><br><span class="line">    Map&lt;String, Aggregation&gt; map = response.getAggregations().asMap();</span><br><span class="line">    <span class="comment">//获取group_by_month结果</span></span><br><span class="line">    Aggregation group_by_month = map.get(<span class="string">"group_by_month"</span>);</span><br><span class="line">    Histogram dates = (Histogram) group_by_month;</span><br><span class="line">    <span class="comment">//转换成分组的桶</span></span><br><span class="line">    Iterator&lt;Histogram.Bucket&gt; buckets = (Iterator&lt;Histogram.Bucket&gt;) dates.getBuckets().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buckets.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//遍历桶中的数据</span></span><br><span class="line">        Histogram.Bucket dateBucket = buckets.next();</span><br><span class="line">        System.out.println(<span class="string">"\n\n月份："</span> + dateBucket.getKeyAsString() + <span class="string">"\n计数："</span> + dateBucket.getDocCount());</span><br><span class="line">        <span class="comment">//获取桶里面的桶by_tag</span></span><br><span class="line">        Aggregation group_by_tag = dateBucket.getAggregations().asMap().get(<span class="string">"by_tag"</span>);</span><br><span class="line">        StringTerms terms = (StringTerms) group_by_tag;</span><br><span class="line">        Iterator&lt;StringTerms.Bucket&gt; tagsBucket = terms.getBuckets().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tagsBucket.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历by_tag桶，获取桶中的平均价格</span></span><br><span class="line">            StringTerms.Bucket tagBucket = tagsBucket.next();</span><br><span class="line">            System.out.println(<span class="string">"\t标签名称："</span> + tagBucket.getKey() + <span class="string">"\n\t数量："</span> + tagBucket.getDocCount());</span><br><span class="line">            Aggregation avg_price = tagBucket.getAggregations().get(<span class="string">"avg_price"</span>);</span><br><span class="line">            Avg avg = (Avg) avg_price;</span><br><span class="line">            System.out.println(<span class="string">"\t平均价格："</span> + avg.getValue() + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="High-Level-REST-Client"><a href="#High-Level-REST-Client" class="headerlink" title="High Level REST Client"></a>High Level REST Client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常见步骤：</span><br><span class="line">1.创建对应的Request对象</span><br><span class="line">2.创建对应的Builder对象&#x2F;编写对应操作</span><br><span class="line">3.Client执行对应的方法</span><br></pre></td></tr></table></figure>



<h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 RestHighLevelClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> createConnection &#123;</span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">            <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>),</span><br><span class="line">            <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9201</span>, <span class="string">"http"</span>)));  <span class="comment">//使用的是9200服务端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line"></span><br><span class="line">    request.settings(Settings.builder()</span><br><span class="line">                     .put(<span class="string">"index.number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                     .put(<span class="string">"index.number_of_replicas"</span>, <span class="number">2</span>)</span><br><span class="line">                    );</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (createIndexResponse.isAcknowledged()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"创建index成功!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"创建index失败!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">"test_index*"</span>);</span><br><span class="line">    GetIndexResponse response = client.indices().get(request, RequestOptions.DEFAULT);</span><br><span class="line">    String[] indices = response.getIndices();</span><br><span class="line">    <span class="keyword">for</span> (String indexName : indices) &#123;</span><br><span class="line">        System.out.println(<span class="string">"index name:"</span> + indexName);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    AcknowledgedResponse response = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (response.isAcknowledged()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"删除index成功!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"删除index失败!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertData</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    List&lt;Product&gt; list = service.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据，index不存在则自动根据匹配到的template创建。index没必要每天创建一个，如果是为了灵活管理，最低建议每月一个 yyyyMM。</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    <span class="comment">//最好不要自定义id 会影响插入速度。</span></span><br><span class="line">    Product product = list.get(<span class="number">0</span>);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    request.id(product.getId().toString());</span><br><span class="line">    request.source(gson.toJson(product), XContentType.JSON);</span><br><span class="line">    IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertData</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//批量插入数据，更新和删除同理</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    product.setPrice(<span class="number">3999.00</span>);</span><br><span class="line">    product.setDesc(<span class="string">"xioami"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        product.setName(<span class="string">"name"</span> + i);</span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest().source(gson.toJson(product), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse response = client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(<span class="string">"数量:"</span> + response.getItems().length);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ID查询数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getById</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意 这里查询使用的是别名。</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">"test_index"</span>, <span class="string">"PPWhwnIBRwX67j4bTmV1"</span>);</span><br><span class="line">    String[] includes = &#123;<span class="string">"name"</span>, <span class="string">"price"</span>&#125;;</span><br><span class="line">    String[] excludes = &#123;<span class="string">"desc"</span>&#125;;</span><br><span class="line">    FetchSourceContext fetchSourceContext = <span class="keyword">new</span> FetchSourceContext(<span class="keyword">true</span>, includes, excludes);</span><br><span class="line">    <span class="comment">//只查询特定字段。如果需要查询所有字段则不设置该项。</span></span><br><span class="line">    request.fetchSourceContext(fetchSourceContext);</span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ID删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">"test_index"</span>, <span class="string">"1"</span>);</span><br><span class="line">    DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiGetById</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//多个根据id查询</span></span><br><span class="line">    MultiGetRequest request = <span class="keyword">new</span> MultiGetRequest();</span><br><span class="line">    request.add(<span class="string">"test_index"</span>, <span class="string">"PPWhwnIBRwX67j4bTmV1"</span>);</span><br><span class="line">    <span class="comment">//两种写法</span></span><br><span class="line">    request.add(<span class="keyword">new</span> MultiGetRequest.Item(</span><br><span class="line">        <span class="string">"test_index"</span>,</span><br><span class="line">        <span class="string">"PfWhwnIBRwX67j4bTmV1"</span>));</span><br><span class="line">    MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">for</span> (MultiGetItemResponse itemResponse : response) &#123;</span><br><span class="line">        System.out.println(itemResponse.getResponse().getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateByQuery</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateByQueryRequest request = <span class="keyword">new</span> UpdateByQueryRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    <span class="comment">//默认情况下，版本冲突会中止 UpdateByQueryRequest 进程，但是你可以用以下命令来代替</span></span><br><span class="line">    <span class="comment">//设置版本冲突继续</span></span><br><span class="line">    <span class="comment">//        request.setConflicts("proceed");</span></span><br><span class="line">    <span class="comment">//设置更新条件</span></span><br><span class="line">    request.setQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"name1 name3"</span>));</span><br><span class="line">    <span class="comment">//        //限制更新条数</span></span><br><span class="line">    <span class="comment">//        request.setMaxDocs(10);</span></span><br><span class="line">    request.setScript(</span><br><span class="line">        <span class="keyword">new</span> Script(ScriptType.INLINE, <span class="string">"painless"</span>, <span class="string">"ctx._source.desc+='#';"</span>, Collections.emptyMap()));</span><br><span class="line">    BulkByScrollResponse response = client.updateByQuery(request,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">carInfo</span><span class="params">(String keyword,Integer from,Integer size)</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    </span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>, keyword));</span><br><span class="line">    searchSourceBuilder.from(from);</span><br><span class="line">    searchSourceBuilder.size(size);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//ESClient.getInstance().closeClient();</span></span><br><span class="line">    </span><br><span class="line">    ResultDto res = <span class="keyword">new</span> ResultDto();</span><br><span class="line">    res.setData(searchResponse.getHits().getHits());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Scroll查询"><a href="#Scroll查询" class="headerlink" title="Scroll查询"></a>Scroll查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">scroll</span><span class="params">(String scrollId)</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.size(<span class="number">2</span>); <span class="comment">//每页两条</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    searchRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));  <span class="comment">//scrollID的有效期1分钟</span></span><br><span class="line"></span><br><span class="line">    SearchResponse searchResponse = scrollId == <span class="keyword">null</span></span><br><span class="line">        ? client.search(searchRequest, RequestOptions.DEFAULT)</span><br><span class="line">        : client.scroll(<span class="keyword">new</span> SearchScrollRequest(scrollId), RequestOptions.DEFAULT);</span><br><span class="line">    scrollId = searchResponse.getScrollId();</span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    </span><br><span class="line">    ResultDto res = <span class="keyword">new</span> ResultDto();</span><br><span class="line">    res.setTag(scrollId);</span><br><span class="line">    res.setData(hits.getHits());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">bulk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"msb_auto"</span>);</span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    request.add(<span class="keyword">new</span> DeleteRequest(<span class="string">"product"</span>, <span class="string">"13"</span>));  <span class="comment">//删除doc</span></span><br><span class="line">    request.add(<span class="keyword">new</span> UpdateRequest(<span class="string">"product"</span>, <span class="string">"22"</span>)</span><br><span class="line">                .doc(XContentType.JSON, <span class="string">"name"</span>, <span class="string">"天籁之音"</span>));  <span class="comment">//修改doc一个字段</span></span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(<span class="string">"product"</span>).id(<span class="string">"4"</span>)</span><br><span class="line">                .source(XContentType.JSON, <span class="string">"myname"</span>, <span class="string">"天津一汽"</span>)); <span class="comment">//修改整doc</span></span><br><span class="line">    BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索模板"><a href="#搜索模板" class="headerlink" title="搜索模板"></a>搜索模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">templateSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//region 创建模板并缓存 作用域为整个集群</span></span><br><span class="line">    Request scriptRequest = <span class="keyword">new</span> Request(<span class="string">"POST"</span>, <span class="string">"_scripts/test_template_search"</span>);</span><br><span class="line">    scriptRequest.setJsonEntity(</span><br><span class="line">        <span class="string">"&#123;"</span> +</span><br><span class="line">        <span class="string">"  \"script\": &#123;"</span> +</span><br><span class="line">        <span class="string">"    \"lang\": \"mustache\","</span> +</span><br><span class="line">        <span class="string">"    \"source\": &#123;"</span> +</span><br><span class="line">        <span class="string">"      \"query\": &#123; \"match\" : &#123; \"&#123;&#123;field&#125;&#125;\" : \"&#123;&#123;value&#125;&#125;\" &#125; &#125;,"</span> +</span><br><span class="line">        <span class="string">"      \"size\" : \"&#123;&#123;size&#125;&#125;\""</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span> +</span><br><span class="line">        <span class="string">"  &#125;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>);</span><br><span class="line">    Response scriptResponse = client.getLowLevelClient().performRequest(scriptRequest);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">    request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"msb_auto"</span>));</span><br><span class="line">    <span class="comment">//STORED 保存到内存模板</span></span><br><span class="line">    request.setScriptType(ScriptType.STORED);</span><br><span class="line">    request.setScript(<span class="string">"test_template_search"</span>);</span><br><span class="line">    <span class="comment">// 本地模板</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//request.setScriptType(ScriptType.INLINE);</span></span><br><span class="line">    <span class="comment">//    request.setScript(</span></span><br><span class="line">    <span class="comment">//                    "&#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"from\": &#123;&#123;from&#125;&#125;,\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"size\": &#123;&#123;size&#125;&#125;,\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"query\": &#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "    \"match\": &#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "      \"master_brand_name\": \"&#123;&#123;master_brand_name&#125;&#125;\"\n" +</span></span><br><span class="line">    <span class="comment">//                    "    &#125;\n" +</span></span><br><span class="line">    <span class="comment">//                    "  &#125;\n" +</span></span><br><span class="line">    <span class="comment">//                    "&#125;");</span></span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Object&gt; scriptParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    scriptParams.put(<span class="string">"field"</span>, <span class="string">"master_brand_name"</span>);</span><br><span class="line">    scriptParams.put(<span class="string">"value"</span>, <span class="string">"一汽"</span>);</span><br><span class="line">    scriptParams.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">    request.setScriptParams(scriptParams);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    SearchTemplateResponse response = client.searchTemplate(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchHit[] fuzzy(String name) &#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.fuzzyQuery(<span class="string">"brand_name.keyword"</span>, name).fuzziness(Fuzziness.AUTO));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> response.getHits().getHits();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多语句查询"><a href="#多语句查询" class="headerlink" title="多语句查询"></a>多语句查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">multiSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个空的MultiSearchRequest</span></span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.创建SearchRequest,并填充查询条件</span></span><br><span class="line">    SearchRequest firstSearchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"series_name"</span>, <span class="string">"朗动"</span>));</span><br><span class="line">    firstSearchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//3.将SearchRequest装配到MultiSearchRequest中</span></span><br><span class="line">    request.add(firstSearchRequest);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//4.创建第二个SearchRequest并重复第三步</span></span><br><span class="line">    SearchRequest secondSearchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"series_name"</span>, <span class="string">"揽胜运动"</span>));</span><br><span class="line">    secondSearchRequest.source(searchSourceBuilder);</span><br><span class="line">    request.add(secondSearchRequest);</span><br><span class="line"></span><br><span class="line">    MultiSearchResponse response = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bool查询"><a href="#Bool查询" class="headerlink" title="Bool查询"></a>Bool查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">boolSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line"></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query</span><br><span class="line">        (</span><br><span class="line">        QueryBuilders.boolQuery()</span><br><span class="line">        .must(matchPhraseQuery(<span class="string">"sale_name"</span>, <span class="string">"2018款"</span>))</span><br><span class="line">        .filter(matchQuery(<span class="string">"master_brand_name"</span>, <span class="string">"大众"</span>).analyzer(<span class="string">"ik_max_word"</span>))</span><br><span class="line">        .mustNot(matchQuery(<span class="string">"series_name"</span>, <span class="string">"速腾"</span>))</span><br><span class="line">    );</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    request.add(searchRequest);</span><br><span class="line">    MultiSearchResponse response = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sniffer-嗅探器"><a href="#Sniffer-嗅探器" class="headerlink" title="Sniffer 嗅探器"></a>Sniffer 嗅探器</h2><p>概念：从运行中的Elasticsearch集群自动发现节点并将它们设置为现有RestClient实例（low实例）。</p>
<p>版本：从ES 2.X开始及更高版本支持。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client-sniffer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">1.创建RestClient：RestClientBuilder</span><br><span class="line">2.HTTPS支持：NodesSniffer</span><br><span class="line">3.绑定：Sniffer.builder(RestClient)</span><br><span class="line">4.监听：SniffOnFailureListener</span><br><span class="line"></span><br><span class="line">相关设置参数：</span><br><span class="line">1.setSniffIntervalMillis：每隔多久触发一次嗅探，单位毫秒，默认30000（5分钟）。</span><br><span class="line">2.setSniffAfterFailureDelayMillis：嗅探失败时触发嗅探一次,经过设置的时间（默认1min）之后再次嗅探直至正常。若无绑定监听器则无效。</span><br><span class="line">3.setFailureListener：设置用于监听嗅探失败的监听器，当监听到普通嗅探失败，则通知Sniffer实例进行新一轮的嗅探，并更新节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ESClient ESClient;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost:9200,localhost:9201"</span>;</span><br><span class="line">    <span class="keyword">private</span> RestClientBuilder builder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sniffer sniffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestHighLevelClient highClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ESClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ESClient <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ESClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ESClient<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ESClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ESClient = <span class="keyword">new</span> ESClient();</span><br><span class="line">                    ESClient.initBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ESClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClientBuilder <span class="title">initBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] hosts = host.split(<span class="string">","</span>);</span><br><span class="line">        HttpHost[] httpHosts = <span class="keyword">new</span> HttpHost[hosts.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hosts.length; i++) &#123;</span><br><span class="line">            String[] host = hosts[i].split(<span class="string">":"</span>);</span><br><span class="line">            httpHosts[i] = <span class="keyword">new</span> HttpHost(host[<span class="number">0</span>], Integer.parseInt(host[<span class="number">1</span>]), <span class="string">"http"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder = RestClient.builder(httpHosts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//region 在Builder中设置请求头</span></span><br><span class="line">        <span class="comment">//  1.设置请求头</span></span><br><span class="line">        Header[] defaultHeaders = <span class="keyword">new</span> Header[]&#123;</span><br><span class="line">            <span class="keyword">new</span> BasicHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        builder.setDefaultHeaders(defaultHeaders);</span><br><span class="line">        <span class="comment">//endregion</span></span><br><span class="line">        <span class="comment">//RestClient restClient = builder.build();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启用嗅探器</span></span><br><span class="line">        <span class="comment">//SniffOnFailureListener sniffOnFailureListener = new SniffOnFailureListener();</span></span><br><span class="line">        <span class="comment">//builder.setFailureListener(sniffOnFailureListener);</span></span><br><span class="line">        <span class="comment">//sniffer = Sniffer.builder(restClient)</span></span><br><span class="line">        <span class="comment">//        .setSniffIntervalMillis(5000)</span></span><br><span class="line">        <span class="comment">//        .setSniffAfterFailureDelayMillis(10000)</span></span><br><span class="line">        <span class="comment">//        .build();</span></span><br><span class="line">        <span class="comment">//sniffOnFailureListener.setSniffer(sniffer);</span></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (highClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ESClient<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (highClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//gighClient是通过lowClient包装产生的</span></span><br><span class="line">                    highClient = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">                    <span class="comment">//设置嗅探器</span></span><br><span class="line">                    <span class="comment">//十秒刷新并更新一次节点</span></span><br><span class="line">                    sniffer = Sniffer.builder(highClient.getLowLevelClient())</span><br><span class="line">                        .setSniffIntervalMillis(<span class="number">5000</span>)</span><br><span class="line">                        .setSniffAfterFailureDelayMillis(<span class="number">15000</span>)</span><br><span class="line">                        .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> highClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 关闭sniffer client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != highClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sniffer.close();    <span class="comment">//需要在highClient close之前操作</span></span><br><span class="line">                highClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snifferTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client = ESClient.getInstance().getHighLevelClient();</span><br><span class="line">    Iterator&lt;Node&gt; nodes = client.getLowLevelClient().getNodes().iterator();</span><br><span class="line">    <span class="keyword">while</span> (nodes.hasNext()) &#123;</span><br><span class="line">        Node node = nodes.next();</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">"5秒后:"</span>);</span><br><span class="line">    nodes = client.getLowLevelClient().getNodes().iterator();</span><br><span class="line">    <span class="keyword">while</span> (nodes.hasNext()) &#123;</span><br><span class="line">        Node node = nodes.next();</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ESClient.getInstance().closeClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有5台机器，IP分别是【9200 - 9204】最后嗅探造成的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先输出:</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9200]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9201]</span><br><span class="line">间隔五秒后输出：</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9200]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9201]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9202]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9203]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9204]</span><br></pre></td></tr></table></figure>

<p><strong>嗅探器它能够给我们监控动态更新集群的节点数量，避免了程序因节点过多或增加/减少节点造成的切换问题。</strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(二)-查询语法</title>
    <url>/2021/05/24/elasticsearch%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><h3 id="Searchtimeout"><a href="#Searchtimeout" class="headerlink" title="Searchtimeout"></a>Searchtimeout</h3><p>①   设置：默认没有timeout，如果设置了timeout，那么会执行timeout机制。</p>
<p>②   Timeout机制：假设用户查询结果有1W条数据，但是需要10″才能查询完毕，但是用户设置了1″的timeout，那么不管当前一共查询到了多少数据，都会在1″后ES讲停止查询，并返回当前数据。</p>
<p>③  用法：GET /_search?timeout=1s/ms/m</p>
<a id="more"></a>

<h3 id="Query-String"><a href="#Query-String" class="headerlink" title="Query_String"></a>Query_String</h3><p>①  查询所有：GET /product/_search</p>
<p>②  带参数：GET /product/_search?q=name:xiaomi</p>
<p>③  分页：GET /product/_search?from=0&amp;size=2&amp;sort=price:asc</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据：</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">3999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line">PUT /product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi nfc phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"zhichi quangongneng nfc,shouji zhong de jianjiji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">4999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"gongjiaoka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /product/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"nfc phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de hongzhaji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">2999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"menjinka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /product/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi erji"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"erji zhong de huangmenji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"low"</span>, <span class="string">"bufangshui"</span>, <span class="string">"yinzhicha"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /product/_doc/5</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"hongmi erji"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"erji zhong de kendeji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">399</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"lowbee"</span>, <span class="string">"xuhangduan"</span>, <span class="string">"zhiliangx"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以后语句将忽略type的其他类型直接使用 _doc，以后 _doc也会移除</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询product索引下的所有type/doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置时限查询</span></span><br><span class="line"><span class="attr">timeout：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">(1)</span> <span class="string">设置：默认没有timeout，如果设置了timeout，那么会执行timeout机制。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">(2)</span> <span class="string">Timeout机制：假设用户查询结果有1W条数据，但是需要10s才能查询完毕</span></span><br><span class="line">    <span class="attr">但是用户设置了1s的timeout，那么不管当前一共查询到了多少数据，都会在1s后ES将停止查询，并返回当前数据。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">/_search?timeout=1s</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询doc中包含xiaomi的所有doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?q=xiaomi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询name中包含xiaomi的所有doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?q=name:xiaomi</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两者的区别：</p>
<p>q=xiaomi  ：将所有字段拼接成一个长字符串进行匹配</p>
<p>q=name:xiaomi   ：直接按照name进行匹配</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分页查询 每页2条数据 取第一页</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?from=0&amp;size=2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#排序 使用排序的话，相关度分数将_score = null</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?sort=price:asc</span></span><br></pre></td></tr></table></figure>

<h3 id="Query-SQL"><a href="#Query-SQL" class="headerlink" title="Query SQL"></a>Query SQL</h3><blockquote>
<p>match_all：匹配所有<br>multi_match：根据多个字段分词查询<br>match :对指定的关键词进行分词检索<br>match_phrase:对指定的关键词进行短语分词检索，如“xiaomi nfc”将按照此短语顺序匹配<br>match_phrase_prefix:对指定的关键词进行短语前缀分词检索，如“xiaomi nf”将按照此短语顺序匹配，最后一个term进行前缀匹配<br>term:对指定的此进行term匹配，不分词<br>keyword:对该值进行精确匹配，不分词<br>bool：可以组合多个查询条件<br>    must：相当于and<br>    must_not：相当于not<br>    should：相当于or</p>
</blockquote>
<h4 id="match-all"><a href="#match-all" class="headerlink" title="match_all"></a>match_all</h4><p>查询所有</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><blockquote>
<p> 分词查询</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><blockquote>
<p> 搜索排序</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"nfc"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"desc"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h4><blockquote>
<p> 据多个字段查询一个关键词</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ，name和desc中包含"nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"nfc"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"desc"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h4><blockquote>
<p>nested类型是<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/object.html" target="_blank" rel="noopener">object</a>数据类型的专用版本，它允许以可以彼此独立地查询对象的方式对对象数组进行索引，当存储内部对象为复杂类型时应该使用nested而不是object。默认嵌套五十层</p>
<p>path：nested对象的查询深度，用在复杂嵌套情况下</p>
<p>score_mode：聚合分数计算方式<br>    avg （默认）：使用所有匹配的子对象的平均相关性得分。<br>    max：使用所有匹配的子对象中的最高相关性得分。<br>    min：使用所有匹配的子对象中最低的相关性得分。<br>    none：不要使用匹配的子对象的相关性分数。该查询为父文档分配得分为0。<br>    sum：将所有匹配的子对象的相关性得分相加。</p>
</blockquote>
<h5 id="单层复杂类型"><a href="#单层复杂类型" class="headerlink" title="单层复杂类型"></a>单层复杂类型</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#不指定mapping创建</span><br><span class="line">PUT /order/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"order_name"</span>: <span class="string">"小米10 Pro订单"</span>,</span><br><span class="line">  <span class="attr">"desc"</span>: <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">  <span class="attr">"goods_count"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"total_price"</span>: <span class="number">12699</span>,</span><br><span class="line">  <span class="attr">"goods_list"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小米10 PRO MAX 5G"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">4999</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"钢化膜"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">19</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"手机壳"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">199</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">#使用bool进行复杂属性查询时，查询时只有匹配到goods_list数组下任意name或price的值就会被查询出来，如需匹配数组下单个元素，需要指定该复杂类型为Nested</span><br><span class="line">GET /order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"goods_list.name"</span>: <span class="string">"小米"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"goods_list.price"</span>: <span class="string">"4999"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#创建nested类型的字段mapping</span><br><span class="line">PUT /order</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"desc"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"goods_count"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"goods_list"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"nested"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"order_name"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"total_price"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#使用nested进行匹配，当goods_list数组的同个对象的属性值匹配上都查询出文档</span><br><span class="line">GET /order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"nested"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"goods_list"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">          <span class="attr">"must"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"match"</span>: &#123;</span><br><span class="line">                <span class="attr">"goods_list.name"</span>: <span class="string">"小米"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"match"</span>: &#123;</span><br><span class="line">                <span class="attr">"goods_list.price"</span>: <span class="string">"4999"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"score_mode"</span>: <span class="string">"avg"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多层复杂类型"><a href="#多层复杂类型" class="headerlink" title="多层复杂类型"></a>多层复杂类型</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建多层mapping</span><br><span class="line">PUT /area</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"province"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">              <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"district"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">                <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                  <span class="attr">"name"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                    <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#创建数据</span><br><span class="line">PUT /area/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"province"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"北京"</span>,</span><br><span class="line">    <span class="attr">"cities"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"北京市"</span>,</span><br><span class="line">        <span class="attr">"district"</span>: [</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"丰台区"</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"海淀区"</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"朝阳区"</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"东城区"</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"西城区"</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">"name"</span>:<span class="string">"昌平区"</span>&#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">city为包含北京市 或者 包含淇滨区的    省份信息</span><br><span class="line">GET /area/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"nested"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"province"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"nested"</span>: &#123;</span><br><span class="line">          <span class="attr">"path"</span>: <span class="string">"province.cities"</span>,</span><br><span class="line">          <span class="attr">"query"</span>: &#123;</span><br><span class="line">            <span class="attr">"bool"</span>: &#123;</span><br><span class="line">              <span class="attr">"should"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"term"</span>: &#123;</span><br><span class="line">                    <span class="attr">"province.cities.name"</span>: <span class="string">"北京"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"nested"</span>: &#123;</span><br><span class="line">                    <span class="attr">"path"</span>: <span class="string">"province.cities.district"</span>,</span><br><span class="line">                    <span class="attr">"query"</span>: &#123;</span><br><span class="line">                      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                        <span class="attr">"must"</span>: [</span><br><span class="line">                          &#123;</span><br><span class="line">                            <span class="attr">"term"</span>: &#123;</span><br><span class="line">                              <span class="attr">"province.cities.district.name"</span>: <span class="string">"淇滨区"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                        ]</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h4><blockquote>
<p>元数据：指定查询的字段</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子中为只查询“name”和“price”字段</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"nfc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"price"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deep-paging"><a href="#deep-paging" class="headerlink" title="deep-paging"></a>deep-paging</h4><blockquote>
<p>分页查询（性能低）</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页（deep-paging）：查询第一页（每页两条数据）</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"asc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ], </span><br><span class="line">    <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><blockquote>
<p>不会分词，直接与term匹配</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//query-term：查询条件 "nfc phone" 不会被分词，不会分成多个单词</span></span><br><span class="line"><span class="comment">//term和match的区别是match 会对查询条件进行分词</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合查询</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"nfc"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"phone"</span>&#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含查询  类似于 SQL: where xxx in ();</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>:[<span class="string">"nfc"</span>,<span class="string">"phone"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全文检索，一个单词进行分词，常用语句！！！</span></span><br><span class="line"><span class="comment">//等价SQL: name in (xiaomi,nfc,zhineng,phone)</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"xiaomi nfc zhineng phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证这个字符串的分词结果</span></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="attr">"text"</span>:<span class="string">"xiaomi nfc zhineng phone"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h4><blockquote>
<p>短语匹配，匹配合适的短语，可能是匹配到多个顺序的term</p>
<p>“nfc phone”短语匹配到了“nfc ”、“phone”两个顺序的term文档</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//短语搜索，和全文检索相反，会将给定的短语（phrase）当成一个完整的查询条件</span></span><br><span class="line"><span class="comment">//等价SQL: name contains("nfc phone")</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match-phrase-prefix"><a href="#match-phrase-prefix" class="headerlink" title="match_phrase_prefix"></a>match_phrase_prefix</h4><blockquote>
<p>与match_phrase类似，但是允许与最后一个term前缀匹配</p>
</blockquote>
<h4 id="Query-and-filter"><a href="#Query-and-filter" class="headerlink" title="Query and filter"></a>Query and filter</h4><blockquote>
<p>bool：可以组合多个查询条件，bool查询也是采用more_matches_is_better的机制，因此满足must和should子句的文档将会合并起来计算分值。</p>
</blockquote>
<p><strong>must</strong>：必须满足</p>
<p>​            子句（查询）必须出现在匹配的文档中，并将有助于得分。</p>
<p><strong>filter</strong>：过滤器 <strong>不计算相关度分数</strong>，cache☆</p>
<p>​            子句（查询）必须出现在匹配的文档中。但是不像 must查询的分数将被忽略。Filter子句在filter上下文中执行，这意味着计分被忽略，并且子句被考虑用于缓存。</p>
<p><strong>should</strong>：可能满足 or</p>
<p>​            子句（查询）应出现在匹配的文档中。</p>
<p><strong>must_not</strong>：必须不满足 <strong>不计算相关度分数</strong>  not</p>
<p>​            子句（查询）不得出现在匹配的文档中。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。由于忽略计分，0因此将返回所有文档的分数。</p>
<p><strong>minimum_should_match</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先筛选name包含“xiaomi phone”并且价格大于1999的数据（不排序）   先执行filter筛选数据</span></span><br><span class="line"><span class="comment">//然后搜索name包含“xiaomi”and desc 包含“shouji”</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"xiaomi"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"desc"</span>: <span class="string">"shouji"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match_phrase"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi phone"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"gt"</span>: <span class="number">1999</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bool多条件 name包含xiaomi 不包含erji 描述里包不包含nfc都可以，价钱要大于等于4999</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">			<span class="comment">//name中必须不能包含“erji”</span></span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"xiaomi"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">			<span class="comment">//name中必须包含“xiaomi”</span></span><br><span class="line">            <span class="attr">"must_not"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"erji"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">			<span class="comment">//should中至少满足0个条件，参见下面的minimum_should_match的解释</span></span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;</span><br><span class="line">                    <span class="attr">"desc"</span>: <span class="string">"nfc"</span></span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ], </span><br><span class="line">			<span class="comment">//筛选价格大于4999的doc</span></span><br><span class="line">            <span class="attr">"filter"</span>: [		</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"gt"</span>: <span class="number">4999</span>   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minimum_should_match：参数指定should返回的文档必须匹配的子句的数量或百分比。<br>如果bool查询包含至少一个should子句，而没有must或 filter子句，则默认值为1。否则，默认值为0</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询 name必须包含 "nfc" 且should中必须满足一个条件</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>:<span class="number">1999</span>&#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>:<span class="number">3999</span>&#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">//表示should里的条件至少满足一个</span></span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种情况下，should至少满足0个条件</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                    <span class="comment">//价格必须大于1999或者大于3999</span></span><br><span class="line">                    <span class="attr">"should"</span>: [</span><br><span class="line">                        &#123; <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">1999</span>&#125;&#125;&#125;,</span><br><span class="line">                        &#123; <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">3999</span>&#125;&#125;&#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"must"</span>: [</span><br><span class="line">                        &#123; <span class="attr">"match"</span>: &#123;<span class="attr">"name"</span>: <span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"my good"</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"or"</span>,   <span class="comment">//可选：or、and  默认是or</span></span><br><span class="line">                <span class="attr">"minimum_should_match"</span>: <span class="number">2</span>, <span class="comment">//最少匹配2个此项</span></span><br><span class="line">                "boost"：1   //相关度算法权重</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有相关查询，ES底层会转换成bool操作</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;    </span><br><span class="line">            <span class="attr">"should"</span>: [  <span class="comment">//and的话，这里就是must, 可选：must/must not/should</span></span><br><span class="line">              &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"my"</span>&#125;&#125;,</span><br><span class="line">              &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"good"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Compound-queries"><a href="#Compound-queries" class="headerlink" title="Compound queries"></a>Compound queries</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合查询</span></span><br><span class="line"><span class="comment">//想要一台带NFC功能的 或者 小米的手机 但是不要耳机</span></span><br><span class="line"><span class="comment">//等价于SQL:</span></span><br><span class="line"><span class="comment">//  SELECT * from product </span></span><br><span class="line"><span class="comment">//  where (`name` like "%xiaomi%" or `name` like '%nfc%')</span></span><br><span class="line"><span class="comment">//  AND `name` not LIKE '%erji%'</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:&#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                    <span class="attr">"should"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi"</span>&#125;&#125;,</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"must_not"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"erji"</span>&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//给他的分数赋值 1.2  没什么 意义</span></span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">1.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//搜索一台xiaomi nfc phone或者一台满足 是一台手机 并且 价格小于等于2999</span></span><br><span class="line"><span class="comment">//等价于SQL：</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123; </span><br><span class="line">                <span class="attr">"bool"</span>:&#123;</span><br><span class="line">                    <span class="attr">"should"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"match_phrase"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi nfc phone"</span>&#125;&#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"bool"</span>:&#123;</span><br><span class="line">                                <span class="attr">"must"</span>:[</span><br><span class="line">                                    &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"phone"</span>&#125;&#125;,</span><br><span class="line">                                    &#123;<span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"lte"</span>:<span class="string">"2999"</span>&#125;&#125;&#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Highlight-search"><a href="#Highlight-search" class="headerlink" title="Highlight search"></a>Highlight search</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高亮查询</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span>:&#123;</span><br><span class="line">        <span class="attr">"fields"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果：会多返回一段高亮信息</span></span><br><span class="line">"highlight" : &#123;</span><br><span class="line">    "name" : [</span><br><span class="line">        <span class="string">"&lt;em&gt;nfc&lt;/em&gt; &lt;em&gt;phone&lt;/em&gt;"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deep-paging问题"><a href="#Deep-paging问题" class="headerlink" title="Deep paging问题"></a>Deep paging问题</h4><p>![](/images/elk/elasticsearch-dql/deep paging问题.png)</p>
<p>假设我要分页获取第5001~5050条数据时，由于数据是无序散落在各个<code>shard</code>分片中的，所以进行分页排序的时候，需要将各个<code>shard</code>分片进行排序，获取每个分片的【0 - 5050】条数据，然后进行合并，最后取出合适的50条数据，然后丢弃其他数据。</p>
<p><strong>这种操作是十分损耗性能的，尽量避免深度分页查询，当你的数据超过1W，不要使用，返回结果不要超过1000个，500以下为宜。</strong></p>
<h4 id="Scroll-search"><a href="#Scroll-search" class="headerlink" title="Scroll search"></a>Scroll search</h4><p>通过使用<code>Scroll search</code>来避免部分分页查询，在查询中添加<code>?scroll</code>参数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中  1m 表示当前的scroll窗口有效期是1分钟</span></span><br><span class="line">GET /product/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>:[&#123;<span class="attr">"price"</span>:<span class="string">"asc"</span>&#125;],</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这样查询，返回值会带上一个<code>_scroll_id</code>结果</p>
<p><img src="/images/elk/elasticsearch-dql/es-02.png" alt="es"></p>
<p>当进行下一页时，直接通过上一次返回的<code>scroll_id</code>进行查询即可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//给scroll进行续命</span></span><br><span class="line">    <span class="attr">"scroll"</span> :<span class="string">"1m"</span>,</span><br><span class="line">    scroll_id:"xxxxxxxxxxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>他的缺点是只能下一页，没办法上一页，不适合实时查询</strong></p>
<h4 id="Filter缓存原理"><a href="#Filter缓存原理" class="headerlink" title="Filter缓存原理"></a>Filter缓存原理</h4><p><img src="/images/elk/elasticsearch-dql/Filter%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png" alt=""></p>
<p><strong>当使用 term词项去倒排索引表进行搜索时，返回的一条条数据，filter会通过一个Bit数组存储，每个词项term对应一个bit数组，1表示匹配成功，0表示匹配失败。</strong></p>
<p>计算多个filter条件的组合时，直接进行bit数组的与运算就能得出相应的结果，在一定条件下，filter会将查询的bit数组进行缓存。</p>
<h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/_mget</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/&lt;index&gt;/_mget</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量查询 查询id =2 和id = 3 的数据</span></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装,把索引名(product提取出来)</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//再封装</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ids"</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include包含哪些字段  exclude排除哪些字段</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: <span class="literal">false</span> <span class="comment">//不显示字段数据</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: [  <span class="comment">//指定字段数据</span></span><br><span class="line">                <span class="string">"name"</span>,</span><br><span class="line">                <span class="string">"price"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"include"</span>: [</span><br><span class="line">                    <span class="string">"name"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"exclude"</span>:[</span><br><span class="line">                    <span class="string">"price"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operate：</span><br><span class="line">  create：PUT &#x2F;index&#x2F;_create&#x2F;id&#x2F;，强制创建（是否制定id）</span><br><span class="line">  delete：删除（lazy delete原理）</span><br><span class="line">  index：可以是创建，也可以是全量替换</span><br><span class="line">  update：执行partial update（全量替换，部分替换）</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动指定id和自动生成</span></span><br><span class="line">PUT /test_index/_doc/1/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强制执行创建 如果数据存在则报错</span></span><br><span class="line">PUT /test_index/_doc/1/_create</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">PUT /test_index/_create/1/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生产id(guid)</span></span><br><span class="line">POST /test_index/_doc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用PUT进行数据覆盖的时候，Version版本号会上升，旧的Version数据会被删除，不会马上删除，会有一个懒删除的机制。</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">bulk：批量增删改  no-query</span><br><span class="line">语法格式：</span><br><span class="line">POST /_bulk</span><br><span class="line">POST /&lt;index&gt;/_bulk</span><br><span class="line">&#123;<span class="attr">"action"</span>: &#123;<span class="attr">"metadata"</span>&#125;&#125;   <span class="comment">//操作和索引</span></span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;   <span class="comment">//数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"1"</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"_bulk create 2"</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"12"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"_bulk create 12"</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"3"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"index product2 "</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"13"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"index product2"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当出现冲突时尝试三次，三次失败后就放弃</span></span><br><span class="line">&#123; <span class="attr">"update"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"4"</span>,<span class="attr">"retry_on_conflict"</span> : <span class="string">"3"</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123;<span class="attr">"test_field2"</span> : <span class="string">"bulk test1"</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<p><code>bulk</code>批处理操作要求数据分两行编写，不可以将<code>{}</code>进行换行操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加?filter_path=items.*.error  只显示失败的，返回从操作失败的数据信息</span></span><br><span class="line">POST /_bulk?filter_path=items.*.error</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"1"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//version=2&amp;&amp;version_type=external 通过版本更新数据，避免并发覆盖---CAS</span></span><br><span class="line">PUT /version_index/_doc/1?version=2&amp;&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"窈窕淑女,君子好逑"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新版本使用者两个</span></span><br><span class="line"><span class="comment">//if_seq_no` and `if_primary_term`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ES是通过CAS+Version解决并发的问题！！！</strong></p>
</blockquote>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>概念：mapping就是ES数据字段field的type元数据，ES在创建索引的时候，dynamic mapping会自动为不同的数据指定相应mapping，mapping中包含了字段的类型、搜索方式（exact value或者full text）、分词器等。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">查看mapping</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_mappings</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Dynamic</span> <span class="string">mapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">“Elasticsearch”：text/keyword</span>		<span class="string"></span></span><br><span class="line"><span class="attr">123456</span>			=<span class="string">&gt;	long			？为什么不是integer</span></span><br><span class="line"><span class="meta">123.123</span>			=<span class="string">&gt;	double		</span></span><br><span class="line"><span class="attr">true</span> <span class="string">false		=&gt;	boolean</span></span><br><span class="line"><span class="meta">2020-05-20</span>		=<span class="string">&gt;	date</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为啥price是long类型而不是integer？因为es的mapping_type是由JSON分析器检测数据类型，而Json没有隐式类型转换（integer=&gt;long or float=&gt; double）,所以dynamic mapping会选择一个比较宽的数据类型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索方式：</span><br><span class="line">exact value 精确匹配：在倒排索引过程中，分词器会将field作为一个整体创建到索引中，</span><br><span class="line">full text全文检索：分词、近义词同义词、混淆词、大小写、词性、过滤、时态转换等（normaliztion）</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【核心类型】：</span><br><span class="line">数字类型：</span><br><span class="line">  long, integer, short, byte, double, float, half_float, scaled_float</span><br><span class="line">  在满足需求的情况下，尽可能选择范围小的数据类型。</span><br><span class="line"></span><br><span class="line">2.字符串：string：</span><br><span class="line">  2.1 keyword：适用于索引结构化的字段，可以用于过滤、排序、聚合。</span><br><span class="line">      keyword类型的字段只能通过精确值（exact value）搜索到。</span><br><span class="line">      Id应该用keyword。</span><br><span class="line"></span><br><span class="line">  2.2 text：</span><br><span class="line">  当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型。</span><br><span class="line">  设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。</span><br><span class="line">  text类型的字段不用于排序，很少用于聚合。</span><br><span class="line">  （解释一下为啥不会为text创建索引：字段数据会占用大量堆空间，尤其是在加载高基数text字段时。</span><br><span class="line">  字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。</span><br><span class="line">  同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问题。这就是默认情况下禁用字段数据的原因）</span><br><span class="line">  </span><br><span class="line">  2.3 有时，在同一字段中同时具有全文本（text）和关键字（keyword）版本会很有用：一个用于全文本搜索，另一个用于聚合和排序。</span><br><span class="line">  </span><br><span class="line">3.date（时间类型）：exact value（精确匹配）</span><br><span class="line">4.布尔类型：boolean</span><br><span class="line">5.binary（二进制）：binary</span><br><span class="line">6.range（区间类型）：integer_range、float_range、long_range、double_range、date_range</span><br><span class="line"></span><br><span class="line">【复杂类型】：</span><br><span class="line">1.Object：用于单个JSON对象</span><br><span class="line">2.Nested：用于JSON对象数组</span><br><span class="line"></span><br><span class="line">【地理位置】：</span><br><span class="line">1.Geo-point：纬度&#x2F;经度积分</span><br><span class="line">2.Geo-shape：用于多边形等复杂形状</span><br><span class="line"></span><br><span class="line">【特有类型】：</span><br><span class="line">1.IP地址：ip 用于IPv4和IPv6地址</span><br><span class="line">2.Completion：提供自动完成建议</span><br><span class="line">3.Tocken_count：计算字符串中令牌的数量</span><br><span class="line">4.Murmur3：在索引时计算值的哈希并将其存储在索引中</span><br><span class="line">5.Annotated-text：索引包含特殊标记的文本（通常用于标识命名实体）</span><br><span class="line">6.Percolator：接受来自query-dsl的查询</span><br><span class="line">7.Join：为同一索引内的文档定义父&#x2F;子关系</span><br><span class="line">8.Rank features：记录数字功能以提高查询时的点击率。</span><br><span class="line">9.Dense vector：记录浮点值的密集向量。</span><br><span class="line">10.Sparse vector：记录浮点值的稀疏向量。</span><br><span class="line">11.Search-as-you-type：针对查询优化的文本字段，以实现按需输入的完成</span><br><span class="line">12.Alias：为现有字段定义别名。</span><br><span class="line">13.Flattened：允许将整个JSON对象索引为单个字段。</span><br><span class="line">14.Shape：shape 对于任意笛卡尔几何。</span><br><span class="line">15.Histogram：histogram 用于百分位数聚合的预聚合数值。</span><br><span class="line">16.Constant keyword：keyword当所有文档都具有相同值时的情况的 专业化。</span><br><span class="line"></span><br><span class="line">【Array（数组）】：在Elasticsearch中，数组不需要专用的字段数据类型。</span><br><span class="line">默认情况下，任何字段都可以包含零个或多个值，但是，数组中的所有值都必须具有相同的数据类型。</span><br><span class="line"></span><br><span class="line">【ES 7新增】：</span><br><span class="line">1.Date_nanos：date plus 纳秒</span><br><span class="line">2.Features：</span><br><span class="line">3.Vector：as</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手工创建mapping fields的mapping只能创建，无法修改</span></span><br><span class="line">PUT /product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: &#123;</span><br><span class="line">                <span class="attr">"mapping_parameter"</span>: <span class="string">"parameter_value"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapping-parameters"><a href="#Mapping-parameters" class="headerlink" title="Mapping parameters"></a>Mapping parameters</h3><p><strong>index</strong>：是否对创建对当前字段创建索引，默认true，如果不创建索引，该字段不会通过索引被搜索到,但是仍然会在source元数据中展示</p>
<p><strong>analyzer</strong>:指定分析器（character filter、tokenizer、Token filters）。</p>
<p><strong>boost</strong>：对当前字段相关度的评分权重，默认1</p>
<p><strong>coerce</strong>：是否允许强制类型转换  true “1”=&gt; 1  false “1”=&lt; 1</p>
<p><strong>copy_to</strong>：拷贝字段值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本案例</span></span><br><span class="line">PUT /product3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"date"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"false"</span>,</span><br><span class="line">                <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"Integer"</span>,</span><br><span class="line">                <span class="attr">"coerce"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tags"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"true"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"parts"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"object"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"partlist"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"nested"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy_to案例</span></span><br><span class="line">PUT copy_to</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"field1"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"copy_to"</span>: <span class="string">"field_all"</span> </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"field2"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"copy_to"</span>: <span class="string">"field_all"</span> </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"field_all"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doc_values</strong>：为了提升排序和聚合效率，默认true，如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，则可以禁用doc值以节省磁盘空间（不支持text和annotated_text）</p>
<p><strong>dynamic</strong>：控制是否可以动态添加新字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true 新检测到的字段将添加到映射中。（默认）</span><br><span class="line"></span><br><span class="line">false 新检测到的字段将被忽略。这些字段将不会被索引，因此将无法搜索，但仍会出现在_source返回的匹配项中。</span><br><span class="line">这些字段不会添加到映射中，必须显式添加新字段。</span><br><span class="line"></span><br><span class="line">strict 如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显式添加到映射中</span><br></pre></td></tr></table></figure>

<p><strong>eager_global_ordinals：用于聚合的字段上，优化聚合性能。</strong></p>
<p>Frozen indices（冻结索引）：有些索引使用率很高，会被保存在内存中，有些使用率特别低，宁愿在使用的时候重新创建，在使用完毕后丢弃数据，Frozen indices的数据命中频率小，不适用于高搜索负载，数据不会被保存在内存中，堆空间占用比普通索引少得多，Frozen indices是只读的，请求可能是秒级或者分钟级。<strong>eager_global_ordinals不适用于Frozen indices</strong></p>
<p><strong>enable</strong>：<strong>只用于mapping中的object字段类型</strong>。当设置为false时，其作用是使es不去解析该字段，并且该字段<strong>不能被查询和store</strong>，只有在_source中才能看到（即查询结果中会显示的_source数据）。设置enabled为false，可以不设置字段类型，默认为object。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "enabled": false </span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "session_data": &#123;</span><br><span class="line">                "type": "object",</span><br><span class="line">                "enabled": false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fielddata</strong>：查询时<strong>内存</strong>数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，需要字段为fielddata数据结构，并且创建正排索引保存到堆中。</p>
<p> <strong>fields：</strong>给field创建多字段，用于不同目的（全文检索或者聚合分析排序）</p>
<p><strong>format</strong>：格式化</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"date": &#123;</span><br><span class="line">    "type":  "date",</span><br><span class="line">    "format": "yyyy-MM-dd"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ignore_above</strong>：<strong>text中的keyword长度，超过长度将被截断</strong></p>
<p><strong>ignore_malformed</strong>：忽略类型错误</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "number_one": &#123;</span><br><span class="line">                "type": "integer",</span><br><span class="line">                "ignore_malformed": true</span><br><span class="line">            &#125;,</span><br><span class="line">            "number_two": &#123;</span><br><span class="line">                "type": "integer"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虽然有异常 但是不抛出</span></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Some text value"</span>,</span><br><span class="line">    <span class="attr">"number_one"</span>:<span class="string">"foo"</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据格式不对</span></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Some text value"</span>,</span><br><span class="line">    <span class="attr">"number_two"</span>: <span class="string">"foo"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index_options</strong>：控制将哪些信息添加到反向索引中以进行搜索和突出显示。仅用于text字段</p>
<p><strong>Index_phrases</strong>：提升exact_value查询速度，但是要消耗更多磁盘空间</p>
<p><strong>Index_prefixes</strong>：前缀搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_chars：前缀最小长度，&gt;0，默认2（包含）</span><br><span class="line">max_chars：前缀最大长度，&lt;20，默认5（包含）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"index_prefixes"</span>: &#123;</span><br><span class="line">    <span class="string">"min_chars"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"max_chars"</span> : <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>meta</strong>：附加元数据</p>
<p><strong>norms</strong>：是否禁用评分（在filter和聚合字段上应该禁用）。</p>
<p><strong>null_value</strong>：为null值设置默认值</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"null_value": "NULL"</span><br></pre></td></tr></table></figure>

<p><strong>proterties</strong>：除了mapping还可用于object的属性设置</p>
<p><strong>search_analyzer</strong>：设置单独的查询时分析</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "settings": &#123;</span><br><span class="line">        "analysis": &#123;</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "autocomplete_filter": &#123;</span><br><span class="line">                    "type": "edge_ngram",</span><br><span class="line">                    "min_gram": 1,</span><br><span class="line">                    "max_gram": 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "analyzer": &#123;</span><br><span class="line">                "autocomplete": &#123; </span><br><span class="line">                    "type": "custom",</span><br><span class="line">                    <span class="comment">//倒排索引的分词器 默认 standard</span></span><br><span class="line">                    "tokenizer": "standard",</span><br><span class="line">                    "filter": [</span><br><span class="line">                        "lowercase",</span><br><span class="line">                        <span class="string">"autocomplete_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "text": &#123;</span><br><span class="line">                "type": "text",</span><br><span class="line">                "analyzer": "autocomplete",</span><br><span class="line">                <span class="comment">//搜索时的分词器 默认 standard</span></span><br><span class="line">                "search_analyzer": "standard" </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Quick Brown Fox"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET my_index/_search&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match": &#123;</span><br><span class="line">            "text": &#123;</span><br><span class="line">                "query": "Quick Br", </span><br><span class="line">                "operator": "and"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>similarity</strong>：为字段设置相关度算法，支持BM25、claassic（默认TF-IDF）、boolean</p>
<p><strong>store</strong>：设置字段是否仅查询</p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>语法：<code>&quot;aggs&quot;:{}</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个tag产品的数量   "size":0, 不显示原始结果  </span></span><br><span class="line"><span class="comment">//使用text类型.keyword，提高效率</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"your_group_name"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//text默认不支持聚合，若想要支持，需要修改mapping的key属性：fielddata</span></span><br><span class="line"><span class="comment">//text直接做聚合，效率极低，不推荐！！！</span></span><br><span class="line">PUT /product/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//价格大于1999的每个tag产品的数量</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">1999</span>&#125;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平均值语法</span></span><br><span class="line">"avg": &#123;</span><br><span class="line">    "field": "your_avg_key"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//价格大于1999的每个tag产品的平均价格</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_avg"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span>,</span><br><span class="line">                <span class="attr">"order"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg_price"</span>: <span class="string">"desc"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照千元机 1000以下  中端机[2000-3000) 高端机 [3000,∞）</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"range"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"ranges"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">100</span>,</span><br><span class="line">                        <span class="attr">"to"</span>: <span class="number">1000</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">1000</span>,</span><br><span class="line">                        <span class="attr">"to"</span>: <span class="number">3000</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">3000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"price_agg"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(五)-分词器</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">分析器：</span></span><br><span class="line"><span class="meta">1.character</span> <span class="string">filter（mapping）：分词之前预处理（过滤无用字符、标签等，转换一些&amp;=&gt;and 《es》=&gt; es</span></span><br><span class="line">   <span class="attr">HTML</span> <span class="string">Strip Character Filter：html_strip  自动过滤html标签</span></span><br><span class="line">   <span class="meta">参数：escaped_tags</span>   <span class="string">需要保留的html标签</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">Mapping</span> <span class="string">Character Filter：type mapping</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">Pattern</span> <span class="string">Replace Character Filter：type pattern_replace</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.tokenizer（分词器）：分词</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.token</span> <span class="string">filter：停用词、时态转换、大小写转换、同义词转换、语气词处理等。如：has=&gt;have  him=&gt;he  apples=&gt;apple</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="normalization"><a href="#normalization" class="headerlink" title="normalization"></a>normalization</h3><p>标准化处理是用于完善分词器结果的，提升recall召回率。</p>
<p><img src="/images/elk/elasticsearch-analysis/es-01.png" alt="es"></p>
<p><img src="/images/elk/elasticsearch-analysis/es-02.png" alt="es"></p>
<h3 id="character-filter"><a href="#character-filter" class="headerlink" title="character filter"></a>character filter</h3><h4 id="HTML-Strip-Character-Filter"><a href="#HTML-Strip-Character-Filter" class="headerlink" title="HTML Strip Character Filter"></a>HTML Strip Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTML Strip Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="comment">//分析器</span></span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;         <span class="comment">//设置html字符过滤器，并保留&lt;a&gt;标签</span></span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"html_strip"</span>,   </span><br><span class="line">                    <span class="attr">"escaped_tags"</span>: [<span class="string">"a"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//分词器</span></span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [<span class="string">"my_char_filter"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试分词</span></span><br><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"&lt;p&gt;I&amp;apos;m so &lt;a&gt;happy&lt;/a&gt;!&lt;/p&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : """</span><br><span class="line">          I'm so &lt;a&gt;happy&lt;/a&gt;!</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapping-Character-Filter"><a href="#Mapping-Character-Filter" class="headerlink" title="Mapping Character Filter"></a>Mapping Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Mapping Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [</span><br><span class="line">                        <span class="string">"my_char_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"mapping"</span>,   <span class="comment">//为指定的字符制定映射规则</span></span><br><span class="line">                    <span class="attr">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"٠ =&gt; 0"</span>,</span><br><span class="line">                        <span class="string">"١ =&gt; 1"</span>,</span><br><span class="line">                        <span class="string">"٢ =&gt; 2"</span>,</span><br><span class="line">                        <span class="string">"٣ =&gt; 3"</span>,</span><br><span class="line">                        <span class="string">"٤ =&gt; 4"</span>,</span><br><span class="line">                        <span class="string">"٥ =&gt; 5"</span>,</span><br><span class="line">                        <span class="string">"٦ =&gt; 6"</span>,</span><br><span class="line">                        <span class="string">"٧ =&gt; 7"</span>,</span><br><span class="line">                        <span class="string">"٨ =&gt; 8"</span>,</span><br><span class="line">                        <span class="string">"٩ =&gt; 9"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"My license plate is ٢٥٠١٥"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : "My license plate is 25015"</span><br></pre></td></tr></table></figure>

<h4 id="Pattern-Replace-Character-Filter"><a href="#Pattern-Replace-Character-Filter" class="headerlink" title="Pattern Replace Character Filter"></a>Pattern Replace Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pattern Replace Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [<span class="string">"my_char_filter"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"pattern_replace"</span>,   <span class="comment">//通过正则匹配，把-替换成_</span></span><br><span class="line">                    <span class="attr">"pattern"</span>: <span class="string">"(\\d+)-(?=\\d)"</span>,</span><br><span class="line">                    <span class="attr">"replacement"</span>: <span class="string">"$1_"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"My credit card is 123-456-789"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : "My credit card is 123_456_789"</span><br></pre></td></tr></table></figure>

<h3 id="token-filter"><a href="#token-filter" class="headerlink" title="token filter"></a>token filter</h3><h4 id="lowercase-token-filter"><a href="#lowercase-token-filter" class="headerlink" title="lowercase token filter"></a>lowercase token filter</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大小写 lowercase token filter</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokenizer"</span> : <span class="string">"standard"</span>,</span><br><span class="line">  <span class="attr">"filter"</span> : [<span class="string">"lowercase"</span>],</span><br><span class="line">  <span class="attr">"text"</span> : <span class="string">"THE Quick FoX JUMPs"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">the、quick、fox、jumps</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当分词后的词项长度满足 &lt; 5 时，执行 filter配置</span></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"condition"</span>,</span><br><span class="line">            <span class="attr">"filter"</span>: [ <span class="string">"lowercase"</span> ],</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"token.getTerm().length() &lt; 5"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"THE QUICK BROWN FOX"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">the、QUICK、BROWN、fox</span><br></pre></td></tr></table></figure>

<h4 id="stopwords-token-filter"><a href="#stopwords-token-filter" class="headerlink" title="stopwords token filter"></a>stopwords token filter</h4><p>在信息检索中，停用词是为节省存储空间和提高搜索效率，处理文本时自动过滤掉某些字或词，这些字或词即被称为Stop Words（停用词）。</p>
<p>停用词大致分为两类。一类是语言中的功能词，这些词极其普遍而无实际含义，如“the”、“is“、“which“、“on”等。另一类是词汇词，比如’want’等，这些词应用广泛，但搜索引擎无法保证能够给出真正相关的搜索结果，难以缩小搜索范围，还会降低搜索效率。</p>
<p>实践中，<strong>通过配置<code>stopwords</code>使得这些词汇不添加进倒排索引中</strong>，从而节省索引的存储空间、提高搜索性能。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>:&#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"stopwords"</span>:<span class="string">"_english_"</span>  <span class="comment">//启动英语停用词</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Teacher Ma is in the restroom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">未启用英语停用词结果：</span><br><span class="line">Teacher、Ma、is、in、the、restroom</span><br><span class="line"></span><br><span class="line">启用英语停用词结果：</span><br><span class="line">Teacher、Ma、restroom</span><br></pre></td></tr></table></figure>

<h3 id="tokenizer"><a href="#tokenizer" class="headerlink" title="tokenizer"></a>tokenizer</h3><p>基于ES 7.6版本，支持的内置分词器有15种。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/analysis-tokenizers.html" target="_blank" rel="noopener">官网介绍</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.standard</span> <span class="string">analyzer：默认分词器，中文支持的不理想，会逐字拆分。</span></span><br><span class="line">   <span class="attr">max_token_length：最大令牌长度。如果看到令牌超过此长度，则将其max_token_length间隔分割。默认为255。</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">2.Pattern</span> <span class="string">Tokenizer：以正则匹配分隔符，把文本拆分成若干词项。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.Simple</span> <span class="string">Pattern Tokenizer：以正则匹配词项，速度比Pattern Tokenizer快。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.whitespace</span> <span class="string">analyzer：以空白符分隔	Tim_cookie</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置内置分词器</span></span><br><span class="line">PUT /test_analysis/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;  <span class="comment">//自定义分词器名称</span></span><br><span class="line">                    <span class="attr">"tokenizer"</span>:<span class="string">"whitespace"</span>   <span class="comment">//指定使用的分词器 standard、pattern、simple</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证分词器</span></span><br><span class="line">GET /test_analysis/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"ooo is bbbb!!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-analysis"><a href="#自定义-analysis" class="headerlink" title="自定义 analysis"></a>自定义 analysis</h4><p>设置<code>&quot;type&quot;: &quot;custom&quot;</code>告诉Elasticsearch我们正在定义一个定制分析器。将此与配置内置分析器的方式进行比较： type将设置为内置分析器的名称，如 standard或simple</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_analysis</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;   <span class="comment">//自定义字符过滤器，设置映射规则</span></span><br><span class="line">                <span class="attr">"test_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="attr">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"&amp; =&gt; and"</span>,</span><br><span class="line">                        <span class="string">"| =&gt; or"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;         <span class="comment">//过滤器，过滤指定字符</span></span><br><span class="line">                <span class="attr">"test_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="attr">"stopwords"</span>: [<span class="string">"is"</span>,<span class="string">"in"</span>,<span class="string">"at"</span>,<span class="string">"the"</span>,<span class="string">"a"</span>,<span class="string">"for"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tokenizer"</span>: &#123;     <span class="comment">//正则分析器</span></span><br><span class="line">                <span class="attr">"punctuation"</span>: &#123; </span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"pattern"</span>,</span><br><span class="line">                    <span class="attr">"pattern"</span>: <span class="string">"[ .,!?]"</span>  <span class="comment">//以正则匹配到的字符做分词</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;      <span class="comment">//自定义分词器</span></span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"custom"</span>,    <span class="comment">//告诉ES这是一个自定义分词器</span></span><br><span class="line">                    <span class="attr">"char_filter"</span>: [     <span class="comment">//设置两个字符过滤器</span></span><br><span class="line">                        <span class="string">"html_strip"</span>,</span><br><span class="line">                        <span class="string">"test_char_filter"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,  <span class="comment">//设置内置分词器</span></span><br><span class="line">                    <span class="attr">"filter"</span>: [<span class="string">"lowercase"</span>,<span class="string">"test_stopwords"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /test_analysis/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Teacher ma &amp; zhang also thinks [mother's friends] is good | nice!!!"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分词结果：</span><br><span class="line">teacher、ma、and、zhang、also、thinks、mother's、friends、good、or、nice</span><br></pre></td></tr></table></figure>

<h4 id="IK中文分词器"><a href="#IK中文分词器" class="headerlink" title="IK中文分词器"></a>IK中文分词器</h4><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">IK分词器下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IK分词器安装步骤：</span><br><span class="line">1.上Github下载IK分词器</span><br><span class="line">2.解压分词器，使用maven进行package打包</span><br><span class="line">3.从releases中获取打好的zip包，放到es安装目录&#x2F;plugins&#x2F;ik&#x2F; 目录下解压</span><br><span class="line">4.重启ES</span><br></pre></td></tr></table></figure>

<p>如果ES版本比IK分词器版本高，启动ES时可能会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin [analysis-ik] was built for Elasticsearch version 7.4.0 but version 7.10.1 is running</span><br></pre></td></tr></table></figure>

<p>需要修改IK分词器的配置文件<code>plugin-descriptor.properties</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改成自己使用的ES版本号</span></span><br><span class="line"><span class="meta">elasticsearch.version</span>=<span class="string">7.10.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IK分词器提供两种analyzer</span><br><span class="line">  ik_max_word：细粒度</span><br><span class="line">  ik_smart：粗粒度</span><br><span class="line"></span><br><span class="line">2.IK文件描述</span><br><span class="line">  IKAnalyzer.cfg.xml：IK分词配置文件</span><br><span class="line">  主词库：main.dic</span><br><span class="line">  英文停用词：stopword.dic，不会建立在倒排索引中</span><br><span class="line">  特殊词库：</span><br><span class="line">    quantifier.dic：特殊词库：计量单位等</span><br><span class="line">    suffix.dic：特殊词库：后缀名</span><br><span class="line">    surname.dic：特殊词库：百家姓</span><br><span class="line">    preposition：特殊词库：语气词</span><br><span class="line">  </span><br><span class="line">  自定义词库：比如当下流行词：857、emmm...、996</span><br><span class="line">  热更新：</span><br><span class="line">    修改ik分词器源码</span><br><span class="line">    基于ik分词器原生支持的热更新方案，部署web服务器，提供http接口，通过modified和tag两个http响应头，来提供词语的热更新</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"你的衣服真好看"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">你、的、衣服、真好、好看</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"你的衣服真好看"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_smart"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">你、的、衣服、真、好看</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(六)-前缀、通配符、正则、模糊查询</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="prefix-前缀"><a href="#prefix-前缀" class="headerlink" title="prefix-前缀"></a>prefix-前缀</h2><p>前缀查询：以xx开头的搜索，不计算相关度评分，和filter比，没有bitcache。前缀搜索，尽量把前缀长度设置的更长，<strong>性能差，因为它会扫描倒排索引整张表，匹配每个term是否包含xx。</strong></p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">index_prefixes: 默认   "min_chars" : 2,   "max_chars" : 5</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于SQL的左Like查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"myword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>index_prefixes</code>映射，ES会额外建立一个长度在2和5之间索引，在进行前缀匹配的时候效率会有很大的提高</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置默认的 启动索引 加快前缀搜索速度</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index_prefixes"</span>: &#123;</span><br><span class="line">                    <span class="attr">"min_chars"</span>:<span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"max_chars"</span>:<span class="number">4</span></span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wildcard-通配符"><a href="#wildcard-通配符" class="headerlink" title="wildcard-通配符"></a>wildcard-通配符</h2><p>通配符：通配符运算符是匹配一个或多个字符的占位符。例如，*通配符运算符匹配零个或多个字符。可以将通配符运算符与其他字符结合使用以创建通配符模式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  "name" : "xiaomi nfc phone"</span></span><br><span class="line"><span class="comment">//通配符匹配</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;     <span class="comment">//匹配倒排索引表中的term词项</span></span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xia?mi"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">能查出  "name" : "xiaomi nfc phone" 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="attr">"name.keyword"</span>: &#123;     <span class="comment">//全量匹配内容</span></span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xia?mi"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">不能查出数据</span><br></pre></td></tr></table></figure>

<h2 id="regexp-正则"><a href="#regexp-正则" class="headerlink" title="regexp-正则"></a>regexp-正则</h2><p>正则：regexp查询的性能可以根据提供的正则表达式而有所不同。为了提高性能，应避免使用通配符模式，如.<em>或 .</em>?+未经前缀或后缀</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"name" : "xiaomi nfc phone"  正则匹配</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"[\\s\\S]*nfc[\\s\\S]*"</span>,  <span class="comment">//  \\s\\S表示任意字符</span></span><br><span class="line">                <span class="attr">"flags"</span>: <span class="string">"ALL"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"desc" : "xiaomi nfc 2020-05-20 phone"</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">".*2020-05-20.*"</span>,</span><br><span class="line">                <span class="attr">"flags"</span>: <span class="string">"ALL"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 无法匹配到上文中的注释数据，原因在于默认使用了<code>standard</code>，会将日期拆成【2020】、【05】、【20】三个词汇，如果想要匹配，需要使用<code>desc.keyword</code>进行全文匹配，但是这样性能十分低下。</p>
<p>而IK分词器很好的对日期进行了分词词项【2020-05-20】，对该索引指定IK分词器（需重建索引），即可查询到结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,   <span class="comment">//倒排索引分词</span></span><br><span class="line">                <span class="attr">"search_analyzer"</span>: <span class="string">"ik_max_word"</span>  <span class="comment">//搜索分词</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzzy-混淆模糊查询"><a href="#fuzzy-混淆模糊查询" class="headerlink" title="fuzzy-混淆模糊查询"></a>fuzzy-混淆模糊查询</h2><p>混淆字符 (<strong>b</strong>ox → <strong>f</strong>ox)                缺少字符 (<strong>b</strong>lack → lack)</p>
<p>多出字符 (sic → sic<strong>k</strong>)                颠倒次序 (<strong>ac</strong>t → <strong>ca</strong>t)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">value：（必需，字符串）</span><br><span class="line">fuzziness：（可选，字符串）最大误差(距离)  并非越大越好, 召回率高 但是结果不准确</span><br></pre></td></tr></table></figure>

<p>距离：两段文本之间的Damerau-Levenshtein距离是指一个字符串需要经过多少次操作之后才能变成另一个字符串。</p>
<p>距离公式：Levenshtein是lucene的，es改进版：Damerau-Levenshtein，<code>axe=&gt;aex  Levenshtein=2</code> ，而<code>Damerau-Levenshtein=1</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 使用fuzzy</span></span><br><span class="line">GET /product/_search </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xioami"</span>,  <span class="comment">//匹配 xiaomi</span></span><br><span class="line">                <span class="attr">"fuzziness"</span>: <span class="number">5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 使用match</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"quangengneng nfc"</span>,</span><br><span class="line">                <span class="attr">"fuzziness"</span>: <span class="string">"AUTO"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="match-phrase-prefix-短语前缀"><a href="#match-phrase-prefix-短语前缀" class="headerlink" title="match_phrase_prefix-短语前缀"></a>match_phrase_prefix-短语前缀</h2><p>match_phrase_prefix与match_phrase相同,但是它多了一个特性,就是它允许在文本的最后一个词项(term)上的前缀匹配。</p>
<p>如果 是一个单词,比如a,它会匹配文档字段所有以a开头的文档,如果是一个短语,比如 “this is ma” ,<strong>他会先在倒排索引中做以ma做前缀搜索,然后在匹配到的doc中做match_phrase查询</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET /index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"fieldName"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">analyzer 指定何种分析器来对该短语进行分词处理</span><br><span class="line">max_expansions 限制匹配到的最大词项，每个分片中匹配的结果达到max_expansions值后停止遍历倒排索引表</span><br><span class="line">boost 用于设置该查询的权重</span><br><span class="line">slop：允许短语间的词项(term)间隔，指为了让查询和文档匹配需要移动term多少(slop)次</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例  匹配 "desc" : "zhichi nfc"   注意！无法匹配 "zhichi aaa nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"zhichi nf"</span>,  <span class="comment">//先进行nf 前缀匹配，再进行match_phrase(zhichi)词项匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 可以匹配到："zhichi aaa nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"zhichi nf"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"whitespace"</span>,</span><br><span class="line">                <span class="attr">"max_expansions"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"slop"</span>: <span class="number">1</span>,   <span class="comment">//配置slop，允许移动一次term匹配结果</span></span><br><span class="line">                <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N-gram：token-filter"><a href="#N-gram：token-filter" class="headerlink" title="N-gram：token filter"></a>N-gram：token filter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edge_ngram：是从第一个字符开始,按照步长,进行分词,适合前缀匹配场景,比如:订单号,手机号,邮政编码的检索</span><br><span class="line">ngram：是从每一个字符开始,按照步长,进行分词,适合前缀中缀检索</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">min_gram &#x3D;1 最小步长 默认值 1</span><br><span class="line">max_gram &#x3D;1 最大步长 默认值 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【edge_ngram】 拆词： &quot;reba always loves me&quot;</span><br><span class="line">min_gram &#x3D;1   max_gram &#x3D;1</span><br><span class="line">#r a l m</span><br><span class="line"></span><br><span class="line">min_gram &#x3D;1   max_gram &#x3D;2</span><br><span class="line">#r a l m</span><br><span class="line">#re al lo me</span><br><span class="line"></span><br><span class="line">min_gram &#x3D;2   max_gram &#x3D;3</span><br><span class="line">#re al lo me</span><br><span class="line">#reb alw lov me</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引，设置分词器和token filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"2_3_edge_ngram"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"edge_ngram"</span>,</span><br><span class="line">                    <span class="attr">"min_gram"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"max_gram"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_edge_ngram"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>: [ <span class="string">"2_3_edge_ngram"</span> ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>:<span class="string">"my_edge_ngram"</span>,</span><br><span class="line">                <span class="attr">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"my_edge_ngram"</span></span><br><span class="line">  , <span class="attr">"text"</span>: [<span class="string">"my english"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">my、en、eng</span><br><span class="line"></span><br><span class="line">如果分词器把edge_ngram换成ngram，则输出结果如下：</span><br><span class="line">my、en、ng、gl、li、is、sh、eng、ngl、gli、lis、ish</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配 "text": "my english is good"</span></span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"my eng is goo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(八)-集群</title>
    <url>/2021/05/26/elasticsearch%EF%BC%88%E5%85%AB%EF%BC%89%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener">下载</a></h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxf  elasticsearch-7.12.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><a id="more"></a>

<h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p>​    ES为了安全，不允许直接使用root用户启动，需要创建普通用户来运行程序：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">############# 方式一 ###############</span></span><br><span class="line"><span class="comment">#创建用户：elasticsearch</span></span><br><span class="line">adduser elasticsearch</span><br><span class="line"><span class="comment">#创建用户密码，需要输入两次</span></span><br><span class="line">passwd elasticsearch</span><br><span class="line"><span class="comment">#切换到es文件夹上，将对应的文件夹权限赋给该用户</span></span><br><span class="line">chown -R elasticsearch elasticsearch-7.10.1</span><br><span class="line"><span class="comment">############# 方式二 ###############</span></span><br><span class="line"><span class="comment">#创建用户组   </span></span><br><span class="line">groupadd esgroup</span><br><span class="line"><span class="comment">#创建用户     </span></span><br><span class="line">useradd -g esgroup elasticsearch</span><br><span class="line"><span class="comment">#设置权限     </span></span><br><span class="line">chown -R elasticsearch:esgroup elasticsearch-7.10.1</span><br><span class="line"><span class="comment">#设置密码     </span></span><br><span class="line">passwd elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换至elasticsearch用户</span></span><br><span class="line">su elasticsearch</span><br></pre></td></tr></table></figure>

<h3 id="创建data和logs目录"><a href="#创建data和logs目录" class="headerlink" title="创建data和logs目录"></a>创建data和logs目录</h3><p>​    为了以后elasticsearch更新升级不影响到数据和日志，需要创建独立存放数据和日志的文件目录，并为用户授权</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/elasticsearch/data</span><br><span class="line">mkdir -p /var/elasticsearch/logs</span><br><span class="line"></span><br><span class="line">chown -R elasticsearch /var/elasticsearch/data</span><br><span class="line">chown -R elasticsearch /var/elasticsearch/logs</span><br></pre></td></tr></table></figure>

<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><code>vim config/elasticsearch.yml</code></p>
<h4 id="node-1"><a href="#node-1" class="headerlink" title="node-1"></a>node-1</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.131</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="node-2"><a href="#node-2" class="headerlink" title="node-2"></a>node-2</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.132</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="node-3"><a href="#node-3" class="headerlink" title="node-3"></a>node-3</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.133</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改完配置后,切换回root会用户关闭防火墙;</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#或者开放9200、9300端口</span></span><br><span class="line">firewall-cmd --zone-public --add-port=9200/tcp --permanent</span><br><span class="line">firewall-cmd --zone-public --add-port=9300/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="修改linux内核参数"><a href="#修改linux内核参数" class="headerlink" title="修改linux内核参数"></a>修改linux内核参数</h3><p>我们需要修改Linux文件的最大打开数，否则会启动报错</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf </span><br><span class="line"></span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* soft nproc  4096</span><br><span class="line">* hard nproc  4096</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"vm.max_map_count=262144"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>



<h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入bin目录启动 -d:表示后台启动  启动如果报错请参见下文解决问题</span></span><br><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure>



<p>如果克隆了服务器或者拷贝了多份elasticsearch目录，需要去<code>path.data:</code>配置的路径下删除节点信息，<strong>否则会造成ID重复的冲突。</strong></p>
<h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;_cat&#x2F;allocation      	#查看单节点的shard分配整体情况</span><br><span class="line">&#x2F;_cat&#x2F;shards          #查看各shard的详细情况</span><br><span class="line">&#x2F;_cat&#x2F;shards&#x2F;&#123;index&#125;  	#查看指定分片的详细情况</span><br><span class="line">&#x2F;_cat&#x2F;master          #查看master节点信息</span><br><span class="line">&#x2F;_cat&#x2F;nodes           #查看所有节点信息</span><br><span class="line">&#x2F;_cat&#x2F;indices         #查看集群中所有index的详细信息</span><br><span class="line">&#x2F;_cat&#x2F;indices&#x2F;&#123;index&#125; 	#查看集群中指定index的详细信息</span><br><span class="line">&#x2F;_cat&#x2F;segments        #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘</span><br><span class="line">&#x2F;_cat&#x2F;segments&#x2F;&#123;index&#125;#查看指定index的segment详细信息</span><br><span class="line">&#x2F;_cat&#x2F;count           #查看当前集群的doc数量</span><br><span class="line">&#x2F;_cat&#x2F;count&#x2F;&#123;index&#125;   #查看指定索引的doc数量</span><br><span class="line">&#x2F;_cat&#x2F;recovery        #查看集群内每个shard的recovery过程.调整replica。</span><br><span class="line">&#x2F;_cat&#x2F;recovery&#x2F;&#123;index&#125;#查看指定索引shard的recovery过程</span><br><span class="line">&#x2F;_cat&#x2F;health          #查看集群当前状态：红、黄、绿</span><br><span class="line">&#x2F;_cat&#x2F;pending_tasks   #查看当前集群的pending task</span><br><span class="line">&#x2F;_cat&#x2F;aliases         #查看集群中所有alias信息,路由配置等</span><br><span class="line">&#x2F;_cat&#x2F;aliases&#x2F;&#123;alias&#125; #查看指定索引的alias信息</span><br><span class="line">&#x2F;_cat&#x2F;thread_pool     #查看集群各节点内部不同类型的threadpool的统计信息,</span><br><span class="line">&#x2F;_cat&#x2F;plugins         #查看集群各个节点上的plugin信息</span><br><span class="line">&#x2F;_cat&#x2F;fielddata       #查看当前集群各个节点的fielddata内存使用情况</span><br><span class="line">&#x2F;_cat&#x2F;fielddata&#x2F;&#123;fields&#125;     #查看指定field的内存使用情况,里面传field属性对应的值</span><br><span class="line">&#x2F;_cat&#x2F;nodeattrs              #查看单节点的自定义属性</span><br><span class="line">&#x2F;_cat&#x2F;repositories           #输出集群中注册快照存储库</span><br><span class="line">&#x2F;_cat&#x2F;templates              #输出当前正在存在的模板信息</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于Docker"><a href="#基于Docker" class="headerlink" title="基于Docker"></a>基于Docker</h2><blockquote>
<p>不建议使用ES启动docker，因为很麻烦！！！</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># docker pull docker.elastic.co/elasticsearch/elasticsearch:7.10.1</span></span><br><span class="line">[root@localhost /]<span class="comment"># docker run -d -p 9200:9200 -p 9300:9300 --name es elasticsearch:7.10.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动命令参考</span></span><br><span class="line">[root@localhost /]<span class="comment"># docker run -d -p 9200:9200 -p 9300:9300 -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" -e discovery.type=single-node --name es elasticsearch:7.10.1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">问题1：error=<span class="string">'Cannot allocate memory'</span> </span><br><span class="line">原因：ES 5.x+堆内存大小默认配置为2G 		ES 7.x+默认4G </span><br><span class="line">解决：</span><br><span class="line">vi config/jvm.options</span><br><span class="line">-Xms4g  →  -Xms512m</span><br><span class="line">-Xmx4g  →  -Xmx512m</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题2：WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br><span class="line">解决：	vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.ip_forward&#x3D;1</span><br><span class="line">restart network &amp;&amp; systemctl restart docker</span><br><span class="line">sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题3: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span><br><span class="line">解释：	5.0以后,ES使用mmapfs作为默认的文件系统存储类型。可以通过配置index.store.type来设置ES默认的文件系统存储类型。</span><br><span class="line">Niofs(非阻塞文件系统)	mmapfs(内存映射文件系统)</span><br><span class="line">配置:index.store.type: niofs</span><br><span class="line">解决：sysctl -w vm.max_map_count&#x3D;262144</span><br><span class="line">查看是否生效：</span><br><span class="line">	或：vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">vm.max_map_count&#x3D;262144</span><br><span class="line">grep vm.max_map_count &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题4：max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</span><br><span class="line">解决：vi &#x2F;etc&#x2F;security&#x2F;limits.conf，最后添加以下内容。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题5：max number of threads [1024] for user [elasticsearch] is too low, increase to at least [2048]</span><br><span class="line">解决：</span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;90-nproc.conf </span><br><span class="line">修改如下内容（注意星号）：</span><br><span class="line">* soft nproc 1024  &#x3D;&gt;  * soft nproc 4096</span><br><span class="line"></span><br><span class="line">当引导检查报未开启内存锁时，需要修改一下配置：</span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf，最后添加以下内容。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 4096</span><br><span class="line">* hard nproc 4096</span><br><span class="line">* hard memlock unlimited</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">vi &#x2F;etc&#x2F;systemd&#x2F;system.conf ，分别修改以下内容。</span><br><span class="line">vi &#x2F;etc&#x2F;systemd&#x2F;system.conf </span><br><span class="line">注意 修改操作系统配置需要重启系统才能生效，如果宿主机内存过小，可能导致容器无法启动。开发模式内存建议4G以上，生产建议32G以上.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题6：docker中的es无法加入集群</span><br><span class="line">elasticsearch.yml配置中增加 network.publish_host:192.168.1.129</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他问题：如路径的权限问题、多网卡问题、引导检查问题</span><br></pre></td></tr></table></figure>



<h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">IK分词器</a></h2><p>下载编译后的安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建插件文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch/plugins/ &amp;&amp; mkdir ik</span><br><span class="line"><span class="comment"># 将编译后的zip上传进ik文件夹中解压</span></span><br><span class="line">unzip elasticsearch-analysis-ik-7.12.1.zip </span><br><span class="line"><span class="comment">#授权</span></span><br><span class="line">chown -R elasticsearch ik</span><br><span class="line"><span class="comment">#重启启动切换其账户启动es</span></span><br></pre></td></tr></table></figure>

<p>两种分词器analyzer</p>
<ul>
<li>ik_max_word：细粒度</li>
<li>ik_smart：粗粒度</li>
</ul>
<p>配置文件说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) IKAnalyzer.cfg.xml：IK分词配置文件</span><br><span class="line">2) 主词库：main.dic</span><br><span class="line">3) 英文停用词：stopword.dic，不会建立在倒排索引中</span><br><span class="line">4) 特殊词库：</span><br><span class="line">    a. quantifier.dic：特殊词库：计量单位等</span><br><span class="line">    b. suffix.dic：特殊词库：后缀名</span><br><span class="line">    c. surname.dic：特殊词库：百家姓</span><br><span class="line">    d. preposition：特殊词库：语气词</span><br><span class="line">5) 自定义词库：比如当下流行词：857、emmm...、渣女、舔屏、996</span><br><span class="line">6) 热更新：</span><br><span class="line">	a. 修改ik分词器源码</span><br><span class="line">	b. 基于ik分词器原生支持的热更新方案，部署一个web服务器，提供一个http接口，通过modified和tag两个http响应头，来提供词语的热更新</span><br></pre></td></tr></table></figure>

<h2 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h2><p>在<code>config/elasticsearch.yml</code>中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.license.self_generated.type:</span> <span class="string">basic</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>进入bin目录下执行<code>./elasticsearch-setup-passwords interactive</code>(此初始化密码命令只能执行一次，之后如果想要执行该命令，需要在es中删除.security索引才能再次使用)，为保留用户elastic、apm_system、kibana、kibana_system、logstash_system、beats_system、remote_monitoring_user初始化设置密码。</p>
<ul>
<li>elastic：es内置超级用户</li>
<li>apm_system：apm服务器在es中存储监视信息时使用的账户</li>
<li>kibana（新版本推荐使用kabana_system）：kibana连接es的账户</li>
<li>logstash_system：logstash将采集的日志输出到es时使用的账户</li>
<li>beats_system：beats在存储数据输出到es时使用的账户</li>
<li>remote_monitoring_user：metribeat用户在es中收集和存储监视信息时使用</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">esuser@host:/usr/<span class="built_in">local</span>/elk/elasticsearch/bin$ ./elasticsearch-setup-passwords interactive</span><br><span class="line">future versions of Elasticsearch will require Java 11; your Java version from [/usr/jdk1.8.0_241/jre] does not meet this requirement</span><br><span class="line"></span><br><span class="line">Your cluster health is currently RED.</span><br><span class="line">This means that some cluster data is unavailable and your cluster is not fully functional.</span><br><span class="line"></span><br><span class="line">It is recommended that you resolve the issues with your cluster before running elasticsearch-setup-passwords.</span><br><span class="line">It is very likely that the password changes will fail when run against an unhealthy cluster.</span><br><span class="line"></span><br><span class="line">Do you want to <span class="built_in">continue</span> with the password setup process [y/N]y</span><br><span class="line"></span><br><span class="line">Initiating the setup of passwords <span class="keyword">for</span> reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to <span class="built_in">continue</span> [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Passwords <span class="keyword">do</span> not match.</span><br><span class="line">Try again.</span><br><span class="line">Enter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Passwords <span class="keyword">do</span> not match.</span><br><span class="line">Try again.</span><br><span class="line">Enter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [elastic]: </span><br><span class="line">Enter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Passwords <span class="keyword">do</span> not match.</span><br><span class="line">Try again.</span><br><span class="line">Enter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [apm_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [kibana_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [kibana_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [logstash_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [logstash_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [beats_system]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [beats_system]: </span><br><span class="line">Enter password <span class="keyword">for</span> [remote_monitoring_user]: </span><br><span class="line">Reenter password <span class="keyword">for</span> [remote_monitoring_user]: </span><br><span class="line">Changed password <span class="keyword">for</span> user [apm_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [kibana_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [kibana]</span><br><span class="line">Changed password <span class="keyword">for</span> user [logstash_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [beats_system]</span><br><span class="line">Changed password <span class="keyword">for</span> user [remote_monitoring_user]</span><br><span class="line">Changed password <span class="keyword">for</span> user [elastic]</span><br></pre></td></tr></table></figure>

<p>修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改密码api</span><br><span class="line">curl -H &quot;Content-Type:application&#x2F;json&quot; -XPOST -u elastic &#39;http:&#x2F;&#x2F;127.0.0.1:9200&#x2F;_xpack&#x2F;security&#x2F;user&#x2F;elastic&#x2F;_password&#39; -d &#39;&#123; &quot;password&quot; : &quot;123456&quot; &#125;&#39;</span><br></pre></td></tr></table></figure>

<h2 id="节点通讯安全性"><a href="#节点通讯安全性" class="headerlink" title="节点通讯安全性"></a>节点通讯安全性</h2><p>未启用加密的集群将以纯文本格式（包括密码）发送所有数据。如果启用了es安全功能，除非具有使用许可证，否则需配置SSL/TLS进行节点通信。</p>
<p>1、确认xpack.security.enabled设置为true</p>
<p>2、生成节点证书：TLS需要X.509证书才能对与之通信的应用程序执行加密和身份验证。为了使节点之间的通信真正安全，必须对证书进行验证。在es集群中验证证书真实性的推荐方法是信任签署证书的证书颁发机构（CA）。这样，将节点添加到集群时，它们只需要使用由同一CA签名的证书，即可自动允许该节点加入集群。此外，建议证书包含与节点IP地址和DNS名称相对应的主题备用名称（SAN），以便可以执行主机名验证。</p>
<ul>
<li><p>为es集群创建证书颁发机构</p>
<p>可以配置集群来信任所有拥有这个CA签署证书的节点。<code>elastic-stack-ca.p12</code>文件是PKCS#12秘钥存储库，其中包含CA的公共证书和用于为每个节点签署证书的秘钥。elasticsearch-certutil命令将提示输入密码以保护文件和秘钥。如果将来计划在集群中添加更多节点，请保留该文件的副本并记住其密码。</p>
<p><code>./bin/elasticsearch-certutil ca</code></p>
<p>生成的<code>elastic-stack-ca.p12</code>文件包含CA的公共证书和用于每个节点的证书签名的私钥。生成过程中设置的密码在日后集群的横向扩容中需要用到，因此牢记</p>
</li>
<li><p>为集群中每个节点生成私钥及证书</p>
<p><code>./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12</code></p>
<p>生成的<code>elastic-cerificates.p12</code>文件包含节点证书、节点秘钥和CA证书。生成时的密码可以直接enter设置为空。节点证书默认不包含主机信息，所以每个节点都可以使用此证书，但是节点必须闭关主机认证。</p>
</li>
<li><p>把节点证书复制到各节点的config目录下</p>
</li>
</ul>
<p>3、每个节点配置文件加上以下配置，启动TLS，transport层必须配置，http层非必须，但是建议配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.security.authc.accept_default_password:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#证书配置</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.verification_mode:</span> <span class="string">certificate</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.keystore.path:</span> <span class="string">elastic-cerificates.p12</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.trustore.path:</span> <span class="string">elastic-cerificates.p12</span></span><br></pre></td></tr></table></figure>

<p>4、重启集群</p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch（十二）geo</title>
    <url>/2021/06/12/elasticsearch%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89geo/</url>
    <content><![CDATA[<h2 id="地理位置搜索"><a href="#地理位置搜索" class="headerlink" title="地理位置搜索"></a>地理位置搜索</h2><ul>
<li>latitude：维度  缩写：lat</li>
<li>longitude：经度  缩写：lon</li>
</ul>
<p>经纬度坐标，只支持WGS84坐标系，坐标范围Lat值为[-90,90]，Lon为[-180,180]，超出这个访问的点在创建时会报错，通过创建mapping时指定ignore_malformed来忽略格式错误的地理位置</p>
<a id="more"></a>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建geo_point类型字段</span><br><span class="line">PUT /geo_point</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"geo_point"</span>,</span><br><span class="line">        <span class="attr">"ignore_malformed"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#创建geo_shape mapping</span><br><span class="line">PUT /geo_shape</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"geo_shape"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="存储数据类型"><a href="#存储数据类型" class="headerlink" title="存储数据类型"></a>存储数据类型</h2><h3 id="geo-point-存储坐标点"><a href="#geo-point-存储坐标点" class="headerlink" title="geo point-存储坐标点"></a>geo point-存储坐标点</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /geo_point/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"地点1"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">"lon"</span>:<span class="number">1.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#lat，lot</span><br><span class="line">PUT /geo_point/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"地点2"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:<span class="string">"1.0,3.00"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#[lot,lat]</span><br><span class="line">PUT /geo_point/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"地点3"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:[<span class="number">3.0</span>,<span class="number">3.0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#WKT  (lot lat)</span><br><span class="line">PUT /geo_point/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"地点4"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:<span class="string">"POINT(1.0 3.0)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式五"><a href="#方式五" class="headerlink" title="方式五"></a>方式五</h4><p>Geo哈希 <a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">点击跳转查看外链介绍</a></p>
<h3 id="geo-shape-存储几何图形"><a href="#geo-shape-存储几何图形" class="headerlink" title="geo shape-存储几何图形"></a>geo shape-存储几何图形</h3><h4 id="点（point）"><a href="#点（point）" class="headerlink" title="点（point）"></a>点（point）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建一个点 [lot,lat]</span><br><span class="line">POST /geo_shape/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"point-地点s1"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">1.0</span>,<span class="number">1.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#WKT创建 (lot lat)</span><br><span class="line">POST /geo_shape/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"point-WKT-地点s1"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:<span class="string">"POINT (1.0 1.0)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线段-linestring"><a href="#线段-linestring" class="headerlink" title="线段(linestring)"></a>线段(linestring)</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建线段</span><br><span class="line">POST /geo_shape/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"linestring-线段"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"linestring"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[[<span class="number">0.0</span>,<span class="number">0.0</span>],[<span class="number">0.0</span>,<span class="number">1.0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#WKT方式创建线程，经度纬度之间需要空格，两个点之间英文逗号分割</span><br><span class="line">POST /geo_shape/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"linestring-WKT-线段"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:<span class="string">"LINESTRING(0.0 0.0,0.0 1.0)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩形（envelope）"><a href="#矩形（envelope）" class="headerlink" title="矩形（envelope）"></a>矩形（envelope）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#矩形</span><br><span class="line">POST /geo_shape/_doc/8</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"矩形"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"envelope"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[[<span class="number">0.0</span>,<span class="number">1.0</span>],[<span class="number">3.0</span>,<span class="number">0.0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多边形（polygon）"><a href="#多边形（polygon）" class="headerlink" title="多边形（polygon）"></a>多边形（polygon）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#多边形 最后一个点需要与第一个点重叠形成闭环,外层有两层[]，表示可以存储多个多表型</span><br><span class="line">POST /geo_shape/_doc/5</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"polygon-多边形"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"polygon"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[</span><br><span class="line">      [</span><br><span class="line">        [<span class="number">0.0</span>,<span class="number">0.0</span>],[<span class="number">1.0</span>,<span class="number">0.0</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0.0</span>,<span class="number">1.0</span>],[<span class="number">0.0</span>,<span class="number">0.0</span>]</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#多线性-WKT 存在多个多边形所以需要两层括号</span><br><span class="line">POST /geo_shape/_doc/6</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"polygon-WKT-多边形"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:<span class="string">"POLYGON ((0.0 0.0,1.0 0.0,1.0 1.0,0.0 1.0,0.0 0.0))"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="圆形（circle）"><a href="#圆形（circle）" class="headerlink" title="圆形（circle）"></a>圆形（circle）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#圆形 7+不支持画圆，需要预先创建画圆的管道（整个es集群全局存在），将圆形转换成多边形，只要点足够多，圆形就足够圆</span><br><span class="line">#管道</span><br><span class="line">PUT /_ingest/pipeline/my_circles</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"圆形转换多边形"</span>,</span><br><span class="line">  <span class="attr">"processors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"circle"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"location"</span>,</span><br><span class="line">        <span class="attr">"error_distance"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"shape_type"</span>: <span class="string">"geo_shape"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">POST /geo_shape/_doc/7?pipeline=my_circles</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"圆形"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"circle"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">0.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    <span class="attr">"radius"</span>:<span class="string">"1m"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>圆形处理精度解释：</p>
<p>表示圆的多边形的精度定义为error_distance。这种差异越小，多边形越接近理想圆。下表是旨在帮助捕获在给定不同输入的情况下圆的半径如何影响多边形的边数的表格。最小边数为4，最大为1000。</p>
<p>error_distance越小，生成的点越多，越趋近于圆，但复杂度增加</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong><em>error_distance</em></strong></th>
<th><strong><em>半径（米）</em></strong></th>
<th><strong><em>多边形的边数</em></strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>45</td>
</tr>
<tr>
<td>1</td>
<td>1,000</td>
<td>141</td>
</tr>
<tr>
<td>1</td>
<td>10,000</td>
<td>445</td>
</tr>
<tr>
<td>1</td>
<td>100,000</td>
<td>1000</td>
</tr>
</tbody></table>
<hr>
<h2 id="查询类型"><a href="#查询类型" class="headerlink" title="查询类型"></a>查询类型</h2><h3 id="geo-bounding-box-（矩形查询）"><a href="#geo-bounding-box-（矩形查询）" class="headerlink" title="geo bounding box （矩形查询）"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl-geo-bounding-box-query.html" target="_blank" rel="noopener">geo bounding box （矩形查询）</a></h3><p>​        在同一个平面内，两个点确定一个矩形，搜索矩形内的坐标。</p>
<ul>
<li>top_left：矩形左上点坐标</li>
<li>bottom_right：矩形右上角表</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#矩形查询，两点确定一个矩形，返回矩形内的点</span><br><span class="line">GET /geo_point/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">          <span class="attr">"lat"</span>: <span class="number">4.0</span>,</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">0.0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">          <span class="attr">"lat"</span>: <span class="number">0.0</span>,</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">4.0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/elasticsearch%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89geo/geo_bounding_box.jpg" alt=""></p>
<h3 id="geo-distance（半径查询）"><a href="#geo-distance（半径查询）" class="headerlink" title="geo distance（半径查询）"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl-geo-distance-query.html" target="_blank" rel="noopener">geo distance（半径查询）</a></h3><p>以某个点为圆心查找指定半径的圆内的坐标。</p>
<p>distance：距离单位，默认是米，支持以下选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mile（英里）：mi 或者 miles</span><br><span class="line">Yard（码）：yd 或者yards</span><br><span class="line">Feet（英尺）：ft 或者feet</span><br><span class="line">Inch（英寸）：in 或者inch</span><br><span class="line">Kilometer（公里）：km 或者kilometers</span><br><span class="line">Meter（米）：m后者meters</span><br><span class="line">Centimeter（厘米）：cm 或者centimeters</span><br><span class="line">Millimeter（毫米）：mm 或者millimeters</span><br><span class="line">Nautical mile（海里）：NM, nmi, 或者nauticalmiles</span><br></pre></td></tr></table></figure>

<p>distance_type：计算距离的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arc（默认值）：更准确，但是速度慢</span><br><span class="line">plane：（更快，但在长距离和极点附近不准确）</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#半径查询，基于点指定半径进行搜索</span><br><span class="line">GET /geo_point/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">            <span class="attr">"distance"</span>: <span class="string">"200km"</span>,</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>: <span class="number">1.1</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">1.1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#半径查询，基于点指定半径进行搜索,距离排序</span><br><span class="line">GET /geo_point/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">            <span class="attr">"distance"</span>: <span class="string">"200km"</span>,</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>: <span class="number">1.1</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">1.1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_geo_distance"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"asc"</span>,</span><br><span class="line">        <span class="attr">"location"</span>: &#123;</span><br><span class="line">          <span class="attr">"lat"</span>: <span class="number">1.1</span>,</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">1.1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geo-polygon（多边形）"><a href="#geo-polygon（多边形）" class="headerlink" title="geo_polygon（多边形）"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl-geo-polygon-query.html" target="_blank" rel="noopener">geo_polygon（多边形）</a></h3><p>查找给定多个点连成的多边形内的坐标。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#多边形查询 不需要收尾封闭</span><br><span class="line">GET /geo_point/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"geo_polygon"</span>: &#123;</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"points"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"lat"</span>: <span class="number">0.0</span>,</span><br><span class="line">                  <span class="attr">"lon"</span>: <span class="number">2.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"lat"</span>: <span class="number">0.0</span>,</span><br><span class="line">                  <span class="attr">"lon"</span>: <span class="number">5.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"lat"</span>: <span class="number">4.0</span>,</span><br><span class="line">                  <span class="attr">"lon"</span>: <span class="number">3.0</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/elasticsearch%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89geo/geo_polygon.jpg" alt=""></p>
<h3 id="geo-shape（特殊几何形状）"><a href="#geo-shape（特殊几何形状）" class="headerlink" title="geo_shape（特殊几何形状）"></a>geo_shape（特殊几何形状）</h3><p>支持指定几何图形相交、包含或是不相交等图形检索</p>
<p>创建数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建mapping</span><br><span class="line">PUT /geo_shape_test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"geo_shape"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#A</span><br><span class="line">POST /geo_shape_test/_doc/A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"红框-A"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"envelope"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[[<span class="number">1.0</span>,<span class="number">7.0</span>],[<span class="number">6.0</span>,<span class="number">1.0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#B</span><br><span class="line">POST /geo_shape_test/_doc/B</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"绿框-B"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"envelope"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[[<span class="number">4.0</span>,<span class="number">8.0</span>],[<span class="number">8.0</span>,<span class="number">5.0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#C</span><br><span class="line">POST /geo_shape_test/_doc/C</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"蓝框-C"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"envelope"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[[<span class="number">2.0</span>,<span class="number">4.0</span>],[<span class="number">4.0</span>,<span class="number">2.0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#P1</span><br><span class="line">POST /geo_shape_test/_doc/P1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"P1"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">3.0</span>,<span class="number">3.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#P2</span><br><span class="line">POST /geo_shape_test/_doc/P2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"P2"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#P3</span><br><span class="line">POST /geo_shape_test/_doc/P3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"P3"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">7.0</span>,<span class="number">7.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#P4</span><br><span class="line">POST /geo_shape_test/_doc/P4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"P4"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">3.0</span>,<span class="number">5.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#P5</span><br><span class="line">POST /geo_shape_test/_doc/P5</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"P5"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"point"</span>,</span><br><span class="line">    <span class="attr">"coordinates"</span>:[<span class="number">7.0</span>,<span class="number">3.0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/elasticsearch（十二）geo/shape.jpg" style="zoom:80%;" />

<h4 id="Relations-空间关系"><a href="#Relations-空间关系" class="headerlink" title="Relations(空间关系)"></a>Relations(空间关系)</h4><ul>
<li>intersects- (默认，相交或包含其中的文档）<pre><code>Return all documents whose shape field intersects the query geometry。
返回形状字段与查询几何图形相交的所有文档</code></pre></li>
<li>disjoint（没有相交）<pre><code>Return all documents whose shape field has nothing in common with the query geometry 
返回形状字段与查询几何形状没有任何共同之处的所有文档</code></pre></li>
<li>within（被查询形状包含）<pre><code>Return all documents whose shape field is within the query geometry。    
返回形状字段位于查询几何形状内的所有文档</code></pre></li>
<li>contains（包含查询形状）<pre><code>Return all documents whose shape field contains the query geometry。
返回其形状字段包含查询几何图形的所有文档</code></pre></li>
</ul>
<h4 id="Inline-Shape-Definition：内联形状，指定形状查询"><a href="#Inline-Shape-Definition：内联形状，指定形状查询" class="headerlink" title="Inline Shape Definition：内联形状，指定形状查询"></a>Inline Shape Definition：内联形状，指定形状查询</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /geo_shape_test/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"shape"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"envelope"</span>,</span><br><span class="line">                <span class="attr">"coordinates"</span>: [</span><br><span class="line">                  [</span><br><span class="line">                    <span class="number">1.0</span>,</span><br><span class="line">                    <span class="number">7.0</span></span><br><span class="line">                  ],</span><br><span class="line">                  [</span><br><span class="line">                    <span class="number">6.0</span>,</span><br><span class="line">                    <span class="number">1.0</span></span><br><span class="line">                  ]</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"relation"</span>: <span class="string">"within"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Pre-Indexed-Shape：预定义形状，使用已创建形状查询"><a href="#Pre-Indexed-Shape：预定义形状，使用已创建形状查询" class="headerlink" title="Pre-Indexed Shape：预定义形状，使用已创建形状查询"></a>Pre-Indexed Shape：预定义形状，使用已创建形状查询</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /geo_shape_test/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"indexed_shape"</span>: &#123;</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"geo_shape_test"</span>,</span><br><span class="line">                <span class="attr">"id"</span>: <span class="string">"A"</span>,</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"location"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"relation"</span>: <span class="string">"within"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka原理解析</title>
    <url>/2020/12/26/eureka%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、Server启动原理"><a href="#一、Server启动原理" class="headerlink" title="一、Server启动原理"></a>一、Server启动原理</h2><ol>
<li>springboot会去加载META-INF下面的spring.factories自动装配<code>org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</code>这个类</li>
</ol>
<p><img src="/images/cloud/eureka/eureka%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.jpg" alt=""></p>
<a id="more"></a>

<p><img src="/images/cloud/eureka/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E7%B1%BB.jpg" alt=""></p>
<ol start="2">
<li><p>此类的判断条件注解标识需要有Mark这个类存在才会加载</p>
</li>
<li><p>而启动类加上<code>@EnableEurekaServer</code>时，会加载Mark类，从而使自动配置类生效，所以当我们需要使用eureka-server时，必须要在启动类加上此注解</p>
</li>
</ol>
<img src="/images/cloud/eureka/eurekaServer注解.jpg" style="zoom:100%;" />

<h2 id="二、Eureka-Sever缓存"><a href="#二、Eureka-Sever缓存" class="headerlink" title="二、Eureka Sever缓存"></a>二、Eureka Sever缓存</h2><h3 id="1-三级缓存"><a href="#1-三级缓存" class="headerlink" title="1.三级缓存"></a>1.三级缓存</h3><h4 id="1-1（ConcurrentHashMap）registry"><a href="#1-1（ConcurrentHashMap）registry" class="headerlink" title="1.1（ConcurrentHashMap）registry"></a>1.1（ConcurrentHashMap）registry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry= <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>​        第一层的 ConcurrentHashMap 的 <code>key=spring.application.name</code> 也就是客户端实例注册的应用名；value 为嵌套的 ConcurrentHashMap。</p>
<p>​        第二层嵌套的 ConcurrentHashMap 的 <code>key=instanceId</code> 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。</p>
<p><img src="/images/cloud/eureka/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="1-2-ReadOnlyMap（ConcurrentHashMap）"><a href="#1-2-ReadOnlyMap（ConcurrentHashMap）" class="headerlink" title="1.2  ReadOnlyMap（ConcurrentHashMap）"></a>1.2  ReadOnlyMap（ConcurrentHashMap）</h4><p>​        <strong>周期更新</strong>，类ResponseCacheImpl成员变量，默认每<strong>30s</strong>从readWriteCacheMap更新</p>
<p>​        ReadOnlyMap是一个只读缓存，供客户端获取注册信息时使用，默认情况下，定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。</p>
<h4 id="1-3-readWriteCacheMap（guava-LoadingCache）"><a href="#1-3-readWriteCacheMap（guava-LoadingCache）" class="headerlink" title="1.3  readWriteCacheMap（guava#LoadingCache）"></a>1.3  readWriteCacheMap（guava#LoadingCache）</h4><p>​        <strong>实时更新</strong>，类AbstractInstanceRegistry成员变量</p>
<p>​        readWriteCacheMap，本质上是 Guava 缓存，数据主要同步于registry。当获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。</p>
<p>​        定时器每60s清理超过90s未续约的节点。</p>
<p>​        缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。</p>
<h3 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h3><h4 id="2-1-注册一个服务实例"><a href="#2-1-注册一个服务实例" class="headerlink" title="2.1 注册一个服务实例"></a>2.1 注册一个服务实例</h4><p>​        向注册表中写入服务实例信息，并使得readWriteCacheMap缓存失效</p>
<h4 id="2-2-寻找一个服务"><a href="#2-2-寻找一个服务" class="headerlink" title="2.2 寻找一个服务"></a>2.2 寻找一个服务</h4><p>​        从ReadOnlyMap缓存中找，如果有则返回，如果没有则去ReadWriteMap缓存拿并更新，如果ReadWriteMap缓存已经失效，触发guava的回调函数从注册表中同步。</p>
<h4 id="2-3-数据同步定时器"><a href="#2-3-数据同步定时器" class="headerlink" title="2.3 数据同步定时器"></a>2.3 数据同步定时器</h4><p>​        默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而UI则从registry更新服务注册信息。</p>
<p><img src="/images/cloud/eureka/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.jpg" alt=""></p>
<h3 id="3-缓存相关配置"><a href="#3-缓存相关配置" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span> <span class="comment"># 续约到期时间，服务端收到最后一次心跳后等待的时间上限，默认90s，超时剔除服务</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#Client是否从readOnlyCacheMap更新数据，false则跳过readOnlyCacheMap直接从readWriteCacheMap更新，默认true</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>



<h3 id="4-多级缓存的优点"><a href="#4-多级缓存的优点" class="headerlink" title="4. 多级缓存的优点"></a>4. 多级缓存的优点</h3><p>​        尽可能保证了内存注册表中的数据不会出现频繁的读写冲突问题，进一步保证了对eurekaServer的大量请求，都是快速读取内存，提供性能</p>
<h3 id="5-优化eureka服务端"><a href="#5-优化eureka服务端" class="headerlink" title="5. 优化eureka服务端"></a>5. 优化eureka服务端</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false # 心跳保护机制，默认开启，自我保护机制，服务可用数量少于85%时默认开启自我保护机制，不会再剔除服务微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span><br><span class="line">    eviction-interval-timer-in-ms: 1000 # 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span><br><span class="line">    renewal-percent-threshold: 0.85 #自我保护机制触发的阈值，默认0.85</span><br><span class="line">    use-read-only-response-cache: false #是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span><br><span class="line">    response-cache-update-interval-ms: 1000 # readwrite 和readOnly 同步时间间隔，默认30 * 1000</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="三-、Eureka-Client缓存"><a href="#三-、Eureka-Client缓存" class="headerlink" title="三 、Eureka Client缓存"></a>三 、Eureka Client缓存</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h3><p>​        Eureka Client存在两种角色：<strong>服务提供者</strong>和<strong>服务消费者</strong>，作为服务消费者一般配合Ribbon（Feign内部使用Ribbon）使用。</p>
<p>​        Client启动后，作为服务提供者立即向Server注册，默认情况下每30s续约(renew)；作为服务消费者立即向Server全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon延时1s向Client获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。</p>
<h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h3><p>2.1 localRegionApps(Eureka Client缓存)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</span><br></pre></td></tr></table></figure>

<p>​        <strong>周期更新</strong>，类DiscoveryClient成员变量，Eureka Client保存服务注册信息，启动后立即向Server全量更新，默认每<strong>30s</strong>增量更新</p>
<p>2.2 upServerListZoneMap(ConcurrentHashMap,Ribbon缓存)</p>
<p>​        <strong>周期更新</strong>，类LoadBalancerStats成员变量，Ribbon保存使用且状态为<strong>UP</strong>的服务注册信息，启动后延时1s向Client更新，默认每<strong>30s</strong>更新</p>
<h3 id="3-缓存相关配置-1"><a href="#3-缓存相关配置-1" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch（十一）Highlight、Suggest</title>
    <url>/2021/06/12/elasticsearch%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Highlight%E3%80%81Suggest/</url>
    <content><![CDATA[<h2 id="一、-Highlight-高亮查询"><a href="#一、-Highlight-高亮查询" class="headerlink" title="一、 Highlight-高亮查询"></a>一、 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html" target="_blank" rel="noopener">Highlight-高亮查询</a></h2><h3 id="三种高亮方式"><a href="#三种高亮方式" class="headerlink" title="三种高亮方式"></a>三种高亮方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unified：默认的高亮方式，使用Lucene的实现方式</span><br><span class="line"></span><br><span class="line">plain：性能较高，消耗少量内存，性价比高</span><br><span class="line"></span><br><span class="line">fvh &#x3D;&gt; fast vactor highlighter 适合字段较大，较复杂的查询情况</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="指定高亮类型"><a href="#指定高亮类型" class="headerlink" title="指定高亮类型"></a>指定高亮类型</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># type =&gt; unified plain fvh(fvh需要在mapping中指定该字段的属性term_vector:with_positions_offsets)</span><br><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:<span class="string">"unified"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#创建mapping，指定term_vector开可以使用fast vactor highlighter方式</span><br><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>:&#123;</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"term_vector"</span>: <span class="string">"with_positions_offsets"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"age"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"des"</span>:&#123;</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单字段高亮"><a href="#单字段高亮" class="headerlink" title="单字段高亮"></a>单字段高亮</h3><p>​    默认的高亮标签为<code>&lt;em&gt;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">   <span class="attr">"bool"</span>: &#123;</span><br><span class="line">     <span class="attr">"should"</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="attr">"match"</span>: &#123;</span><br><span class="line">           <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,&#123;</span><br><span class="line">         <span class="attr">"match"</span>: &#123;</span><br><span class="line">           <span class="attr">"des"</span>: <span class="string">"测试"</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"fvh"</span>,</span><br><span class="line">        <span class="attr">"post_tags"</span>: <span class="string">"&lt;/b&gt;"</span>,</span><br><span class="line">        <span class="attr">"pre_tags"</span>: <span class="string">"&lt;b&gt;"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"des"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/elasticsearch（十一）Highlight、Suggest/单字段高亮.jpg" style="zoom: 67%;" />

<h3 id="全局字段高亮"><a href="#全局字段高亮" class="headerlink" title="全局字段高亮"></a>全局字段高亮</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"测试"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"des"</span>: <span class="string">"测试"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"post_tags"</span>: <span class="string">"&lt;/b&gt;"</span>,</span><br><span class="line">    <span class="attr">"pre_tags"</span>: <span class="string">"&lt;b&gt;"</span>,</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"des"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/elasticsearch（十一）Highlight、Suggest/全局高亮.jpg" style="zoom:67%;" />

<h2 id="二、Suggest-搜索推荐"><a href="#二、Suggest-搜索推荐" class="headerlink" title="二、Suggest-搜索推荐"></a>二、Suggest-搜索推荐</h2><p>四种suggest：term suggester、phrase suggester、completion suggester、context suggester</p>
<h3 id="2-1、term-suggester"><a href="#2-1、term-suggester" class="headerlink" title="2.1、term suggester"></a>2.1、term suggester</h3><p>根据词项的词频来推荐</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text：用户搜索的文本</span><br><span class="line">field：要从哪个字段选取推荐数据</span><br><span class="line">analyzer：使用哪种分词器</span><br><span class="line">size：每个建议返回的最大结果数</span><br><span class="line">sort：如何按照提示词项排序，参数值只可以是以下两个枚举：</span><br><span class="line">	- score：分数&gt;词频&gt;词项本身</span><br><span class="line"> 	- frequency：词频&gt;分数&gt;词项本身</span><br><span class="line">max_edits：可以具有最大偏移距离候选建议以便被认为是建议。只能是1到2之间的值。任何其他值都将导致引发错误的请求错误。默认为2</span><br><span class="line">prefix_length：前缀匹配的时候，必须满足的最少字符</span><br><span class="line">min_doc_freq：最少的文档频率</span><br><span class="line">suggest_mode：搜索推荐的推荐模式，参数值亦是枚举：</span><br><span class="line">	- missing 匹配不再索引中的词项（不包含自己的结果）</span><br><span class="line">	- popular 匹配比原始词项的文档词频更高的词项（比自己高的结果）</span><br><span class="line">	- always 匹配推荐的任意词项（匹配所有结果）</span><br></pre></td></tr></table></figure>

<h4 id="推荐模式（默认missing）"><a href="#推荐模式（默认missing）" class="headerlink" title="推荐模式（默认missing）"></a>推荐模式（默认missing）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /news/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">    <span class="attr">"missing_suggest"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"baoqian baoqiang"</span>,</span><br><span class="line">      <span class="attr">"term"</span>: &#123;</span><br><span class="line">        <span class="attr">"suggest_mode"</span>: <span class="string">"missing"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"popular_suggest"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"baoqian baoqiang"</span>,</span><br><span class="line">      <span class="attr">"term"</span>: &#123;</span><br><span class="line">        <span class="attr">"suggest_mode"</span>: <span class="string">"popular"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"always_suggest"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"baoqian baoqiang"</span>,</span><br><span class="line">      <span class="attr">"term"</span>: &#123;</span><br><span class="line">        <span class="attr">"suggest_mode"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、phrase-suggester"><a href="#2-2、phrase-suggester" class="headerlink" title="2.2、phrase suggester"></a>2.2、phrase suggester</h3><p>phrase suggester和term suggester相比，对建议的文本会参考上下文，也就是一个句子的其他token，不只是单纯的token距离匹配，它可以基于共生和频率选出更好的建议。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /news/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">    <span class="attr">"my-suggestion"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"baoqing baoqiang"</span>,</span><br><span class="line">      <span class="attr">"phrase"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title"</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">          <span class="attr">"pre_tag"</span>: <span class="string">"&lt;h1&gt;"</span>,</span><br><span class="line">          <span class="attr">"post_tag"</span>: <span class="string">"&lt;/h1&gt;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"direct_generator"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"suggest_mode"</span>: <span class="string">"always"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"content"</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            <span class="attr">"suggest_mode"</span>: <span class="string">"popular"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"content"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3、completion-suggester（支持中文）"><a href="#2-3、completion-suggester（支持中文）" class="headerlink" title="2.3、completion suggester（支持中文）"></a>2.3、completion suggester（支持中文）</h3><p>自动补全，自动完成，基于内存，性能很高，支持三种查询【<strong><em>前缀查询（prefix）</em></strong>/模糊查询（fuzzy）/正则表达式查询（regex）】 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#创建mapping，指端suggest类型</span><br><span class="line">PUT suggest_carinfo</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"completion"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"content"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prefix-query"><a href="#prefix-query" class="headerlink" title="prefix query"></a>prefix query</h4><p>​    基于前缀查询的搜索提示，是最常用的一种搜索推荐查询。只匹配前缀的话召回率低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prefix：客户端搜索词</span><br><span class="line">field：建议词字段</span><br><span class="line">size：需要返回的建议词数量</span><br><span class="line">skip_duplicates：是否过滤掉重复建议，默认false</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET suggest_carinfo/_search?pretty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">        <span class="attr">"car_suggest"</span> : &#123;</span><br><span class="line">            <span class="attr">"prefix"</span> : <span class="string">"A6"</span>, </span><br><span class="line">            <span class="attr">"completion"</span> : &#123; </span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"title.suggest"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fuzzy-query"><a href="#fuzzy-query" class="headerlink" title="fuzzy query"></a>fuzzy query</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fuzziness：允许的偏移量，默认auto</span><br><span class="line">transpositions：如果设置为true，则换位计为一次更改而不是两次更改，默认为true。</span><br><span class="line">min_length：返回模糊建议之前的最小输入长度，默认 3</span><br><span class="line">prefix_length：输入的最小长度（不检查模糊替代项）默认为 1</span><br><span class="line">unicode_aware：如果为true，则所有度量（如模糊编辑距离，换位和长度）均以Unicode代码点而不是以字节为单位。这比原始字节略慢，因此默认情况下将其设置为false。</span><br><span class="line">skip_duplicates：是否过滤掉重复建议，默认false</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST suggest_carinfo/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">    <span class="attr">"car_suggest"</span>: &#123;</span><br><span class="line">      <span class="attr">"prefix"</span>: <span class="string">"宝马5系"</span>,</span><br><span class="line">      <span class="attr">"completion"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title.suggest"</span>,</span><br><span class="line">        <span class="attr">"skip_duplicates"</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">          <span class="attr">"fuzziness"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="regex-query"><a href="#regex-query" class="headerlink" title="regex query"></a>regex query</h4><p>可以用正则表示前缀，不建议使用</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST suggest_carinfo/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">    <span class="attr">"car_suggest"</span>: &#123;</span><br><span class="line">      <span class="attr">"regex"</span>: <span class="string">"[\\s\\S]*"</span>,</span><br><span class="line">      <span class="attr">"completion"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"title.suggest"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch（十）相关性得分及分值排序优化</title>
    <url>/2021/06/06/elasticsearch%EF%BC%88%E5%8D%81%EF%BC%89relevance%20score/</url>
    <content><![CDATA[<h2 id="relevance-score（相关性得分）"><a href="#relevance-score（相关性得分）" class="headerlink" title="relevance score（相关性得分）"></a>relevance score（相关性得分）</h2><h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF/IDF"></a>TF/IDF</h3><ul>
<li>TF(term frequency): 关键词在每个doc中出现的次数</li>
<li>IDF(inverse doc frequency): 关键词在整个索引中出现的次数</li>
</ul>
<h3 id="计算规则"><a href="#计算规则" class="headerlink" title="计算规则"></a>计算规则</h3><p>​        TF数值大的得分较高，因为关键词在一个文档出现的次数多，证明该文档的相关性更大</p>
<p>​        IDF数值大的得分较低，关键词在整个倒排索引中出现的次数越多，关联的文档越多，证明其相关越低</p>
<p>​        relevance score（相关性得分）：每个query的分数，乘以matched query数量，除以总query数量</p>
<ol>
<li>它会执行 should 语句中的两个查询。</li>
<li>两个查询的评分相加。</li>
<li>乘以匹配语句的总数。</li>
<li>除以所有语句总数</li>
</ol>
<a id="more"></a>

<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;match&quot;: &#123;&quot;name&quot;: &quot;吃鸡手机&quot;&#125;&#125;,</span><br><span class="line">	doc1:	吃鸡1次，手机1次，计2分	</span><br><span class="line">	doc2:	吃鸡0次，手机1次，计1分</span><br><span class="line">	doc3:	吃鸡0次，手机1次，计1分</span><br><span class="line">&#123;&quot;match&quot;: &#123;&quot;desc&quot;: &quot;吃鸡手机&quot;&#125;&#125;</span><br><span class="line">doc1:	吃鸡0次，手机0次，计0分	</span><br><span class="line">	doc2:	吃鸡0次，手机1次，计1分</span><br><span class="line">	doc3:	吃鸡0次，手机1次，计1分</span><br><span class="line">	</span><br><span class="line">总分：（query1分数+query2分数）*matched query &#x2F; total query</span><br><span class="line"></span><br><span class="line">doc1:	query1+query2：2		matched：1	total query：2		result：2*1&#x2F;2&#x3D;1</span><br><span class="line">doc2:	query1+query2：2		matched：2	total query：2		result：2*2&#x2F;2&#x3D;2</span><br><span class="line">doc3:	query1+query2：2		matched：2	total query：2		result：2*2&#x2F;2&#x3D;2</span><br><span class="line">	</span><br><span class="line">matched query数量 &#x3D; 2</span><br><span class="line">总query数量 &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>总结：<code>总分 =（query1分数+query2分数）*matched query / total query</code></p>
<h3 id="shard-local-idf和global-idf"><a href="#shard-local-idf和global-idf" class="headerlink" title="shard local idf和global idf"></a>shard local idf和global idf</h3><p>es的每个shard只保存一部分的doc数据，当我们的查询路由到某个shard上进行查询时，只在该shard上计算idf，即<code>shard local idf</code>；如果不同的shard存在的文档数量不同，出现不同的shard local idf，在差距较大的情况下会影响分值的计算，影响排序结果。</p>
<p>解决：</p>
<ol>
<li>一般来说，生产环境下，数据量大时尽可能实现均匀分配，一定程度是哪个避免多个shard之间出现shard local idf差距过大的情况</li>
<li>搜索附带<code>search_type=dfs_query_then_fetch</code>参数，当计算一个doc的相关度分数的时候，就会将所有shard对应的local IDF获取出来，在本地进行global IDF分数的计算，所有shard的doc作为上下文来进行计算确保准确性，生产环境下，不推荐这个参数，因为性能很差。</li>
</ol>
<h2 id="排序规则优化"><a href="#排序规则优化" class="headerlink" title="排序规则优化"></a>排序规则优化</h2><h3 id="dix-max"><a href="#dix-max" class="headerlink" title="dix_max"></a>dix_max</h3><p>Disjunction Max Query,将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回 。</p>
<p>tie_breaker：取值范围 [0,1]，其中 0 代表使用 dis_max 最佳匹配语句的普通逻辑，1表示所有匹配语句同等重要。最佳的精确值需要根据数据与查询调试得出，但是合理值应该与零接近（处于 0.1 - 0.4 之间），这样就不会颠覆 dis_max 最佳匹配性质的根本。</p>
<p>boost：设置分值比例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#查询匹配的文档，被更多term命中的feild查询语句作为查询评分结果（默认使用best_fields）</span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"dis_max"</span>: &#123;</span><br><span class="line">            <span class="attr">"queries"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"name"</span>: <span class="string">"超级快充"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"desc"</span>: <span class="string">"超级快充"</span>&#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"dis_max"</span>: &#123;</span><br><span class="line">            <span class="attr">"queries"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"name"</span>: <span class="string">"超级快充"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"desc"</span>: <span class="string">"超级快充"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">           	<span class="attr">"boost"</span>: <span class="number">2.0</span>,</span><br><span class="line">            <span class="attr">"tie_breaker"</span>: <span class="number">0.7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><h4 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h4><h5 id="best-fields（默认）"><a href="#best-fields（默认）" class="headerlink" title="best_fields（默认）"></a>best_fields（默认）</h5><p>​            多个字段进行查询匹配时，返回评分最高的字段评分作为查询结果。类似：dis_max query。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"best_fields"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"超级快充"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [</span><br><span class="line">        <span class="string">"name"</span>,</span><br><span class="line">        <span class="string">"desc"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"tie_breaker"</span>: <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">#dis_max query查询与上述best_fields等价   </span><br><span class="line">POST product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"dis_max"</span>: &#123;</span><br><span class="line">      <span class="attr">"queries"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"超级快充"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: <span class="string">"超级快充"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"tie_breaker"</span>: <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="most-fields"><a href="#most-fields" class="headerlink" title="most_fields"></a>most_fields</h5><p>​            多个字段进行查询匹配时，多个字段的评分一起参与计算，返回的综合评分（非最高分）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"超级快充"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"most_fields"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [</span><br><span class="line">        <span class="string">"name^10"</span>,</span><br><span class="line">        <span class="string">"desc"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#与上面的most_fields等价</span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">              <span class="attr">"query"</span>: <span class="string">"超级快充"</span>,</span><br><span class="line">              <span class="attr">"boost"</span>: <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: <span class="string">"超级快充"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="cross-fields"><a href="#cross-fields" class="headerlink" title="cross_fields"></a>cross_fields</h5><p>​                跨字段匹配与operator指令结合操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#查询的关键词的term必须在name and desc中出现</span><br><span class="line">#例如，超级必须在name或desc中出现 and  快充必须在name或desc中出现</span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span> : &#123;</span><br><span class="line">      <span class="attr">"query"</span>:      <span class="string">"超级 快充"</span>,</span><br><span class="line">      <span class="attr">"type"</span>:       <span class="string">"cross_fields"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>:     [ <span class="string">"name"</span>, <span class="string">"desc"</span> ],</span><br><span class="line">      <span class="attr">"operator"</span>:   <span class="string">"and"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="function-score"><a href="#function-score" class="headerlink" title="function_score"></a>function_score</h3><p>必须定义一个查询和一个或多个函数，自定义函数会为查询返回的每个文档计算一个新分数</p>
<p>​    field：要计算的字段</p>
<p>​    factor：当前分数计算，对整个结果产生的权重比</p>
<p>​    modifier：以何种运算方式计算，接受以下枚举</p>
<ul>
<li>none：不处理</li>
<li>log：计算对数</li>
<li>log1p：先将字段值 +1，再计算对数</li>
<li>log2p：先将字段值 +2，再计算对数</li>
<li>ln：计算自然对数</li>
<li>ln1p：先将字段值 +1，再计算自然对数</li>
<li>ln2p：先将字段值 +2，再计算自然对数</li>
<li>square：计算平方</li>
<li>sqrt：计算平方根</li>
<li>reciprocal：计算倒数</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#默认分值与指定field字段数值相乘得出分数、根据modifier指定的运算方式处理、factor权重比、max_boost表示最大的分值、boost_mode指定计算后的分数与原始的_score如何合并</span><br><span class="line">GET /person/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"field_value_factor"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"age"</span>,</span><br><span class="line">        <span class="attr">"modifier"</span>: <span class="string">"none"</span>,</span><br><span class="line">        <span class="attr">"factor"</span>: <span class="number">1.2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"max_boost"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"boost_mode"</span>: <span class="string">"multiply"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boost_mode：指定计算后的分数与原始的_score如何合并，有以下选</p>
<ul>
<li><p>multiply：查询分数和函数分数相乘</p>
</li>
<li><p>sum：查询分数和函数分数相加</p>
</li>
<li><p>avg：取平均值</p>
</li>
<li><p>replace：替换原始分数</p>
</li>
<li><p>min：取查询分数和函数分数的最小值</p>
</li>
<li><p>max：取查询分数和函数分数的最大值</p>
<p>script_score：通过自定义脚本计算分值</p>
</li>
</ul>
<p>max_boost：分数上限</p>
<p>random_score：随机得到 0 到 1 分数</p>
<h2 id="term-vectors-term向量指标"><a href="#term-vectors-term向量指标" class="headerlink" title="term vectors-term向量指标"></a>term vectors-term向量指标</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#查询指定内容对应字段的文档term向量指标</span><br><span class="line">GET /test_vector/_termvectors</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"content"</span>:<span class="string">"you can kill"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"offsets"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"payloads"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"positions"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"term_statistics"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"field_statistics"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">#查询指定字段的文档term向量指标</span><br><span class="line">GET /test_vector/_termvectors/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"fields"</span>: [<span class="string">"content"</span>],</span><br><span class="line">  <span class="attr">"offsets"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"payloads"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"positions"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"term_statistics"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"field_statistics"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="images/elasticsearch（十）relevance score/termvectors.jpg" style="zoom:67%;" />]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka集群安装</title>
    <url>/2020/12/06/eureka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 服务端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 安全配置，服务之间注册需要校验 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查，用于服务之间的心跳检测 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-启动类添加注解"><a href="#2-启动类添加注解" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-节点一的yml配置"><a href="#3-1-节点一的yml配置" class="headerlink" title="3.1 节点一的yml配置"></a>3.1 节点一的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9991</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka1.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9991 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-节点二的yml配置"><a href="#3-2-节点二的yml配置" class="headerlink" title="3.2 节点二的yml配置"></a>3.2 节点二的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9992</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka2.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9992 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">456</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-节点三的yml配置"><a href="#3-3-节点三的yml配置" class="headerlink" title="3.3 节点三的yml配置"></a>3.3 节点三的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9993</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka3.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9993 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">789</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="二、-客户端"><a href="#二、-客户端" class="headerlink" title="二、 客户端"></a>二、 客户端</h2><h3 id="1-依赖-1"><a href="#1-依赖-1" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 客户端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-启动类添加注解-1"><a href="#2-启动类添加注解-1" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="3-yml配置"><a href="#3-yml配置" class="headerlink" title="3. yml配置"></a>3. yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9302</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-pay</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span></span><br><span class="line">        <span class="string">http://eureka:eureka@eureka1.com:9991/eureka/,http://eureka:eureka@eureka2.com:9992/eureka/,http://eureka:eureka@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<h2 id="三、控制台"><a href="#三、控制台" class="headerlink" title="三、控制台"></a>三、控制台</h2><p>当服务出现在available-replicas中才算搭建成功</p>
<p><img src="/images/cloud/eureka/eureka%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<h2 id="四、健康检查"><a href="#四、健康检查" class="headerlink" title="四、健康检查"></a>四、健康检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">managementUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator</span><br><span class="line">healthUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator&#x2F;health</span><br><span class="line">serviceUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="五、cap原则"><a href="#五、cap原则" class="headerlink" title="五、cap原则"></a>五、cap原则</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一致性（Consistency）</span><br><span class="line">可用性（Availability）</span><br><span class="line">分区容错性（Partition tolerance）</span><br><span class="line">1.eureka是ap，去中心化，每个节点是平等的，15分钟内，可用实例低于85%,开启心跳保护，不会剔除心跳异常的实例，保证可用性，仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用），所以实例调用需要有熔断机制保证</span><br><span class="line">2.zookpeer是cp，由leader提供服务，ZooKeeper选举Leader时候会造成服务一定时间内的不可用，保证了一致性，不保证可用性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab安装部署</title>
    <url>/2021/11/13/gitlab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="创建清华源"><a href="#创建清华源" class="headerlink" title="创建清华源"></a>创建清华源</h3><p><code>vim /etc/yum.repos.d/gitlab-ce.repo</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository </span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el<span class="variable">$releasever</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>yum makecache &amp;&amp; yum install -y gitlab-ce</code></p>
<a id="more"></a>

<h3 id="修改访问地址"><a href="#修改访问地址" class="headerlink" title="修改访问地址"></a>修改访问地址</h3><p><code>vim /etc/gitlab/gitlab.rb</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">external_url <span class="string">'IP地址+端口号'</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/gitlab/gitlab%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80.jpg" alt=""></p>
<h3 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h3><p><code>gitlab-ctl reconfigure</code></p>
<p><img src="/images/gitlab/gitlab%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90.jpg" alt=""></p>
<h3 id="获取root账户密码"><a href="#获取root账户密码" class="headerlink" title="获取root账户密码"></a>获取root账户密码</h3><p><code>more /etc/gitlab/initial_root_password</code></p>
<p><img src="/images/gitlab/%E6%9F%A5%E7%9C%8Broot%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p><img src="/images/gitlab/%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开gitlab访问端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8001&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;8001&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p><img src="/images/gitlab/%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E9%A1%B9%E7%9B%AE.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>gitlab</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(四)-painless</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E5%9B%9B%EF%BC%89painless/</url>
    <content><![CDATA[<h2 id="Painless"><a href="#Painless" class="headerlink" title="Painless"></a>Painless</h2><p>Painless是一种专门用于Elasticsearch的简单,用于内联和存储脚本，类似于Java,也有注释、关键字、类型、变量、函数等，安全的脚本语言。它是Elasticsearch的默认脚本语言，可以安全地用于内联和存储脚本。</p>
<a id="more"></a>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将price的价格减少1</span></span><br><span class="line"><span class="comment">//ctx._source 拿取上下文的source对象，固定写法</span></span><br><span class="line">POST index/_update/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: <span class="string">"ctx._source.price -=1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略的写法</span></span><br><span class="line">POST index/_update/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.price -=1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用方法添加tags里的数据</span></span><br><span class="line">POST product2/_update/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="comment">//标识这是一个painless语言</span></span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.tags.add('无线充电')"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传参调用</span></span><br><span class="line">POST product2/_update/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.tags.add(params.tag_name)"</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"tag_name"</span>: <span class="string">"无线充电"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete  id=15的数据</span></span><br><span class="line">POST product2/_update/15</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx.op='delete'"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="upsert"><a href="#upsert" class="headerlink" title="upsert"></a>upsert</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果数据存在,执行script语句进行更新操作,如果数据不存在,那么执行upsert进行插入操作</span></span><br><span class="line">GET /product2/_doc/15</span><br><span class="line">POST product2/_update/15</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.price += params.param1"</span>,</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"param1"</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"小米10"</span>,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="number">1999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><blockquote>
<p>Elasticsearch首次执行脚本时，将对其进行编译并将编译后的版本存储在缓存中。编译过程比较消耗性能。<br>如果需要将变量传递到脚本中，则应以命名形式传递变量，params而不是将值硬编码到脚本本身中。例如，如果您希望能够将字段值乘以不同的乘数，请不要将乘数硬编码到脚本中</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看took消耗</span></span><br><span class="line"><span class="comment">//doc['price'].value 获取doc对象里的price列的值</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//由于是查询字段经过了script计算，返回的结果需要定义一个名称，使用script_fields接收结果</span></span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_field"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value * 9"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更换num的值 对比took消耗   </span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_field"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"expression"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value * num"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"num"</span>: <span class="number">9</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doc[&#39;price&#39;] * num</code>只编译一次，而<code>doc[&#39;price&#39;] * 9</code> 会随着数字改变而一直编译，效率没有传参的方式高效。ES默认每分钟支持15次编译。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持查原数据 + 计算数据 ，如原始价格 和 多个打折价格</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"discount_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="comment">//这里要使用数据，因为有多个参数</span></span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"[doc['price'].value * params.p1,doc['price'].value * params.p2]"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"p1"</span>: <span class="number">0.8</span>,</span><br><span class="line">                    <span class="attr">"p2"</span>: <span class="number">0.7</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stored-scripts"><a href="#Stored-scripts" class="headerlink" title="Stored scripts"></a>Stored scripts</h3><p><strong>Stored scripts</strong> :可以理解为script模板  缓存在集群的cache中，默认缓存大小是100MB  没有过期时间 可以手工设置过期时间script.cache.expire 通过script.cache.max_size设置缓存大小 脚本最大64MB 通过<code>script.max_size_in_bytes</code>配置 只有发生变更时重新编译。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：/_scripts/&#123;id&#125;  类似存储过程  计算折扣 作用域为整个集群 &#123;id&#125;是scripts的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">POST _scripts/calculate-discount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"doc['price'].value * params.discount"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看</span></span><br><span class="line">GET _scripts/calculate-discount</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">DELETE _scripts/calculate-discount</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"discount_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="comment">//调用名称为calculate-discount的srcipt</span></span><br><span class="line">                <span class="attr">"id"</span>:<span class="string">"calculate-discount"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"discount"</span>: <span class="number">0.8</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dates"><a href="#Dates" class="headerlink" title="Dates"></a>Dates</h3><p><strong>Dates</strong>：ZonedDateTime类型，因此它们支持诸如之类的方法getYear，getDayOfWeek 或例如从历元开始到毫秒getMillis。要在脚本中使用它们，请省略get前缀并继续使用小写的方法名其余部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getYear()</span></span><br><span class="line"><span class="comment">//getMonth()</span></span><br><span class="line"><span class="comment">//getDayOfMonth()</span></span><br><span class="line"><span class="comment">//getDayOfWeek()</span></span><br><span class="line"><span class="comment">//getDayOfYear()</span></span><br><span class="line"><span class="comment">//getHour()</span></span><br><span class="line"><span class="comment">//getMinute()</span></span><br><span class="line"><span class="comment">//getSecond()</span></span><br><span class="line"><span class="comment">//getNano()</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_year"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc.createtime.value.year"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><p>通过两个<code>&quot;&quot;&quot;</code>括起来，在里面能够把它当做java代码进行编写，每个语句分隔使用<code>;</code>，支持使用条件语句。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            ctx._source.name += params.name;</span></span><br><span class="line"><span class="string">            ctx._source.price -= 1</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"无线充电"</span>,</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则部分匹配phone</span></span><br><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            // =~ 部分匹配 name中包含phone   [\s\S]表示任意符号 </span></span><br><span class="line"><span class="string">            if (ctx._source.name =~ /[\s\S]*phone[\s\S]*/) &#123;</span></span><br><span class="line"><span class="string">                ctx._source.name += "</span>***|<span class="string">";</span></span><br><span class="line"><span class="string">            &#125; else &#123;</span></span><br><span class="line"><span class="string">                //什么都不做</span></span><br><span class="line"><span class="string">                ctx.op = "</span>noop<span class="string">";</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则匹配日期 yyyy-MM-dd</span></span><br><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            // ==~ 全匹配 日期</span></span><br><span class="line"><span class="string">            if (ctx._source.createtime ==~ /[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;/) &#123;</span></span><br><span class="line"><span class="string">                ctx._source.name += "</span>|***<span class="string">";</span></span><br><span class="line"><span class="string">            &#125; else &#123;</span></span><br><span class="line"><span class="string">                ctx.op = "</span>noop<span class="string">";</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式默认情况下处于禁用状态，因为他们绕过了<code>Painless</code>的针对长时间运行和占用内存的脚本保护措施，而且有深度堆栈行为，若想要开启，则需要在<code>elasticsearch.yml</code>增加配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">script.painless.regex.enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算价格小于1000的tags数量</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;</span><br><span class="line">                        <span class="attr">"price"</span>: &#123;</span><br><span class="line">                            <span class="attr">"lt"</span>: <span class="number">1000</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                <span class="attr">"script"</span>: &#123;</span><br><span class="line">                    <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                    <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                        int total = 0;</span></span><br><span class="line"><span class="string">                    for (int i = 0; i &lt; doc['tags.keyword'].length; i++)</span></span><br><span class="line"><span class="string">                    &#123;</span></span><br><span class="line"><span class="string">                        total++</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                    return total;</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doc[‘field’].value和params[‘_source’] [‘field’] 的区别：</p>
</blockquote>
<p>理解之间的区别是很重要的，首先，使用doc关键字，将导致该字段的条件被加载到内存（缓存），这将导致更快的执行，但更多的内存消耗。</p>
<p>此外，<strong>doc[…]符号只允许简单类型</strong>（不能返回一个复杂类型(JSON对象或者nested类型)），只有在非分析或单个词条的基础上有意义。</p>
<p>但是，doc如果可能，使用仍然是从文档访问值的推荐方式，因为_source每次使用时都必须加载并解析。使用_source非常缓慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询一批数据中，字段people：[&#123;"SF":男&#125;,&#123;"SF":女&#125;]，有多少个男性</span></span><br><span class="line">GET /test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span>: &#123;</span><br><span class="line">        <span class="string">"sum_person"</span>: &#123;</span><br><span class="line">            <span class="string">"sum"</span>: &#123;</span><br><span class="line">                <span class="string">"script"</span>: &#123;</span><br><span class="line">                    <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                    <span class="string">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                        int total = 0;</span></span><br><span class="line"><span class="string">                    for (int i = 0; i &lt; params['_source']['people'].length; i++)</span></span><br><span class="line"><span class="string">                    &#123;</span></span><br><span class="line"><span class="string">                        if (params['_source']['people'][i]['SF'] == '男') &#123;</span></span><br><span class="line"><span class="string">                            total += 1;</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                    return total;</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8安装</title>
    <url>/2020/11/29/jdk1.8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、安装rz、sz命令"><a href="#一、安装rz、sz命令" class="headerlink" title="一、安装rz、sz命令"></a>一、安装rz、sz命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure>

<h2 id="二、rpm方式安装jdk"><a href="#二、rpm方式安装jdk" class="headerlink" title="二、rpm方式安装jdk"></a>二、rpm方式安装jdk</h2><a id="more"></a>

<h3 id="1-查看是否含有系统自带jdk"><a href="#1-查看是否含有系统自带jdk" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-上传安装包"><a href="#2-上传安装包" class="headerlink" title="2. 上传安装包"></a>2. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效"><a href="#3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效" class="headerlink" title="3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)"></a>3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh jdk-8u162-linux-x64.rpm</span><br></pre></td></tr></table></figure>

<img src="/images/linux/jdk/rpm安装jdk.jpg" style="zoom:100%;" />

<h3 id="4-修改系统环境变量"><a href="#4-修改系统环境变量" class="headerlink" title="4. 修改系统环境变量"></a>4. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容"><a href="#5-追加以下内容" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/jdk/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%E5%86%85%E5%AE%B9.jpg" alt=""></p>
<h3 id="6-让修改生效"><a href="#6-让修改生效" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态"><a href="#7-查看系统环境状态" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/jdk/%E8%AE%A9%E4%BF%AE%E6%94%B9%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.jpg" alt=""></p>
<h3 id="8-删除rpm安装的jdk"><a href="#8-删除rpm安装的jdk" class="headerlink" title="8. 删除rpm安装的jdk"></a>8. 删除rpm安装的jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br><span class="line">yum -y remove xxx</span><br></pre></td></tr></table></figure>

<h2 id="三、tar-gz包安装jdk"><a href="#三、tar-gz包安装jdk" class="headerlink" title="三、tar.gz包安装jdk"></a>三、tar.gz包安装jdk</h2><h3 id="1-查看是否含有系统自带jdk-1"><a href="#1-查看是否含有系统自带jdk-1" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2. 创建文件夹"></a>2. 创建文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure>

<h3 id="3-上传安装包"><a href="#3-上传安装包" class="headerlink" title="3. 上传安装包"></a>3. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="4-解压"><a href="#4-解压" class="headerlink" title="4. 解压"></a>4. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>-z　通过gzip指令处理备份文件<br>-x　从备份文件中还原文件<br>-v　显示指令执行过程<br>-f　指定备份文件</p>
<h3 id="5-修改系统环境变量"><a href="#5-修改系统环境变量" class="headerlink" title="5. 修改系统环境变量"></a>5. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容-1"><a href="#5-追加以下内容-1" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<h3 id="6-让修改生效-1"><a href="#6-让修改生效-1" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态-1"><a href="#7-查看系统环境状态-1" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载与创建</title>
    <url>/2021/01/03/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="/images/jvm/jvm-base/jvm-01.png" alt="jvm"></p>
<a id="more"></a>

<h2 id="Class格式"><a href="#Class格式" class="headerlink" title="Class格式"></a>Class格式</h2><p>Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。</p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a><strong>无符号数</strong></h3><p>属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a><strong>表</strong></h3><p>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。表主要用于描述有层次关系的复合结构的数据，比如方法、字段。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的。具体的顺序定义如下：</p>
<p><img src="/images/jvm/jvm-base/jvm-03.png" alt="jvm"></p>
<p>从二进制的数据来看：</p>
<p><img src="/images/jvm/jvm-base/jvm-02.png" alt="jvm"></p>
<p>通过<code>javap</code>编译成可视化语言来看：</p>
<p><img src="/images/jvm/jvm-base/jvm-06.png" alt="jvm"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cafe babe 0000 0034 000f 0a00 0300 0c07</span><br><span class="line">000d 0700 0e01 0006 3c69 6e69 743e 0100</span><br><span class="line">0328 2956 0100 0443 6f64 6501 000f 4c69</span><br><span class="line">6e65 4e75 6d62 6572 5461 626c 6501 0004</span><br><span class="line">6d61 696e 0100 1628 5b4c 6a61 7661 2f6c</span><br><span class="line">616e 672f 5374 7269 6e67 3b29 5601 000a</span><br><span class="line">536f 7572 6365 4669 6c65 0100 134a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 742e 6a61 7661</span><br><span class="line">0c00 0400 0501 0013 6b75 726f 2f4a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 7401 0010 6a61</span><br><span class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0021</span><br><span class="line">0002 0003 0000 0000 0002 0001 0004 0005</span><br><span class="line">0001 0006 0000 001d 0001 0001 0000 0005</span><br><span class="line">2ab7 0001 b100 0000 0100 0700 0000 0600</span><br><span class="line">0100 0000 0300 0900 0800 0900 0100 0600</span><br><span class="line">0000 1900 0000 0100 0000 01b1 0000 0001</span><br><span class="line">0007 0000 0006 0001 0000 0006 0001 000a</span><br><span class="line">0000 0002 000b</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">魔法数字： cafe babe</span><br><span class="line">次版本号： 0000</span><br><span class="line">主版本号： 0034			JDK1.8</span><br><span class="line">常量数量： 000f			从1开始</span><br><span class="line">#1常量 ： 0a			 表示表中第十项（CONSTANT_Methodref_info）</span><br><span class="line">      :  00 03		   指向#3常量</span><br><span class="line">      ： 00 0c		  指向#13常量</span><br></pre></td></tr></table></figure>

<p><img src="/images/jvm/jvm-base/jvm-04.png" alt="jvm"></p>
<p>详情可查阅查阅：</p>
<p><img src="/images/jvm/jvm-base/jvm-05.png" alt="jvm"></p>
<h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><p>​        使用new关键字创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>​        使用Class类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = A<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>​        使用Constructor类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;A&gt; constructor = A<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">A a = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>​        使用Clone方法创建对象</p>
<p>​        使用(反)序列化机制创建对象</p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><img src="/images/jvm/jvm-base/jvm-07.png" alt="jvm"></p>
<h3 id="加载-class-loading"><a href="#加载-class-loading" class="headerlink" title="加载(class loading)"></a>加载(class loading)</h3><blockquote>
<p>1.通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2.将这个字节流所代表的的静态存储结构转化成访问区的运行时数据结构。</p>
<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
</blockquote>
<h3 id="验证-class-verification"><a href="#验证-class-verification" class="headerlink" title="验证(class verification)"></a>验证(class verification)</h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证等等。</p>
<p>如验证是否以0xCAFEBABE开头</p>
<h3 id="准备-class-preparation"><a href="#准备-class-preparation" class="headerlink" title="准备(class preparation)"></a>准备(class preparation)</h3><p>为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p><strong>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中。</strong></p>
<p><strong>正常情况下，这里初始化的值是静态变量的数据类型的默认值，而不是属性指定的值，如果它还被final修饰了，那么将会在这个阶段直接初始化成属性指定的值。</strong></p>
<h3 id="解析-class-resolution"><a href="#解析-class-resolution" class="headerlink" title="解析(class resolution)"></a>解析(class resolution)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="类初始化-class-initalizing"><a href="#类初始化-class-initalizing" class="headerlink" title="类初始化(class initalizing)"></a>类初始化(class initalizing)</h3><p>类初始化就是执行<code>&lt;clinit&gt;()</code>方法，<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，<strong>静态语句块中只能访问到定义在静态语句之前的变量</strong>。</p>
<p>也就是说，静态属性和静态代码块的赋值和调用在<strong>初始化</strong>过程中执行，先执行父类的，再执行子类的。</p>
<h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><p>实例初始化过程，就是执行<code>&lt;init&gt;()</code>方法<br>         <code>&lt;init&gt;()</code>方法可能重载有多个，有几个构造器就有几个<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>         非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>         每次创建实例对象，调用对应构造器，执行的就是对应的<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法的首行是surper(或super(实参列表),即对应父类的<code>&lt;init&gt;</code>方法</p>
<h3 id="类初始化与实例初始化，在子父类内部执行顺序"><a href="#类初始化与实例初始化，在子父类内部执行顺序" class="headerlink" title="类初始化与实例初始化，在子父类内部执行顺序"></a>类初始化与实例初始化，在子父类内部执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类静态成员</span><br><span class="line">父类静态代码块</span><br><span class="line">	-&gt;子类静态成员</span><br><span class="line">	-&gt;子类静态代码块</span><br><span class="line">		-&gt;父类代码块</span><br><span class="line">		-&gt;父类成员变量</span><br><span class="line">		-&gt;父类构造器</span><br><span class="line">			-&gt;子类代码块</span><br><span class="line">			-&gt;子类成员变量</span><br><span class="line">			-&gt;子类构造器</span><br><span class="line">类初始化</span><br><span class="line">	静态成员赋值的代码、静态代码块（两者先后看顺序）</span><br><span class="line">实例初始化</span><br><span class="line">	super()</span><br><span class="line">	非静态赋值的代码、非静态代码块（两者先后看顺序）</span><br><span class="line">	无参构造</span><br></pre></td></tr></table></figure>

<p>​        样例：</p>
<img src="/images/jvm/jvm-base/类实例化和类初始化.jpg" style="zoom:95%;" />

<p>上图执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、1、10、6、9、3、2、9、8、7</span><br><span class="line">9、3、2、9、8、7</span><br><span class="line"></span><br><span class="line">类初始化与实例初始化</span><br><span class="line">5  父类静态成员j调用父类的静态方法method()，静态方法不可重写，所以不会调用子类的</span><br><span class="line">1  父类静态代码块</span><br><span class="line">10 子类静态成员j调用子类的静态方法method()</span><br><span class="line">6  子类静态代码块</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br><span class="line"></span><br><span class="line">再次实例初始化</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 count = 2; T t = new T();---&gt;调用构造方法--&gt;count++;</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 T t = new T();---&gt;调用构造方法--&gt;count++; count = 1;</span></span><br><span class="line">        <span class="comment">//--按照顺序赋值静态变量 count = 2;（覆盖掉之前的值）</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果是<code>Object o = new Object()</code>，有以下几步：</strong></p>
<p>1、申请内存空间，这时候成员变量均是默认值</p>
<p>2、调用构造方法，初始化成员变量值</p>
<p>3、建立栈上和堆内存对象的关联关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们调用构造方法时，java的底层的字节码指令如下：</span></span><br><span class="line">0: new           #2                  // class java/lang/Object		申请内存空间</span><br><span class="line"><span class="number">3</span>: dup								 <span class="comment">// 复制内存空间地址，供以调用构造方法时出栈使用</span></span><br><span class="line">4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V    调用构造方法</span><br><span class="line"><span class="number">7</span>: astore_1							 <span class="comment">// Object o 指向开辟的内存地址</span></span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/images/jvm/jvm-base/jvm-08.png" alt="jvm"></p>
<p><img src="/images/jvm/jvm-base/jvm-09.png" alt="jvm"></p>
<p>如果一个类加载器收到了类加载的请求，它不会先尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载。</p>
<p><strong>这里的父-子是通过使用组合关系，成员变量有个叫做parent的属性记录上层的类加载器，而不是继承关系。</strong></p>
<p><strong>父类加载器不是类加载器的加载器，也不是类加载器的父类加载器。双亲委派是一个孩子向父亲方向，然后父亲向孩子方向的双亲委派过程。</strong></p>
<blockquote>
<p>为什么用双亲委派机制？</p>
<p>安全，保证了Java程序的稳定运行。避免核心类库被用户覆盖。</p>
</blockquote>
<p>查看各个类加载器加载的路径及信息可以查阅<code>Launcher.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BootStrap ClassLoader:sun.boot.class.path</span><br><span class="line">ExtClassLoader:java.ext.dirs</span><br><span class="line">AppClassLoader：java.class.path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK破坏双亲委派机制的历史</p>
<p>双亲委派模型的第一次被破坏发生在双亲委派模型出现之前，由于双亲委派模型在JDK1.2之后才被引入，为了向前兼容，JDK1.2之后添加了一个findClass()方法。</p>
<p>双亲委派模型的第二次被破坏是由于模型自身的缺陷导致的，有些标准服务是由启动类加载器（Bootstrap）去加载的，但它又需要调用独立厂商实现并部署在应用程序的ClassPath下的代码，为了解决这个问题，引入了<strong>线程上下文类加载器</strong>，如果有了线程上下文类加载器，父类加载器将会请求子类加载器去完成类加载动作。</p>
<p>双亲委派模型的第三次被破坏是由于用户对程序动态性的追求导致的。如热替换、热部署。</p>
<p>假设每个程序都有一个自己的类加载器，当需要更换一个代码片段时，就把这个代码片段连同类加载器一起换掉实现代码的热替换。</p>
</blockquote>
<p>当我们需要定义自己的类加载器时，继承ClassLoad，重写findClass()方法，当调用loadClass()加载class，找不到时会调用我们自定义的findClass()，读取要加载的文件流，调用defineClass()去真正加载，保证了双亲委派机制</p>
<p>若要破坏双亲委派模型，我们可以直接重写loadClass()方法，直接加载指定的class，没有的情况下再走parent的loadClass()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//File To byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(<span class="string">"xxx"</span>));</span><br><span class="line">        <span class="comment">//调用父类的defineClass装载</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h2><p>Java默认采用混合模式，初期通过编译器编译Class文件的代码，当出现热点代码时，会通过<code>JIT</code>解释器把热点代码解释成本地代码，提高运行效率。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 热点代码的阈值频次</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CompileThreshold = 10000</span></span><br><span class="line"><span class="comment"># 使用编译器运行</span></span><br><span class="line"><span class="attr">-Xcomp</span></span><br><span class="line"><span class="comment">#使用解释器运行</span></span><br><span class="line"><span class="attr">-Xint</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins安装部署</title>
    <url>/2021/11/13/jenkins%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>需要有java环境</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华源</a>进行安装</p>
<p><code>yum install -y https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/jenkins-2.317-1.1.noarch.rpm</code></p>
<a id="more"></a>

<p>出现如下错误</p>
<p><img src="/images/jenkins/%E5%AE%89%E8%A3%85jinkens%E5%A4%B1%E8%B4%A5.jpg" alt=""></p>
<p>执行<code>yum -y install epel-release</code>、<code>yum -y install daemonize</code>安装指定依赖后再重新安装</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>vim /etc/sysconfig/jenkins</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改jenkins用户名为root，或者将jenkins假如用户组，否则之后执行脚本可能出问题</span></span><br><span class="line"><span class="comment">#JENKINS_USER="jenkins"</span></span><br><span class="line">JENKINS_USER=<span class="string">"root"</span></span><br><span class="line"><span class="comment">#修改端口号，默认8080</span></span><br><span class="line">JENKINS_PORT=<span class="string">"8002"</span></span><br></pre></td></tr></table></figure>

<h3 id="插件加速源"><a href="#插件加速源" class="headerlink" title="插件加速源"></a>插件加速源</h3><p>执行<code>vim /var/lib/jenkins/updates/default.json</code> 将google的搜索以及国外的服务器搜索替换成百度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;http:\&#x2F;\&#x2F;updates.jenkins- ci.org\&#x2F;download&#x2F;https:\&#x2F;\&#x2F;mirrors.tuna.tsinghua.edu.cn\&#x2F;jenkins&#x2F;g&#39; default.json &amp;&amp; sed -i &#39;s&#x2F;http:\&#x2F;\&#x2F;www.google.com&#x2F;https:\&#x2F;\&#x2F;www.baidu.com&#x2F;g&#39; default.json</span><br></pre></td></tr></table></figure>

<p>在没有启动jenkins的时候<code>var/lib/jenkins</code>下是空的，执行<code>systemctl start jenkins</code>启动服务后将出现目录</p>
<p>启动报错，jenkins默认java路径加载错误</p>
<p><img src="/images/jenkins/java%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98.jpg" alt=""></p>
<p><code>vim  /etc/init.d/jenkins</code>如下图，增加本机jdk位置，需指定到bin目录下得java执行文件</p>
<p><img src="/images/jenkins/java%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.jpg" alt=""></p>
<p>保存后执行<code>systemctl faemon-reload</code>、<code>systemctl start jenkins</code></p>
<p>如果启动界面卡住不动，就需要进入<code>/var/lib/jenkins/hudson.model.UpdateCenter.xml</code>将center换成清华源<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></p>
<p><img src="/images/jenkins/%E5%90%AF%E5%8A%A8%E6%85%A2%E6%9B%BF%E6%8D%A2%E6%B8%85%E5%8D%8E%E6%BA%90.jpg" alt=""></p>
<p>重新启动jenkins<code>systemctl restart jenkins</code></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>访问jenkins</p>
<p><img src="/images/jenkins/jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E7%99%BB%E5%BD%95.jpg" alt=""></p>
<p>执行<code>cat /var/lib/jenkins/secrets/initialAdminPassword</code>从服务器获取初始密码</p>
<p><img src="/images/jenkins/%E8%8E%B7%E5%8F%96%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<p>安装插件</p>
<p><img src="/images/jenkins/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.jpg" alt=""></p>
<p>创建第一个管理员用户，账户：jkadmin、密码：123</p>
<p><img src="/images/jenkins/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.jpg" alt=""></p>
<p>进入系统</p>
<p><img src="/images/jenkins/%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins自动构建</title>
    <url>/2021/11/17/jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="jenkins安装maven插件"><a href="#jenkins安装maven插件" class="headerlink" title="jenkins安装maven插件"></a>jenkins安装maven插件</h3><p><img src="/images/jenkins/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%851.jpg" alt=""></p>
<p><img src="/images/jenkins/maven%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.jpg" alt=""></p>
<a id="more"></a>

<h3 id="配置jenkins全局环境"><a href="#配置jenkins全局环境" class="headerlink" title="配置jenkins全局环境"></a>配置jenkins全局环境</h3><p><img src="/images/jenkins/jenkins%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<p>git环境，通过<code>whereis git</code>命令查看git安装位置</p>
<p>![](/images/jenkins/whereis git.jpg)</p>
<h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><p><img src="/images/jenkins/jenkins%E7%9A%84git%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h4 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h4><p><img src="/images/jenkins/jenkins%E7%9A%84maven%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h4 id="配置jdk"><a href="#配置jdk" class="headerlink" title="配置jdk"></a>配置jdk</h4><p><img src="/images/jenkins/jenkins%E7%9A%84jdk%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h3 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h3><p><img src="/images/jenkins/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%9A%84maven%E9%A1%B9%E7%9B%AE.jpg" alt=""></p>
<p>任务构建</p>
<p><img src="/images/jenkins/maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.jpg" alt=""></p>
<p>构建触发器</p>
<p><img src="/images/jenkins/%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A801.jpg" alt=""></p>
<blockquote>
<p>拷贝 jenkins的钩子地址到gitlab上<a href="http://192.168.1.18:8002/project/my-maven-test" target="_blank" rel="noopener">http://192.168.1.18:8002/project/my-maven-test</a></p>
<p>生成访问的Secret token</p>
</blockquote>
<p><img src="/images/jenkins/gitlab%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<blockquote>
<p>当gitlab触发指定分支和事件时，触发webhooks调起jenkins执行指定任务</p>
</blockquote>
<p>gitlab添加webhooks失败</p>
<p><img src="/images/jenkins/gitlab%E6%B7%BB%E5%8A%A0%E9%92%A9%E5%AD%90%E5%A4%B1%E8%B4%A5.jpg" alt=""></p>
<p>解决方式</p>
<p><img src="/images/jenkins/gitlab%E6%B7%BB%E5%8A%A0%E9%92%A9%E5%AD%90%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3.jpg" alt=""></p>
<p>之后再重新添加webhooks，如下图可以看到有一个项目的钩子出现</p>
<p><img src="/images/jenkins/gitlab%E6%B7%BB%E5%8A%A0%E9%92%A9%E5%AD%90.jpg" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8 HashMap和ConcurrentHashMap 源码和实现</title>
    <url>/2021/03/31/jdk8-hashmap/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>AVL树：</p>
<p>在计算机科学中，<strong>AVL树</strong>是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的<strong>高度最大差别为1</strong>，所以它也被称为<strong>高度平衡树</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>特点：</p>
<p>1.本身首先是一棵二叉搜索树。</p>
<p>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p>
<p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p>
</blockquote>
<a id="more"></a>

<p><strong>树的左旋</strong>：绕着子结点逆时针转动，如下图：</p>
<p><img src="/images/jdk8-hashmap/source-01.png" alt="source-01"></p>
<p><strong>树的右旋</strong>：绕着子结点顺时针转动，如下图</p>
<p><img src="/images/jdk8-hashmap/source-02.png" alt="source-02"></p>
<blockquote>
<p>红黑树：</p>
<p>是一种自平衡二叉查找树，是一种特化的AVL树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 </p>
<p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在<strong>O(log n)</strong>时间内做查找，插入和删除，这里的n 是树中元素的数目。</p>
<p>若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。</p>
<p>红黑树的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet。</p>
</blockquote>
<blockquote>
<p>红黑树的定义如下：</p>
<p>1.每个结点是红的或者黑的</p>
<p>2.根结点是黑的</p>
<p>3.每个叶结点是黑的（每个结点有默认的黑色的NULL结点）</p>
<p>4.如果一个结点是红的，则它的两个儿子都是黑的（父子结点之间不能出现两个连续的红结点）</p>
<p>5.对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点（黑色平衡）</p>
</blockquote>
<p><strong>在算法导论中，新插入的结点优先默认是红色的，优先满足第五条定义，再满足其他定义。</strong></p>
<hr>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><blockquote>
<p>1.假设现在插入一个根结点（10）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-03.png" alt="source-03"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先插入一个红色的结点，满足第五条定义</span><br><span class="line">2.不满足第二条定义---&gt;变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.再插入一个结点（20）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-04.png" alt="source-04"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先和根节点比大小，判断要落在根节点的右边</span><br><span class="line">2.校验是否满足所有定义---&gt;满足</span><br></pre></td></tr></table></figure>

<p><strong>这是一颗正常的红黑树</strong>。因为每个节点，它的末尾节点都有隐藏的黑色空节点，所以满足第三条定义。</p>
<blockquote>
<p>再插入一个结点（30）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-05.png" alt="source-05"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.插入节点后判断是否满足第五定义---&gt;左旋</span><br><span class="line">2.左旋后判断是否满足第二定义---&gt;需要变色</span><br><span class="line">3.旋转的结点和中心结点进行变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入一个结点（40）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-06.png" alt="source-06"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.插入结点后判断是否满足第四定义---&gt;变色</span><br><span class="line">2.判断是否满足第二定义---&gt;变色</span><br><span class="line">结论：</span><br><span class="line">父节点是黑色的，则不需要调整</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入两个结点（5）（25）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-09.png" alt="source-09"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">父节点是黑色的，不需要调整</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入一个结点（50）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-10.png" alt="source-10"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.父节点和叔叔节点变色</span><br><span class="line">2.祖父节点变色</span><br><span class="line">结论：父节点是红色时，叔叔节点也是红色时，则父节点和叔叔节点变色，祖父节点变色。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入两个结点（35）（60）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-11.png" alt="source-11"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先保证红框中的子树是一颗红黑树</span><br><span class="line">2.按照上文案例的结论，父节点和叔叔节点变色，祖父节点变色</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk8-hashmap/source-12.png" alt="source-12"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.在上面步骤的基础上，达到了子树是一颗红黑树</span><br><span class="line">2.然后把变色的结点（40）当做是一个新节点，插入到红框中的树中</span><br><span class="line">3.在这种情况下进行红框树的调整</span><br><span class="line">4.先左旋，结点重连，然后旋转的节点和中心节点变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入个结点（6）</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-13.png" alt="source-13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.(5)结点以(6)为中心，进行左旋</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk8-hashmap/source-14.png" alt="source-14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">2.然后就和上文插入(60)结点步骤相同</span><br><span class="line">3.先进行右旋，然后变色</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>当插入一个新节点（红色）时</strong>：</p>
<blockquote>
<p>父节点是黑色的，不用进行调整</p>
</blockquote>
<p><img src="/images/jdk8-hashmap/source-07.png" alt="source-07"></p>
<blockquote>
<p>父节点是红色的，并且</p>
</blockquote>
<p><strong>1.叔叔是空的，旋转+变色</strong></p>
<p><img src="/images/jdk8-hashmap/source-08.png" alt="source-08"></p>
<p><strong>2.叔叔是红色，父节点+叔叔节点变黑色，祖父节点变红色</strong></p>
<p><img src="/images/jdk8-hashmap/source-10.png" alt="source-10"></p>
<p><strong>3.叔叔是黑色，旋转+变色</strong></p>
<p><img src="/images/jdk8-hashmap/source-12.png" alt="source-12"></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="树化条件"><a href="#树化条件" class="headerlink" title="树化条件"></a>树化条件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当链表长度达到阈值8时，转换成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//满足树化的最小数组长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//当扩容红黑树拆分链表后判断其数量是否大于6，大于则重组红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h5 id="红黑树存储结构-TreeNode"><a href="#红黑树存储结构-TreeNode" class="headerlink" title="红黑树存储结构-TreeNode"></a>红黑树存储结构-TreeNode</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树存储结构对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">//双向链表的前一个结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">//继承Node得到，双向链表的下一个结点</span></span><br><span class="line">    <span class="comment">//Node&lt;K,V&gt; next;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeNode继承的LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedHashMap.Entry继承Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，上文<code>TreeNode</code>实际上是<code>Node</code>的子类，它有着两个属性，一个<code>next</code>，一个<code>prev</code>，也就是说，<strong><code>TreeNode</code>还是一个双向链表</strong>。</p>
<hr>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JDK1.8的HashMap有了红黑树的保障，所以相对于计算Hash值没有JDK1.7那么复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">//对数组初始化或扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 计算数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果头结点的key等于插入的key，赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果P是个红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果P是个链表，HashMap默认</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//使用尾插法插入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当插入第九个元素时，调用树化方法</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当插入的数据刚好落在链表中时</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否要更新，并且返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//自增size后判断是否超过扩容因子（JDK1.7时还有判断当前链表是否有元素）</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h6><h6 id="数组扩容或构建双向链表"><a href="#数组扩容或构建双向链表" class="headerlink" title="数组扩容或构建双向链表"></a>数组扩容或构建双向链表</h6><p><strong>在JDK1.7中，采用头插法插入到链表的头部，而在JDK1.8中，采用的是尾插法插入到链表中，并且当链表的数量大于8时，也就是添加第九个元素时，会调用树化方法<code>treeifyBin</code>，根据条件将链表转换成红黑树。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表树化红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果当前数组为空 或者 数组长度小于64时</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//对数组进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//把Node类型转换成红黑树的TreeNode类型</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//缓存头结点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//建立双向链表关系</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//hd作为链表的头结点，也是红黑树的根节点，遍历链表把其他数值逐个插入到红黑树中</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把Node类型转换成TreeNode类型</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk8-hashmap/source-20.png" alt="source-20"></p>
<h6 id="真正树化"><a href="#真正树化" class="headerlink" title="真正树化"></a>真正树化</h6><p>接下来是真正的将链表树化的逻辑方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//this（链表的头结点），开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//获取链表的下一个结点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//设置结点左右子结点都是NULL</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果root根节点对象等于null，则赋值root根节点对象，并且变黑色</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新增结点的Key的值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//新增结点的hash值</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//Key的数据类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//根节点的key值</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//如果根结点的hash值大于新增结点的hash值，则放在左树上（dir = -1）代表左边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则放在右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果hash值相同，获取key的数据类型，判断是否实现Comparable接口，则调用实现的compareTo方法</span></span><br><span class="line">                <span class="comment">//如果compareTo还相同或者没实现Compareable接口，则调用tieBreakOrder</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//比较getClass().getName() 和 System.identityHashCode</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//一直遍历直到想放的位置没有结点，等于 null</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//赋值新节点x的父节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//如果左边放左边，如果右边放右边</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//执行插入红黑树过程</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把根节点存储到数组中,并且把红黑树的根节点设置成双向链表的根节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="根节点移动到双向链表头部"><a href="#根节点移动到双向链表头部" class="headerlink" title="根节点移动到双向链表头部"></a>根节点移动到双向链表头部</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            <span class="comment">//把红黑树的根节点赋值在数组上</span></span><br><span class="line">            tab[index] = root;</span><br><span class="line">            <span class="comment">//获取红黑树的根节点在双向链表中的前一个结点rp</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="comment">//如果红黑树根节点在双线链表中的下一个结点rn不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//下一个结点的prev指向rp（等于跳过了root）</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="comment">//如果上一个结点rp不为空，它的next指向rn（等于跳过了root）</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="comment">//如果原数组中的存储的链表头结点不为空，则通过头插法，把root插入到first之上</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="红黑树添加新节点"><a href="#红黑树添加新节点" class="headerlink" title="红黑树添加新节点"></a>红黑树添加新节点</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//查找key是否属于红黑树中</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  红黑树的插入逻辑</span></span><br><span class="line"><span class="comment">  @Params</span></span><br><span class="line"><span class="comment">  root 	根节点</span></span><br><span class="line"><span class="comment">  x		即将插入的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新节点默认为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//xp表示父节点，xpp表示x的祖父节点，xppl表示xpp的左孩子结点，xppr表示xpp的右孩子结点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//如果x没有父节点，则表示x是第一个结点，自动成为根节点，根节点为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果父节点是黑色的，不需要做调整</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//上面逻辑已经处理了父节点是黑色的情况，所以下面的逻辑父节点一定是红色的</span></span><br><span class="line">        <span class="comment">//当新节点的父节点是xpp的左叶子节点时</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//叔叔节点不为空 且 叔叔节点等于红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//叔叔节点变黑色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//父节点变黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//祖父节点变红色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//子树调整完成，可能需要递归调整，把祖父节点赋值给x，递归调整</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入else语句 叔叔节点为空或者等于黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当新节点落在父节点的右边时</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    <span class="comment">//重新赋值xp 和xpp的值</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果xp（也就是之前插入的新节点）不为null</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把xp变成黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//祖父节点不为null时，变成红色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//进行右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当新节点的父节点是xpp的右叶子节点，且它的叔叔节点不为空且红色</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//如果新增的父节点p不等于null且 p的右子结点（新增节点） 不等于null</span></span><br><span class="line">    <span class="comment">//1.r = p.right （把新增节点赋值给 r）</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2.p.right = r.left解释：</span></span><br><span class="line">        <span class="comment">//新增的节点r.left默认为null ，将null 赋值给 p.right，等于取消p对r的指针</span></span><br><span class="line">        <span class="comment">//rl != null 时主要用于递归父树左旋</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="comment">//3.r.parent = p.parent</span></span><br><span class="line">        <span class="comment">//将新增的节点r.parent指向p.parent上，也就是新增节点的祖父节点pp</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果等于根节点，赋值黑色</span></span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//用于定位p节点处于pp节点的左侧还是右侧，然后断开pp对p的指向，修改成pp对r的指向</span></span><br><span class="line">        <span class="comment">//如果父节点落在祖父节点的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            <span class="comment">//把r当做pp的左叶子节点</span></span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="comment">//如果父节点落在祖父节点的右边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//把r当做pp右叶子节点</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        <span class="comment">//把p当做r的左叶子节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk8-hashmap/source-15.png" alt="source-15"></p>
<p><img src="/images/jdk8-hashmap/source-16.png" alt="source-16"></p>
<p><img src="/images/jdk8-hashmap/source-17.png" alt="source-17"></p>
<p><img src="/images/jdk8-hashmap/source-18.png" alt="source-18"></p>
<p>完成左旋之后进行变色，变完色之后右旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用  root = rotateLeft(root, xpp); 所以参数 p = xpp</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="comment">//祖父节点p和它的左子节点l不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//用于右旋之后节点分配</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="comment">//如果祖父节点p是根节点，则p.parent等于null，右旋之后，l将作为根节点，所以变色黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果祖父节点p不是根节点，则获取p的父节点pp，右旋之后，pp指向l</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        <span class="comment">//把p作为l的右结点</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk8-hashmap/source-19.png" alt="source-19"></p>
<hr>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>再看一下扩容方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//扩容，长度左移</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//新数组的大小乘以扩容因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果老数组不为空，也就是扩容逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果链表上只有一个元素，直接移动过去并且赋值到数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果数组上的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//链表转移，使用尾插法，链表元素的hash值&amp;旧数组长度，等于0的元素转移到lo链表、其余的元素转移到hi链表，最终newTab[j] = loHead、newTab[j + oldCap] = hiHead完成链表扩容</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//hash值和原数组长度相与，等于0原数组</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//赋值低位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接低位index的结点</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="comment">//赋值高位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接高位index的结点</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表赋值到数组的低位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="comment">//链表赋值到数组的高位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链表扩容"><a href="#链表扩容" class="headerlink" title="链表扩容"></a>链表扩容</h6><p>​    链表转移，使用尾插法，链表元素的hash值&amp;旧数组长度，等于0的元素转移到lo链表、其余的元素转移到hi链表，最终newTab[j] = loHead、newTab[j + oldCap] = hiHead完成链表扩容</p>
<h6 id="红黑树扩容"><a href="#红黑树扩容" class="headerlink" title="红黑树扩容"></a>红黑树扩容</h6><p>​        遍历数组，获取数组上的红黑树root节点进行操作，树节点（treeNode）存在双向链表结构，使用next指针如链表转移一般进行操作，构建高低位链表，记录高位、低位节点个数，头部节点放入数组索引位置</p>
<p>a、节点个数如果小于6则结构改回单向链表（TreeNode-&gt;Node）<br>b、大于6个，如果高低位链表仅存在一个，不需要额外操作，因为整棵树已经迁移；如果两个都存在，重新进行树化<br>c、tab[index] = loHead，tab[index + bit] = hiHead</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组上的红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历红黑树的双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//计数低位index的链表的个数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//计数高位index的链表的个数</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拆分成两个链表之后，比较</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表长度&lt;=6</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//退化成链表赋值到数组中</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当hiHead == null时，则等于红黑树不需要拆分，直接把整棵树（也就是根节点）移动到数组上</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//hiHead不为空时，对低位链表进行树化，整个链表重新创建红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下逻辑和低位链表逻辑相同</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//新数组下标 = 原数组下标 + 原数组长度</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历双向链表，把TreeNode类型转换成Node类型，建立单向链表，返回头结点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a><code>get</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">//如果刚好等于根节点，返回</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它是红黑树，则调用红黑树的查找算法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//否则循环链表查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* h: get的Key的hash值</span></span><br><span class="line"><span class="comment">* k: get的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//判断hash在左边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//在右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//相等且key相同，返回节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//如果左边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//如果右边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果key自定义了比较算法，compare之类的判断走哪一边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">//否则递归查询</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示当前的整个ConcurrentHashMap正在扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建数组时用于Cas操作，设置成 -1 则代表CAS操作成功，然后创建数组，计算扩容的阈值并赋值到sizeCtl上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap中元素的最大值 2的31次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当扩容数组时，待迁移的数组长度值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储扩容时的数组，用以迁移新旧数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure>

<h5 id="红黑树结构对象-TreeBin"><a href="#红黑树结构对象-TreeBin" class="headerlink" title="红黑树结构对象-TreeBin"></a>红黑树结构对象-TreeBin</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把整个红黑树结构封在TreeBin对象中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;\</span><br><span class="line">    <span class="comment">//红黑树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的数组中将存储<code>Node</code>类型和<code>TreeBin</code>类型，<code>TreeBin</code>用于承载红黑树的整个结构，其中有一个<code>root</code>属性存储红黑树的根节点。</p>
<p>这样做的目的是为了后面对红黑树根节点加锁时，直接对<code>TreeBin</code>对象加锁，可以不用考虑在加锁的过程中，红黑树的根节点变化情况。</p>
<h5 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//获取数组下标的Node对象并赋值到f中，并判断是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过cas操作赋值到数组下标中，如果失败则重新循环（就不会再进到这个条件了，因为数组下标内容已经不为空）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ConcurrentHashMap正在扩容，则帮助它进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对链表/红黑树的头节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断加完锁之后头结点是否还是f（避免加锁时被修改了）</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//统计链表长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表，插入</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//尾插法</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度大于8，则进行树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素，总元素数量加1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//放弃对CPU资源的控制，再和其他线程竞争CPU资源</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//CAS对sizeCtl减1，如果成功则创建tab数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 16 - 4 = 12 扩容阈值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//赋值扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//树化前加锁链表头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//改成双向链表</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//链表头结点</span></span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//通过TreeBin的构造方法创建红黑树并赋值到数组上</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于累加计数元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于分治对baseCount进行CAS失败后的资源竞争，等同于LongAdder的计算思想</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于创建CounterCell数组时加锁的状态位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x 表示需要增加的值</span></span><br><span class="line"><span class="comment">//通过CAS对baseCount进行累加操作，若CAS失败，则退而求其次，将累加的值累加到CounterCell篮子里</span></span><br><span class="line"><span class="comment">//避免了多线程情况下对同一个资源竞争，分治，一个资源分散成多个资源CAS</span></span><br><span class="line"><span class="comment">//复制了LongAdder的写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//如果CounterCell数组非空  或  CAS修改BaseCount失败时进入下面逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//满足条件：1.[as == null] 或者 2.[长度小于0] 或者 3.[对应下标的CounterCell对象为空]</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">//下标计算规则：随机数 &amp; as.length - 1</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">//上面的条件均不满足时，也就是CounterCell对象不为空，则将执行第四个逻辑分支</span></span><br><span class="line">            <span class="comment">//4.对CounterCell里的值进行CAS累加</span></span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若上面四个分支条件有一个满足，则进入这个方法</span></span><br><span class="line">            <span class="comment">//进行数组初始化、CounterCell对象初始化、累加x</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当累加操作成功执行后，进入扩容检查逻辑</span></span><br><span class="line">    <span class="comment">//小于0（delete操作）则跳过，大于等于0（add操作）则开启扩容检查</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//当元素大小大于扩容阈值，并且数组长度小于最大值 MAXIMUM_CAPACITY 时，进入扩容逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS将sc 改成一个很小的负数值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//进入扩容逻辑，在该逻辑中会赋值nextTable属性</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x:累加值  wasUncontended: false 表示已经进行过CAS操作并且失败了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//计算数组下标，ThreadLocalRandom.getProbe()同一个线程调用会得到相同的随机数</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//当counterCells数组不为空时</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当对应index的CounterCell对象 == null时</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//并且cellsBusy状态位为0时</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化CounterCell对象</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//通过CAS设置cellsBusy状态位</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//若获得cellsBusy锁时，再进行doubleCheck</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//赋值对象到数组中</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">//设置创建状态</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//重置锁状态位</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//创建状态成功时，跳出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//否则重新进入循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作已经失败过了，则设置它为true，后续的重新循环就不走这个分支了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//对当前的CounterCell对象进行cas操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//当数组和当前对象不符（有其他线程扩容过）或者大于CPU核心数，则把扩容标志位设置成false</span></span><br><span class="line">            <span class="comment">//目的是用来防止无限次扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//CAS失败或者cellsBusy被占用繁忙时，第一次循环会先进行重新计算index下标</span></span><br><span class="line">            <span class="comment">//当第二次循环依旧失败时，走到这个逻辑时，则设置扩容标志位等于true</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//第三次循环进来时，当扩容标志位等于ture时，进行CAS加锁并且扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        <span class="comment">//数组扩容一倍</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据现有的下标重新计算一个新的下标并赋值到 h 上</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果counterCells数组没有初始化，则对cellsBusy进行CAS赋值，类似于Lock状态位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">//doubleCheck，判断依旧没初始化</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    <span class="comment">//初始化CounterCell数组，赋值长度 = 2</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">//创建下标index = 1的CounterCell对象</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    <span class="comment">//设置初始化成功标志位</span></span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//初始化成功，重置状态位</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳出死循环</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上述所有分支时，或者多线程竞争cellsBusy失败时，就CAS竞争baseCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用该对象占用在数组上，表示这个位置正在扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在putval中，有一个分值逻辑代码是这样的，表示如果当前的f.hash == MOVED时，则进行帮助扩容逻辑</span></span><br><span class="line"><span class="comment">//也就是说，在putval的过程中，如果数组中的元素类型是ForwardingNode，则代表它正在扩容</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程进行扩容操作</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//判断数组元素类型，并且扩容数组nextTab是否产生</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//CAS对cs进行加1，sc在扩容时会被设置成一个负数，来一个线程扩容，该值就会加1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tab 原数组  , nextTab 新数组</span></span><br><span class="line"><span class="comment">//这里的扩容逻辑是从右往左，多线程并发扩容，每个线程依次获取某段长度=stride的数据进行扩容迁移</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//计算扩容的步长，多线程情况下，每个线程拾取相对步长的元素进行迁移，并发扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果新数组等于null，则初始化新数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容一倍长度的数组对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值到nextTable属性上</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//待迁移的数组长度</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//创建一个标识正在扩容的对象</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//标记当前线程是否具备继续往左进行数组元素迁移的能力（false表示正在迁移中）</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//标记当前线程是否已经完成了它自身所能够涉及到的数据迁移（我向左找不到了）</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//如果右下标大于左下标（表示有待迁移的数据,右下标自减一直缩），或者当前线程已经完成了扩容迁移</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//赋值nextIndex，并且判断是否有待处理的数组元素，若没有，则设置 i = -1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS修改待迁移的数组长度，假设 transferIndex = 4， stride = 2的话</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      <span class="comment">//计算该线程的应该负责迁移数组元素的起始下标 通过计算得到 4 - 2 = 2</span></span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//表示当前线程需要负责的起始下标，若CAS成功，则赋值到bound = 2</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//表示当前线程需要负责的结束下标 4 - 1 = 3，所以最终该线程负责[2,3]区域</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//获得待负责的区域了，设置状态false</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当上文逻辑判断没有待处理的数组元素时，i = -1 ，会进入当前分支</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//当完成迁移了</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//将新的数组设置到旧的数组属性上</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//重新设置扩容阈值</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程执行完扩容操作，对sc进行自减</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前的sc和之前计算的sc是否相等，若不等则有其他线程还在进行扩容操作，扩容还没完成</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//若相等，则表示所有线程都已经扩容完成，设置完成标识位</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前位置的元素 == null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将ForwardingNode设置到 旧数组tab上，其他线程访问时判断是该对象类型，则会帮助扩容</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//若当前位置已经被迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//锁数组的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//doubleCheck</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//链表的扩容逻辑，和JDK1.7的ConcurrentHashMap迁移一样</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//把旧数组的上的元素改成fwd对象</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置true，继续往左走</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树迁移逻辑，和JDK1.8的HashMap一样</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//把旧数组的上的元素改成fwd对象</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置true，继续往左走</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析完添加元素和累加计数的分治方法之后，再看看统计元素大小的<code>size</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//baseCount + CounterCell[] 的数据，累加起来就是总的Size</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>“本篇文章主要摘自<a href="https://www.bilibili.com/video/BV1x741117jq?p=3" target="_blank" rel="noopener">参考资料</a>”</p>
</blockquote>
]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM（一） 运行时数据区域</title>
    <url>/2021/01/03/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>​        <strong>Java 虚拟机在执行 Java 程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。</strong></p>
<p><img src="/images/jvm/jvm-memory/memory-1.png" alt="memory-1"></p>
<a id="more"></a>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​        程序计数器（<code>Program Counter Register</code>）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>​        <strong>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。</strong></p>
<p>​        因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”</strong>的内存。</p>
<p>​        如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <code>Native</code> 方法，这个计数器值则为空（<code>Undefined</code>）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何<code>OutOfMemoryError</code> 情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​        与程序计数器一样，Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）也是线程私有的，它的生命周期与线程相同。</p>
<p>​        <strong>虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧（<code>Stack Frame</code>）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></p>
<p>​        每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>​        经常有人把Java内存区分为<strong>堆内存</strong>（<code>Heap</code>）和<strong>栈内存</strong>（<code>Stack</code>），这种划分方式的流行只能说明大多数程序员最关注的、域对象内存分配关系最密切的内存区是这两块。Java 内存区域的划分实际上远比这复杂。</p>
<p>​        其中所指的“<strong>栈</strong>”就是虚拟机栈，或者说是虚拟机栈中的局部变量表。<br><img src="/images/jvm/jvm-memory/memory-2.png" alt="memory-2"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>​        局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。</p>
<p>​        基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p>
<p>​        对象引用：<code>reference</code>类型，它不等同于对象本身，可能是个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他于此对象相关的位置</p>
<p>​        <code>returnAddress</code>类型：指向了一条字节码指令的地址</p>
<p>​        其中64位长度的 <code>long</code> 和 <code>double</code> 类型的数据会占用2个局部变量空间（<code>Slot</code>），其余的数据类型只占用1个。<code>Slot</code>是栈帧中的局部变量表的最小单位。</p>
<p>​        局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>​    虚拟机栈规定了两种异常情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常。</li>
<li>如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，将抛出<code>OutOfMemoryError</code>(<code>OOM</code>)异常。</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>​        Java 虚拟机的解释执行引擎被称为“ 基于栈的执行引擎 ”，其中所指的栈就是指－操作数栈。 <strong>操作数栈也常被称为操作栈</strong>，<strong>它是一个后入先出栈</strong>。</p>
<p>​        和局部变量表一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作( <strong>压栈和出栈</strong> )来访问的。</p>
<p>​        比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p>
<p>​        虚拟机在操作数栈中存储数据的方式和在局部变量表中是一样的。</p>
<p>​        虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>​        举例来说，在JVM中执行 <code>a = b + c</code>的字节码执行过程中操作数栈以及局部变量表的变化如下图所示。</p>
<p>​        局部变量表中存储着 <code>a、b、c</code> 三个局部变量，首先将 <code>b</code> 和 <code>c</code> 分别压入栈中，如下图<br><img src="/images/jvm/jvm-memory/memory-3.png" alt="memory-3"><br>​        将栈顶的两个数<strong>出栈执行求和操作，并将结果再次压入栈顶中</strong>，之后将栈顶的数出栈赋值给 <code>a</code>，如下图<br><img src="/images/jvm/jvm-memory/memory-4.png" alt="memory-4"></p>
<p>看一个比较经典的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncrementTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="keyword">int</span> j = i++;</span><br><span class="line">        <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">k = <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>代码分析：</strong></p>
<p><img src="/images/jvm/jvm-memory/memory-5.png" alt="memory-5"></p>
<p>​        如上图，代码 <code>i = i++</code>，自增操作是在局部变量表中的，而不是在操作数栈中，因为是后++操作，所以i的值进入操作数栈之后自身才在局部变量表中自增，然后操作数栈的值会赋值回局部变量表，此时自增的结果被覆盖。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>i</code> 变量，此时 <code>i</code> 的值又变为了 <strong>1</strong></p>
</li>
</ul>
<p><img src="/images/jvm/jvm-memory/memory-6.png" alt="memory-6"></p>
<p>​        如上图，代码 <code>int j = i++</code>，因为是后++操作，i的值先进入操作数栈，自身再在局部变量表进行自增，操作数栈的值赋值给j。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>j</code> 变量，此时 <code>j</code> 的值为 <strong>1</strong></p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
</ul>
<p><img src="/images/jvm/jvm-memory/memory-7.png" alt="memory-7"></p>
<p>​        如上图，代码 <code>int k = i + ++i * i++</code></p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>2</strong> 压入操作数栈中</p>
</li>
<li><p>++i是先++，所以局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，再压入操作数栈中，此时 <code>i</code> 的值为 <strong>3</strong>，</p>
</li>
</ul>
<p><img src="/images/jvm/jvm-memory/memory-8.png" alt="memory-8"></p>
<p>如上图</p>
<ul>
<li>i++是后自增，i的值先进入操作数栈，而后局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code>的值为 <strong>4</strong></li>
<li>把操作数栈中前两个弹出求乘积<strong>（3 * 3 = 9）</strong>，将结果再次压入操作数栈中</li>
<li>把操作数栈中前两个弹出求和<strong>（9 + 2 = 11）</strong>，将结果再次压入操作数栈中</li>
<li>将操作数栈中的值 <strong>11</strong> 赋值给局部变量表中的 <code>k</code> 变量，此时 <code>k</code> 的值为 <strong>11</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>赋值 =，最后计算</li>
<li>= 右边的从左到右加载值依次压入操作数栈</li>
<li>根据运算符的优先级判断先算哪个</li>
<li><strong>自增和自减操作都是直接修改变量的值，不经过操作数栈</strong></li>
<li>最后赋值之前，临时结果都是保存在操作数栈中的</li>
</ul>
<p>值得提醒的是，<code>i++</code>和<code>++i</code>都不是原子操作，因为它并不会作为一个不可分割的操作来执行，实际上它包含三个独立的操作：</p>
<ul>
<li>读取<code>i</code>的值</li>
<li>将值加<code>1</code></li>
<li>然后将计算结果写入<code>i</code><br>这是一个<strong>读取-修改-写入</strong>的操作序列，并且其结果状态依赖于之前的状态。</li>
</ul>
<p>即使使用 <code>volatile</code> 修饰，保证了多个线程多<code>i</code>的可见性，每次从局部变量表读取的都是最新的值，也不是线程安全的。</p>
<p>如果假设 <strong>i=9</strong>，在某些情况下，多个线程读到的值都为 <strong>9</strong>，接着执行递增操作，并且都将<code>i</code>设置成 <strong>10</strong> ，显然不是线程安全的。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>​        每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p>
<p>​        Class 文件中存放了大量的符号引用，这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析，如静态方法、私有方法等等，另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。<br><strong>栈帧中保存了一个引用，指向该方法在运行时常量池中的位置，通过运行时常量池的符号引用（指向堆），完成将符号引用转化为直接引用</strong>。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>方法执行时有两种退出情况：</p>
<ul>
<li><p>正常退出，即正常执行到任何方法的返回字节码指令，如 <code>return</code>等</p>
</li>
<li><p>异常退出，即某些指令导致了 Java 虚拟机抛出异常并且没有处理</p>
</li>
</ul>
<p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p>
<ul>
<li><p>返回值压入上层调用栈帧。</p>
</li>
<li><p>异常信息抛给能够处理的栈帧。</p>
</li>
<li><p>PC计数器指向方法调用后的下一条指令。</p>
</li>
</ul>
<p>当方法执行正常退出时，当前栈帧承担着恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器、跳过刚才执行的方法调用指令等。调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​        本地方法栈（<code>Native Method Stack</code>）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <code>Native</code> 方法服务。<code>Sun HotSpot</code>虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<p>​        与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>​        对于大多数应用来说，Java 堆（<code>Java Heap</code>）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>​        Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做 “ <code>GC</code>堆 ”（<code>Garbage Collected Heap</code>）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 <code>Eden</code> 空间、<code>From Survivor</code> 空间、<code>To Survivor</code> 空间等。</p>
<p>​        从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（<code>Thread Local Allocation Buffer,TLAB</code>）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。</p>
<p>​        Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutOfMemoryError</code>异常。</p>
<p><img src="/images/jvm/jvm-memory/memory-9.png" alt="memory-9"></p>
<p><img src="/images/jvm/jvm-memory/memory-17.png" alt="memory"></p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>​        TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术，目的是提升在堆上创建对象的性能。</p>
<p>​        如果一个对象被创建到堆上时，需要在堆上申请指定大小的内存供新创建的对象使用，在这个过程中，堆会通过加锁或指针碰撞的方式防止同一块被重复申请，在JVM中，内存分配是一个非常频繁的动作，而给堆加锁或者校验碰撞指针的方式必定会影响内存创建效率，TLAB的出现就是为了优化这个问题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">TLAB是线程的一块私有内存:</span><br><span class="line"></span><br><span class="line">1.在线程启动的时候会在堆中为其申请一块指定大小的内存，这块内存只给当前线程使用，属于线程私有的.</span><br><span class="line">如果线程需要为线程内的对象分配内存，就在自己的空间上分配，这样就不存在内存分配竞争的情况了，大大的提升了分配效率。</span><br><span class="line"></span><br><span class="line">2.当TLAB空间容量不足时，就新申请一个TLAB，原来的那个TLAB区里的对象还维持现状，因为对象只能感知到自己在Eden区。</span><br><span class="line"></span><br><span class="line">3.TLAB空间的内存非常小，默认大小仅有Eden区的1%，一般用默认的就可以。</span><br><span class="line">也可以通过JVM参数-XX:TLABWasteTargetPercent设置TLAB空间占Eden空间的百分比大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">-UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置每个TLAB区域占Eden区的大小比例</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">TLABWasteTargetPercent</span></span><br></pre></td></tr></table></figure>

<p>​        每一个TLAB空间大小都是固定的，默认的是Eden区大小的的1%，既然大小是固定的，那么肯定会出现空间浪费的情况，比如TLAB大小是100kb，已经被使用了90kb，此时有一个12kb的对象来申请空间，但是TLAB的剩余空间已经不足以分配给这个对象了，此时怎么办？</p>
<p>​        是新申请一个TLAB，还是直接分配到Eden区？在设计TLAB的时候就已经考虑到这种情况了，<strong>使用变量refill_waste_limit来控制一个TLAB允许被浪费的空间大小</strong>。</p>
<p>​        当申请了新的TLAB后，旧的TLAB交由Eden管理。</p>
<p><img src="/images/jvm/jvm-memory/memory-16.png" alt="memory"></p>
<p><img src="/images/jvm/jvm-memory/memory-18.png" alt="memory"></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        方法区（<code>Method Area</code>）与 Java 堆一样，<strong>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。虽然<br><strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <code>Non-Heap</code>（非堆），目的应该是与 Java 堆区分开来。</p>
<p>​        Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<h4 id="HotSpot-虚拟机"><a href="#HotSpot-虚拟机" class="headerlink" title="HotSpot 虚拟机"></a><code>HotSpot</code> 虚拟机</h4><p>​        它是<code>Sun JDK</code>和<code>OpenJDK</code>中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。<br>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，Oracle同时拥有了两款优秀的Java虚拟机：<code>JRockit VM</code>和<code>HotSpot VM</code>。<br><img src="/images/jvm/jvm-memory/memory-10.png" alt="memory-10"></p>
<h4 id="永久代、元空间"><a href="#永久代、元空间" class="headerlink" title="永久代、元空间"></a>永久代、元空间</h4><p>​        方法区只是 <code>JVM</code> 的一种规范，不同的虚拟机实现的原理不一样，只有JDK1.7及以下才有永久代的概念，JDK1.8称为元空间。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="class常量池"><a href="#class常量池" class="headerlink" title="class常量池"></a>class常量池</h4><p>​        我们写的每一个 Java 类被编译后，就会形成一份<code>class</code> 文件。<code>class</code> 文件中除了包含类的<strong>版本、字段、方法、接口等描述信息外，还有一项信息就是常量池</strong>(<code>constant pool table</code>)，用于存放编译器生成的各种<strong>字面量</strong>(<code>Literal</code>)和<strong>符号引用</strong>(<code>Symbolic References</code>)。</p>
<p>​        每个class文件都有一个class常量池。</p>
<p>字面量包括：</p>
<ul>
<li>文本字符串</li>
<li>八大基本类型的值</li>
<li>被申明为<code>final</code>的常量</li>
</ul>
<p>符号引用包括：</p>
<ul>
<li>类和方法的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<strong>class文件常量池将在类加载后进入方法区的运行时常量池中存放</strong>。</p>
<p>​        一般来说，除了保存 <code>Class</code> 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​        <strong>运行时常量池相对于 <code>Class</code> 文件常量池的另外一个重要特征是具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 <code>Class</code> 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</p>
<p>​        既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，<strong>当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常</strong>。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>​        在<code>HotSpot</code>虚拟机里实现的字符串常量池(<code>string pool</code>)功能的是一个<code>StringTable</code>类，它是一个<code>Hash</code>表，这个<code>StringTable</code>在每个<code>HotSpot</code>虚拟机的实例<strong>只有一份</strong>，被所有的类共享。字符串常量由一个一个字符组成，放在了<code>StringTable</code>上。</p>
<h4 id="JDK版本变化"><a href="#JDK版本变化" class="headerlink" title="JDK版本变化"></a>JDK版本变化</h4><p>​        <strong>JDK1.6及以前的版本，字符串常量池是存放在永久代中。</strong></p>
<p>​        <strong>在JDK1.7的版本中，字符串常量池从永久代移出到正常的Java 堆(Java Heap)中，原因是因为永久代空间太小，容易造成OOM。</strong></p>
<p>​        <strong>在JDK1.8的版本中，Hotspot虚拟机废除了永久代，开始使用元空间（Metaspace）实现方法区，字符串常量池依旧保留在堆内存中，其他内容移至元空间，元空间直接在本地内存分配，而不需要占用堆内存，所以不会造成OOM现象。</strong></p>
<p>​        <strong>值得注意的是，方法区只是Jvm的一种规范，Hotspot通过废除永久代，使用元空间实现方法区，并不存在废除方法区、方法区被元空间代替这种说法。</strong></p>
<p>​        <strong>为什么要使用元空间取代永久代的实现？</strong></p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为 <code>GC</code> 带来不必要的复杂度，并且回收效率偏低</li>
<li>将 <code>HotSpot</code> 与 <code>JRockit</code> 合二为一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"String"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        str.intern();</span><br><span class="line">        str = str + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/jvm/jvm-memory/memory-11.png" alt="memory-11"><br>        使用<strong>JDK1.7 或者 1.8</strong> 能够看到，往字符串常量池中无限增加，最终 <code>OOM</code> 的位置是在Java 堆（<code>Java heap</code>）中。</p>
<p>​        <strong><code>String.intern()</code>用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。</strong></p>
<p>​        看一道比较常见的面试题，在不考虑 <code>GC</code> 的情况下，下面的代码创建了多少个 <code>String</code> 对象，输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure>
<p><strong>答案：</strong></p>
<ul>
<li>在 JDK 1.6 下输出是 <strong><code>false</code></strong>，<strong>创建了 6 个对象</strong></li>
<li>在 JDK 1.7 之后的版本输出是 <strong><code>true</code></strong>，<strong>创建了 5 个对象</strong></li>
</ul>
<p><strong>代码分析：</strong></p>
<p>​        为什么输出会有这些变化呢？主要还是字符串池从永久代中脱离、移入堆区的原因， <code>intern()</code> 方法也相应发生了变化：</p>
<ul>
<li><p>在 <code>JDK 1.6</code> 中，调用 <code>intern()</code> 首先会在字符串池中寻找<code>equal()</code> 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，<strong>虚拟机会重新在永久代上创建一个实例</strong>，将 <code>StringTable</code> 的一个表项指向这个新创建的实例。<br><img src="/images/jvm/jvm-memory/memory-12.png" alt="memory-12"></p>
</li>
<li><p>在 <code>JDK 1.7</code> 中，由于字符串池不在永久代了，<code>intern()</code> 做了一些修改，更方便地利用堆中的对象。字符串存在时和 <code>JDK 1.6</code>一样返回常量池的引用，不存在时如果堆中存在，那也不需要再拷贝字符串的实例到常量池，既然字符串常量池已经移到Java堆中，只需要在常量池里记录一下首次出现的实例引用即可。<br><img src="/images/jvm/jvm-memory/memory-13.png" alt="memory-13"></p>
</li>
</ul>
<p>我们基于JDK1.7版本，来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>由于字符串常量池中已存在<code>abc</code>，所以返回了字符串常量池中的引用，如下图所示<br><img src="/images/jvm/jvm-memory/memory-14.png" alt="memory-14"></p>
<p>再来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">str1.intern();</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>​        该结果等于<code>true</code>应该是能够理解的，不理解的可以查看上文针对该代码的实例分析图</p>
<p>​        这里扩展一点，若是把<code>str1.intern();</code>代码注释掉，则产生的结果为<code>false</code>。</p>
<p>​        其原因在于<code>str1</code>对象是通过<code>new</code>对象拼接产生的，字符串常量池中并不存在字符串<code>hello</code>，当调用<code>String str2=&quot;hello&quot;;</code>代码时字符串常量池中产生才该字符串，所以他们并不是同一个地址引用。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>​        <strong>直接内存（<code>Direct Memory</code>）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</strong>。</p>
<p>​        在 <code>JDK 1.4</code> 中新加入了 <code>NIO</code>，引入了一种基于通道（<code>Channel</code>）与缓冲区（<code>Buffer</code>）的 <code>I/O</code> 方式，它可以使用 <code>Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>​        显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p>
<p><img src="/images/jvm/jvm-memory/memory-15.png" alt="memory-15"></p>
<hr>
<blockquote>
<p>“本篇文章主要摘自《深入理解Java虚拟机_JVM高级特性与最佳实践 第2版》”</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.7 HashMap和ConcurrentHashMap 源码和实现</title>
    <url>/2021/03/31/jdk7-hashmap/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>问题：JDK1.7中，HashMap是通过什么原理实现的呢？</p>
<p>答案：数组+链表</p>
<p>问题：什么叫哈希碰撞（哈希冲突）？</p>
<p>不同的键值通过哈希函数运算得到相同的哈希值，解决哈希冲突的方式有开放寻址法和链表法，ThreadLocalMap由于其元素个数较少，采用的是开放寻址法，而HashMap采用的是链表法来解决哈希冲突，即所有散列值相同的元素都放在相同槽对应的链表中（也就是数组+链表的方式）。</p>
</blockquote>
<a id="more"></a>

<h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><p>先分析一下HashMap的关键属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap初始化容量大小，默认是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">* by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">* MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap最大的容量大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap的扩容因子，默认是0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// If table == EMPTY_TABLE then this is the initial capacity at which the</span></span><br><span class="line"><span class="comment">// table will be created when inflated.</span></span><br><span class="line"><span class="comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；</span></span><br><span class="line"><span class="comment">//当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">//HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//当前HashMap存储的键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">* Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">* the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">* rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">* the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//用于计算链表中的修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap内部的存储结构是一个数组，此处数组为空，即没有初始化之前的状态  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap的主干数组，就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>

<p>HashMap的主干是一个<strong>Entry数组</strong>。Entry是HashMap的基本组成单元，Entry是一个链表，每一个Entry包含一个<code>key-value</code>键值对，每一个Entry都有一个<code>next</code>属性指向下一个<code>Entry</code>对象。</p>
<p>Entry是HashMap中的一个静态内部类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Entry有一个构造函数，该构造函数第三个参数是<code>Entry&lt;K,V&gt; n</code>，<strong>主要用于链表的头插入，传入链表的链表头，将新生成的Entry对象作为链表的头部，<code>next</code>属性指向原链表头。</strong></p>
<p><img src="/images/jdk7-hashmap/source-01.png" alt="source-01"></p>
<hr>
<p>接着看一下<code>HashMap</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当初始化的容量小于0时抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//当初始化容量大于最大值时，修改成最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//这里先把初始化的容量大小赋值给 threshold阈值</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//LinkedHashMap初始化的使用，HashMap类是个空方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>在看HashMap的<code>put</code>方法之前，先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">		String a = map.put(<span class="string">"1"</span>, <span class="string">"3"</span>);</span><br><span class="line">		System.out.println(a);   <span class="comment">//输出结果：2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会输出结果是【2】呢？来HashMap的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用了懒加载，初始化HashMap对象时并未真正赋予其数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当Key等于null时，默认其存储的数组下标是0</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算Key的Hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//将Hash值进行算法计算，得出存储的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历寻找key值是否存在于链表中，存在则替换value成新值，并且返回旧值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//修改次数++</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//不存在于链表中，执行添加操作</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒加载初始化"><a href="#懒加载初始化" class="headerlink" title="懒加载初始化"></a>懒加载初始化</h4><p>接着解析一下<code>put</code>方法的逻辑，可以看到它懒加载时调度了<code>inflateTable</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inflates the table. </span></span><br><span class="line"><span class="comment">* 初始化table数组大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">// 用于获取toSize 大于或等于的 2的次方数 HashMap规定了容量大小必须是2个次方倍</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在看以下运算之前，我们应该了解到，2的幂次方数在二进制位数上只有一个1的存在</span></span><br><span class="line"><span class="comment">	2  0000 0010</span></span><br><span class="line"><span class="comment">	4  0000 0100</span></span><br><span class="line"><span class="comment">	8  0000 1000</span></span><br><span class="line"><span class="comment">	16 0001 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//int java.lang.Integer.highestOneBit(int i) </span></span><br><span class="line"><span class="comment">//返回小于等于i的2的次方数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1			比如：i=17  binary（17）= 0001 0001</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);				<span class="comment">//0001 0001 | 0000 1000 = 0001 1001</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);				<span class="comment">//0001 1001 | 0000 0110 = 0001 1110</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);				<span class="comment">//以下也如此，主要是为了把低数值都填充为1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);				<span class="comment">//0001 1111 | 0000 0000 = 0001 1111</span></span><br><span class="line">    <span class="comment">//以上操作时为了将低位全部变成1</span></span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);		<span class="comment">//0001 1111 - 0000 1111 = 0001 0000</span></span><br><span class="line">    <span class="comment">//如此以上操作我们就得到了小于等于2的幂次方数，因为传入的数值经过左移1处理，即数值翻倍，所以得到的次方数为大于等于原始数值的2的幂次方数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关注代码：<code>Integer.highestOneBit((number - 1) &lt;&lt; 1)</code><br>1、highestOneBit获取的是<strong>小于等于i</strong>的2次方数，而这里需要获取<strong>大于等于i</strong>的2次方数</p>
<p>2、传入的参数值通过向左位移一位，将数字扩大两倍，如number=10，需要将它左移后得到20，通过highestOneBit方法可以获取到小于等于传入值的2次方数，即16，如此便可获得大于等于number的2次方数</p>
<p>3、（number - 1）是为了兼容特殊场景，number刚好等于2的次方数 ，例如16，此时如果直接左位移后传入计算，则得到的数字为32，远远超出我们的需求，所以需要进行减1操作，适配这种情况</p>
</blockquote>
<hr>
<blockquote>
<p>思考：HashMap的采用的数组+链表的存储方式，那么当一个键值对put进来时，它的下标是怎么计算的呢？</p>
<p>思考：为什么HashMap规定了其容量的大小必须是2的幂次方数？其原因是什么？</p>
</blockquote>
<p><code>put</code>方法接着往下看，可以看到，它把<code>Key</code>值拿去做了<code>HashCode</code>运算，并调用<code>indexFor</code>，根据返回的<code>HashCode</code>值<strong>计算该键值对应该存放的Entry数组下标</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns index for hash code h.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>意义</th>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>0001 0000</td>
<td>16</td>
</tr>
<tr>
<td>length-1</td>
<td>0000 1111</td>
<td>15</td>
</tr>
<tr>
<td>HashCode</td>
<td>1010 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0000 1010</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到下标的结果将落在了【0 - 15】 中，通过<code>length -1</code>，将低位全部变成1，进行与运算后，下标必定落在其范围中，这也是为什么规定了HashMap的容量必须是2的次方数。</p>
<p>(Length - 1) &amp; HashCode公式中，因为数组长度需要其加入&amp;运算，当长度减1时，高位变成0，低位全部变成1，与HashCode值进行&amp;运算之后的数值必定落的[0,Length -1]之间,因此保证长度为2的幂次方时，运算可以等同于HashCode%数组长度</p>
<p>细心的同学可以发现，这里参与计算的只有<code>HashCode</code>的地位，而HashCode的高位并没有参与计算，那么就会导致数据分散在数组中会很不均匀，这时候回过头再来看上一行的<code>hash</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当hashSeed!=0时，计算时hash值将加入哈希种子打散hash值的分布</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当取到了<code>hashCode</code>之后，对<code>hashCode</code>进行了右移的异或运算，再将得出的结果拿去计算数组下标，这是为了让<code>hashcode</code>的高位也能参与到数组下标的计算过程当中，解决数据分布不均匀的问题。</p>
<hr>
<p>再接着往下看<code>put</code>方法的执行，定位到数组下标后遍历其链表，判断链表是否存在相同的<code>key</code>值，如果找到，新值覆盖旧值，并且返回旧值。这也是为什么上文例子中，输出的结果是【2】的原因。</p>
<h4 id="扩容判断及添加元素"><a href="#扩容判断及添加元素" class="headerlink" title="扩容判断及添加元素"></a>扩容判断及添加元素</h4><p>接着详细看看<code>put</code>方法中执行的<code>addEntry</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* int hash:	当前Key的Hash值</span></span><br><span class="line"><span class="comment">* bucketIndex:	数组下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//需要扩容时，传参传入了table.length的长度的两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前链表的表头，即数组bucketIndex索引上的元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将key-value键值对赋予到新Entry对象中，并通过头插入法，其Entry的next属性指向原链表表头</span></span><br><span class="line">    <span class="comment">//则新的Entry对象成为了链表的新表头，并将该表头存储在table数组中。</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//添加新元素，hashMap的元素数量++</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：根据源码可以得出，JDK1.7的HashMap插入链表采用的是“头插入”法。</strong></p>
<p>问题：为什么采用头插法呢？</p>
<p>答案：因为头插法效率高，不需要遍历链表。</p>
<p>​        但其实插入之前都需要遍历链表的旧元素，判断是否存在相同的key，存在则修改，没有才会在遍历之后进行头插入新增；所以这里并不能体现出头插法的优势。因为在我们遍历旧链表时，新增情况下，我们可以知道尾节点的元素，因此尾插法也可以直接将元素添加上去；如若修改和插入的方法进行分离，无法记录尾节点的情况下，头插法才能在插入时体现出效率优势。</p>
<p>​        </p>
<p>问题：在添加新的键值对的时候，需要判断是否需要扩容，那么它什么情况下需要扩容？</p>
<p>答案：</p>
<p>1.当前HashMap的键值对数量（size）&gt;= <code>threshold</code>【threshold=capacity（当前数组容量）*loadFactory（扩容因子）】</p>
<p>2.Entry数组上的元素不为空</p>
</blockquote>
<hr>
<blockquote>
<p>问题：HashMap为什么需要扩容？</p>
<p>答案：初始化的Entry数组容量是16，元素过多会导致链表过长，当调用get方法遍历链表时会增加耗时，所以需要通过扩容，将一条链表的数据内容分散成多条链表，添加到扩容数组的新下标中。</p>
</blockquote>
<h4 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h4><p>接下来看看他的扩容逻辑，当满足扩容条件（size大于等于阈值 &amp;&amp; 数组当前索引位置不为空）时，调度了<code>resize</code>方法：</p>
<p>重新计算链表元素的索引位置（h &amp; (length-1)），使用头插法，旧元素next指向新链表索引位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历原Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">//遍历链表中的每一个非空Entry</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新计算该Entry需要存储的数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//将next属性指向原链表头</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">//替换数组中的链表头位置</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//将e元素指向下一个链表中的Entry</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>key的<code>rehash</code>是有条件的</strong>，需要根据参数的布尔值决定它是否需要重新计算hash值，<strong>并不是所有扩容都需要重新计算key的Hash值。</strong></p>
<blockquote>
<p>假设链表中有三个元素，分别是【1、2、3】，具体行为如下：</p>
</blockquote>
<p><img src="/images/jdk7-hashmap/source-02.png" alt="source-02"></p>
<p>在遍历过程中，由于数组下标没有发生变化，其Entry对象依旧将指向新数组的同一个下标，接着循环遍历链表的第二个元素。</p>
<p><img src="/images/jdk7-hashmap/source-03.png" alt="source-03"></p>
<p>遍历第二个元素时，通过表头插入法，其next指向原链表表头，并将自身作为Entry数组的链表头，最终得出的结果如下：</p>
<p><img src="/images/jdk7-hashmap/source-04.png" alt="source-04"></p>
<p>可以看到，<strong>在扩容过程中，计算出来的数组下标没有发生变化时，链表被反序存储了。</strong></p>
<hr>
<blockquote>
<p>问题：怎么将一条链表的数据内容分散成多条链表，添加到扩容数组的新下标中？新下标满足什么规律？</p>
</blockquote>
<p>假设原数组长度是16，那么扩容后则等于32，看看其计算下标的变化：</p>
<table>
<thead>
<tr>
<th>意义</th>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>0010 0000</td>
<td>32</td>
</tr>
<tr>
<td>length-1</td>
<td>0001 1111</td>
<td>31</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Akey：HashCode</td>
<td>1010 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0000 1010</td>
<td>index=10</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bkey：HashCode</td>
<td>1011 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0001 1010</td>
<td>index=26</td>
</tr>
</tbody></table>
<p>可以看到，当<code>Akey=HashCode=1010 1010</code>时，计算的数组下标未发生变化，而当<code>Bkey=HashCode=1011 1010</code>时，计算的等于26，也就是说，<strong>通过这种方式，就能够将属于同一个链表的元素，在重新计算下标的过程中，将链表元素分配到其他新的链表中。</strong></p>
<p><strong>在Hash值未被重新计算的前提下，若链表元素被分配到其他新链表时，其新链表的下标=原下标+原数组长度</strong>。</p>
<hr>
<blockquote>
<p>问题：HashMap为什么在多线程并发的情况下会出现问题？著名的HashMap死锁问题原因是什么？</p>
</blockquote>
<p>假设现在有两条线程同时对同一个HashMap操作，执行<code>put</code>方法，而且<strong>刚好满足扩容条件</strong>时，假设这时候两条线程都运行到了<code>transfer</code>方法的循环语句，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//假设两条多线程都运行到该行位置</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;	</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<strong>代码中遍历的<code>table</code>数组是一个成员变量，是共享的</strong>，所以循环到该点时的指向如下图：</p>
<p><img src="/images/jdk7-hashmap/source-05.png" alt="source-05"></p>
<p>由于Java的多线程并发是通过CPU上下文切换交替执行的，<strong>假设这时候线程2被CPU挂起了，线程1执行完扩容操作，线程2再恢复执行，那么当线程1执行完扩容后，其对应的<code>table</code>数组内容已经发生改变，当线程2被CPU唤醒继续执行扩容时，其结构图如下：</strong></p>
<p><img src="/images/jdk7-hashmap/source-06.png" alt="source-06"></p>
<p>按照代码的流程走向，经过一次while循环以后，值得注意的是，其<strong>e对象指向Entry对象（1），其next对象指向Entry（2）</strong>，得到如下：</p>
<p><img src="/images/jdk7-hashmap/source-07.png" alt="source-07"></p>
<p>再经过一次while循环以后，其原本的<strong>Entry对象（2）的next属性指向Entry对象（1），所以其next对象将会重新指向Entry对象（1）</strong>，将得到下图：</p>
<p><img src="/images/jdk7-hashmap/source-08.png" alt="source-08"></p>
<p>再经过一次while循环以后，<strong>其next对象将会指向null值，而Entry对象（1）的next属性将会指向原表头Entry对象（2）</strong>，将得到下图：</p>
<p><img src="/images/jdk7-hashmap/source-09.png" alt="source-09"></p>
<blockquote>
<p>从逻辑上可以看出，在多线程情况下造成了循环链表，由于最后的循环中的next对象指向了null，所以线程2的扩容是可以执行的，但是当有其他线程遍历该循环链表时，将会造成死循环，耗尽CPU资源，这就是HashMap在多线程并发情况下造成的死锁问题。</p>
</blockquote>
<blockquote>
<p>问题：如何在多线程情况下避免HashMap的死锁问题？</p>
<p>答案：如果已知了数据长度时，可以使用<code>public HashMap(int initialCapacity, float loadFactor)</code>构造函数设置其大小以及扩容因子，使得<code>size &gt;= threshold</code>条件不成立，避免造成扩容。</p>
</blockquote>
<hr>
<p>接着再回去看看<code>resize</code>和<code>transfer</code>方法，通过源码得知，<code>initHashSeedAsNeeded</code>方法是控制是否需要重算<code>hash</code>值，在它在什么情况下需要重算<code>key</code>的<code>hash</code>值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始条件下 哈希种子hashSeed=0，所以currentAltHashing = false;</span></span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//具体逻辑：当capacity 大于 Holder.ALTERNATIVE_HASHING_THRESHOLD时，才可能重算Hash</span></span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">        (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="comment">//取异或 不相等才返回true</span></span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后跟踪源码得知，<strong>在默认情况下，无论怎么扩容都不会造成重算Hash值，除非配置了JVM启动参数<code>jdk.map.althashing.threshold</code>。这里哈希种子的目的就是为了打散链表的hash值，使得每次扩容时，各链表分布更加均匀，</strong>这里就不再详细讨论了。</p>
<hr>
<p>在<code>HashMap</code>的属性中，定义了一个<code>transient int modCount;</code>，用来记录该对象的修改次数，<strong>是hashMap提供的一种快速失败机制（<code>fast fail</code>），用于迭代遍历时校验对象是否被修改，当集合在迭代过程中对象被其他线程并发修改时，将会抛出<code>ConcurrentModificationException</code>异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在遍历集合之前会将modCount赋值给expectedModCount，接着遍历过程中会不断验证modCount是否发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    current = e;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：那想要在遍历集合的过程中删除集合的元素，该如何实现？</p>
<p>答案：通过使用<code>Iterator</code>迭代器遍历集合，调用迭代器的<code>remove</code>方法删除元素，该方法在删除元素的时候会重新对<code>expectedModCount</code>赋值，保证了<code>modCount == expectedModCount</code>。</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>众做周知，HashMap就算避免了死锁问题，也不是一个线程安全的集合，而<strong><code>HashTable</code>类就是达到通过对HashMap里的各个方法加<code>synchronized</code>锁实现HashMap集合的线程安全，<code>HashTable</code>是一个同步容器类</strong>。</p>
<h4 id="属性结构-1"><a href="#属性结构-1" class="headerlink" title="属性结构"></a>属性结构</h4><p>而<code>ConcurrentHashMap</code>是一个并发容器类，底层使用了<code>Segment</code>分段锁的原理，先从源码中看看它和<code>HashMap</code>相比，属性上的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default concurrency level for this table, used when not</span></span><br><span class="line"><span class="comment">* otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//并发级别，用于计算一个Segment负责管理多少个Entry数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The minimum capacity for per-segment tables.  Must be a power</span></span><br><span class="line"><span class="comment">* of two, at least two to avoid immediate resizing on next use</span></span><br><span class="line"><span class="comment">* after lazy construction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//规定了segment中的HashEntry数组最小容量，数组容量必须是2的次方数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum number of times to tryLock in a prescan before</span></span><br><span class="line"><span class="comment">* possibly blocking on acquire in preparation for a locked</span></span><br><span class="line"><span class="comment">* segment operation. On multiprocessors, using a bounded</span></span><br><span class="line"><span class="comment">* number of retries maintains cache acquired while locating</span></span><br><span class="line"><span class="comment">* nodes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取锁失败时，tryLock循环的最大次数，获取当前CPU核数，大于1则设置成64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">    Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum number of segments to allow; used to bound</span></span><br><span class="line"><span class="comment">* constructor arguments. Must be power of two less than 1 &lt;&lt; 24.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//规定了segment数组的最大值不能超过2的16次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Mask value for indexing into segments. The upper bits of a</span></span><br><span class="line"><span class="comment">* key's hash code are used to choose the segment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//segmentMask = segment[].length - 1 用来执行【haschCode &amp; segmentMask】计算Hash值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//ConcurrentHashMap的分段锁对象，自身带了一把锁且存储了链表结构</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<hr>
<p>在<code>HashEntry</code>类<code>ConcurrentHashMap</code>是的基础单元(节点)，是实际数据的载体，等同于<code>HashMap</code>中的<code>Entry</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk7-hashmap/source-10.png" alt="source-10"></p>
<hr>
<p><code>Segment</code> 继承 <code>ReentrantLock</code> 锁,用于存放数组 <code>HashEntry[]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">* subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">* simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum number of times to tryLock in a prescan before</span></span><br><span class="line"><span class="comment">    * possibly blocking on acquire in preparation for a locked</span></span><br><span class="line"><span class="comment">    * segment operation. On multiprocessors, using a bounded</span></span><br><span class="line"><span class="comment">    * number of retries maintains cache acquired while locating</span></span><br><span class="line"><span class="comment">    * nodes.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//HashEntry数组，ConcurrentHashMap数据的存储的载体</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment">    * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//HashEntry的数组中的所有HashEntry大小（包括链表）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//HashEntry数组的变化次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">	<span class="comment">//扩容阈值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">	<span class="comment">//扩容因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdk7-hashmap/source-12.jpg" alt="source-12"></p>
<hr>
<h4 id="构造初始化"><a href="#构造初始化" class="headerlink" title="构造初始化"></a>构造初始化</h4><p>在看看<code>ConcurrentHashMap</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">     * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//规定了不能大于2的16次方</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">//该值用于存储segment数组容量的次方数</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//ssize小于并发级别则循环，并发级别默认16，该循环主要是找大于等于concurrencyLevel的2的次方数</span></span><br><span class="line">    <span class="comment">//默认的并发级别concurrencyLevel=16，循环4次后，sshift=4,ssize=16</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;<span class="comment">//28 = 32 - 4</span></span><br><span class="line">    <span class="comment">//ssize为segment[]的数组长度，所以segmentMask=segment.length-1</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//c相当于initialCapacity与ssize相差的倍数值，因除法可能舍弃小数位，所以有c * ssize &lt; initialCapacity的判断，进行自增，有小数位的情况下c会自增1</span></span><br><span class="line">    <span class="comment">//用于之后的cap计算</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">//cap是HashEntry数组大小，默认最小值为2</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//规定HashEntry数组必须是2的次方数，所以循环获取大于等于计算的HashEntry数组大小的2的次方数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">//在初始化Segment数组时默认初始化segment[0]，主要是为了生成原型，当初始化其他segment对象时无需再计算HashEntry数组大小</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其构造函数相比<code>HashMap</code>，多了一个<code>concurrencyLevel</code>参数，该参数主要是用来设置并发级别，用于</p>
<p>计算每个<code>segment</code>的<code>HashEntry</code>数组大小，<code>ConcurrentHashMap</code>规定了<code>segment</code>数组和<code>HashEntry</code>数组的大小必须是2的次方数，其缘由与<code>HashMap</code>一致。</p>
<blockquote>
<p><code>ConcurrentHashMap</code>构造方法的执行步骤：</p>
<p>1.判断参数的范围合法性</p>
<p>2.计算<code>concurrencyLevel</code>大于等于2的次方数</p>
<p>3.设置<code>segmentMask</code>的值</p>
<p>4.计算<code>segment</code>对象的<code>HashEntry</code>数组长度</p>
<p>5.设置<code>HashEntry</code>数组长度的合理长度（2&lt;=计算的HashEntry数组长度&lt;=合理长度=2的次方数）</p>
<p>6.根据合理的<code>segment</code>数组长度及<code>HashEntry</code>数组长度初始化<code>Segment[]</code>和<code>Segment[0]</code></p>
</blockquote>
<hr>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>接着看<code>ConcurrentHashMap</code>的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">//concurrentHashMap规定了Key和Value不能为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算Key的Hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//计算需要存储的segment数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//获取segment数组中的第j个位置的segment对象并赋值给对象s，如果为null，则初始化segment对象并存储进数组中</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">//将key-value键值对存储到segment中的HashEntry数组中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文中通过调用<code>UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)</code>获取<code>Segment</code>数组中的第<code>j</code>个下标的<code>segment</code>对象，因为通过这种偏移量获取对象效率会高很多。</p>
<blockquote>
<p>问题：在计算segment数组下标时，为什么需要执行<code>(hash &gt;&gt;&gt; segmentShift)</code>向右位移呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过观察ConcurrentHashMap的构造函数，其中有部分代码如下：</span></span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br></pre></td></tr></table></figure>

<p>上文分析了构造函数，该循环用于计算大于等于<code>concurrencyLevel</code>的2的次方数，假设<code>concurrencyLevel=16</code>，那么通过循环得知<code>sshift=4</code>，<code>segmentShift = 32 - sshift = 28</code>。</p>
<p><img src="/images/jdk7-hashmap/source-13.png" alt="source-13"></p>
<p>如上图，其向右无符号位移28（<code>segmentShift=28</code>）位，最后将保留<code>HashCode</code>的高4（<code>sshift=4</code>）位，并使用<code>HashCode</code>的高位和<code>segmentMark</code>相与计算所在的<code>segment</code>数组下标。</p>
<p><strong>总而言之，就是取了<code>HashCode</code>的高位，和<code>segmentMask</code>计算数组下标</strong>，向右偏移获取<code>HashCode</code>高位的数量取决于初始化的<code>concurrencyLevel</code>的值，是2的几次方。</p>
<hr>
<p>当<code>put</code>方法执行计算<code>Segment[]</code>下标后，获取的<code>segment</code>对象有可能尚未初始化，根据逻辑会调度<code>ensureSegment</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">//进入方法后重新判断是否被其他线程初始化，若被初始化，则直接赋值seg对象并返回</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取segment[0]对象，以它为原型初始化segment对象</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">//获取原型的HashEntry数组长度</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="comment">//获取扩容因子</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="comment">//计算阈值</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">//double Check，再次判断是否已被其他线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">//创建Segment对象</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">//采用CAS自旋，将新生成的Segment对象塞进数组中，若失败，则获取数组对象返回</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析，当有多个线程同时并发执行创建同一个数组下标的<code>segment</code>对象时，由于<code>CAS</code>自旋机制，最终只会有一个线程创建成功，其他线程将获取数组对象并返回，从而达到在并发情况下的线程安全。</p>
<hr>
<p>创建完<code>segment</code>对象后，将调用<code>Segment.put()</code>方法，添加<code>key-value</code>键值对到<code>Segment</code>对象中，我们来看看<code>Segment</code>类的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试加锁 tryLock不阻塞</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//计算存储的HashEntry数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取HashEntry数组中的index下标，这里命名的first指的是HashEntry中的链表的头结点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//普通put方法的onlyIfAbsent=false，有相同的key，进入判断，更新旧值，返回旧值，</span></span><br><span class="line">                    <span class="comment">//putIfAbsent方法的onlyIfAbsent=true，有相同的key，不会进入此判断，不更新旧值，返回旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设遍历到最后节点均未匹配到相同的key由于它是最后的链表节点，e.next==null</span></span><br><span class="line">                <span class="comment">//再次循环时，将会运行到下面的else条件新建节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当获取锁失败时，会调用scanAndLockForPut提前生成node对象，这里只需设置链表头即可</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建HashEntry对象，采用头插法，新的HashEntry对象的next属性指向first</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//HashEntry总数+1</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果数量达到了扩容的阈值，则进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//添加HashEntry对象到数组中，并替换数组中的链表头（替换成新创建的HashEntry对象）</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                <span class="comment">//Setment中累加变化次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//赋值新计算的count值</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁ReentrantLock</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>Segment</code>继承了<code>ReentrantLock</code>，当它在插入元素时会调用<code>tryLock</code>非阻塞尝试获取锁，当获取锁失败时，调用<code>scanAndLockForPut</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment">* acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment">* return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment">* methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment">* traversal speed doesn't matter, we might as well help warm</span></span><br><span class="line"><span class="comment">* up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Hash值计算数组下标并获取链表的表头</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用这个变量来控制循环的逻辑</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">//循环尝试获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当链表的表头 == null 或者遍历链表后未匹配到元素时，创建HashEntry对象</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//设置retries=0用以下次循环时调用其他逻辑</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当链表表头不为空时，遍历链表，寻址到链表元素时设置retries=0调用其他逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//当链表遍历到最后一个节点，e.next=null,当再次循环时，会调用创建HashEntry对象的逻辑</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当重试次数大于一定的次数时，直接调用阻塞的Lock方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(retries &amp; 1) == 0 ：当retries是偶数时，返回true，表示每隔一次才去判断链表表头是否发生变化</span></span><br><span class="line">        <span class="comment">//重新获取链表表头，当链表表头与原来获取的first不同时，设置retries=-1，重新遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了，当尝试获取锁失败而调度<code>scanAndLockForPut</code>方法，其目的是为了在无法获取锁的时候能够提前创建<code>HashEntry</code>对象并返回。</p>
<hr>
<blockquote>
<p>回头接着看<code>Segment</code>的<code>put</code>方法的步骤：</p>
<p>1.当<code>Segment</code>获取到锁之后，先进行遍历，判断<code>HashEntry</code>是否有同样的<code>key</code>值存在</p>
<p>2.若key值存在，根据参数<code>onlyIfAbsent</code>判断是否覆盖<code>value</code>值，并返回旧值</p>
<p>3.若key值不存在，则创建HashEntry对象并设置链表头（有可能在获取锁时创建）</p>
<p>4.判断其扩容条件，若需要扩容，则进行链表重排</p>
<p>5.若不需要扩容，则添加HashEntry对象到数组中，并替换数组中的链表头</p>
<p>6.更新count值和modCount值</p>
</blockquote>
<hr>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>接着来看看其扩容的方法，当满足<code>count + 1 &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>条件时，将调用<code>rehash</code>扩容方法：</p>
<p>segement数组不扩容，HashEntry数组进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：这里传的参数是新的HashEntry对象，其next属性指向原链表的头部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//向左偏移1位，扩容一倍大小</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">//初始化新的HashEntry数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">//HashEntry[].length - 1 用于计算Hash值</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历旧的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//计算出新的HashEntry数组下标</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="comment">//当链表中只有一个元素时，直接将该元素赋值到数组中</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">//该循环的目的是从链表尾部截取出一条与链表末尾节点的新数组下标相同，并且相连的链表</span></span><br><span class="line">                <span class="comment">//并存储该截取链表的头对象到lastRun对象，存储新数组下标到lastIdx中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//直接移动尾部截取的链表到新的数组下标中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">//重新顺着从原链表头开始遍历，遍历到lastRun，也就是链表截取处时，跳出循环</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">//采用头插法讲一个个元素分别插入到链表头中，并赋值给HashEntry数组</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原链表扩容完成之后，计算新的HashEntry的下标</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">//替换链表头</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    <span class="comment">//赋值到HashEntry数组中</span></span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的扩容逻辑和<code>HashMap</code>不太一样，<code>HashMap</code>存在逻辑判断可能会重新计算<code>key</code>的<code>hash</code>值，而<code>ConcurrentHashMap</code>并没有，所以它的必定满足<strong>新数组下标=原下标+原数组长度</strong>。</p>
<p><strong>它的扩容并非直接遍历整张链表，而是先遍历一次链表，计算每个元素的新数组下标，如果从某个A元素开始，一直到链表遍历完成，他们计算的新数组下标均相同，意味着可以直接截取该链表，从A元素开始一致到末尾，整条迁移到新节点上，如下图：</strong></p>
<p><img src="/images/jdk7-hashmap/source-11.png" alt="source-11"></p>
<p><strong>当迁截取部分链表赋值到新数组之后，遍历原链表，采用头插法插入链表，并赋值到新数组中，一直遍历到截取的A元素位置时挑出循环。最后才将新增的元素对象插入到扩容的数组中。</strong></p>
<hr>
<p>最后看看<code>Segment</code>类中的<code>put</code>方法中调用的<code>setEntryAt</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the ith element of given table, with volatile write</span></span><br><span class="line"><span class="comment">     * semantics. (See above about use of putOrderedObject.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setEntryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>UNSAFE</code>调用CPU指令，意思是将<code>HashEntry</code>对象赋值到<code>HashEntry</code>数组的<code>index</code>下标中。</p>
<hr>
<h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><p>接着看看<code>ConcurrentHashMap</code>的<code>size</code>方法，它的设计思想可以在编码中借鉴：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//当重试次数超过2次时，开启加锁计算</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//累加各个segment的修改次数</span></span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="comment">//累加各个segment的元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次循环：当ConcurrentHashMap的modCount=0时，代表没元素，跳出循环</span></span><br><span class="line">                <span class="comment">//第二次循环：和上一次循环计算的元素总数量数比较，如果相同返回，不同则加锁</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//第一次循环计算的元素总数量赋值给last</span></span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实它的实现逻辑很简单，先在不加锁的情况下，进行计算，第一次计算的结果和第二次计算的结果相同时，就认为这个结果是稳定的，直接返回，当两次计算的结果不相同时，则进行加锁计算。</p>
<hr>
<blockquote>
<p>“本篇文章主要摘自<a href="https://www.bilibili.com/video/BV1x741117jq?p=3" target="_blank" rel="noopener">参考资料</a>”</p>
</blockquote>
]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>maven安装</title>
    <url>/2020/11/29/maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="1-下载地址：http-maven-apache-org-download-cgi"><a href="#1-下载地址：http-maven-apache-org-download-cgi" class="headerlink" title="1. 下载地址：http://maven.apache.org/download.cgi"></a>1. 下载地址：<code>http://maven.apache.org/download.cgi</code></h3><a id="more"></a>

<h3 id="2-解压："><a href="#2-解压：" class="headerlink" title="2. 解压："></a>2. 解压：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-重命名："><a href="#3-重命名：" class="headerlink" title="3. 重命名："></a>3. 重命名：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-maven-3.6.3 maven3.6.3</span><br></pre></td></tr></table></figure>



<h3 id="4-添加环境变量："><a href="#4-添加环境变量：" class="headerlink" title="4. 添加环境变量："></a>4. 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$M2_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<h3 id="5-让修改生效："><a href="#5-让修改生效：" class="headerlink" title="5. 让修改生效："></a>5. 让修改生效：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="6-验证："><a href="#6-验证：" class="headerlink" title="6. 验证："></a>6. 验证：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

<h3 id="7-修改配置文件"><a href="#7-修改配置文件" class="headerlink" title="7. 修改配置文件"></a>7. 修改配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3&#x2F;conf&#x2F;settings.xml</span><br><span class="line">	&lt;!-- 本地仓库 --&gt;</span><br><span class="line">	&lt;localRepository&gt;&#x2F;usr&#x2F;local&#x2F;mvn_repository&lt;&#x2F;localRepository&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--使用阿里云，速度比官方快很多行指定中央仓库的镜像。--&gt;</span><br><span class="line">	&lt;mirror&gt;</span><br><span class="line">		&lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">		&lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;</span><br><span class="line">	&lt;&#x2F;mirror&gt;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&lt;!--更改Maven的默认jdk版本 --&gt;</span><br><span class="line">	&lt;profile&gt;</span><br><span class="line">		&lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;activation&gt;</span><br><span class="line">			&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">			&lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;</span><br><span class="line">		&lt;&#x2F;activation&gt;</span><br><span class="line">		&lt;properties&gt;</span><br><span class="line">			&lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">			&lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">			&lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;</span><br><span class="line">		&lt;&#x2F;properties&gt;</span><br><span class="line">   &lt;&#x2F;profile&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>maven</category>
      </categories>
  </entry>
  <entry>
    <title>mycat基本安装及高可用部署</title>
    <url>/2021/05/07/mycat%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、<a href="http://dl.mycat.org.cn/1.6.7.5/2020-4-10/" target="_blank" rel="noopener">下载</a></h3><h3 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h3><p>解压安装包，<code>-C</code>指定安装目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.5-release-20200422133810-linux.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="3、前台启动"><a href="#3、前台启动" class="headerlink" title="3、前台启动"></a>3、前台启动</h3><p>进入mycat的bin目录下执行启动<code>cd /usr/local/mycat/bin</code></p>
<p><img src="/images/linux/mycat/mycat%E7%9A%84bin%E7%9B%AE%E5%BD%95.jpg" alt=""></p>
<p>通过执行<code>./mycat help</code>查看相关命令，其中<code>console</code>为控制台启动，其余命令为后台操作</p>
<p><img src="/images/linux/mycat/mycat%E7%9A%84help%E5%91%BD%E4%BB%A4.jpg" alt=""></p>
<p><code>./mycat console</code>控制台启动后，如图可以看到缺少日志目录而报错</p>
<p><img src="/images/linux/mycat/mycat%E7%9A%84%E7%BC%BA%E5%B0%91%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95.jpg" alt="mycat的缺少日志目录"></p>
<p>查看mycat目录，确实没有logs层级需要<code>mkdir /usr/local/mycat/logs</code>创建对应的层级目录</p>
<p><img src="/images/linux/mycat/%E6%9F%A5%E7%9C%8Bmycat%E7%9B%AE%E5%BD%95.jpg" alt=""></p>
<h3 id="4、登录"><a href="#4、登录" class="headerlink" title="4、登录"></a>4、登录</h3><p>mycat有两个端口，<code>9066</code>是管理控制台端口、<code>8066</code>是操作端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用8066端口连接mycat</span><br><span class="line">mysql -uroot -pRoot_123 -P 8066</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/%E8%BF%9E%E6%8E%A5mycat.jpg" alt=""></p>
<h3 id="5、环境变量"><a href="#5、环境变量" class="headerlink" title="5、环境变量"></a>5、环境变量</h3><p>配置环境变量，可以在任意地方直接使用<code>mycat</code>命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> MYCAT_HOME=/usr/<span class="built_in">local</span>/mycat</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$MYCAT_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#让添加的配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8console%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.jpg" alt=""></p>
<h3 id="6、配置"><a href="#6、配置" class="headerlink" title="6、配置"></a>6、配置</h3><h4 id="6-1、server-xml"><a href="#6-1、server-xml" class="headerlink" title="6.1、server.xml"></a>6.1、<code>server.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License"); </span></span><br><span class="line"><span class="comment">	- you may not use this file except in compliance with the License. - You </span></span><br><span class="line"><span class="comment">	may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 </span></span><br><span class="line"><span class="comment">	- - Unless required by applicable law or agreed to in writing, software - </span></span><br><span class="line"><span class="comment">	distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT </span></span><br><span class="line"><span class="comment">	WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the </span></span><br><span class="line"><span class="comment">	License for the specific language governing permissions and - limitations </span></span><br><span class="line"><span class="comment">	under the License. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:server <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"server.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>Root_123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSchema"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2、schema-xml"><a href="#6-2、schema-xml" class="headerlink" title="6.2、schema.xml"></a>6.2、<code>schema.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- name：逻辑库名</span></span><br><span class="line"><span class="comment">             checkSQLschema ：是否自带库名</span></span><br><span class="line"><span class="comment">             sqlMaxLimit：默认数据查询限制，如果SQL语句没带限制，会默认带上，如果带了，则以带的为准</span></span><br><span class="line"><span class="comment">             dataNode:真实数据库节点</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			dataNode的name与schema的dataNode对应；</span></span><br><span class="line"><span class="comment">			dataHost属性与dataHost标签的name对应</span></span><br><span class="line"><span class="comment">			database:真正的库名</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"mytest"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			dbDriver="jdbc"修改为native </span></span><br><span class="line"><span class="comment">			maxCon:最大连接数</span></span><br><span class="line"><span class="comment">			minCon:最小连接数</span></span><br><span class="line"><span class="comment">			balance：读库和写库的负载均衡策略(具体策略看下文)</span></span><br><span class="line"><span class="comment">			writeType：表示写操作发送到哪台机器</span></span><br><span class="line"><span class="comment">			switchType：表示如何进行切换</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 心跳检测使用的sql语句 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            	<span class="comment">&lt;!-- 写库配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">	                    <span class="comment">&lt;!-- 读库配置，可以与写库在同一个库，可以不同（读写分离） --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3、负载策略"><a href="#6-3、负载策略" class="headerlink" title="6.3、负载策略"></a>6.3、负载策略</h4><ul>
<li>balance=0:不开启读写分离机制，所有读操作都发送到当前可用的writehost上</li>
<li>balance=1:全部的readhost和stand by writehost参与select 语句的负载均衡，简单的说，当双主双从模式下，其他的节点都参与select语句的负载均衡</li>
<li>balance=2:所有读操作都随机的在writehost，readhost上分发</li>
<li>balance=3:所有读请求随机的分发到readhost执行，writehost不负担读压力</li>
</ul>
<p>修改<code>balance=&quot;2&quot;</code>，<code>mycat restart</code>重启mycat，测试负载情况</p>
<img src="/images/linux/mycat/mycat负载.jpg" style="zoom:80%;" />

<h3 id="7、后台启动"><a href="#7、后台启动" class="headerlink" title="7、后台启动"></a>7、后台启动</h3><p><code>mycat start</code></p>
<p><img src="/images/linux/mycat/start%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.jpg" alt=""></p>
<p><code>mycat status</code>查看状态</p>
<p><img src="/images/linux/mycat/mycat%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<hr>
<h2 id="二、mycat的高可用"><a href="#二、mycat的高可用" class="headerlink" title="二、mycat的高可用"></a>二、mycat的高可用</h2><p>​        在之前的操作中，我们已经实现了mysql机器的高可用，可以动态切换master，那么如果mycat崩溃了呢？我们应该如何处理呢？所以此时就需要搭建mycat的高可用集群了。</p>
<p>​        在mycat的权威指南中，介绍了多种高可用的方案，在这里我们讲解一种使用最多的方案，使用HAProxy+Keepalived配合使用来实现myact的高可用。</p>
<p>​        HAproxy实现了mycat多借点的集群高可用和负载均衡，而HAProxy自身的高可用则可以通过Keepalived来实现。</p>
<img src="/images/linux/mycat/mycat高可用.png" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>编号</th>
<th>角色</th>
<th>IP地址</th>
<th>机器名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>mycat1</td>
<td>192.168.243.131</td>
<td>node01</td>
</tr>
<tr>
<td>2</td>
<td>mycat2</td>
<td>192.168.243.132</td>
<td>node02</td>
</tr>
<tr>
<td>3</td>
<td>HAProxy(master)</td>
<td>192.168.243.133</td>
<td>node03</td>
</tr>
<tr>
<td>4</td>
<td>Keepalived(master)</td>
<td>192.168.243.133</td>
<td>node03</td>
</tr>
<tr>
<td>5</td>
<td>HAProxy(backup)</td>
<td>192.168.243.135</td>
<td>node04</td>
</tr>
<tr>
<td>6</td>
<td>keepalived(backup)</td>
<td>192.168.243.135</td>
<td>node04</td>
</tr>
</tbody></table>
<hr>
<h3 id="1、安装配置HAProxy"><a href="#1、安装配置HAProxy" class="headerlink" title="1、安装配置HAProxy"></a>1、安装配置HAProxy</h3><p>​    在node-3和node-4安装<a href="https://src.fedoraproject.org/repo/pkgs/haproxy/" target="_blank" rel="noopener">HAProxy</a></p>
<h4 id="1-1、准备好HAProxy的安装包"><a href="#1-1、准备好HAProxy的安装包" class="headerlink" title="1.1、准备好HAProxy的安装包"></a>1.1、准备好HAProxy的安装包</h4><h4 id="1-2、解压到-usr-local目录"><a href="#1-2、解压到-usr-local目录" class="headerlink" title="1.2、解压到/usr/local目录"></a>1.2、解压到/usr/local目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf haproxy-1.8.25.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3、进入到解压后的目录，查看内核版本，进行编译"><a href="#1-3、进入到解压后的目录，查看内核版本，进行编译" class="headerlink" title="1.3、进入到解压后的目录，查看内核版本，进行编译"></a>1.3、进入到解压后的目录，查看内核版本，进行编译</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/haproxy-1.8.25/</span><br><span class="line">uname -r</span><br><span class="line">make TARGET=generic</span><br></pre></td></tr></table></figure>

<h4 id="1-4、编译完成之后，开始进行安装"><a href="#1-4、编译完成之后，开始进行安装" class="headerlink" title="1.4、编译完成之后，开始进行安装"></a>1.4、编译完成之后，开始进行安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make install PREFIX=/usr/<span class="built_in">local</span>/haproxy</span><br></pre></td></tr></table></figure>

<h4 id="1-5、安装完成之后，创建目录，创建HAProxy配置文件"><a href="#1-5、安装完成之后，创建目录，创建HAProxy配置文件" class="headerlink" title="1.5、安装完成之后，创建目录，创建HAProxy配置文件"></a>1.5、安装完成之后，创建目录，创建HAProxy配置文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/data/haproxy</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/haproxy/conf</span><br><span class="line">vi /usr/<span class="built_in">local</span>/haproxy/conf/haproxy.conf</span><br></pre></td></tr></table></figure>

<h4 id="1-6、向配置文件中添加配置信息"><a href="#1-6、向配置文件中添加配置信息" class="headerlink" title="1.6、向配置文件中添加配置信息"></a>1.6、向配置文件中添加配置信息</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">        <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">        <span class="comment">#log 127.0.0.1 local1 notice</span></span><br><span class="line">        <span class="comment">#log loghost local0 info</span></span><br><span class="line">        maxconn 4096</span><br><span class="line">        chroot /usr/<span class="built_in">local</span>/haproxy</span><br><span class="line">        pidfile /usr/data/haproxy/haproxy.pid</span><br><span class="line">        uid 99</span><br><span class="line">        gid 99</span><br><span class="line">        daemon</span><br><span class="line">        <span class="comment">#debug</span></span><br><span class="line">        <span class="comment">#quiet</span></span><br><span class="line">defaults</span><br><span class="line">		<span class="built_in">log</span> global</span><br><span class="line">		mode tcp</span><br><span class="line">		option abortonclose</span><br><span class="line">		option redispatch</span><br><span class="line">		retries 3</span><br><span class="line">		maxconn 2000</span><br><span class="line">		timeout connect 5000</span><br><span class="line">		timeout client 50000</span><br><span class="line">		timeout server 50000</span><br><span class="line">listen proxy_status</span><br><span class="line">	<span class="built_in">bind</span> :48066</span><br><span class="line">		mode tcp</span><br><span class="line">		balance roundrobin</span><br><span class="line">		server mycat_1 192.168.243.131:8066 check inter 10s</span><br><span class="line">		server mycat_2 192.168.242.132:8066 check inter 10s</span><br><span class="line">frontend admin_stats</span><br><span class="line">	<span class="built_in">bind</span> :7777</span><br><span class="line">		mode http</span><br><span class="line">		stats <span class="built_in">enable</span></span><br><span class="line">		option httplog</span><br><span class="line">		maxconn 10</span><br><span class="line">		stats refresh 30s</span><br><span class="line">		stats uri /admin</span><br><span class="line">		stats auth admin:123123</span><br><span class="line">		stats hide-version</span><br><span class="line">		stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure>

<h4 id="1-7、启动haproxy服务"><a href="#1-7、启动haproxy服务" class="headerlink" title="1.7、启动haproxy服务"></a>1.7、启动haproxy服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/haproxy/sbin/haproxy -f /usr/<span class="built_in">local</span>/haproxy/conf/haproxy.conf</span><br></pre></td></tr></table></figure>

<h4 id="1-8、查看haproxy的进程，如果存在则说明没有问题"><a href="#1-8、查看haproxy的进程，如果存在则说明没有问题" class="headerlink" title="1.8、查看haproxy的进程，如果存在则说明没有问题"></a>1.8、查看haproxy的进程，如果存在则说明没有问题</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep haproxy</span><br></pre></td></tr></table></figure>

<h4 id="1-9、打开浏览器访问-用户名为admin，密码为123123"><a href="#1-9、打开浏览器访问-用户名为admin，密码为123123" class="headerlink" title="1.9、打开浏览器访问,用户名为admin，密码为123123"></a>1.9、打开浏览器访问,用户名为admin，密码为123123</h4><p>​        <code>http://192.168.85.113:7777/admin</code></p>
<h4 id="1-10、任一连接一台haproxy登录访问"><a href="#1-10、任一连接一台haproxy登录访问" class="headerlink" title="1.10、任一连接一台haproxy登录访问"></a>1.10、任一连接一台haproxy登录访问</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h192.168.243.133 -P48066</span><br><span class="line">mysql -uroot -pRoot_123 -h192.168.243.134 -P48066</span><br></pre></td></tr></table></figure>

<img src="/images/linux/mycat/haproxy监控.jpg"  />

<hr>
<h3 id="2、安装配置Keepalived"><a href="#2、安装配置Keepalived" class="headerlink" title="2、安装配置Keepalived"></a>2、安装配置Keepalived</h3><p>​        在node-3和node-4安装<a href="https://www.keepalived.org/download.html" target="_blank" rel="noopener">Keepalived</a></p>
<h4 id="2-1、准备好Keepalived安装包"><a href="#2-1、准备好Keepalived安装包" class="headerlink" title="2.1、准备好Keepalived安装包"></a>2.1、准备好Keepalived安装包</h4><h4 id="2-2、解压到-usr-local目录"><a href="#2-2、解压到-usr-local目录" class="headerlink" title="2.2、解压到/usr/local目录"></a>2.2、解压到/usr/local目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf keepalived-1.4.5.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3、安装需要依赖的环境组件"><a href="#2-3、安装需要依赖的环境组件" class="headerlink" title="2.3、安装需要依赖的环境组件"></a>2.3、安装需要依赖的环境组件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install gcc openssl-devel popt-devel -y</span><br></pre></td></tr></table></figure>

<h3 id="2-4、进入到解压目录，进行编译"><a href="#2-4、进入到解压目录，进行编译" class="headerlink" title="2.4、进入到解压目录，进行编译"></a>2.4、进入到解压目录，进行编译</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span><br></pre></td></tr></table></figure>

<h4 id="2-5、编译完成之后，进行安装"><a href="#2-5、编译完成之后，进行安装" class="headerlink" title="2.5、编译完成之后，进行安装"></a>2.5、编译完成之后，进行安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="2-6、将keepalived的服务注册为系统服务"><a href="#2-6、将keepalived的服务注册为系统服务" class="headerlink" title="2.6、将keepalived的服务注册为系统服务"></a>2.6、将keepalived的服务注册为系统服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/</span><br><span class="line">mkdir /etc/keepalived</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</span><br></pre></td></tr></table></figure>

<h4 id="2-7、修改配置文件"><a href="#2-7、修改配置文件" class="headerlink" title="2.7、修改配置文件"></a>2.7、修改配置文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> etc/keepalived/</span><br><span class="line">vi keepalived.conf</span><br><span class="line"></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER <span class="comment">#备机需要修改此配置 backof</span></span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.243.100/24 dev ens33 label ens33:3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8、启动keepalived"><a href="#2-8、启动keepalived" class="headerlink" title="2.8、启动keepalived"></a>2.8、启动keepalived</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/keepalived%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt=""></p>
<p><img src="/images/linux/mycat/vip.jpg" alt=""></p>
<h4 id="2-9、登录验证"><a href="#2-9、登录验证" class="headerlink" title="2.9、登录验证"></a>2.9、登录验证</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h 192.168.243.100 -P 48066</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、mycat监控工具"><a href="#三、mycat监控工具" class="headerlink" title="三、mycat监控工具"></a>三、mycat监控工具</h2><p>​        mycat-web是mycat可视化运维管理和监控平台，弥补了mycat在监控上的空白。帮mycat分担统计任务和配置管理任务。mycat-web引入了zookeeper作为配置中心，可以管理多个节点。mycat-web主要管理和监控mycat的流量、连接、活动现成和内存等，具备IP白名单、邮件告警等模块，还可以统计SQL并分析慢SQL和高频SQL等，为SQL的优化提供了依据。</p>
<h4 id="1、安装zookeeper"><a href="#1、安装zookeeper" class="headerlink" title="1、安装zookeeper"></a>1、安装zookeeper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载zookeeper安装包3.6.1</span><br><span class="line">2、安装拷贝到&#x2F;usr&#x2F;local目录，并解压</span><br><span class="line">3、进入到zookeeper解压后的目录conf,复制配置文件并改名</span><br><span class="line">	cp zoo_sample.cfg zoo.cfg</span><br><span class="line">4、进入到zookeeper的bin目录，运行启动命令</span><br><span class="line">	.&#x2F;zkServer.sh start</span><br><span class="line">5、执行如下命令，看zookeeper是否正常启动</span><br><span class="line">	netstat -nlpt | grep 2181</span><br></pre></td></tr></table></figure>

<h4 id="2、安装mycat-web"><a href="#2、安装mycat-web" class="headerlink" title="2、安装mycat-web"></a>2、安装mycat-web</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载mycat-web安装包1.0</span><br><span class="line">2、解压安装包到&#x2F;usr&#x2F;local目录</span><br><span class="line">3、进入mycat-web的目录运行启动命令</span><br><span class="line">	.&#x2F;start.sh &amp;</span><br><span class="line">4、mycat-web的服务端口是8082，查看服务是否启动</span><br><span class="line">	netstat -nlpt | grep 8082</span><br><span class="line">5、通过地址访问服务</span><br><span class="line">	192.168.85.111:8082&#x2F;mycat&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="3、mycat-web配置"><a href="#3、mycat-web配置" class="headerlink" title="3、mycat-web配置"></a>3、mycat-web配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、配置zookeeper</span><br><span class="line">	进入到mycat-web的&#x2F;usr&#x2F;local&#x2F;mycat-web&#x2F;mycat-web&#x2F;WEB-INF&#x2F;classes，修改mycat.properties文件，可以修改zookeeper的地址</span><br><span class="line">2、添加mycat实例</span><br><span class="line">	在页面的mycat配置--》mycat服务管理中添加mycat实例，需要填写相关的参数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat使用</title>
    <url>/2021/05/07/mcat%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、读写分离"><a href="#一、读写分离" class="headerlink" title="一、读写分离"></a>一、读写分离</h2><p>​    通过<a href="/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#%E5%AE%89%E8%A3%85">mycat</a>和<a href="/2021/04/28/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/#%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E">mysql的主从复制</a>配合搭建数据库的读写分离，可以实现mysql的高可用性。</p>
<p>修改mycat的<code>schema.xml</code>配置</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"my_multi_test"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改负载策略</span></span><br><span class="line"><span class="comment">	balance=1:全部的readhost和stand by writehost参与select 语句的负载均衡，简单的说，当双主双从模式下，其他的节点都参与select语句的负载均衡	</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">       	 <span class="comment">&lt;!--master-1--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!--slave-1--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        	<span class="comment">&lt;!--master-2--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.133:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!--slave-2--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.134:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="writeType"><a href="#writeType" class="headerlink" title="writeType"></a>writeType</h3><p>​    表示写操作发送到哪台机器</p>
<ul>
<li>writeType=0:所有写操作都发送到配置的第一个writeHost，第一个挂了切换到还生存的第二个</li>
<li>writeType=1:所有写操作都随机的发送到配置的writehost中，1.5之后废弃</li>
</ul>
<h3 id="switchType"><a href="#switchType" class="headerlink" title="switchType"></a>switchType</h3><p>​    表示如何进行切换</p>
<ul>
<li><p>switchType=1:默认值，自动切换</p>
</li>
<li><p>switchType=-1:表示不自动切换</p>
</li>
<li><p>switchType=2：基于mysql主从同步的状态决定是否切换</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>重启<code>mycat restart</code></p>
<p>连接mycat <code>mysql -uroot -pRoot_123 -P 8066 -h 192.168.243.131</code></p>
<p>执行插入语句 <code>insert into t1 values(2,@@hostname);</code></p>
<p>分别连接四台mysql查询结果</p>
<p><img src="/images/linux/mycat/mycat%E6%8F%92%E5%85%A5.jpg" alt=""></p>
<p>连接mycat查询结果</p>
<img src="/images/linux/mycat/读写分离查询.jpg" style="zoom: 80%;" />



<p>到此，mysql双主双从结合mycat搭建读写分离完成，架构如下图所示</p>
<img src="/images/linux/mycat/mycat多主多从.jpg" style="zoom: 60%;" />

<ul>
<li>当查询时，会被分发到<code>slave-1</code>、<code>master-2</code>、<code>slave-2</code>这三台机器上；</li>
<li>当写操作时，会被分发到<code>master-1</code>上；</li>
<li>如果<code>master-1</code>宕机，mycat会将写操作自动切换到<code>master-2</code>，之后如果<code>master-1</code>恢复（从master-2同步数据，slave-1再从master-1同步数据），也只提供读服务，写仍由<code>master-2</code>提供。</li>
</ul>
<hr>
<h2 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h2><p>​        数据的切分，主要有两种方式，分别是垂直切分和水平切分，所谓的垂直切分就是将不同的表分布在不同的数据库实例中，而水平切分指的是将一张表的数据按照不同的切分规则切分在不同实例的相同名称的表中。</p>
<h3 id="1、分库"><a href="#1、分库" class="headerlink" title="1、分库"></a>1、分库</h3><p>将不同的表分布在不同的库中，但是访问的时候使用的是同一个mycat的终端，这些操作都由mycat来完成的，我们只需修改相应的配置即可。</p>
<h4 id="1-1、修改-etc-my-cnf文件"><a href="#1-1、修改-etc-my-cnf文件" class="headerlink" title="1.1、修改/etc/my.cnf文件"></a>1.1、修改<code>/etc/my.cnf</code>文件</h4><p>​        在mycat操作时它是不区分表明大小写的，需要在mysql的配置文件中添加<code>lower_case_table_names=1</code>参数，来保证查询的时候能够进行正常的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_case_table_names&#x3D;1</span><br></pre></td></tr></table></figure>

<h4 id="1-2、重启mysql"><a href="#1-2、重启mysql" class="headerlink" title="1.2、重启mysql"></a>1.2、重启mysql</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">service mysqld status</span><br></pre></td></tr></table></figure>

<h4 id="1-3、修改schema-xml文件"><a href="#1-3、修改schema-xml文件" class="headerlink" title="1.3、修改schema.xml文件"></a>1.3、修改<code>schema.xml</code>文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定customer表分发到db2进行操作，其余未指定的表默认dn1 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> = <span class="string">"customer"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"my_db"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"host2"</span> <span class="attr">database</span>=<span class="string">"my_db"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--master-1--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--slave-1--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host2"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">				<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--master-2--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.133:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--slave-2--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.134:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4、重启mycat"><a href="#1-4、重启mycat" class="headerlink" title="1.4、重启mycat"></a>1.4、重启mycat</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">mycat restart</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">mycat status</span><br></pre></td></tr></table></figure>

<h4 id="1-5、停止master的slave服务"><a href="#1-5、停止master的slave服务" class="headerlink" title="1.5、停止master的slave服务"></a>1.5、停止<code>master</code>的slave服务</h4><p>​        使用mycat进行分库操作之前，需要分别登陆<code>master-1</code>和<code>master-2</code>执行<code>stop slave</code>，将它们的主备关系去除，否则相互之间会进行数据同步，起不到分库的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 停止slave服务</span><br><span class="line">stop slave;</span><br><span class="line">-- 查看状态</span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>

<p>登陆<code>master-1</code>和<code>master-2</code>的mysql服务分别创建my_db数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database my_db;</span><br></pre></td></tr></table></figure>

<h4 id="1-6、验证"><a href="#1-6、验证" class="headerlink" title="1.6、验证"></a>1.6、验证</h4><h5 id="登陆mcat"><a href="#登陆mcat" class="headerlink" title="登陆mcat"></a>登陆mcat</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h 192.168.243.131 -P 8066</span><br></pre></td></tr></table></figure>

<h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/%E5%88%86%E5%BA%93-01.jpg" alt=""></p>
<blockquote>
<p>由上图可以看到，<code>mycat</code>的建表语句被分发到了<code>master-2</code>执行，并且因为<code>master-2</code>与<code>slave-2</code>主从同步，<code>slave-2</code>也出现了customer表。</p>
</blockquote>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/%E5%88%86%E5%BA%93-02.jpg" alt=""></p>
<blockquote>
<p>由上图可以看到，<code>mycat</code>插入的语句被分发到了<code>master-2</code>执行，并且因为<code>master-2</code>与<code>slave-2</code>主从同步，<code>slave-2</code>也出现了相关的数据。</p>
</blockquote>
<hr>
<h3 id="2、分表（分片）"><a href="#2、分表（分片）" class="headerlink" title="2、分表（分片）"></a>2、分表（分片）</h3><p>​        相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中 包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中 。</p>
<h4 id="2-1、取模运算"><a href="#2-1、取模运算" class="headerlink" title="2.1、取模运算"></a>2.1、取模运算</h4><p>​        <code>把customer_id按照取模运算进行数据拆分</code></p>
<h5 id="修改schema-xml文件"><a href="#修改schema-xml文件" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><p>​        在上文<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#1-3%E3%80%81%E4%BF%AE%E6%94%B9schema-xml%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">分库的schema文件</a>基础上修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span>		</span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> = <span class="string">"customer"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> =<span class="string">"orders"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"mod_rule"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件"><a href="#修改rule-xml文件" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><p>​        配置取模运算规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span>		</span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat"><a href="#重启mycat" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-1"><a href="#建表-1" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">	order_type <span class="built_in">INT</span>,</span><br><span class="line">	customer_id <span class="built_in">INT</span>,</span><br><span class="line">	amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-1"><a href="#插入数据-1" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="/images/linux/mycat/%E5%88%86%E8%A1%A8-%E5%8F%96%E6%A8%A1.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>customer_id</code>字段值%2，结果为0的分发到<code>master-1</code>，为1分发<code>master-2</code></p>
</blockquote>
<hr>
<h4 id="2-2、分片枚举"><a href="#2-2、分片枚举" class="headerlink" title="2.2、分片枚举"></a>2.2、分片枚举</h4><p>​        <code>通过在配置文件中配置可能存在的值，配置分片。</code></p>
<h5 id="修改schema-xml文件-1"><a href="#修改schema-xml文件-1" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"orders_ware_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_intfile"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-1"><a href="#修改rule-xml文件-1" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_intfile"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数,对应下面的function标签 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile： 标识配置文件名称--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  type： 0为int型、 非0为String --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span></span><br><span class="line"><span class="comment">	设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-hash-int-txt文件"><a href="#修改partition-hash-int-txt文件" class="headerlink" title="修改partition-hash-int.txt文件"></a><strong>修改<code>partition-hash-int.txt</code>文件</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#10000&#x3D;0</span><br><span class="line">#10010&#x3D;1</span><br><span class="line">110&#x3D;0</span><br><span class="line">120&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-1"><a href="#重启mycat-1" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-2"><a href="#建表-2" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_ware_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'订单编号'</span>,</span><br><span class="line">    <span class="string">`address`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">comment</span> <span class="string">'地址'</span>,</span><br><span class="line">    <span class="string">`areacode`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">'区域编号'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-2"><a href="#插入数据-2" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">'北京'</span>,<span class="string">'110'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">2</span>,<span class="string">'天津'</span>,<span class="string">'120'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mycat/%E5%88%86%E7%89%87-%E5%88%86%E7%89%87%E6%9E%9A%E4%B8%BE.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>areacode</code>值与<code>partition-hash-int.txt</code>文件中配置参数比对确定存放的节点，110被分发到<code>node-1</code>，120被分发到<code>node-2</code></p>
</blockquote>
<hr>
<h4 id="2-3、范围分片"><a href="#2-3、范围分片" class="headerlink" title="2.3、范围分片"></a>2.3、范围分片</h4><p>​    根据分片字段，约定好属于哪一个范围</p>
<h5 id="修改schema-xml文件-2"><a href="#修改schema-xml文件-2" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"payment_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-2"><a href="#修改rule-xml文件-2" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto-sharding-long"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile： 标识配置文件名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span></span><br><span class="line"><span class="comment">	设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改autopartition-long-txt文件"><a href="#修改autopartition-long-txt文件" class="headerlink" title="修改autopartition-long.txt文件"></a>修改<code>autopartition-long.txt</code>文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K&#x3D;1000,M&#x3D;10000.</span><br><span class="line">#0-500M&#x3D;0</span><br><span class="line">#500M-1000M&#x3D;1</span><br><span class="line">#1000M-1500M&#x3D;2</span><br><span class="line">0-102&#x3D;0</span><br><span class="line">103-200&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-2"><a href="#重启mycat-2" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-3"><a href="#建表-3" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'订单编号'</span>,</span><br><span class="line">    <span class="string">`payment_status`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'支付状态'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-3"><a href="#插入数据-3" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id ,payment_status) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-1"><a href="#查询结果-1" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="/images/linux/mycat/%E5%88%86%E7%89%87-%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>order_id</code>值与<code>autopartition-long.txt</code>文件中配置参数比对确定存放的节点</p>
</blockquote>
<hr>
<h4 id="2-4、范围求模算法"><a href="#2-4、范围求模算法" class="headerlink" title="2.4、范围求模算法"></a>2.4、范围求模算法</h4><p>​    该算法为先进行<code>范围分片</code>，计算出分片组，<code>组内再求模</code>，综合了范围分片和求模分片的优点。</p>
<p>​    分片组内使用求模可以保证组内的数据分步比较均匀，分片组之间采用范围分片可以兼顾范围分片的特点。事先规定好分片的数量，数据扩容时按分片组扩容，则原有分片组的数据不需要迁移。由于分片组内的数据分步比较均匀，所以分片组内可以避免热点数据问题。</p>
<h5 id="修改schema-xml文件-3"><a href="#修改schema-xml文件-3" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-rang-mod"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-3"><a href="#修改rule-xml文件-3" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto-sharding-rang-mod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-mod<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-mod"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByRangeMod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-range-mod-txt文件"><a href="#修改partition-range-mod-txt文件" class="headerlink" title="修改partition-range-mod.txt文件"></a><strong>修改partition-range-mod.txt文件</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node group size</span><br><span class="line"># 0-200M&#x3D;5</span><br><span class="line"># 200M1-400M&#x3D;1</span><br><span class="line"># 400M1-600M&#x3D;4</span><br><span class="line"># 600M1-800M&#x3D;4</span><br><span class="line"># 800M1-1000M&#x3D;6</span><br><span class="line">0-1M&#x3D;2</span><br><span class="line">1M1-2M&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-3"><a href="#重启mycat-3" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-4"><a href="#建表-4" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-4"><a href="#插入数据-4" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">9999</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">10000</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">20000</span>,<span class="string">'zhangsan4'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-2"><a href="#查询结果-2" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="/images/linux/mycat/%E5%88%86%E7%89%87-%E8%8C%83%E5%9B%B4%E6%B1%82%E6%A8%A1.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>partition-range-mod.txt</code>文件中配置参数比对，确定存放在哪个分片，如果该分片只有一个节点直接放入，分片存在多个节点时，需要对<code>id</code>值进行取模运算确定存放的节点</p>
<p>先匹配范围，再取模</p>
</blockquote>
<hr>
<h4 id="2-5、固定分片hash算法"><a href="#2-5、固定分片hash算法" class="headerlink" title="2.5、固定分片hash算法"></a>2.5、固定分片hash算法</h4><p>​        类似于十进制的求模运算，但是为二进制的操作，取id的二进制低10位，即id的二进制 &amp; 1111111111，结果落在0-1023之间，所以默认最大分片为1024.</p>
<p>​        此算法的优点在于如果按照十进制取模运算，则在连续插入1<del>10时，1</del>10会被分到1~10个分片，增大了插入事务的控制难度。而此算法根据二进制则可能会分到连续的分片，降低了插入事务的控制难度。</p>
<h5 id="修改schema-xml文件-4"><a href="#修改schema-xml文件-4" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-4"><a href="#修改rule-xml文件-4" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionCount为分片个数列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionLength为分片范围列表，分区长度默认最大为1024，即最大支持1024个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-4"><a href="#重启mycat-4" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-5"><a href="#建表-5" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-5"><a href="#插入数据-5" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1023</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1024</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">266</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">255</span>,<span class="string">'zhangsan4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1025</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1025</span>,<span class="string">'zhangsan5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1257</span>,<span class="string">'zhangsan6'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1281</span>,<span class="string">'zhangsan7'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">256</span>,<span class="string">'zhangsan8'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">511</span>,<span class="string">'zhangsan9'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">512</span>,<span class="string">'zhangsan10'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-3"><a href="#查询结果-3" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-固定分片hash算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>rule.xml</code>文件中配置参数比对，确定存放在哪个分片，当数值超过1024时会减去1024再进行范围匹配</p>
<p>最大分片数为1024，范围从0-1023</p>
</blockquote>
<hr>
<h4 id="2-6、取模范围算法"><a href="#2-6、取模范围算法" class="headerlink" title="2.6、取模范围算法"></a>2.6、取模范围算法</h4><p>​    取模运算与范围约束的结合主要是为后续的数据迁移做准备，即可以自主决定取模后数据的节点分布。</p>
<h5 id="修改schema-xml文件-5"><a href="#修改schema-xml文件-5" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user2"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-pattern"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-5"><a href="#修改rule-xml文件-5" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-pattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByPattern"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile：切分规则配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- patternValue：求模基数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patternValue"</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点，如果超出配置的范围，则使用默认节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-pattern-txt文件"><a href="#修改partition-pattern-txt文件" class="headerlink" title="修改partition-pattern.txt文件"></a>修改partition-pattern.txt文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-86&#x3D;0</span><br><span class="line">87-173&#x3D;1</span><br><span class="line">174-256&#x3D;2</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-5"><a href="#重启mycat-5" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-6"><a href="#建表-6" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-6"><a href="#插入数据-6" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">85</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">100</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">200</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">257</span>,<span class="string">'zhangsan4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">343</span>,<span class="string">'zhangsan5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">430</span>,<span class="string">'zhangsan6'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-4"><a href="#查询结果-4" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-取模范围算法-1620120538787.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>rule.xml</code>文件中配置的取模基数<code>patternValue</code>进行计算，看结果落在哪个范围分片，最终确定存放在哪个节点</p>
<p>先取模，再匹配范围</p>
</blockquote>
<hr>
<h4 id="2-7、字符串hash求模范围算法"><a href="#2-7、字符串hash求模范围算法" class="headerlink" title="2.7、字符串hash求模范围算法"></a>2.7、字符串hash求模范围算法</h4><p>​        与取模范围算法类似，该算法支持数值、符号、字母取模，此方式就是将指定位数的字符的ascll码的和进行取模运算。</p>
<h5 id="修改schema-xml文件-6"><a href="#修改schema-xml文件-6" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-prefixpattern"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-6"><a href="#修改rule-xml文件-6" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-prefixpattern"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns标识将要分片的表字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm为分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-prefixpattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-prefixpattern"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByPrefixPattern"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile：切分规则配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- patternValue：求模基数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patternValue"</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prefixLength:ASCII 截取的位数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefixLength"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-pattern-txt文件-1"><a href="#修改partition-pattern-txt文件-1" class="headerlink" title="修改partition-pattern.txt文件"></a>修改partition-pattern.txt文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ASCII</span><br><span class="line"># 8-57&#x3D;0-9 阿拉伯数字</span><br><span class="line"># 64、 65-90&#x3D;@、 A-Z</span><br><span class="line"># 97-122&#x3D;a-z  </span><br><span class="line">0-86&#x3D;0</span><br><span class="line">87-173&#x3D;1</span><br><span class="line">174-256&#x3D;2</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-6"><a href="#重启mycat-6" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-7"><a href="#建表-7" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user3`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-7"><a href="#插入数据-7" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'wangwu'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'zzzzzzz'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'z99'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-5"><a href="#查询结果-5" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-字符串hash求模范围算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>name</code>值的前五位进行截取计算ASCII值，结果值再与<code>rule.xml</code>文件中配置的取模基数<code>patternValue</code>进行取模计算，看取模结果落在哪个范围分片，最终确定存放在哪个节点</p>
<p>先截取换算ASCII值，取模计算，再匹配范围</p>
</blockquote>
<hr>
<h4 id="2-8、应用指定的算法"><a href="#2-8、应用指定的算法" class="headerlink" title="2.8、应用指定的算法"></a>2.8、应用指定的算法</h4><p>​    在运行阶段由应用程序自主决定路由到哪个分片。</p>
<h5 id="修改schema-xml文件-7"><a href="#修改schema-xml文件-7" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user4"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-substring"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-7"><a href="#修改rule-xml文件-7" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-substring"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-substring"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionDirectBySubString"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始的索引值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startIndex"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取值长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分片数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认的分片节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultPartition"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-7"><a href="#重启mycat-7" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-8"><a href="#建表-8" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user4`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-8"><a href="#插入数据-8" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'0-zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'1-lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'2-wangwu'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-6"><a href="#查询结果-6" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-应用指定的算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>name</code>值从<code>startIndex</code>截取<code>size</code>数量的字符，结果值匹配分片的索引，最终确定存放在哪个节点</p>
</blockquote>
<hr>
<h4 id="2-9、字符串hash解析算法"><a href="#2-9、字符串hash解析算法" class="headerlink" title="2.9、字符串hash解析算法"></a>2.9、字符串hash解析算法</h4><p>​        字符串hash解析分片，其实就是根据配置的hash预算位规则，将截取的字符串进行hash计算后，得到的int数值即为datanode index(分片节点索引，从0开始)。</p>
<h5 id="修改schema-xml文件-8"><a href="#修改schema-xml文件-8" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user5"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-stringhash"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml5文件"><a href="#修改rule-xml5文件" class="headerlink" title="修改rule.xml5文件"></a><strong>修改<code>rule.xml5</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-stringhash"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns标识将要分片的表字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm为分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-stringhash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">partitionLength:求模基数</span></span><br><span class="line"><span class="comment">partitionCount:分片数量</span></span><br><span class="line"><span class="comment">hashslice： hash预算位，即根据子字符串中 int 值 hash 运算</span></span><br><span class="line"><span class="comment">    0 代表 str.length(), -1 代表 str.length()-1，大于0只代表数字自身</span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">    * “2” -&gt; (0,2)</span></span><br><span class="line"><span class="comment">    * “1:2” -&gt; (1,2)</span></span><br><span class="line"><span class="comment">    * “1:” -&gt; (1,0)</span></span><br><span class="line"><span class="comment">    * “-1:” -&gt; (-1,0)</span></span><br><span class="line"><span class="comment">    * “:-1” -&gt; (0,-1)</span></span><br><span class="line"><span class="comment">    * “:” -&gt; (0,0)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-stringhash"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByString"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionLength为分片范围列表，分区长度默认最大为1024，即最大支持1024个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512,256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionCount为分片个数列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>1,2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashSlice"</span>&gt;</span>0:6<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-8"><a href="#重启mycat-8" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-9"><a href="#建表-9" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user5`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-9"><a href="#插入数据-9" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1111111</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2222222</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3333333</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4444444</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8960000</span>,<span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-7"><a href="#查询结果-7" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-字符串hash解析算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据中的<code>id</code>值根据<code>hashslice</code>截取合适的字符串进行hash值计算，再从长度是1024的数组中获取对应的节点索引值，将结果存入该节点</p>
<p>最大分片数为1024，范围从0-1023</p>
</blockquote>
<hr>
<h4 id="2-10、按照日期范围分片"><a href="#2-10、按照日期范围分片" class="headerlink" title="2.10、按照日期范围分片"></a>2.10、按照日期范围分片</h4><p>​        按照某个指定的日期进行分片</p>
<h5 id="修改schema-xml文件-9"><a href="#修改schema-xml文件-9" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"login_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_date"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-8"><a href="#修改rule-xml文件-8" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"shardingByDate"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByDate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ：开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ：开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-06-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sEndDate：结束日期,则代表数据达到了这个日期的分片后循环从开始分片插入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sEndDate"</span>&gt;</span>2020-06-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay ：分区天数，即默认从开始日期算起，分隔 2 天一个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-9"><a href="#重启mycat-9" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-10"><a href="#建表-10" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> login_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'用户编号'</span>,</span><br><span class="line">    <span class="string">`login_date`</span> <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">'登录日期'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-10"><a href="#插入数据-10" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="string">'2020-06-01'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="string">'2020-06-02'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="string">'2020-06-03'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="string">'2020-06-04'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">103</span>,<span class="string">'2020-06-05'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">6</span>,<span class="number">104</span>,<span class="string">'2020-06-06'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-8"><a href="#查询结果-8" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-按照日期范围分片.jpg" style="zoom:80%;" />

<blockquote>
<p>按照某个指定的日期进行分片,达到结束日期后循环开始分片插入</p>
</blockquote>
<hr>
<h4 id="2-11、按单月小时分片"><a href="#2-11、按单月小时分片" class="headerlink" title="2.11、按单月小时分片"></a>2.11、按单月小时分片</h4><p>​        此规则是单月内按照小时拆分，最小粒度是小时，可以一天最多24个分片，最少一个分片，一个月完成后下个月开始循环，每个月月尾，需要手工清理数据。</p>
<h5 id="修改schema-xml文件-10"><a href="#修改schema-xml文件-10" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user6"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-hour"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-9"><a href="#修改rule-xml文件-9" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-hour"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns： 拆分字段，字符串类型（yyyymmddHH） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-hour<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-hour"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.LatestMonthPartion"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- splitOneDay ：一天切分的分片数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"splitOneDay"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-10"><a href="#重启mycat-10" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-11"><a href="#建表-11" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user6(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    create_time <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-11"><a href="#插入数据-11" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060100'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060101'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060102'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060103'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060104'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060105'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060106'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060107'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060108'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060109'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060110'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060111'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060112'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060113'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060114'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060115'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060116'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060117'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060118'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060119'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060120'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060121'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060122'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060123'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060200'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060201'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060202'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060203'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060204'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060205'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060206'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060207'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060208'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060209'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060210'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060211'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-9"><a href="#查询结果-9" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分表-按单月小时分片.jpg" style="zoom:67%;" />

<blockquote>
<p>当运行完成之后会发现，第一天的数据能够正常的插入成功，均匀的分散到3个分片上，但是第二天的数据就无法成功分散了，原因就在于我们的数据分片不够，所以这种方式几乎没有人使用。</p>
<p>ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER6 -&gt; CREATE_TIME -&gt; 2020060200 -&gt; Index : 3</p>
</blockquote>
<hr>
<h4 id="2-12、日期范围hash分片"><a href="#2-12、日期范围hash分片" class="headerlink" title="2.12、日期范围hash分片"></a>2.12、日期范围hash分片</h4><p>​        思想与范围求模一致，当由于日期在取模会有数据集中问题，所以改成了hash方法。先根据时间hash使得短期内数据分布的更均匀，有点可以避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题，要求日期格式尽量精确，不然达不到局部均匀的目的。</p>
<h5 id="修改schema-xml文件-11"><a href="#修改schema-xml文件-11" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user7"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"rangeDateHash"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-10"><a href="#修改rule-xml文件-10" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rangeDateHash"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns： 拆分字段，字符串类型（yyyymmddHH） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm:分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>range-date-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"range-date-hash"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByRangeDateHash"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate:指定开始的日期，与dateFormat格式一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-06-01 00:00:00<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay:代表多少天一组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dateFormat:指定的日期格式，符合java标准 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一组分片的分片数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"groupPartionSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-11"><a href="#重启mycat-11" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-12"><a href="#建表-12" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user7(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    create_time <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-12"><a href="#插入数据-12" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-01 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-02 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-03 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-04 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-05 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-06 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-07 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-08 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-09 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-10 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-11 00:00:00'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-10"><a href="#查询结果-10" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分表-日期范围hash分片.jpg" style="zoom: 67%;" />

<blockquote>
<p>通过结果也可以看出，每三天一个分片，那么我们只有三个数据节点，所以到10号的数据的时候，没有办法进行数据的插入了，原因就在于没有足够多的数据节点。</p>
<p>insert into user7(id,name,create_time) values(1,’steven’,’2020-06-11 00:00:00’);ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER7 -&gt; CREATE_TIME -&gt; 2020-06-10 00:00:00 -&gt; Index : 3</p>
</blockquote>
<hr>
<h4 id="2-13、冷热数据分片"><a href="#2-13、冷热数据分片" class="headerlink" title="2.13、冷热数据分片"></a>2.13、冷热数据分片</h4><p>​        根据日期查询冷热数据分布，最近n个月的到实时交易库查询，其他的到其他库中</p>
<h5 id="修改schema-xml文件-12"><a href="#修改schema-xml文件-12" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user8"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-hotdate"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-11"><a href="#修改rule-xml文件-11" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-hotdate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-hotdate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-hotdate"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByHotDate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dataFormat：时间格式化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sLastDay:热数据的天数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sLastDay"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay:冷数据的分片天数（按照天数分片）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-12"><a href="#重启mycat-12" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-13"><a href="#建表-13" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  user8(create_time <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>  ,<span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-13"><a href="#插入数据-13" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-10'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-11'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-21'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-30'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-10'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-30'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-24'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-25'</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-11"><a href="#查询结果-11" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分表-冷热数据分片.jpg" style="zoom:67%;" />

<blockquote>
<p>当前时间之后及前<code>sLastDay</code>天的数据放入第一个节点</p>
<p>当前操作时间前<code>sPartionDay</code>-当前操作时间前<code>sLastDay</code>天内的数据放入第二个节点</p>
<p>其余当如第三个节点</p>
</blockquote>
<hr>
<h4 id="2-14、自然月分片"><a href="#2-14、自然月分片" class="headerlink" title="2.14、自然月分片"></a>2.14、自然月分片</h4><h5 id="修改schema-xml文件-13"><a href="#修改schema-xml文件-13" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user9"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-month"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-12"><a href="#修改rule-xml文件-12" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-month"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-month<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-month"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMonth"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dateFormat ： 日期字符串格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ： 开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2021-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-13"><a href="#重启mycat-13" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-14"><a href="#建表-14" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  user9(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),create_time <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-14"><a href="#插入数据-14" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-01-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-03-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-05-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-07-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-09-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-11-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-02-01'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-12"><a href="#查询结果-12" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-自然月分片.jpg" style="zoom:67%;" />

<blockquote>
<p>从<code>sBeginDate</code>指定的月份开始，根据配置的节点数进行分片，因为配置了三个节点，所以如图所示，只有前三个月的数据会被会被分配插入，其余的报错ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER9 -&gt; CREATE_TIME -&gt; 2021-11-01 -&gt; Index : 10  因为无法找到对应有效的节点</p>
</blockquote>
<hr>
<h4 id="2-15、一致性hash分片"><a href="#2-15、一致性hash分片" class="headerlink" title="2.15、一致性hash分片"></a>2.15、一致性hash分片</h4><p>​        实现方式：一致性hash分片，利用一个分片节点对应一个或者多个虚拟hash桶的思想，尽可能减少分片扩展时的数据迁移。将指定的列值进行hash再对2^32进行取模得到hash环的对应位置</p>
<p>​        优点：有效解决了分布式数据库的扩容问题。</p>
<p>​        缺点：在横向扩展的时候，需要迁移部分数据；由于虚拟桶倍数与分片节点数都必须是正整数，而且要服从”虚拟桶倍数×分片节点数=设计极限”，因此在横向扩容的过程中，增加分片节点并不是一台一台地加上去的，而是以一种因式分解的方式增加，因此有浪费物理计算力的可能性。</p>
<h5 id="修改schema-xml文件-14"><a href="#修改schema-xml文件-14" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user10"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-murmur"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-13"><a href="#修改rule-xml文件-13" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-murmur"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"murmur"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMurmurHash"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认是 0--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"seed"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的 160 倍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"virtualBucketTimes"</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--节点的权重，没有指定权重的节点默认是 1。以 properties 文件的格式填写，以从 0 开始到 count-1 的整数值也就是节点索引为 key，以节点权重值为值。所有权重值必须是正整数，否则以 1 代替 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="weightMapFile"&gt;weightMapFile&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的 murmur hash 值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bucketMapPath"</span>&gt;</span>/etc/mycat/bucketMapPath<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-14"><a href="#重启mycat-14" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-15"><a href="#建表-15" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user10(<span class="keyword">id</span> <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-15"><a href="#插入数据-15" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1111111</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2222222</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3333333</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4444444</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8960000</span>,<span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-13"><a href="#查询结果-13" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="/images/linux/mycat/分片-一致性hash.jpg" style="zoom: 55%;" />

<blockquote>
<p>根据<code>count</code>指定分片的节点数量，每个节点会被映射<code>virtualBucketTimes</code>倍的虚拟节点，将<code>columns</code>字段计算hash值再对2^32取模得出hash槽位，顺时针寻找该位最近的节点进行存储</p>
</blockquote>
<hr>
<h2 id="三、分片join"><a href="#三、分片join" class="headerlink" title="三、分片join"></a>三、分片join</h2><p>​        Join绝对是关系型数据库中最常用的一个特性，然而在分布式环境中，跨分配的join却是最复杂的，最难解决的一个问题。</p>
<p>​        性能建议：</p>
<ol>
<li>尽量避免使用left join或right join，而用inner join</li>
<li>在使用left join或right join时，on会优先执行，where条件在最后执行，所以再使用过程中，条件尽可能的在on语句中判断，减少where的执行</li>
<li>少使用子查询，而用join</li>
</ol>
<p>​        mycat目前版本支持跨分配的join，主要有四种实现方式：<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#%E5%85%A8%E5%B1%80%E8%A1%A8" target="_blank" rel="noopener"><code>全局表</code></a>、<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#ER%E5%88%86%E7%89%87" target="_blank" rel="noopener"><code>ER分片</code></a>、<code>catletT(人工智能)</code>、<code>ShareJoin</code></p>
<h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a><strong>全局表</strong></h3><p>​        在分片的情况下，当业务表因为规模而进行分片之后，业务表与这个字典表的之间关联会变得比较棘手，因此，在mycat中存在一种全局表，他具备以下特性：</p>
<ol>
<li>全局表的插入、更新操作会实时的在所有节点上执行，保持各个分片的数据一致性</li>
<li>全局表的查询操作，只从一个节点获取</li>
<li>全局表可以跟任何一个表进行join操作</li>
</ol>
<h4 id="修改schema-xml文件-15"><a href="#修改schema-xml文件-15" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"dict_order_type"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">type</span>=<span class="string">"global"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-15"><a href="#重启mycat-15" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-16"><a href="#建表-16" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dict_order_type(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-16"><a href="#插入数据-16" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">101</span>,<span class="string">'type1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">102</span>,<span class="string">'type2'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-14"><a href="#查询结果-14" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><img src="/images/linux/mycat/全局表.jpg" style="zoom:67%;" />

<blockquote>
<p>由图可以看出，每个节点都保存了一份数据，而查询只会从一个节点获取，相当于每个节点都冗余了一个全局表，以便节点内的数据join操作</p>
</blockquote>
<hr>
<h3 id="ER分片"><a href="#ER分片" class="headerlink" title="ER分片"></a><strong>ER分片</strong></h3><p>​        在mycat中，我们已经将orders进行了数据分片，但是orders表跟orders_detail发生关联，如果只把orders_detail放到一个分片上，那么跨库的join很麻烦，所以提出了ER关系的表分片。什么意思呢？<code>就是通过关联关系，将子表与父表关联的记录放在同一个数据分片上。</code></p>
<h4 id="修改schema-xml文件-16"><a href="#修改schema-xml文件-16" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> =<span class="string">"orders"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">"orders_detail"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">joinKey</span>=<span class="string">"order_id"</span> <span class="attr">parentKey</span>=<span class="string">"id"</span> /&gt;</span>	<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>修改<code>rule.xml</code>文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-16"><a href="#重启mycat-16" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-17"><a href="#建表-17" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--订单表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_type <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span>,</span><br><span class="line">    amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--订单详细表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_detail(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    detail <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    order_id <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-17"><a href="#插入数据-17" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'detail1'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'detail1'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'detail1'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'detail1'</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'detail1'</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">'detail1'</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-15"><a href="#查询结果-15" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><img src="/images/linux/mycat/er分片.jpg" style="zoom:60%;" />

<blockquote>
<p>关联关系，将子表与父表关联的记录放在同一个数据分片上，以便数据之间的join关联</p>
</blockquote>
<hr>
<h3 id="Share-join"><a href="#Share-join" class="headerlink" title="Share join"></a>Share join</h3><p>​        ShareJoin是一个简单的跨分片join,基于HBT的方式实现。目前支持2个表的join，原理是解析SQL语句，拆分成单表的SQL语句执行，然后把各个节点的数据汇集。</p>
<h4 id="修改schema-xml文件-17"><a href="#修改schema-xml文件-17" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"company"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"customers"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-intfile"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改rule-xml文件-14"><a href="#修改rule-xml文件-14" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod-long"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-intfile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改partition-hash-int-txt文件-1"><a href="#修改partition-hash-int-txt文件-1" class="headerlink" title="修改partition-hash-int.txt文件"></a>修改partition-hash-int.txt文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10000&#x3D;0</span><br><span class="line">10010&#x3D;1</span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-17"><a href="#重启mycat-17" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-18"><a href="#建表-18" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> company(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),company_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,sharding_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-18"><a href="#插入数据-18" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'mycat'</span>);</span><br><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'ibm'</span>);</span><br><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'hp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(<span class="keyword">id</span>,<span class="keyword">name</span>,company_id,sharding_id)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'wang'</span>,<span class="number">1</span>,<span class="number">10000</span>),(<span class="number">2</span>,<span class="string">'xue'</span>,<span class="number">2</span>,<span class="number">10010</span>),(<span class="number">3</span>,<span class="string">'feng'</span>,<span class="number">3</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-16"><a href="#查询结果-16" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可以看到有时可以查出对应的结果，有时则查询不到</span></span><br><span class="line"><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a,company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">--可以看到每次都可以直接查询到结果</span></span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a,company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">--其他写法</span></span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a <span class="keyword">join</span> company b <span class="keyword">on</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a <span class="keyword">join</span> company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、全局序列号"><a href="#四、全局序列号" class="headerlink" title="四、全局序列号"></a>四、全局序列号</h2><h3 id="1、本地文件方式"><a href="#1、本地文件方式" class="headerlink" title="1、本地文件方式"></a>1、本地文件方式</h3><p>​        使用此方式的时候，mycat讲sequence配置到文件中，当使用到sequence中的配置，mycat会更新sequence_conf.properties文件中sequence当前的值。</p>
<p>​        <strong>配置方式：</strong></p>
<p>​        在 sequence_conf.properties 文件中做如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">GLOBAL_SEQ.HISIDS</span>=<span class="string"></span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.MINID</span>=<span class="string">10001</span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.MAXID</span>=<span class="string">20000</span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.CURID</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure>

<p>​        其中 HISIDS 表示使用过的历史分段(一般无特殊需要可不配置)， MINID 表示最小 ID 值， MAXID 表示最大<br>ID 值， CURID 表示当前 ID 值。<br>​        server.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        注： sequnceHandlerType 需要配置为 0，表示使用本地文件方式。  </p>
<p>​        案例使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test3'</span>);</span><br></pre></td></tr></table></figure>

<p>​        缺点：当mycat重新发布后，配置文件中的sequence会恢复到初始值</p>
<p>​        优点：本地加载，读取速度较快</p>
<h3 id="2、数据库方式"><a href="#2、数据库方式" class="headerlink" title="2、数据库方式"></a>2、数据库方式</h3><p>​        在数据库中建立一张表，存放sequence名称（name）,sequence当前值(current_value),步长（increment int类型，每次读取多少个sequence，假设为K）等信息；</p>
<p>​        <strong>获取数据步骤</strong>：</p>
<p>​        1、当初次使用该sequence时，根据传入的sequence名称，从数据库这张表中读取current_value和increment到mycat中，并将数据库中的current_value设置为原current_value值+increment值。</p>
<p>​        2、mycat将读取到current_value+increment作为本次要使用的sequence值，下次使用时，自动加1，当使用increment次后，执行步骤1中的操作</p>
<p>​        3、mycat负责维护这张表，用到哪些sequence，只需要在这张表中插入一条记录即可，若某次读取的sequence没有用完，系统就停掉了，则这次读取的sequence剩余值不会再使用</p>
<p>​        <strong>配置方式：</strong></p>
<p>​        1、修改server.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        2、修改schema.xml文件        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"mycat_sequence"</span> <span class="attr">primaryKey</span>=<span class="string">"name"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        3、修改mycat配置文件sequence_db_conf.properties，添加属性值</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sequence stored in datanode</span></span><br><span class="line"><span class="attr">GLOBAL</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">COMPANY</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">CUSTOMER</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">ORDERS</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">MYCAT</span>=<span class="string">dn2</span></span><br></pre></td></tr></table></figure>

<p>​        4、在dn2上添加mycat_sequence表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_sequence;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mycat_sequence (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="keyword">increment</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">100</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">name</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>​        5、在dn2上的mycat_sequence表中插入初始记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mycat_sequence(<span class="keyword">name</span>,current_value,<span class="keyword">increment</span>) <span class="keyword">VALUES</span> (<span class="string">'mycat'</span>, <span class="number">-99</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>​        6、在dn2上创建函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建函数</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_currval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_currval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>)     <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> retval <span class="built_in">VARCHAR</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">SET</span> retval=<span class="string">"-999999999,null"</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="keyword">CAST</span>(current_value <span class="keyword">AS</span> <span class="built_in">CHAR</span>),<span class="string">","</span>,<span class="keyword">CAST</span>(<span class="keyword">increment</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>)) <span class="keyword">INTO</span> retval <span class="keyword">FROM</span> mycat_sequence <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--设置sequence值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_setval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_setval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),<span class="keyword">value</span> <span class="built_in">INTEGER</span>) <span class="keyword">RETURNS</span>     <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> mycat_sequence</span><br><span class="line"><span class="keyword">SET</span> current_value = <span class="keyword">value</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--获取下一个sequence值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_nextval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_nextval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>)     <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> mycat_sequence</span><br><span class="line"><span class="keyword">SET</span> current_value = current_value + <span class="keyword">increment</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>​        <strong>数据测试：</strong></p>
<p>​        1、插入数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>​        2、查询对应的序列数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mycat_sequence;</span><br></pre></td></tr></table></figure>

<p>​        3、向表中插入数据，可以多执行几次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_MYCAT,(<span class="keyword">select</span> <span class="keyword">database</span>()));</span><br></pre></td></tr></table></figure>

<p>​        4、查询添加的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>​        5、重新启动mycat，重新添加数据，查看结果，重启之后从101开始</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mycat_sequence;</span><br></pre></td></tr></table></figure>

<p>​        6、重新查询数据表test</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>​        大家在使用的时候会发现报错的情况，这个错误的原因不是因为我们的配置，是因为我们的版本问题，简单替换下版本即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into test(id,name) values(next value for MYCATSEQ_MYCAT,(select database()));</span><br><span class="line">ERROR 1003 (HY000): mycat sequnce err.java.lang.NumberFormatException: null</span><br></pre></td></tr></table></figure>

<h3 id="3、本地时间戳方式"><a href="#3、本地时间戳方式" class="headerlink" title="3、本地时间戳方式"></a>3、本地时间戳方式</h3><p>​        ID= 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加)。</p>
<p>​        换算成十进制为 18 位数的 long 类型，每毫秒可以并发 12 位二进制的累加。  </p>
<p>​        <strong>使用方式：</strong></p>
<p>​        1、配置server.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        2、修改sequence_time_conf.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">WORKID</span>=<span class="string">06 #任意整数</span></span><br><span class="line"><span class="attr">DATAACENTERID</span>=<span class="string">06  #任意整数</span></span><br></pre></td></tr></table></figure>

<p>​        3、修改schema.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"test2"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        4、启动mycat，并且创建表进行测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2(<span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment primary <span class="keyword">key</span>,xm <span class="built_in">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2(<span class="keyword">id</span>,xm) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL，<span class="string">'lisi'</span>) ;</span><br></pre></td></tr></table></figure>

<p>​        此方式的优点是配置简单，但是缺点也很明显就是18位的id太长，需要耗费多余的存储空间。</p>
<h3 id="4、自定义全局序列"><a href="#4、自定义全局序列" class="headerlink" title="4、自定义全局序列"></a>4、自定义全局序列</h3><p>​        用户还可以在程序中自定义全局序列，通过java代码来实现，这种方式一般比较麻烦，因此在能使用mycat提供的方式满足需求的前提下一般不需要自己通过java代码来实现。</p>
<h3 id="5、分布式ZK-ID生成器"><a href="#5、分布式ZK-ID生成器" class="headerlink" title="5、分布式ZK ID生成器"></a>5、分布式ZK ID生成器</h3><p>​        如果在搭建的时候使用了zookeeper，也可以使用zk来生成对应的id，此方式需要zk的配合，此处不再展示，有兴趣的同学下去自己演示即可。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从复制</title>
    <url>/2021/04/28/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。</p>
<p>​        MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<a id="more"></a>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>​        （1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</p>
<p>​        （2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p>
<p>​        （3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。        </p>
<p><strong>也就是说</strong>：</p>
<ul>
<li>从库会生成两个线程,一个<code>I/O线程</code>,一个<code>SQL线程</code>;</li>
<li><code>I/O线程</code>会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li>
<li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li>
<li><code>SQL线程</code>,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li>
<li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li>
<li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li>
<li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</li>
<li>master和slave两节点间时间需同步</li>
</ul>
<p><strong>具体步骤</strong>：</p>
<p>1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</p>
<p>2、从库的IO线程和主库的dump线程建立连接。</p>
<p>3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p>
<p>4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p>
<p>5、从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p>
<p>6、从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p>
<hr>
<h2 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h2><p>延迟问题请点击跳转<a href="https://yrlzero.gitee.io/2021/05/02/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F" target="_blank" rel="noopener">主从复制延迟专题</a></p>
<h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改<code>master</code>配置文件<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启动二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="comment">#设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br></pre></td></tr></table></figure>

<p>修改<code>slave</code>配置文件<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p>重启master和slave的mysql服务</p>
<p><code>service mysql restart</code></p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E9%87%8D%E5%90%AFmysql%E6%9C%8D%E5%8A%A1.jpg" alt=""></p>
<h3 id="授权账户"><a href="#授权账户" class="headerlink" title="授权账户"></a>授权账户</h3><p>登录master的mysql服务，授权账户主从复制权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Root_123&#39;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7slave%E6%9D%83%E9%99%90.jpg" alt=""></p>
<h3 id="查看master状态"><a href="#查看master状态" class="headerlink" title="查看master状态"></a>查看master状态</h3><p>登录master的mysql服务中，执行<code>show master status</code>查询master状态</p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bmaster%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<p>File和Position的值在下面的slave服务中会使用到；</p>
<p>可以通过<code>start master</code>、<code>stop master</code>、<code>reset master</code>等命令操作master，但是操作之后的master状态值可能发生变化</p>
<h3 id="slave执行主从复制命令"><a href="#slave执行主从复制命令" class="headerlink" title="slave执行主从复制命令"></a>slave执行主从复制命令</h3><p>登录slave的mysql服务中，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-slave%E6%89%A7%E8%A1%8C%E5%A4%8D%E5%88%B6%E6%8C%87%E4%BB%A4.jpg" alt=""></p>
<h3 id="查看slave状态"><a href="#查看slave状态" class="headerlink" title="查看slave状态"></a>查看slave状态</h3><p>在slave的mysql服务中执行<code>show slave status\G</code>查看slave状态</p>
<p>这时可以看到Slave_IO_Running，Slave_SQL_Running这两个属性都是NO</p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bslave%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<h3 id="启动slave"><a href="#启动slave" class="headerlink" title="启动slave"></a>启动slave</h3><p>此时需要执行<code>start slave</code>命令，启动slave</p>
<p>当看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示主从复制已经准备好了，可以进行具体的操作了</p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bslave%E7%8A%B6%E6%80%81-02.jpg" alt=""></p>
<p>关于slave，也可以通过<code>start slave</code>、<code>stop slave</code>、<code>reset slave</code>等命令操作slave</p>
<h3 id="建库同步"><a href="#建库同步" class="headerlink" title="建库同步"></a>建库同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave查看数据库，都没有mytest这个库</span><br><span class="line">-- 在master执行建库语句</span><br><span class="line">create database mytest;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E5%BB%BA%E5%BA%93%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中创建的mytest库</p>
<h3 id="建表同步"><a href="#建表同步" class="headerlink" title="建表同步"></a>建表同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave中进入mytest数据库，查看表格，都没有t1这个表</span><br><span class="line">-- 在master执行建表语句</span><br><span class="line">create table t1(id int,name varchar(10));</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E5%BB%BA%E8%A1%A8%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中创建的t1表</p>
<h3 id="语句同步"><a href="#语句同步" class="headerlink" title="语句同步"></a>语句同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave中进入mytest数据库，查看t1表格数据，都为空</span><br><span class="line">-- 在master执行insert语句</span><br><span class="line">insert into t1 values(1,&#39;zhangsan&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-insert%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中执行insert命令插入的数据</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当master执行的语句被同步到slave时，如果slave存在对应的语句在约束上与master同步过来的语句冲突时，同步会失败，在<code>/var/log/mysqld.log</code>中可以看到错误。</p>
<p>所以一般来说从库不允许写入，只能读取。</p>
<hr>
<h2 id="多主多从"><a href="#多主多从" class="headerlink" title="多主多从"></a>多主多从</h2><p>​    在上述的一主一从的架构设计中，很容易出现单点的问题，所以我们要想让生产环境中的配置足够稳定，可以配置双主双从，解决单点的问题。</p>
<img src="/images/linux/mycat/mycat多主多从.jpg" style="zoom: 67%;" />

<p>在此架构中，可以让一台主机用来处理所有写请求，此时，它的从机和备机，以及备机的从机复制所有读请求，当主机宕机之后，另一台主机负责写请求，两台主机互为备机。</p>
<p>主机分布如下：    </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>角色</th>
<th>ip</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>master-1</td>
<td>192.168.243.131</td>
<td>centos-1</td>
</tr>
<tr>
<td>2</td>
<td>slave-1</td>
<td>192.168.243.132</td>
<td>centos-2</td>
</tr>
<tr>
<td>3</td>
<td>master-2</td>
<td>192.168.243.133</td>
<td>centos-3</td>
</tr>
<tr>
<td>4</td>
<td>slave-2</td>
<td>192.168.243.134</td>
<td>centos-4</td>
</tr>
</tbody></table>
<p><code>master-1</code>与<code>slave-1</code>为主从关系、<code>master-2</code>与<code>slave-2</code>为主从关系、<code>master-1</code>与<code>master-2</code>互为主备关系</p>
<h3 id="master-1"><a href="#master-1" class="headerlink" title="master-1"></a><code>master-1</code></h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=my_multi_test</span><br><span class="line"><span class="comment">#设置binlog的格式row（生产推荐使用，在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h3 id="master-2"><a href="#master-2" class="headerlink" title="master-2"></a><code>master-2</code></h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=my_multi_test</span><br><span class="line"><span class="comment">#设置binlog的格式row（生产推荐使用，在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h3 id="slave-1"><a href="#slave-1" class="headerlink" title="slave-1"></a>slave-1</h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="slave-2"><a href="#slave-2" class="headerlink" title="slave-2"></a>slave-2</h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启启动4台mysql <code>service musqld restart</code></p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E9%87%8D%E5%90%AFmysql.jpg" alt=""></p>
<h3 id="授权账户-1"><a href="#授权账户-1" class="headerlink" title="授权账户"></a>授权账户</h3><p>登录<code>master-1</code>、<code>master-2</code>的mysql服务，授权账户主从复制权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Root_123&#39;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7slave%E6%9D%83%E9%99%90.jpg" alt=""></p>
<h3 id="slave执行主从复制命令-1"><a href="#slave执行主从复制命令-1" class="headerlink" title="slave执行主从复制命令"></a>slave执行主从复制命令</h3><p>因为<code>master-1</code>之前生成过bin log文件所以file为mysql-bin.000006，可以通过执行重置命令<code>reset master</code>解决，回归初始状态</p>
<p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E9%87%8D%E7%BD%AEmaster.jpg" alt=""></p>
<p>登录<code>slave</code>的mysql服务中，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- slave-1中执行命令，对master-1进行主从复制</span><br><span class="line">-- MASTER_HOST为master-1的ip、MASTER_LOG_FILE为master-1的File名、MASTER_LOG_POS为master-1的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br><span class="line"></span><br><span class="line">-- slave-2中执行命令，对master-2进行主从复制</span><br><span class="line">-- MASTER_HOST为master-2的ip、MASTER_LOG_FILE为master-2的File名、MASTER_LOG_POS为master-2的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.133&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;442;</span><br></pre></td></tr></table></figure>

<h3 id="启动slave-1"><a href="#启动slave-1" class="headerlink" title="启动slave"></a>启动slave</h3><p>此时需要执行<code>start slave</code>命令，启动slave</p>
<h3 id="查看slave状态-1"><a href="#查看slave状态-1" class="headerlink" title="查看slave状态"></a>查看slave状态</h3><p>在slave的mysql服务中执行<code>show slave status\G</code>查看slave状态</p>
<p>当看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示主从复制已经准备好了，可以进行具体的操作了</p>
<h3 id="主备同步"><a href="#主备同步" class="headerlink" title="主备同步"></a>主备同步</h3><p>让<code>master-1</code>、<code>master-2</code>之间相互进行主从复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- master-1中执行命令，对master-2进行主从复制</span><br><span class="line">-- MASTER_HOST为master-2的ip、MASTER_LOG_FILE为master-2的File名、MASTER_LOG_POS为master-2的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.133&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;442;</span><br><span class="line"></span><br><span class="line">-- master-2中执行命令，对master-1进行主从复制</span><br><span class="line">-- MASTER_HOST为master-1的ip、MASTER_LOG_FILE为master-1的File名、MASTER_LOG_POS为master-1的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br></pre></td></tr></table></figure>

<p>执行<code>start slave</code>命令，启动slave</p>
<p>当两台master执行<code>show slave status\G</code>都看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示互为主备成功</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在<code>master-1</code>中执行<code>create database my_multi_test</code>语句创建数据库，如下图可以看到<code>master-1</code>执行完之后其余三台mysql均能查询到my_multi_test库；在<code>master-1</code>进入该数据库创建表t1，并在其他mysql能够查到，证明主从和主备搭建成功</p>
<img src="/images/linux/mysql/双主双从-01.jpg" style="zoom: 80%;" />

<img src="/images/linux/mysql/双主双从-02.jpg" style="zoom: 80%;" />

<hr>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>使用<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#读写分离" target="_blank" rel="noopener">mycat</a>进行读写分离，具体细节请点击查看<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#读写分离" target="_blank" rel="noopener">mycat-读写分离</a></p>
<hr>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>如果在运行时发现从库数据没有同步，则需要执行<code>show slave status\G</code>查看slave状态，如果看到Slave_IO_Running，Slave_SQL_Running这两个属性任一出现NO，则需要进行重置操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- master-1</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">master</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- slave-1</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- master-2</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">master</span></span><br><span class="line"><span class="comment">-- slave-2</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- 再执行主从命令	</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line"><span class="comment">-- 启动每个mysql的slave</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br></pre></td></tr></table></figure>

<p>此时再查看可以发现数据可以进行同步，但是之前的旧数据仍保持不变，之前同步失败的仍旧不会同步过来；</p>
<p>如果需要将之前的旧数据进行同步，那么slave节点的mysql需要清空数据，再重置，执行<code>CHANGE MASTER TO</code>主从命令；</p>
<p>但是需要注意的是主从命令参数中的<code>MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,MASTER_LOG_POS=154</code>需要是主节点最初的对应的参数；</p>
<p>因此，建议搭建之后保存相关的参数命令以便以后操作。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从复制延迟问题</title>
    <url>/2021/05/02/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h2><p><img src="/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt=""></p>
<ul>
<li>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进bin log，由于bin log是顺序写，所以效率很高。</li>
<li>master和slave之间的数据传输依靠了内部网络或专线，一般来说也是比较快的</li>
<li>slave读取master的数据写入relay log是追加日志，属于顺序io效率并不低</li>
<li>slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多</li>
<li>另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</li>
</ul>
<a id="more"></a>

<p>​        由此可以看出，延迟主要体现在<code>sql thread</code>处理数据入库阶段。</p>
<hr>
<h3 id="1、如何查看同步延迟状态？"><a href="#1、如何查看同步延迟状态？" class="headerlink" title="1、如何查看同步延迟状态？"></a>1、如何查看同步延迟状态？</h3><p>​            在从服务器上通过  show slave status 查看具体的参数，有几个参数比较重要：</p>
<p>​            <strong>master_log_file:    slave中的IO线程正在读取的主服务器二进制日志文件的名称</strong></p>
<p>​            <strong>read_master_log_pos:    在当前的主服务器二进制日志中，slave中的IO线程已经读取的位置</strong></p>
<p>​            <strong>relay_log_file:    sql线程当前正在读取和执行的中继日志文件的名称</strong></p>
<p>​            <strong>relay_log_pos:    在当前的中继日志中，sql线程已经读取和执行的位置</strong></p>
<p>​            <strong>relay_master_log_file:    由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称</strong></p>
<p>​            <strong>slave_io_running:    IO线程是否被启动并成功的连接到主服务器上</strong></p>
<p>​            <strong>slave_sql_running:    sql线程是否被启动</strong></p>
<p>​            <strong>seconds_behind_master:    从属服务器sql线程和从属服务器IO线程之间的事件差距，单位以秒计</strong></p>
<p>​            在观察同步延迟的时候，上述的几个参数都是比较重要的，其中有一个最最重要的参数需要我们引起注意，那就是<code>seconds_behind_master</code>，这个参数就表示当前备库延迟了多长时间，那么这个值是如何计算的呢？</p>
<p>​            在进行主从复制的时候，需要注意以下几个关键的时刻：</p>
<p>​            1、主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</p>
<p>​            2、之后传给备库B,我们把备库B接受完这个binlog的时刻记为T2;</p>
<p>​            3、备库B执行完成这个事务，我们把这个时刻记为T3;</p>
<p>​            所谓的主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到SBM。</p>
<p>​            如果刚刚的流程明白了，那么下面我们就要开始分析产生这个时间差值的原因有哪些了，以方便我们更好的解决生产环境中存在的问题。</p>
<h3 id="2、主从复制延迟产生的原因有哪些？"><a href="#2、主从复制延迟产生的原因有哪些？" class="headerlink" title="2、主从复制延迟产生的原因有哪些？"></a>2、主从复制延迟产生的原因有哪些？</h3><p>​        2.1、在某些部署环境中，slave所在的机器性能要比master所在的机器性能差。此时如果机器的资源不足的话就会影响slave同步的效率。</p>
<p>​        2.2、slave充当了读库，一般情况下主要写的压力在于master，那么slave会提供一部分读的压力，而如果slave的查询压力过大的话，slave的查询消耗了大量的CPU资源，那么必不可少的就会影响同步的速度。</p>
<p>​        2.3、大事务执行，如果master的一个事务执行了10分钟，而bin log的写入必须要等待事务完成之后，才会传入slave，那么此时在开始执行的时候就已经延迟了10分钟了。</p>
<p>​        2.4、master的对于bin log的写操作是追加日志，属于顺序写，slave单线程去master顺序读bin log，slave取到bin log之后在本地执行。mysql的主从复制都是<strong>单线程</strong>的操作，但是由于master是顺序写，所以效率很高，而slave也是顺序读取master的日志，此时的效率也是比较高的，但是当数据拉取回来之后，sql thread处理数据变成了随机的操作，而不是顺序的，所以此时成本会提高。</p>
<p>​        2.5、 slave在同步数据的同时，可能跟其他查询的线程发生锁抢占的情况，此时也会发生延时。</p>
<p>​        2.6、 当master的TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟。</p>
<p>​        2.7、 在进行bin log日志传输的时候，如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟。</p>
<p>​        这些就是可能会造成备库延迟的原因。</p>
<h3 id="3、如何解决复制延迟的问题"><a href="#3、如何解决复制延迟的问题" class="headerlink" title="3、如何解决复制延迟的问题"></a>3、如何解决复制延迟的问题</h3><p>​        先说一些虚的东西，什么叫虚的东西呢？就是一听上去感觉很有道理，但是在实施或者实际的业务场景中可能难度很大或者很难实现，下面我们从几个方面来进行描述：</p>
<h4 id="3-1、架构方面"><a href="#3-1、架构方面" class="headerlink" title="3.1、架构方面"></a>3.1、架构方面</h4><p>​            3.1.1、业务的持久化层的实现采用分库架构，让不同的业务请求分散到不同的数据库服务上，分散单台机器的压力</p>
<p>​            3.1.2、服务的基础架构在业务和mysql之间加入缓存层，减少mysql的读的压力，但是需要注意的是，如果数据经常要发生修改，那么这种设计是不合理的，因为需要频繁的去更新缓存中的数据，保持数据的一致性，导致缓存的命中率很低，所以此时就要慎用缓存了</p>
<p>​            3.1.3、使用更好的硬件设备，比如cpu，ssd等，但是这种方案一般对于公司而言不太能接受，原因也很简单，会增加公司的成本，而一般公司其实都很抠门，所以意义也不大，但是你要知道这也是解决问题的一个方法，只不过你需要评估的是投入产出比而已。</p>
<h4 id="3-2、从库配置方面"><a href="#3-2、从库配置方面" class="headerlink" title="3.2、从库配置方面"></a>3.2、从库配置方面</h4><p>​        <strong>3.2.1、修改sync_binlog的参数的值</strong></p>
<p>​        想要合理设置此参数的值必须要清楚的知道binlog的写盘的流程：</p>
<img src="/images/linux/mysql/sync_binlog.png" style="zoom:80%;" />

<p>可以看到，每个线程有自己的bin log cache，但是共用同一份bin log。</p>
<p>​        图中的write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快</p>
<p>​        图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占用磁盘的IOPS</p>
<p>​        而write和fsync的时机就是由参数sync_binlog来进行控制的。</p>
<p>​        1、当sync_binlog=0的时候，表示每次提交事务都只write，不fsync</p>
<p>​        2、当sync_binlog=1的时候，表示每次提交事务都执行fsync</p>
<p>​        3、当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p>
<p>​        一般在公司的大部分应用场景中，我们建议将此参数的值设置为1，因为这样的话能够保证数据的安全性，但是如果出现主从复制的延迟问题，可以考虑将此值设置为100~1000中的某个数值，非常不建议设置为0，因为设置为0的时候没有办法控制丢失日志的数据量，但是如果是对安全性要求比较高的业务系统，这个参数产生的意义就不是那么大了。        </p>
<p>​        2、直接禁用salve上的bin log，当从库的数据在做同步的时候，有可能从库的binlog也会进行记录，此时的话肯定也会消耗io的资源，因此可以考虑将其关闭，但是需要注意，如果你搭建的集群是级联的模式的话，那么此时的bin log也会发送到另外一台从库里方便进行数据同步，此时的话，这个配置项也不会起到太大的作用。</p>
<p>​        3、设置innodb_flush_log_at_trx_commit 属性，这个属性用来表示每一次的事务提交是否需要把日志都写入磁盘，这是很浪费时间的，一共有三个属性值，分别是0（每次写到服务缓存，一秒钟刷写一次），1（每次事务提交都刷写一次磁盘），2（每次写到os缓存，一秒钟刷写一次），一般情况下我们推荐设置成2，这样就算mysql的服务宕机了，卸载os缓存中的数据也会进行持久化。</p>
<h3 id="4、从根本上解决主从复制的延迟问题"><a href="#4、从根本上解决主从复制的延迟问题" class="headerlink" title="4、从根本上解决主从复制的延迟问题"></a>4、从根本上解决主从复制的延迟问题</h3><p>​        大多数时候我们在线上的业务系统中都使用了mysql的主从复制，但是需要注意的是，并不是所有的场景都适合主从复制，一般情况下是读要远远多于写的应用，同时读的时效性要求不那么高的场景。如果真实场景中真的要求立马读取到更新之后的数据，那么就只能强制读取主库的数据，所以在进行实现的时候要考虑实际的应用场景，不要为了技术而技术，这是很严重的事情。</p>
<p>​        在mysql5.6版本之后引入了一个概念，就是我们通常说的<code>MTS</code>-Multi Thread Slave（并行复制），如下图：</p>
<img src="/images/linux/mysql/并行复制.png" style="zoom:80%;" />

<p>通过上图我们可以发现其实所谓的<code>MTS-并行复制</code>，就是在中间添加了一个分发的环节，也就是说原来的<code>sql thread</code>变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看并行的slave的线程的个数，默认是0.表示单线程</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slave_parallel_workers'</span>;</span><br><span class="line"><span class="comment">-- 根据实际情况保证开启多少线程</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slave_parallel_workers = <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 设置并发复制的方式，默认是一个线程处理一个库，值为database</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slave_parallel_type%'</span>;</span><br><span class="line"><span class="comment">-- 停止slave</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="comment">-- 设置属性值</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slave_parallel_type=<span class="string">'logical_check'</span>;</span><br><span class="line"><span class="comment">-- 开启slave</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- 查看线程数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure>

<p>​        通过上述的配置可以完成我们说的<code>MTS</code>-并行复制，但是此时需要思考几个问题</p>
<blockquote>
<p>1、在并行操作的时候，可能会有并发的事务问题，slave在执行的时候可以按照轮询的方式发送给各个worker吗？</p>
<p>​        答案：不行，因为事务被分发给worker以后，不同的worker就开始独立执行了，但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。</p>
<p>2、同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p>
<p>​        答案：不行，举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。</p>
</blockquote>
<p>​        我们通过讲解上述两个问题的最主要目的是为了说明一件事，就是coordinator在进行分发的时候，需要遵循的策略是什么？</p>
<blockquote>
<p>1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p>
<p>2、同一个事务不能被拆开，必须放到同一个worker中。</p>
</blockquote>
<p>​        综上所述，我们来说一下具体实现的原理和过程。</p>
<p>​        如果让我们自己来设计的话，我们应该如何操作呢？这是一个值得思考的问题。其实如果按照实际的操作的话，我们可以按照粒度进行分类，分为按库分发，按表分发，按行分发。</p>
<p>​        其实不管按照什么方式进行分发，大家需要注意的就是在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一个hash表，用来保存当前这个work正在执行的事务所涉及到的表。hash表的key值按照不同的粒度需要存储不同的值：</p>
<p>​        按库分发：key值是数据库的名字，这个比较简单</p>
<p>​        按表分发：key值是库名+表名</p>
<p>​        按行分发：key值是库名+表名+唯一键</p>
<h4 id="4-1、MySQL5-6版本的并行复制策略"><a href="#4-1、MySQL5-6版本的并行复制策略" class="headerlink" title="4.1、MySQL5.6版本的并行复制策略"></a>4.1、MySQL5.6版本的并行复制策略</h4><p>​        其实从mysql的5.6版本开始就已经支持了并行复制，只是支持的粒度是按库并行，这也是为什么现在的版本中可以选择类型为database，其实说的就是支持按照库进行并行复制。</p>
<p>​        但是其实用过的同学应该都知道，这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好，但是如果主库的所有表都放在同一DB上，那么所有的操作都会分发给一个worker，变成单线程操作了，那么这个策略的效果就不好了，因此在实际的生产环境中，用的并不是特别多。</p>
<h4 id="4-2、mariaDB的并行复制策略"><a href="#4-2、mariaDB的并行复制策略" class="headerlink" title="4.2、mariaDB的并行复制策略"></a>4.2、mariaDB的并行复制策略</h4><p>​        在mysql5.7的时候采用的是基于组提交的并行复制，换句话说，slave服务器的回放与主机是一致的，即主库是如何并行执行的那么slave就如何怎样进行并行回放，这点其实是参考了mariaDB的并行复制，下面我们来看下其实现原理。</p>
<p>​        mariaDB的并行复制策略利用的就是这个特性：</p>
<p>​        1、能够在同一组里提交的事务，一定不会修改同一行；</p>
<p>​        2、master上可以并行执行的事务，slave上也一定是可以并行执行的。</p>
<p>​        在实现上，mariaDB是这么做的：</p>
<p>​        1、在一组里面一起提交的事务，有一个相同的commit_id,下一组就是commit_id+1;</p>
<p>​        2、commit_id直接写到binlog里面；</p>
<p>​        3、传到slave应用的时候，相同commit_id的事务会分发到多个worker执行；</p>
<p>​        4、这一组全部执行完成后，coordinator再去取下一批。</p>
<p>​        这是mariaDB的并行复制策略，大体上看起来是没有问题的，但是你仔细观察的话会发现他并没有实现“真正的模拟主库并发度”这个目标，在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>​        我们真正想要达到的并行复制应该是如下的状态，也就是说当第一组事务提交的是，下一组事务是运行的状态，当第一组事务提交完成之后，下一组事务会立刻变成commit状态。</p>
<p><img src="/images/linux/mysql/mariaDB1.png" alt=""></p>
<p>​        但是按照mariaDB的并行复制策略，那么备库上的执行状态会变成如下所示：</p>
<p><img src="/images/linux/mysql/mariaDB2.png" alt=""></p>
<p>可以看到，这张图跟上面这张图的最大区别在于，slave上执行的时候必须要等第一组事务执行完成之后，第二组事务才能开始执行，这样系统的吞吐量就不够了。而且这个方案很容易被大事务拖后腿，如果trx2是一个大事务，那么在备库应用的时候，trx1和trx3执行完成之后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费。</p>
<h4 id="4-3、mysql5-7的并行复制策略"><a href="#4-3、mysql5-7的并行复制策略" class="headerlink" title="4.3、mysql5.7的并行复制策略"></a>4.3、mysql5.7的并行复制策略</h4><p>​        mysql5.7版本的时候，根据mariaDB的并行复制策略，做了相应的优化调整后，提供了自己的并行复制策略，并且可以通过参数slave-parallel-type来控制并行复制的策略：</p>
<p>​        1、当配置的值为DATABASE的时候，表示使用5.6版本的按库并行策略；</p>
<p>​        2、当配置的值为LOGICAL_CLOCK的时候，表示跟mariaDB相同的策略。</p>
<p>​        此时，大家需要思考一个问题：<strong>同时处于执行状态的所有事务，是否可以并行？</strong></p>
<p>​        答案：不行，因为多个执行中的事务是有可能出现锁冲突的，锁冲突之后就会产生锁等待问题。</p>
<p>​        在mariaDB中，所有处于commit状态的事务是可以并行，因为如果能commit的话就说明已经没有锁的问题，但是大家回想下，我们mysql的日志提交是两阶段提交，如下图，其实只要处于prepare状态就已经表示没有锁的问题了。</p>
<img src="/images/linux/mysql/两阶段提交.png" style="zoom: 45%;" />

<p>因此，mysql5.7的并行复制策略的思想是：</p>
<p>​        1、同时处于prepare状态的事务，在slave执行是可以并行的。</p>
<p>​        2、处于prepare状态的事务，与处于commit状态的事务之间，在slave上执行也是可以并行的。</p>
<p>​        基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置</p>
<p>​        1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</p>
<p>​        2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p>
<h3 id="5、基于GTID的主从复制问题"><a href="#5、基于GTID的主从复制问题" class="headerlink" title="5、基于GTID的主从复制问题"></a>5、基于GTID的主从复制问题</h3><p>​        在我们之前讲解的主从复制实操中，每次想要复制，必须要在备机上执行对应的命令，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.85.11'</span>,master_user=<span class="string">'root'</span>,master_password=<span class="string">'123456'</span>,master_port=<span class="number">3306</span>,master_log_file=<span class="string">'master-bin.000001'</span>,master_log_pos=<span class="number">154</span>;</span><br></pre></td></tr></table></figure>

<p>​        在此配置中我们必须要知道具体的bin log是哪个文件，同时在文件的哪个位置开始复制，正常情况下也没有问题，但是如果是一个主备主从集群，那么如果主机宕机，当从机开始工作的时候，那么备机就要同步从机的位置，此时位置可能跟主机的位置是不同的，因此在这种情况下，再去找位置就会比较麻烦，所以在5.6版本之后出来一个基于GTID的主从复制。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>
<p>​        GTID(global transaction id)是对于一个已提交事务的编号，并且是一个全局唯一的编号。GTID实际上是由UUID+TID组成的，其中UUID是mysql实例的唯一标识，TID表示该实例上已经提交的事务数量，并且随着事务提交单调递增。这种方式保证事务在集群中有唯一的ID，强化了主备一致及故障恢复能力。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务、日志</title>
    <url>/2021/04/21/mysql%E4%BA%8B%E5%8A%A1%E3%80%81%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="1、操作事务"><a href="#1、操作事务" class="headerlink" title="1、操作事务"></a>1、操作事务</h3><h4 id="1-1、手动提交"><a href="#1-1、手动提交" class="headerlink" title="1.1、手动提交"></a>1.1、手动提交</h4><p><img src="/images/linux/mysql/%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.jpg" alt=""></p>
<a id="more"></a>

<p><code>set autocommit=0</code>:当前session禁用自动提交事物.</p>
<p><code>begin</code>或<code>start transaction</code>：显式的开启一个事务.</p>
<p><code>commit</code>：提交事务，并使已对数据库进行的所有修改成为永久性的。</p>
<p><code>rollback</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改.</p>
<h4 id="1-2、自动提交"><a href="#1-2、自动提交" class="headerlink" title="1.2、自动提交"></a>1.2、自动提交</h4><p><code>set autocommit=1</code>开启自动提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL的每⼀条DML(增删改)语句都是⼀个单独的事务，每条语句都会⾃动开启⼀个事务，执⾏完毕⾃</span><br><span class="line">动提交事务，MySQL默认开始⾃动提交事务</span><br></pre></td></tr></table></figure>

<h4 id="1-3、回滚点"><a href="#1-3、回滚点" class="headerlink" title="1.3、回滚点"></a>1.3、回滚点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前⾯操作都已经成功，可以在当前成功的位置设置⼀个回滚点。</span><br><span class="line">可以供后续失败操作返回到该位置，⽽不是返回所有操作，这个点称之为回滚点。</span><br></pre></td></tr></table></figure>

<p>设置回滚点语法： <code>savepoint 回滚点名字</code></p>
<p>回到回滚点语法：<code>rollback to 回滚点名字</code></p>
<p>总结：设置回滚点可以让我们在失败的时候回到回滚点，⽽不是回到事务开启的时候。</p>
<h3 id="2、隔离级别"><a href="#2、隔离级别" class="headerlink" title="2、隔离级别"></a>2、隔离级别</h3><h4 id="2-1、查看"><a href="#2-1、查看" class="headerlink" title="2.1、查看"></a>2.1、查看</h4><p><code>show variables like &#39;%isolation%&#39;</code></p>
<h4 id="2-2、设置"><a href="#2-2、设置" class="headerlink" title="2.2、设置"></a>2.2、设置</h4><p><code>set global transaction isolation level &#39;级别字符串&#39;</code></p>
<h4 id="2-3、级别对比"><a href="#2-3、级别对比" class="headerlink" title="2.3、级别对比"></a>2.3、级别对比</h4><table>
<thead>
<tr>
<th>名字</th>
<th>隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th>实现</th>
<th>默认级别</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>READ UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td>每次都读取最新的数据</td>
<td></td>
</tr>
<tr>
<td>读已提交</td>
<td>READ COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td>每次读取前都创建read view，<br/>通过mvcc控制</td>
<td>Oracle、Sql Server</td>
</tr>
<tr>
<td>可重复读</td>
<td>REPEATABLE READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td>第一次读取之前创建read view，<br/>通过mvcc控制</td>
<td>Mysql</td>
</tr>
<tr>
<td>串行化</td>
<td>SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td>加锁</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-4、不同级别出现的问题"><a href="#2-4、不同级别出现的问题" class="headerlink" title="2.4、不同级别出现的问题"></a>2.4、不同级别出现的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>一个事务读到了另一个事务未提交的事务</p>
<p><img src="/images/linux/mysql/%E8%84%8F%E8%AF%BB%E6%BC%94%E7%A4%BA.jpg" alt=""></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>一个事务多次读取数据结果不一致</p>
<p><img src="/images/linux/mysql/%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%AF%BB%E6%BC%94%E7%A4%BA.jpg" alt=""></p>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p><img src="/images/linux/mysql/%E5%B9%BB%E8%AF%BB.jpg" alt=""></p>
<p>图中第四步的update是当前读，更新了数据的同时也更新了隐藏字段的<code>DB_TRX_ID</code>，之后在进行select快照读时，此数据对于当前事务课件，所以会将该数据读出。</p>
<p><strong>如果事务中都是用快照读，那么不会产生幻读的问题，但是快照读和当前读一起使用的时候就会产生幻读</strong>。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>T1</td>
<td>select * from user where age =20 for update;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into user values(25,’25’,20);此时会阻塞等待锁</td>
</tr>
<tr>
<td>T3</td>
<td>select * from user where age =20 for update;</td>
<td></td>
</tr>
</tbody></table>
<p>此时，可以看到事务2被阻塞了，需要等待事务1提交事务之后才能完成，其实本质上来说采用的是间隙锁的机制解决幻读问题。</p>
<h4 id="2-5、如何实现？"><a href="#2-5、如何实现？" class="headerlink" title="2.5、如何实现？"></a>2.5、如何实现？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读未提交，每次都读取最新的数据</span><br><span class="line">读已提交，每次读取之前创建read view，通过mvcc控制</span><br><span class="line">可重复读，第一次读取才创建read view，通过mvcc控制</span><br><span class="line">序列化，加锁</span><br></pre></td></tr></table></figure>

<p>​    <strong>总的来说，数据库的隔离级别依靠<code>MVCC</code>和<code>锁</code>实现；而<code>MVCC</code>依靠<code>隐藏字段</code>、<code>read view</code>、<code>undo log</code>实现。</strong></p>
<h3 id="3、事务四大特点"><a href="#3、事务四大特点" class="headerlink" title="3、事务四大特点"></a>3、事务四大特点</h3><table>
<thead>
<tr>
<th>事务特性</th>
<th>含义</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>A-原子性</td>
<td>事务中的多条SQL语句是⼀个整体，不可再分割，<br/>一起成功，一起失败。</td>
<td>通过undo log来保证</td>
</tr>
<tr>
<td>C-一致性</td>
<td>事务前后的数据要保证⼀致</td>
<td>通过原子性、隔离性、持久性来保证</td>
</tr>
<tr>
<td>I-隔离性</td>
<td>⼀个事务执⾏的结果不能影响另⼀个事务。</td>
<td>通过mvcc、间隙锁来保证</td>
</tr>
<tr>
<td>D-持久性</td>
<td>事务⼀旦提交，对数据库的数据影响是永久了。</td>
<td>通过redo log来保证</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、log"><a href="#二、log" class="headerlink" title="二、log"></a>二、log</h2><h3 id="1、bin-log（二进制日志、归档日志）"><a href="#1、bin-log（二进制日志、归档日志）" class="headerlink" title="1、bin log（二进制日志、归档日志）"></a>1、bin log（二进制日志、归档日志）</h3><p>server层面的日志，属于逻辑日志，以二进制形式记录相关语句的原始逻辑，没有crash-safe能力</p>
<h3 id="2、redo-log（重做日志）"><a href="#2、redo-log（重做日志）" class="headerlink" title="2、redo log（重做日志）"></a>2、redo log（重做日志）</h3><ul>
<li>是innodb存储引擎的日志，当发生数据修改时，先写到redolog中并更新内存；</li>
<li>该文件的大小是固定的，所以当记录满后从头循环继续写；</li>
<li>有了redolog日志，可以保证异常重启时数据不丢失,具有crash-safe能力</li>
</ul>
<img src="/images/linux/mysql/write_pos、check_point.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkpoint，在检查点之前的日志已经被记录到磁盘并擦除；</span><br><span class="line">write post表示当前写的位置；</span><br><span class="line">当两者相遇表示redo log日志已经写满，此时数据库停止进行相关的语句更新，转而进行redo log日志同步到磁盘的操作</span><br></pre></td></tr></table></figure>

<p>redo log刷盘</p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src="/images/linux/mysql/redo-logbuffer.jpg" alt=""></p>
<p>如右图所示，redo log的刷盘存在三种方式，可以通过<code>innodb_flush_log_at_trx_commit</code>参数进行调整，主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2</p>
<ul>
<li><p>值0：在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是等待后台线程每秒将缓存日志回写入文件缓存系统(OS Cache)，并fsync()刷盘。</p>
<blockquote>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
</blockquote>
</li>
<li><p>值1：在事务提交时，InnoDB立即将缓存日志写入文件缓存系统(OS Cache)，并fsync()刷盘。</p>
<blockquote>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
</blockquote>
</li>
<li><p>值2：在每个事务提交时，InnoDB立即将缓存中的redo日志回写到文件缓存系统(OS Cache)，但后台线程刷盘。</p>
<blockquote>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
</blockquote>
</li>
</ul>
<p>执行<code>SHOW VARIABLES LIKE &#39;innodb_flush_log_at_trx_commit&#39;</code>命令可知，mysql默认值为1</p>
<p><img src="/images/linux/mysql/innodb_flush.jpg" alt=""></p>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认设置为1，这是为了保证数据的持久性。当然，我们可以将这个配置项设置为1以外的值来换取更高的性能，但是在系统崩溃的时候，将会丢失1秒的数据。</span><br><span class="line"></span><br><span class="line">设置为0的话，Mysql进程崩溃的时候，就会丢失最后1秒的事务。</span><br><span class="line"></span><br><span class="line">设置为2的话，只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</span><br></pre></td></tr></table></figure>

<h3 id="3、relo-log两阶段提交"><a href="#3、relo-log两阶段提交" class="headerlink" title="3、relo log两阶段提交"></a>3、relo log两阶段提交</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/images/linux/mysql/redo%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>a、执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回<br>b、执行器拿到数据之后会先修改数据，然后调用引擎接口重新写入数据<br>c、引擎将数据更新到内存，同时写数据到redo中，此时处于<code>prepare</code>阶段，并通知执行器执行完成，随时可以操作<br>d、执行器生成这个操作的<code>bin log</code><br>f、执行器调用引擎的事务提交接口，引擎把刚刚写完的redo改成<code>commit</code>状态，更新完成</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>先写redo log后写bin log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设在redo log写完，bin log还没写完的时候，mysql进程异常启动。</span><br><span class="line">由于redo log写完之后，系统即使崩溃，仍然能把数据恢复回来，所以恢复后这一行数据值。</span><br><span class="line">但是由于bin log没写完就crash了，这时候bin log里面没有记录这个语句。</span><br><span class="line">因此，备份日志的时候，存起来的bin log里面就没有这条语句。</span><br><span class="line">之后如果使用这个bin log来恢复时，由于这条语句的丢失，恢复过来的数据会缺少此次的修改，与原数据值不同。</span><br></pre></td></tr></table></figure>

<p>先写bin log后写redo log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在bin log写完之后creash，由于redo log还没完，崩溃恢复以后这个事务无效，所以这样记录的值没有恢复。</span><br><span class="line">但是bin log里面已经记录了此次修改。</span><br><span class="line">在之后用bin log来恢复时就多出了一个事务，恢复的数据多出了这个值，与原库不一致</span><br></pre></td></tr></table></figure>

<h3 id="4、bin-log和redo-log区别"><a href="#4、bin-log和redo-log区别" class="headerlink" title="4、bin log和redo log区别"></a>4、bin log和redo log区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redo log是属于innoDB层面；</span><br><span class="line">binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</span><br><span class="line"></span><br><span class="line">redo log是物理日志，记录该数据页更新的内容；</span><br><span class="line">binlog是逻辑日志，记录的是这个更新语句的原始逻辑</span><br><span class="line"></span><br><span class="line">redo log是循环写，日志空间大小固定；</span><br><span class="line">binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</span><br><span class="line"></span><br><span class="line">binlog在事务提交后才会写入，可以作为恢复数据使用，主从复制搭建，在事务进行中数据修改前写入，然后才对缓存中的数据进行修改;</span><br><span class="line">redo log作为异常宕机或者介质故障后的数据恢复使用。</span><br></pre></td></tr></table></figure>

<h3 id="5、undo-log（回滚日志）"><a href="#5、undo-log（回滚日志）" class="headerlink" title="5、undo log（回滚日志）"></a>5、undo log（回滚日志）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份数据，实现事务的回滚操作保证原子性，当出现错误或者执行rollback语句，系统利用undo log中的备份数据恢复到事务开始之前的状态</span><br><span class="line">提供innodb中实现MVCC功能</span><br><span class="line">undo log采用回滚段方式记录，5.5之后每个回滚段中有1024个undo log segment</span><br><span class="line">当删除时不会从undo log直接删除，只会记录delete_flag，之后再由purge线程判断是否删除</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。</span><br><span class="line">MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</span><br><span class="line"></span><br><span class="line">MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</span><br></pre></td></tr></table></figure>

<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像select lock in share mode(共享锁), select...for update; update, insert ,delete(排他锁)这些操作都是一种当前读;</span><br><span class="line"></span><br><span class="line">为什么叫当前读？</span><br><span class="line">就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</span><br></pre></td></tr></table></figure>

<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像不加锁的select操作就是快照读，即不加锁的非阻塞读；</span><br><span class="line">快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；</span><br><span class="line">之所以出现快照读的情况，是基于提高并发性能的考虑;</span><br><span class="line">快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；</span><br><span class="line">既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</span><br></pre></td></tr></table></figure>

<h3 id="当前读、快照读、MVCC关系"><a href="#当前读、快照读、MVCC关系" class="headerlink" title="当前读、快照读、MVCC关系"></a>当前读、快照读、MVCC关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现MVCC的一个非阻塞读功能。</span><br><span class="line">MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。</span><br></pre></td></tr></table></figure>

<h3 id="3个隐式字段"><a href="#3个隐式字段" class="headerlink" title="3个隐式字段"></a>3个隐式字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_TRX_ID：6byte,最近修改事务ID，记录最后一次操作（首次创建、最后一个更新）这条记录的事务id</span><br><span class="line">DB_ROLL_PTR：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment）</span><br><span class="line">DB_ROW_ID：6byte，隐藏主键，当表没有主键或者唯一键时，会自动创建该隐藏的自增id</span><br></pre></td></tr></table></figure>

<h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>Read View是事务进行快照读操作的时候生产的读视图，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。</p>
</li>
<li><p>其实Read View的最大作用是用来做可见性判断的，也就是说当某个事务在执行快照读的时候，对该记录创建一个Read View的视图，把它当作条件去判断当前事务能够看到哪个版本的数据，有可能读取到的是最新的数据，也有可能读取的是当前行记录的undolog中某个版本的数据</p>
</li>
<li><p>Read View遵循的可见性算法主要是将要被修改的数据的最新记录中的DB_TRX_ID（当前事务id）取出来，与系统当前其他活跃事务的id去对比，如果DB_TRX_ID跟Read View的属性做了比较，不符合可见性，那么就通过DB_ROLL_PTR回滚指针去取出undolog中的DB_TRX_ID做比较，即遍历链表中的DB_TRX_ID，直到找到满足条件的DB_TRX_ID，这个DB_TRX_ID所在的旧记录就是当前事务能看到的最新老版本数据。</p>
</li>
</ul>
<h4 id="read-view生成时机"><a href="#read-view生成时机" class="headerlink" title="read view生成时机"></a>read view生成时机</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RC-读已提交：每次读取数据前，都生成read view</span><br><span class="line">RR-可重复读：在第一次读取数据前，生成read view</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在RR（可重复读）级别下的某个事务的对某条记录的第一次快照读会创建一个快照即Read View，将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View；只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见</p>
</li>
<li><p>在RR（可重复读）级别下，快照读生成Read View时，Read View会记录此时所有其他活动和事务的快照，这些事务的修改对于当前事务都是不可见的，而早于Read View创建的事务所做的修改均是可见</p>
</li>
<li><p>在RC（可重复读）级别下，事务中，每次快照读都会新生成一个快照和Read View,这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p>
</li>
</ul>
<p>​        <strong>总结：在RC（可重复读）隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR（可重复读）隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View.</strong></p>
<h4 id="Read-View的全局属性"><a href="#Read-View的全局属性" class="headerlink" title="Read View的全局属性"></a>Read View的全局属性</h4><p>​        <code>trx_list</code>：一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</p>
<p>​        <code>up_limit_id</code>：记录trx_list列表中事务ID最小的ID，以下用min_trx_id 来表示方便理解</p>
<p>​        <code>low_limit_id</code>：Read View生成时刻系统尚未分配的下一个事务ID，以下用max_trx_id来表示方便理解</p>
<p>​        <code>create_trx_id</code>：当前事务id</p>
<h4 id="数据可见性判断"><a href="#数据可见性判断" class="headerlink" title="数据可见性判断"></a>数据可见性判断</h4><p>​    情况一：<code>DB_TRX_ID</code>与<code>create_trx_id</code>相等</p>
<ul>
<li>表明该数据是当前事务修改的记录</li>
</ul>
<p>​    当出现数据事务id不等于当前事务id时，根据undo log中的数据版本链往上追溯进行判断</p>
<p>​    情况二：<code>DB_TRX_ID</code> &lt;<code>min_trx_id</code></p>
<ul>
<li>当前<code>DB_TRX_ID</code>(记录的事务id)小于<code>min_trx_id</code>(最小活跃事务id)，这表明这条记录在其他活跃事务事前已经提交，所以数据对于当前事务可见</li>
</ul>
<p>情况三：<code>DB_TRX_ID</code> &gt;= <code>max_trx_id</code></p>
<ul>
<li>当前DB_TRX_ID (记录的事务id)大于<code>max_trx_id</code>(未分配事务id)，这表明在当前事务开启之后又有新的事务开启，并且修改提交了该数据，所以数据对于当前事务不可见</li>
</ul>
<p>情况四：<code>min_trx_id</code> &lt;= <code>DB_TRX_ID</code> &lt; <code>max_trx_id</code>，数据在两者之间需要分情况分析</p>
<ul>
<li><p>在区间内，<code>DB_TRX_ID</code> 也在<code>trx_list</code>中，那么当前事务不能读取。这表明该行数据是与当前事务一起开启的事务提交后生成的数据，所以数据对当前事务不可见</p>
</li>
<li><p>在区间内，但是<code>DB_TRX_ID</code> 不在<code>trx_list</code>中，在区间内表明之前存在多个开启事务，不在<code>DB_TRX_ID</code> 表明在之前的多个热点事务中，id处于中间的某个事务提交，所以当前的事务读取的行数据为之前提交的事务数据，所以数据对于当前事务可见</p>
</li>
<li><p>总得来说就是判断<code>DB_TRX_ID</code> 是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，未修改的数据，当前事务也是看不到；如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</p>
</li>
</ul>
<h4 id="purge与read-view"><a href="#purge与read-view" class="headerlink" title="purge与read view"></a>purge与read view</h4><p>​    为了节省磁盘空间，innodb有专门的<code>purge</code>线程来清理delete_bit为true的记录。为了不影响mvcc的正常工作，<code>purge</code>线程自己维护一个read view；如果某个记录的delete_bit为true，同时它的DB_TRX_ID（事务id）存在于<code>purge</code>线程的read view中，那么该记录可以被安全删除</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020/12/06/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、下载地址："><a href="#一、下载地址：" class="headerlink" title="一、下载地址："></a>一、下载地址：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/1.png" alt=""></p>
<a id="more"></a>

<p><img src="/images/linux/mysql/2.png" alt=""></p>
<h2 id="二、-删除旧有版本"><a href="#二、-删除旧有版本" class="headerlink" title="二、 删除旧有版本"></a>二、 删除旧有版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看MySql与mariadb安装情况</span><br><span class="line"># grep -i是不分大小写字符查询，只要含有mysql就显示</span><br><span class="line">rpm -qa | grep -i mysql </span><br><span class="line">rpm -qa | grep mariadb</span><br><span class="line"></span><br><span class="line"># 卸载mariadb(会与mysql冲突)</span><br><span class="line">rpm -e --nodeps xxxxx</span><br></pre></td></tr></table></figure>

<h2 id="三、-rpm安装新MySQL"><a href="#三、-rpm安装新MySQL" class="headerlink" title="三、 rpm安装新MySQL"></a>三、 rpm安装新MySQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建新文件夹</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line"></span><br><span class="line"># 上传文件</span><br><span class="line"></span><br><span class="line"># 对”mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar”解包，不是压缩文件不需要解压缩</span><br><span class="line">tar -xvf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E8%A7%A3%E5%8E%8Bmysqltar%E5%8C%85.jpg" alt=""></p>
<p>执行如下安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、安装 mysql-community-common</span><br><span class="line">rpm -ivh mysql-community-common-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 2、安装 mysql-community-libs</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 3、安装 mysql-community-client </span><br><span class="line">rpm -ivh mysql-community-client-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 4、安装 mysql-community-server</span><br><span class="line">yum -y install perl</span><br><span class="line">rpm -ivh mysql-community-server-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 5、安装 mysql-community-devel</span><br><span class="line">rpm -ivh mysql-community-devel-5.7.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>安装完成。MySql默认安装文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;    #数据库目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;mysql   #配置文件目录</span><br><span class="line">&#x2F;usr&#x2F;bin             #相关命令目录</span><br><span class="line">&#x2F;etc&#x2F;my.cnf         #核心配置文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mysqld.log #mysql日志存在位置</span><br></pre></td></tr></table></figure>

<h2 id="四、配置MySQL"><a href="#四、配置MySQL" class="headerlink" title="四、配置MySQL"></a>四、配置MySQL</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动mysql </span><br><span class="line">service mysqld start</span><br><span class="line">#重启mysql </span><br><span class="line">service mysqld restart</span><br><span class="line">#停止mysql</span><br><span class="line">service mysqld stop</span><br><span class="line">#查看mysql状态</span><br><span class="line">service mysqld status</span><br><span class="line"></span><br><span class="line"># 设置开机启动Mysql</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"># 设置开机不启动Mysql</span><br><span class="line">systemctl disable mysqld</span><br></pre></td></tr></table></figure>

<p>修改root密码</p>
<p>MySQL安装成功后，会生成一个临时密码，我们第一次登录需要输入这个密码，所以查看该临时密码，然后修改密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看临时密码(&#x2F;var&#x2F;log&#x2F;mysqld.log)</span><br><span class="line">grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line"></span><br><span class="line"># 使用root登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line">#然后输入&#x2F;var&#x2F;log&#x2F;mysqld.log文件中的临时密码</span><br><span class="line"></span><br><span class="line">#登录后；修改密码为Root_123</span><br><span class="line">set password &#x3D; password(&#39;Root_123&#39;);</span><br><span class="line"></span><br><span class="line">注意：密码必须包含大小写字母、数字、特殊符号</span><br></pre></td></tr></table></figure>

<h2 id="五、设置允许远程访问"><a href="#五、设置允许远程访问" class="headerlink" title="五、设置允许远程访问"></a>五、设置允许远程访问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录，密码为新修改的密码Root_123</span><br><span class="line">mysql -uroot –p</span><br><span class="line"></span><br><span class="line">#设置远程访问（使用root密码）：</span><br><span class="line">mysql&gt; grant all privileges on  *.*  to  &#39;root&#39; @&#39;%&#39;  identified by &#39;Root_123&#39; with grant option; </span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>设置3306端口可以被访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 退出mysql</span><br><span class="line"># 防火墙中打开3306端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;3306&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -P 3306 -h 127.0.0.1 -p&#39;password&#39;</span><br></pre></td></tr></table></figure>

<h2 id="七、备份"><a href="#七、备份" class="headerlink" title="七、备份"></a>七、备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份命令mysqldump格式</span><br><span class="line">   格式：mysqldump -h主机名  -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql </span><br><span class="line">还原MySQL数据库的命令</span><br><span class="line">	mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql核心概念</title>
    <url>/2021/04/21/mysql%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、基本架构"><a href="#一、基本架构" class="headerlink" title="一、基本架构"></a>一、基本架构</h2><p><img src="/images/linux/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<h3 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h3><p>连接器负责跟客户端建立连接，获取权限、维持和管理连接</p>
<ul>
<li><p>用户名、密码校验</p>
</li>
<li><p>查询权限信息，分配对应的权限</p>
</li>
<li><p>可以使用<code>show precesslist</code>查看现在的连接情况</p>
</li>
<li><p>如果太长时间没有动静，就会自动断开，通过<code>wait_timeout</code>控制，默认8小时</p>
</li>
</ul>
<p>连接可以分为两类</p>
<ul>
<li>长连接，推荐使用，但是要周期性的断开长连接</li>
<li>短连接</li>
</ul>
<h3 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h3><p>当执行查询语句的时候，会先去<code>查询缓存</code>中查看结果，之前执行过的sql语句及其结果可能以key-value的形势存储在缓存中，如果能找到则直接返回，找不到，就继续执行后续的阶段</p>
<p>不推荐使用<code>查询缓存</code>：</p>
<ul>
<li><code>查询缓存</code>的失效比较频繁，只要表更新，缓存就会清空</li>
<li>缓存对应新的更新数据命中率比较低</li>
</ul>
<h3 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h3><p>词法分析：mysql需要把输入字符串进行识别每个部分代表什么意思</p>
<ul>
<li>把字符串T识别成表明T</li>
<li>把字符串id识别成列id</li>
</ul>
<p>语法分析：根据语法规则判断这个sql语句是否满足mysql语法，如果不符合就会报错<code>You have an error in your SQL synta</code></p>
<h3 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h3><p>在具体执行sql语句之前，要先经过优化器的处理</p>
<ul>
<li>当表中有多个索引的时候，决定用哪个索引</li>
<li>当sql语句需要做多表关联的时候，决定表的链接，顺序</li>
</ul>
<p>不同的执行方式对sql语句的执行效率影响很大，目前有两种优化策略</p>
<ul>
<li>RBO：基于规则的优化</li>
<li>CBO：基于成本的优化</li>
</ul>
<p><code>show status like &#39;last_query_cost&#39;</code>查询最后一条语句使用的成本，预估的数据页值</p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接器：管理连接，权限校验</span><br><span class="line">分析器：词法分析，语法分析</span><br><span class="line">优化器：执行计划，索引选择</span><br><span class="line">执行器：操作引擎，返回结果</span><br><span class="line">存储引擎：存储数据，提供读写接口</span><br></pre></td></tr></table></figure>

<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1、hash"><a href="#1、hash" class="headerlink" title="1、hash"></a>1、hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于哈希表的实现，只有精确匹配索引所有列的查询才有效</span><br><span class="line">在mysql中，只有memory的存储引擎显式支持哈希索引</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash.jpg" alt="HASH"></p>
<h3 id="2、二叉树"><a href="#2、二叉树" class="headerlink" title="2、二叉树"></a>2、二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果数据有序出现单边增长的情况，会单边倾斜出现链表结构</span><br><span class="line">会应为树的深度过深而造成io次数变多，影响数据读取效率</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"></p>
<h3 id="3、红黑树（二叉平衡树）"><a href="#3、红黑树（二叉平衡树）" class="headerlink" title="3、红黑树（二叉平衡树）"></a>3、红黑树（二叉平衡树）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在二叉树的基础上多了树平衡，当出现单边失衡时，会进行转换，形成节点，但是数据量大时，层级会很深</span><br><span class="line">会应为树的深度过深而造成io次数变多，影响数据读取效率</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%91%E7%BA%A2%E6%A0%91.jpg" alt="红黑树"></p>
<h3 id="4、B树"><a href="#4、B树" class="headerlink" title="4、B树"></a>4、B树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对顶级节点进行横向扩展，叶节点具有相同的深度，节点存放数据</span><br><span class="line">特点：</span><br><span class="line">	1、所以键值分布在整棵树中</span><br><span class="line">	2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找</span><br><span class="line">	3、每个节点最多拥有m个子树</span><br><span class="line">	4、根节点至少有2个子树</span><br><span class="line">	5、分支节点至少拥有m&#x2F;2颗子树（除根节点和叶子节点外都是分支节点）</span><br><span class="line">	6、所有叶子数据存储在每个节点上节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</span><br><span class="line">缺点：数据存储在每个节点上，而mysql每次读取16K的数据，每个磁盘区块只有4K，当节点因存储数据而造成数据量变大的情况下，每次可读取的索引值也就变少了</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91.jpg" alt="B树"></p>
<h3 id="5、B-树"><a href="#5、B-树" class="headerlink" title="5、B+树"></a>5、B+树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">非叶子结点不存储data，数据只在叶子结点存储，这样mysql每次io读取的记录数能够得到较大提升</span><br></pre></td></tr></table></figure>

<img src="/images/linux/mysql/数据结构-b+树.jpg" alt="B+树" style="zoom:150%;" />

<h2 id="三、执行引擎"><a href="#三、执行引擎" class="headerlink" title="三、执行引擎"></a>三、执行引擎</h2><p>MyISAM与Innodb对比如下</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>Innodb</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引</td>
<td>即支持聚簇索引又支持非聚簇索引</td>
<td>只支持非聚簇索引</td>
</tr>
<tr>
<td>行锁</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储文件</td>
<td>frm，ibd</td>
<td>frm,myi,myd</td>
</tr>
<tr>
<td>具体行数</td>
<td>每次必须要全表扫描统计行数</td>
<td>通过变量保存行数（查询不能带条件）</td>
</tr>
<tr>
<td>适合操作类型</td>
<td>大量insert、delete、update</td>
<td>大量select</td>
</tr>
</tbody></table>
<p>如何选择？</p>
<p>​        1、是否需要支持事务，如果需要选择innodb，如果不需要选择myisam </p>
<p>​        2、如果表的大部分请求都是读请求，可以考虑myisam，如果既有读也有写，使用innodb</p>
<p>​        现在mysql的默认存储引擎已经变成了Innodb,推荐使用innodb</p>
<h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="1、结构类型"><a href="#1、结构类型" class="headerlink" title="1、结构类型"></a>1、结构类型</h3><h4 id="1-1、聚簇索引"><a href="#1-1、聚簇索引" class="headerlink" title="1.1、聚簇索引"></a>1.1、聚簇索引</h4><p>innodb使用该索引结构，数据文件和索引文件存放在一起</p>
<p><img src="/images/linux/mysql/innodb-b+%E6%A0%91.jpg" alt=""></p>
<h4 id="1-2、非聚簇索引"><a href="#1-2、非聚簇索引" class="headerlink" title="1.2、非聚簇索引"></a>1.2、非聚簇索引</h4><p>myisam使用该索引结构，数据文件和索引文件分开存放</p>
<p><img src="/images/linux/mysql/myisamb-b+%E6%A0%91.jpg" alt=""></p>
<h3 id="2、使用类型"><a href="#2、使用类型" class="headerlink" title="2、使用类型"></a>2、使用类型</h3><p>​    主键索引、唯一索引、普通索引、组合索引、全文索引</p>
<h3 id="3、相关概念"><a href="#3、相关概念" class="headerlink" title="3、相关概念"></a>3、相关概念</h3><h4 id="3-1、回表"><a href="#3-1、回表" class="headerlink" title="3.1、回表"></a>3.1、回表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当使用普通索引时，叶子结点查询到主键，根据主键找到主键索引叶子结点的数据</span><br></pre></td></tr></table></figure>

<h4 id="3-2、索引覆盖"><a href="#3-2、索引覆盖" class="headerlink" title="3.2、索引覆盖"></a>3.2、索引覆盖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般在组合索引的使用情况下出现的几率比较大，查询的列与索引的列相对应，可以在索引叶子结点找到匹配的数据，不需要再次回表查询</span><br></pre></td></tr></table></figure>

<h4 id="3-3、索引下推"><a href="#3-3、索引下推" class="headerlink" title="3.3、索引下推"></a>3.3、索引下推</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">高级别版本，如果多个条件进行查询，会一起带到执行引擎进行判断过滤，不需要匹配一个索引之后再回到server层进行判断，减少io交互</span><br></pre></td></tr></table></figure>

<h4 id="3-4、最左匹配"><a href="#3-4、最左匹配" class="headerlink" title="3.4、最左匹配"></a>3.4、最左匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组合索引在使用时，需要注意必须包含该组合最左边的列，否则无法使用该索引</span><br></pre></td></tr></table></figure>

<h3 id="4、常见优化"><a href="#4、常见优化" class="headerlink" title="4、常见优化"></a>4、常见优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、全值匹配</span><br><span class="line">2、最左匹配</span><br><span class="line">3、不在索引条件上做函数操作</span><br><span class="line">4、范围查找条件右边的列不会使用到索引</span><br><span class="line">5、尽量使用覆盖索引</span><br><span class="line">6、‘不等于’操作会导致全表扫描</span><br><span class="line">7、is null或is not null无法使用索引</span><br><span class="line">8、like 全模糊无法使用索引，应使用右模糊</span><br><span class="line">9、参数类型应与数据库类型匹配</span><br><span class="line">10、or会让索引失效</span><br><span class="line">11、join语句的关联条件尽量使用索引</span><br></pre></td></tr></table></figure>

<h3 id="5、order优化"><a href="#5、order优化" class="headerlink" title="5、order优化"></a>5、order优化</h3><h4 id="5-1、双路排序"><a href="#5-1、双路排序" class="headerlink" title="5.1、双路排序"></a>5.1、双路排序</h4><p>​        读取排序字段，在buffer进行排序，再从磁盘读取其他查询字段</p>
<h4 id="5-2、单路排序"><a href="#5-2、单路排序" class="headerlink" title="5.2、单路排序"></a>5.2、单路排序</h4><p>​        4.1之后，一次性读取排序字段和查询字段，在buffer排序之后直接返回，一次性读取两类数据使用更容易超出buffer总大小</p>
<p><code>查询的字段总大小小于max_length_for_sort_data的限制值（1024B），且排序字段不是TEXT|BLOB时，会使用单路排序</code></p>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存在问题：</span><br><span class="line">	sort_buffer的容量有限，如果读取的数据超过了buffer的默认大小262144B（256KB），造成需要多次读取，创建templ文件再进行合并排序，io次数增加，性能下降；</span><br><span class="line">	</span><br><span class="line">优化：</span><br><span class="line">	可以通过调整sort_buffer_size、sort_buffer_size的大小来进行优化</span><br><span class="line">	不管单路还是双路，提高sort_buffer_size都能提高效率，但需要根据系统能力去调整</span><br><span class="line">	提高max_length_for_sort_data的大小会影响使用何种排序算法</span><br></pre></td></tr></table></figure>

<h3 id="6、group优化"><a href="#6、group优化" class="headerlink" title="6、group优化"></a>6、group优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group by 实际上是先排序后分组</span><br><span class="line">无法使用到索引列时，可以考虑增大max_length_for_sort_data和sort_buffer_size参数</span><br><span class="line">where优先级高于having，条件尽量在where进行限制</span><br></pre></td></tr></table></figure>



<h2 id="五、局部性原理和磁盘预读"><a href="#五、局部性原理和磁盘预读" class="headerlink" title="五、局部性原理和磁盘预读"></a>五、局部性原理和磁盘预读</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘 I&#x2F;O。</span><br><span class="line">	为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</span><br><span class="line"></span><br><span class="line">局部性原理：</span><br><span class="line">	当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</span><br><span class="line">	</span><br><span class="line">磁盘预读：</span><br><span class="line">	由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I&#x2F;O 效率。</span><br><span class="line">	预读的长度一般为页（4K）（page）的整倍数。</span><br></pre></td></tr></table></figure>

<h2 id="六、页分裂"><a href="#六、页分裂" class="headerlink" title="六、页分裂"></a>六、页分裂</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页可能填充至100%，在页填满了之后，下一页会继续接管新的记录。但如果下一页也满了，数据又需要按顺序插入，就会产生页分裂。</span><br><span class="line"></span><br><span class="line">InnoDB的做法是（简化版）：</span><br><span class="line">    创建新页</span><br><span class="line">    判断当前页可以从哪里进行分裂（记录行层面）</span><br><span class="line">    移动记录行</span><br><span class="line">    重新定义页之间的关系</span><br><span class="line">    </span><br><span class="line">等于创建了一个新页，并且把当前页的数据迁移部分到新页中，然后插入在当前页和下一页的中间。</span><br></pre></td></tr></table></figure>

<h2 id="七、页合并"><a href="#七、页合并" class="headerlink" title="七、页合并"></a>七、页合并</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</span><br><span class="line"></span><br><span class="line">当页中删除的记录达到MERGE_THRESHOLD（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</span><br></pre></td></tr></table></figure>

<h2 id="八-、Sql-Join"><a href="#八-、Sql-Join" class="headerlink" title="八 、Sql Join"></a>八 、Sql Join</h2><p>​        MySQL是只支持一种Join算法Nested-Loop Join(嵌套循环连接)，并不支持哈希连接和合并连接，不过在mysql中包含了多种变种，能够帮助MySQL提高join执行的效率。</p>
<h3 id="1、Simple-Nested-Loop-Join"><a href="#1、Simple-Nested-Loop-Join" class="headerlink" title="1、Simple Nested-Loop Join"></a><strong>1、Simple Nested-Loop Join</strong></h3><p>​        这个算法相对来说就是很简单了，从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了。</p>
<h3 id="2、Index-Nested-Loop-Join"><a href="#2、Index-Nested-Loop-Join" class="headerlink" title="2、Index Nested-Loop Join"></a><strong>2、Index Nested-Loop Join</strong></h3><p>​        索引嵌套联系由于非驱动表上有索引，所以比较的时候不再需要一条条记录进行比较，而可以通过索引来减少比较，从而加速查询。这也就是平时我们在做关联查询的时候必须要求关联字段有索引的一个主要原因。</p>
<p>​        这种算法在链接查询的时候，驱动表会根据关联字段的索引进行查找，当在索引上找到了符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表。至于驱动表的选择，MySQL优化器一般情况下是会选择记录数少的作为驱动表，但是当SQL特别复杂的时候不排除会出现错误选择。</p>
<p>​        在索引嵌套链接的方式下，如果非驱动表的关联键是主键的话，这样来说性能就会非常的高，如果不是主键的话，关联起来如果返回的行数很多的话，效率就会特别的低，因为要多次的回表操作。先关联索引，然后根据二级索引的主键ID进行回表的操作。这样来说的话性能相对就会很差。</p>
<h3 id="3、Block-Nested-Loop-Join"><a href="#3、Block-Nested-Loop-Join" class="headerlink" title="3、Block Nested-Loop Join"></a><strong>3、Block Nested-Loop Join</strong></h3><p>​        在有索引的情况下，MySQL会尝试去使用Index Nested-Loop Join算法，在有些情况下，可能Join的列就是没有索引，那么这时MySQL的选择绝对不会是最先介绍的Simple Nested-Loop Join算法，而是会优先使用Block Nested-Loop Join的算法。</p>
<p>​        Block Nested-Loop Join对比Simple Nested-Loop Join多了一个中间处理的过程，也就是join buffer，使用join buffer将驱动表的查询JOIN相关列都给缓冲到了JOIN BUFFER当中，然后批量与非驱动表进行比较，这也来实现的话，可以将多次比较合并到一次，降低了非驱动表的访问频率。也就是只需要访问一次S表。这样来说的话，就不会出现多次访问非驱动表的情况了，也只有这种情况下才会访问join buffer。</p>
<p>​        在MySQL当中，我们可以通过参数join_buffer_size来设置join buffer的值，然后再进行操作。默认情况下join_buffer_size=256K，在查找的时候MySQL会将所有的需要的列缓存到join buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join buffer。</p>
<h2 id="九、锁"><a href="#九、锁" class="headerlink" title="九、锁"></a>九、锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁并不是数据库自带的，如果需要使用乐观锁，那么需要自己去实现，一般情况下，我们会在表中新增一个version字段，每次更新数据version+1,在进行提交之前会判断version是否一致。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>mysql中的绝大部分锁都是悲观锁，按照粒度可以分为行锁和表锁</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul>
<li><p>共享锁：当读取一行记录的时候，为了防止别人修改，则需要添加S锁</p>
</li>
<li><p>排它锁：当修改一行记录的时候，为了防止别人同时进行修改，则需要添加X锁</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<ul>
<li>记录锁：添加在行索引上的锁</li>
<li>间隙锁：锁定范围是索引记录之间的间隙，针对可重复读以上隔离级别</li>
<li>临键锁：记录锁+间隙锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li><p>意向锁：在获取某行的锁之前，必须要获取表的锁，分为意向共享锁，意向排它锁</p>
</li>
<li><p>自增锁：对自增字段所采用的特殊表级锁</p>
</li>
</ul>
<h4 id="锁模式的含义"><a href="#锁模式的含义" class="headerlink" title="锁模式的含义"></a>锁模式的含义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IX：意向排它锁</span><br><span class="line"></span><br><span class="line">X：锁定记录本身和记录之前的间隙</span><br><span class="line"></span><br><span class="line">S：锁定记录本身和记录之前的间隙</span><br><span class="line"></span><br><span class="line">X,REC_NOT_GAP：只锁定记录本身</span><br><span class="line"></span><br><span class="line">S，REC_NOT_GAP：只锁定记录本身</span><br><span class="line"></span><br><span class="line">X，GAP：间隙锁，不锁定记录本身</span><br><span class="line"></span><br><span class="line">S，GAP：间隙锁，不锁定记录本身</span><br><span class="line"></span><br><span class="line">X，GAP,INSERT_INTENTION：插入意向锁</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos集群安装</title>
    <url>/2020/12/06/nacos%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载稳定版本1-3-1（July-10-2020）"><a href="#1-下载稳定版本1-3-1（July-10-2020）" class="headerlink" title="1. 下载稳定版本1.3.1（July 10, 2020）"></a>1. 下载稳定版本<a href="https://github.com/alibaba/nacos/releases/tag/1.3.1" target="_blank" rel="noopener">1.3.1（July 10, 2020）</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他版本参考：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos&#x2F;releases</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-官方文档："><a href="#2-官方文档：" class="headerlink" title="2. 官方文档："></a>2. 官方文档：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;quick-start.html</span><br></pre></td></tr></table></figure>

<h2 id="3-sql脚本导入"><a href="#3-sql脚本导入" class="headerlink" title="3. sql脚本导入"></a>3. sql脚本导入</h2><p><img src="/images/cloud/alibaba/nacos/nacos%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6.jpg" alt=""> <img src="/images/cloud/alibaba/nacos/%E6%89%A7%E8%A1%8Cnaocs%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.jpg" alt=""></p>
<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建安装目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nacos</span><br><span class="line"># 上传压缩包</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf nacos-server-1.3.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="5-修改集群配置"><a href="#5-修改集群配置" class="headerlink" title="5. 修改集群配置"></a>5. 修改集群配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf</span><br><span class="line"># 拷贝集群配置</span><br><span class="line">cp cluster.conf.example  cluster.conf</span><br><span class="line"># 修改配置文件</span><br><span class="line">vi cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="/images/cloud/alibaba/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.jpg" alt=""> </p>
<h2 id="6-远程拷贝集群配置文件"><a href="#6-远程拷贝集群配置文件" class="headerlink" title="6. 远程拷贝集群配置文件"></a>6. 远程拷贝集群配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从第一台机器拷贝配置文件都其他机器</span><br><span class="line">scp root@192.168.243.131:&#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;cluster.conf &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cloud/alibaba/nacos/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D.jpg" alt=""></p>
<h2 id="7-修改启动配置"><a href="#7-修改启动配置" class="headerlink" title="7. 修改启动配置"></a>7. 修改启动配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取JAVA_HOME</span><br><span class="line">echo $JAVA_HOME</span><br><span class="line"></span><br><span class="line"># 修改jdk，新增jdk配置，原有的注释</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/cloud/alibaba/nacos/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="8-修改naocs自身配置"><a href="#8-修改naocs自身配置" class="headerlink" title="8. 修改naocs自身配置"></a>8. 修改naocs自身配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;application.properties</span><br></pre></td></tr></table></figure>

<p><img src="/images/cloud/alibaba/nacos/nacos%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="9-异常情况"><a href="#9-异常情况" class="headerlink" title="9. 异常情况"></a>9. 异常情况</h2><p>如果出现JAVA服务无法连接nacos集群的情况，可以修改nacos.inetutils.ip-address为本机ip(一般情况下不加)</p>
<h2 id="10-开放防火墙"><a href="#10-开放防火墙" class="headerlink" title="10. 开放防火墙"></a>10. 开放防火墙</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开8848端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8848&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>alibaba</tag>
        <tag>配置中心</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx安装</title>
    <url>/2020/11/29/nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><img src="/images/linux/nginx/nginx版本介绍.jpg" style="zoom: 67%;" />

<a id="more"></a>

<h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><h3 id="1-下载安装包方式"><a href="#1-下载安装包方式" class="headerlink" title="1. 下载安装包方式"></a>1. 下载安装包方式</h3><ul>
<li><p>官网直接下载<code>http://nginx.org/en/download.html</code></p>
</li>
<li><p>使用<code>wget</code>命令下载（推荐）。确保系统已经安装了<code>wget</code>，如果没有安装，执行 <code>yum install wget</code> 安装<code>wget -c https://nginx.org/download/nginx-1.18.0.tar.gz</code></p>
</li>
</ul>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-yum安装依赖项"><a href="#3-yum安装依赖项" class="headerlink" title="3. yum安装依赖项"></a>3. yum安装依赖项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gcc安装，nginx源码编译需要；pcre-devel 安装，nginx 的 http 模块使用 pcre 来解析正则表达式；zlib安装，nginx 使用zlib对http包的内容进行gzip</span><br><span class="line"></span><br><span class="line">yum install gcc pcre-devel zlib-devel</span><br></pre></td></tr></table></figure>

<h3 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx-1.18.0</span><br><span class="line"></span><br><span class="line">#使用默认配置</span><br><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>

<h3 id="5-编译安装"><a href="#5-编译安装" class="headerlink" title="5. 编译安装"></a>5. 编译安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="6-启动、停止nginx"><a href="#6-启动、停止nginx" class="headerlink" title="6. 启动、停止nginx"></a>6. 启动、停止nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx </span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line">.&#x2F;nginx -s quit</span><br><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="Yum安装"><a href="#Yum安装" class="headerlink" title="Yum安装"></a><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener">Yum安装</a></h2><h3 id="安装yum"><a href="#安装yum" class="headerlink" title="安装yum"></a>安装yum</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install yum-utils</span><br></pre></td></tr></table></figure>

<h3 id="添加yum安装源"><a href="#添加yum安装源" class="headerlink" title="添加yum安装源"></a>添加yum安装源</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加以下内容</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>redis-安装</title>
    <url>/2020/12/12/redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="一、下载地址"><a href="#一、下载地址" class="headerlink" title="一、下载地址"></a>一、<a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></h4><p><img src="/images/linux/redis/%E4%B8%8B%E8%BD%BD.jpg" alt=""></p>
<a id="more"></a>

<h4 id="二、安装gcc依赖"><a href="#二、安装gcc依赖" class="headerlink" title="二、安装gcc依赖"></a>二、安装gcc依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看gcc版本是否在9.3以上，centos7.6默认安装4.8.5</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E6%9F%A5%E7%9C%8Bgcc%E7%89%88%E6%9C%AC.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis6以上,gcc版本不能低于5,升级gcc到9.3及以上,如下：</span><br><span class="line">升级到gcc 9.3：</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。</span><br><span class="line">如果要长期使用gcc 9.3的话：</span><br><span class="line"></span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">这样退出shell重新打开就是新版的gcc了</span><br><span class="line">以下其他版本同理，修改devtoolset版本号即可。</span><br></pre></td></tr></table></figure>

<h4 id="三、上传安装"><a href="#三、上传安装" class="headerlink" title="三、上传安装"></a>三、上传安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#上传安装包、解压、编译</span><br><span class="line">tar zxf redis-6.0.9.tar.gz </span><br><span class="line">cd redis-6.0.9</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">#安装并指定安装目录</span><br><span class="line">make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>

<h4 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><h6 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>

<h6 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h6><p>1.从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>2.修改 redis.conf 文件，把 daemonize no 改为 daemonize yes</p>
<p><img src="/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%AE%88%E6%8A%A4%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<p>3.注释掉 # bind 127.0.0.1，并修改 protected-mode yes 改为 protected-mode no</p>
<p><img src="/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<p>4.设置密码</p>
<p><img src="/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<p>5.启动命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line"># 停止</span><br><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>1.修改redis环境变量方便之后使用redis命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<img src="/images/linux/redis/redis_etc_profile.jpg" style="zoom: 80%;" />

<p>2.执行安装服务脚本</p>
<p>回到压缩包解压目录的 utils文件夹中，执行install_server.sh脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;utils</span><br><span class="line">.&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>

<p>2.1执行失败</p>
<p><img src="/images/linux/redis/%E5%AE%89%E8%A3%85redis%E6%9C%8D%E5%8A%A1%E5%A4%B1%E8%B4%A5.jpg" alt=""></p>
<p>进入install_server.sh脚本中，注释图中所示代码</p>
<p><img src="/images/linux/redis/%E4%BF%AE%E6%94%B9install_server%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<p>2.2执行成功</p>
<p><img src="/images/linux/redis/%E5%AE%89%E8%A3%85redis%E6%9C%8D%E5%8A%A1.jpg" alt=""></p>
<p>3.启动成功</p>
<p>之后可以通过service redis_6379 start/stop/status等命令进行操作</p>
<p><img src="/images/linux/redis/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt=""></p>
<h4 id="五、开放防火墙"><a href="#五、开放防火墙" class="headerlink" title="五、开放防火墙"></a>五、开放防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开6379端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;6379&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h4 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.243.131 -p 6379 -a passsword</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq系列-amqp</title>
    <url>/2020/06/03/rabbitmq%E7%B3%BB%E5%88%97-amqp/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>​         AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。</p>
<a id="more"></a>

<h2 id="二、spring-boot的应用"><a href="#二、spring-boot的应用" class="headerlink" title="二、spring boot的应用"></a><strong>二、spring boot的应用</strong></h2><h4 id="1-消息生产者"><a href="#1-消息生产者" class="headerlink" title="1.消息生产者"></a><strong>1.消息生产者</strong></h4><h5 id="1）导入maven依赖："><a href="#1）导入maven依赖：" class="headerlink" title="1）导入maven依赖："></a><strong>1）导入maven依赖：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2）配置application-yml"><a href="#2）配置application-yml" class="headerlink" title="2）配置application.yml"></a><strong>2）配置application.yml</strong></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">yrl_test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test123</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br></pre></td></tr></table></figure>

<h5 id="3）controller发送消息"><a href="#3）controller发送消息" class="headerlink" title="3）controller发送消息"></a><strong>3）controller发送消息</strong></h5><p>​    实际使用，应抽取rabbitTemplate注入序列化器，不应该每个方法设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange、routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgUser</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(param.get(<span class="string">"msg"</span>));</span><br><span class="line">        user.setBirthday(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不指定exchange，根据routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDefault"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDefault</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"key"</span>),msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange,不指定routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendHeader"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeader</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),<span class="string">""</span>,msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"key-one"</span>, <span class="string">"1"</span>);</span><br><span class="line">            properties.setHeader(<span class="string">"key-two"</span>, <span class="string">"2"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延迟消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDelay"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelay</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"x-delay"</span>, <span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-消息消费者"><a href="#2-消息消费者" class="headerlink" title="2. 消息消费者"></a><strong>2. 消息消费者</strong></h4><h5 id="1-配置"><a href="#1-配置" class="headerlink" title="1) 配置"></a><strong>1) 配置</strong></h5><h6 id="a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"><a href="#a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"></a>a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> *   durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line"><span class="comment"> *   exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line"><span class="comment"> *   autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line"><span class="comment"> *   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">testDirectQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"testDirectQueue"</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建直连交换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">testDirectExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"testDirectExchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将exchange和queue进行绑定，并设置匹配的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(testDirectQueue()).to(testDirectExchange()).with(<span class="string">"testDirectRouting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建监听器容器工厂，设置连接工厂、序列化方式（解决实体序列化问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">	factory.setConnectionFactory(connectionFactory);</span><br><span class="line">	factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">	<span class="comment">//开启手动Ack（后续使用配置消息确认使用）</span></span><br><span class="line">	<span class="comment">//factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span></span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	args.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">"delayExchangeCus"</span>, <span class="string">"x-delayed-message"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">"delayCusQueue"</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">queueBinding</span><span class="params">(Queue delayQueue, CustomExchange delayExchange)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(<span class="string">"cusDelayKey"</span>).noargs();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"><a href="#b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"></a>b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,routingKey为queue的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(<span class="string">"myDefaultQueue"</span>))</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultDirectReceiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"默认交换器，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.2"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue3"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.3"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct3Receiver</span><span class="params">(User param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器3，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.*"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器1</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器2</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，任意匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"any"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-three"</span>,value = <span class="string">"3"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，任意匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，全匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"all"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-two"</span>,value = <span class="string">"2"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，全匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"delayCusQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">		bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">				exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">				value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">				key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">		)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-开启手动应答模式"><a href="#2-开启手动应答模式" class="headerlink" title="2) 开启手动应答模式"></a><strong>2) 开启手动应答模式</strong></h5><h6 id="a-添加application-yml配置"><a href="#a-添加application-yml配置" class="headerlink" title="a. 添加application.yml配置"></a>a. 添加application.yml配置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="b-连接工厂设置参数"><a href="#b-连接工厂设置参数" class="headerlink" title="b. 连接工厂设置参数"></a>b. 连接工厂设置参数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启手动Ack</span></span><br><span class="line"><span class="keyword">new</span> SimpleRabbitListenerContainerFactory().setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br></pre></td></tr></table></figure>

<h6 id="c-监听器"><a href="#c-监听器" class="headerlink" title="c. 监听器"></a>c. 监听器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">           bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                   exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">                   value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">                   key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">           )</span><br><span class="line">   )</span><br><span class="line">   <span class="meta">@RabbitHandler</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">       Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">       System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String message = (String) param.get(<span class="string">"message"</span>);</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">"延迟消息1"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息1拒绝"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"延迟消息2"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">true</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息2拒绝,重新放入队列"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               channel.basicAck(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"正常提交"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>rabbitmq系列-基础篇</title>
    <url>/2020/06/02/rabbitmq%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现</p>
<a id="more"></a>

<h4 id="exchange"><a href="#exchange" class="headerlink" title="exchange:"></a>exchange:</h4><p>​        生产者将消息发送到 Exchange（交换器），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。Exchange 并不存储消息。RabbitMQ 中的 Exchange 有 direct、fanout、topic、headers 四种类型，每种类型对应不同的路由规则。</p>
<h4 id="queue："><a href="#queue：" class="headerlink" title="queue："></a>queue：</h4><p>​        队列是 RabbitMQ 的内部对象，用于存储消息。消息消费者就是通过订阅队列<br>来获取消息的，RabbitMQ 中的消息都只能存储在 Queue 中，生产者生产消息并最终投递到Queue 中，消费者可以从 Queue 中获取消息并消费。多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<h4 id="connection："><a href="#connection：" class="headerlink" title="connection："></a>connection：</h4><p>connection就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。程序的起始处就是建立这个TCP连接。</p>
<h4 id="channels："><a href="#channels：" class="headerlink" title="channels："></a>channels：</h4><p>​        虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p>
<p>那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。</p>
<h4 id="VirtualHost："><a href="#VirtualHost：" class="headerlink" title="VirtualHost："></a>VirtualHost：</h4><p>​        权限控制的基本单位，一个 VirtualHost 里面有若干 Exchange 和MessageQueue，以及指定被哪些 user 使用</p>
<h4 id="routing-key："><a href="#routing-key：" class="headerlink" title="routing key："></a>routing key：</h4><p>​        生产者在将消息发送给exchange的时候，一般会指定一个routing key，来匹配这个消息的路由规则。其实是匹配exchnage与queue绑定的bbinding key</p>
<h4 id="binding-key-："><a href="#binding-key-：" class="headerlink" title="binding key ："></a>binding key ：</h4><p>​        用于绑定exchange与queue之间的关系</p>
<h2 id="二、windows安装"><a href="#二、windows安装" class="headerlink" title="二、windows安装"></a><strong>二、windows安装</strong></h2><p>1）下载安装erlang</p>
<p>2）下载安装rabbitmq</p>
<p>3）安装管理界面（插件）</p>
<p>进入rabbitmq安装目录sbin中，调起cmd界面输入：rabbitmq-plugins enable rabbitmq_management</p>
<p>4）重启rabbitmq服务</p>
<p>5）访问地址127.0.0.1:15672，默认账号密码都为guest</p>
<h2 id="三、docker启动"><a href="#三、docker启动" class="headerlink" title="三、docker启动"></a>三、docker启动</h2><p>1)     搜索镜像：docker search rabbitmq</p>
<p>2)    下载镜像：docker pull rabbitmq:management</p>
<p>3)    创建容器，rabbitmq 需要有映射以下端口: 5671 5672 4369 15671 15672<br>25672</p>
<ul>
<li>15672  management管理端监听端口</li>
<li>5672、5671 AMQP使用端口</li>
<li>4369 epmd代表erlang守护进程的端口</li>
<li>25672 (Erlang distribution)</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -di --name=my_rabbitmq -p 5671:5617 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span></span><br></pre></td></tr></table></figure>

<h2 id="四、exchange-type"><a href="#四、exchange-type" class="headerlink" title="四、exchange type"></a><strong>四、exchange type</strong></h2><h4 id="1）直连模式-direct："><a href="#1）直连模式-direct：" class="headerlink" title="1）直连模式-direct："></a>1）直连模式-direct：</h4><p>​        direct类型的exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的queue中 。</p>
<p>​        默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,binding key为queue的名称。</p>
<img src="/images/直连模式.jpg" style="zoom:67%;" />

<h4 id="2）主题模式-topic"><a href="#2）主题模式-topic" class="headerlink" title="2）主题模式-topic"></a>2）主题模式-topic</h4><p> topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同， 可以根据某些规则进行匹配，如果 exchange 没有发现能够与 routing Key 匹配的 queue，则会抛弃此消息</p>
<img src="/images/主题模式.jpg" style="zoom:67%;" />

<p>符号 # 匹配一个或多个词，符号 * 匹配一个词</p>
<h4 id="3）分裂模式-fanout"><a href="#3）分裂模式-fanout" class="headerlink" title="3）分裂模式-fanout"></a><strong>3）分裂模式-fanout</strong></h4><p> fanout类型的exchange路由规则非常简单，它会把所有发送到该exchange的消息路由到所有与它绑定的queue中 </p>
<img src="/images/分裂模式.jpg" style="zoom:67%;" />



<h4 id="4）头部模式-headers"><a href="#4）头部模式-headers" class="headerlink" title="4）头部模式-headers"></a><strong>4）头部模式-headers</strong></h4><p>​         headers类型的exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定queue与exchange时指定一组键值对；当消息发送到exchange时，rabbitMq会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配queue与exchange绑定时指定的键值对；如果完全匹配则消息会路由到该queue，否则不会路由到该queue </p>
<h4 id="5）延迟消息（特殊模式需要安装插件）"><a href="#5）延迟消息（特殊模式需要安装插件）" class="headerlink" title="5）延迟消息（特殊模式需要安装插件）"></a><strong>5）延迟消息（特殊模式需要安装插件）</strong></h4><p>​         需要在这个页面：<a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">http://www.rabbitmq.com/community-plugins.html</a> 中找到<code>rabbitmq_delayed_message_exchange</code>插件，根据您使用的RabbitMQ版本选择对应的插件版本下载即可 。 在下载好之后，解压得到<code>.ez</code>结尾的插件包，将其复制到RabbitMQ安装目录下的<code>plugins</code>文件夹 。</p>
<pre><code>然后通过命令行启用该插件： </code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>redis-常见问题</title>
    <url>/2021/04/17/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一、穿透"><a href="#一、穿透" class="headerlink" title="一、穿透"></a>一、穿透</h3><p>数据库不存在，redis不存在</p>
<ul>
<li><p>key设置null值</p>
</li>
<li><p>布隆过滤器（存在一定的误差）</p>
<a id="more"></a>

</li>
</ul>
<h3 id="二、击穿"><a href="#二、击穿" class="headerlink" title="二、击穿"></a>二、击穿</h3><p>某个key，数据库存在，redis不存在（首次请求、key过期），大量（相同key）的请求一次性进来</p>
<ul>
<li>过期时间随机</li>
<li>锁方案（见下文）</li>
</ul>
<h3 id="三、雪崩"><a href="#三、雪崩" class="headerlink" title="三、雪崩"></a>三、雪崩</h3><p>缓存击穿的情况*N，一批key，数据库存在，redis不存在（首次请求、key过期），大量（不同key）的请求一次性进来</p>
<ul>
<li>过期时间随机</li>
<li>锁方案（见下文）</li>
</ul>
<h3 id="四、解决方案"><a href="#四、解决方案" class="headerlink" title="四、解决方案"></a>四、解决方案</h3><h4 id="布隆过滤器方案"><a href="#布隆过滤器方案" class="headerlink" title="布隆过滤器方案"></a>布隆过滤器方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、客户端实现过滤拦截</span><br><span class="line">2、客户端实现布隆算法，映射到redis的bitmap实现</span><br><span class="line">3、使用redis的bloomfilter组件</span><br><span class="line"></span><br><span class="line">问题：	</span><br><span class="line">1、只能key的映射增加不能删除（布谷鸟过滤器可以解决）</span><br><span class="line">2、不存在的key有一定程度可能跟存在的key出现映射重合，存在一定的误差</span><br></pre></td></tr></table></figure>

<h4 id="锁方案"><a href="#锁方案" class="headerlink" title="锁方案"></a>锁方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、请求redis，没有值</span><br><span class="line">2、抢锁setnx px</span><br><span class="line">	2.1、抢到锁的查询DB</span><br><span class="line">	2.2、抢不到锁的sleep（或者服务治理返回）</span><br><span class="line">3、更新redis数据，删除锁</span><br><span class="line">4、sleep苏醒的线程回到第一步</span><br><span class="line"></span><br><span class="line">问题：引入分布式锁，需要解决这个问题</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用SET key value [EX seconds] [PX milliseconds] [NX] 或 setnx + EXPIRE </span><br><span class="line">1.setnx</span><br><span class="line">2.过期时间</span><br><span class="line">3.多线程（守护线程）延长过期</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">1、线程使用setnx抢占之后可能宕机造成锁未释放，出现死锁？</span><br><span class="line">引入过期时间</span><br><span class="line"></span><br><span class="line">2、业务执行时间过久，造成锁已失效，期间其他线程抢占了锁，当前线程执行解锁误删其他线程的锁？</span><br><span class="line">设置value当前线程的操作标识（可以是随机数），删除时取出该值进行判断，看是否为当前线程持有的锁，是的话才进行删除</span><br><span class="line"></span><br><span class="line">3、当前线程取出value值判断锁为本线程持有，到删除之间存在时间差，可能因为锁失效缘故造成其他线程再次期间抢占到了锁？</span><br><span class="line">保证get操作和del操作的原子性，使用lua脚本或者事务</span><br><span class="line"></span><br><span class="line">4、当前业务未执行完，锁已经失效？</span><br><span class="line">多线程监控（守护线程），对key延长失效时间，可以使用redisson解决方案</span><br></pre></td></tr></table></figure>



<h3 id="五、缓存双写一致"><a href="#五、缓存双写一致" class="headerlink" title="五、缓存双写一致"></a>五、缓存双写一致</h3><p>先更新数据库，后更新缓存</p>
<p><img src="/images/linux/redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B401.png" alt=""></p>
<p>由图可知：</p>
<ul>
<li>请求A先更新DB</li>
<li>请求B也更新DB</li>
<li>但是因为网络等原因，B却比A更早更新了缓存。</li>
<li>导致数据的不一致，出现脏数据</li>
</ul>
<p>先更新数据库，后删除缓存</p>
<ul>
<li>更新DB成功</li>
<li>删除缓存失败</li>
<li>导致缓存数据为旧数据，出现脏数据</li>
</ul>
<p>先更新缓存，后更新数据库</p>
<ul>
<li>更新缓存成功</li>
<li>更新DB失败</li>
<li>导致数据不一致，出现脏数据</li>
</ul>
<p>先删除缓存，后更新数据库</p>
<p><img src="/images/linux/redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B404.png" alt=""></p>
<p>由图可知：</p>
<pre><code>- 如果同时有一个请求A先删除，再进行更新操作
- 中间另一个请求B进行查询发现没有缓存，查询了DB更新了缓存
- 之后A再更新DB
- 导致数据的不一致，出现脏数据</code></pre><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、消息队列</span><br><span class="line">2、canal</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-持久化</title>
    <url>/2021/04/11/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><img src="/images/linux/redis/redis-02.png" alt=""></p>
<a id="more"></a>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认开启rdb</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.只有一个文件 dump.rdb，方便持久化。 </span><br><span class="line">2.性能大化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 ，使用fork()创建子进程来进行RDB备份操作，子进程拥有父进程数据的指针，不需要全部数据拷贝一份，当有主进程有新数据进行修改时，触发系统内核的copy on write写时复制的机制，新数据写入新的内存位置，之后再操作旧数据的指针，而子进程的指针仍指向旧数据，因此两个进程的数据是隔离的，也保证了数据备份的时点性，</span><br><span class="line">3.二进制文件，相比于aof恢复比较快</span><br><span class="line">4.存在数据丢失的可能性</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#RDB触发规则，多少秒触发了多少次则执行RDB，“”表示不开启RDB，可以多个save规则同时配置</span></span><br><span class="line"><span class="comment">#   save ""</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># bgsave快照出错时是否停止数据写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否设置检查点</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># rdb文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否同步删除rdb文件</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持久化文件存放的目录（RDB和AOF问备份文件都会放在这里）</span></span><br><span class="line">dir /var/lib/redis/6379</span><br></pre></td></tr></table></figure>



<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><img src="/images/linux/redis/redis-03.png" alt=""></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.满足条件时触发重写</span><br><span class="line">	4.0以前，重写时，删除抵消命令，合并重复命令</span><br><span class="line">	4.0后，重写时，将旧数据RDB到aof文件中，之后将增量数据append到aof中</span><br><span class="line">2.redis是内存数据库，写操作触发io，造成性能下降</span><br><span class="line">3.aof可以修改触发级别：no、always、everysec</span><br><span class="line">4.如果RDB、AOF两个都配了优先加载AOF</span><br></pre></td></tr></table></figure>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一 次 命令操作就记录到aof文件中一次。 </span><br><span class="line">2.AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命 令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</span><br></pre></td></tr></table></figure>

<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.AOF 文件比 RDB 文件大，且恢复速度慢。</span><br></pre></td></tr></table></figure>



<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof触发策略</span></span><br><span class="line">appendfsync always <span class="comment">#每个动作都追加</span></span><br><span class="line">appendfsync everysec <span class="comment">#默认配置，每秒都追加</span></span><br><span class="line">appendfsync no <span class="comment">#等待内核缓冲区满了在一起追加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当有其他子进程在对磁盘进行写操作（rdb）或者重写操作时，no表示不参与争抢，此时不进行aof操作</span></span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100   </span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#aof达到64MB时触发重写</span></span><br><span class="line"></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#是否混合使用RDB和AOF备份，重写时会将旧数据以RDB形势放入aof文件前面，新数据以追加日志方式写入，[RDB file][AOF tail]，当打开aof文件时前面出现"REDIS"证明是开启RDB前置的新AOF混合文件，4.0之后才有的新功能</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h2 id="持久化选择"><a href="#持久化选择" class="headerlink" title="持久化选择"></a>持久化选择</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 </span><br><span class="line">- 如果非常关心数据，但仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。 </span><br><span class="line">- 有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 </span><br><span class="line">- 如果只希望数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-布隆过滤器</title>
    <url>/2021/04/10/redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="bloom机制"><a href="#bloom机制" class="headerlink" title="bloom机制"></a>bloom机制</h2><p><img src="/images/linux/redis/redis-01.png" alt=""></p>
<a id="more"></a>

<h2 id="下载BLOOM模块zip包"><a href="#下载BLOOM模块zip包" class="headerlink" title="下载BLOOM模块zip包"></a><a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">下载BLOOM模块zip包</a></h2><h2 id="解压zip包"><a href="#解压zip包" class="headerlink" title="解压zip包"></a>解压zip包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install unzip</span><br><span class="line">unzip RedisBloom-master.zip</span><br></pre></td></tr></table></figure>

<img src="/images/linux/redis/unzip安装.jpg" style="zoom: 50%;" />

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E7%BC%96%E8%AF%91bloom.jpg" alt=""></p>
<p>将编译后出现的redisbloom.so文件拷贝到/opt/redis/下</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;redis&#x2F;6379.conf</span><br><span class="line"># 添加以下配置</span><br><span class="line">loadmodule &#x2F;opt&#x2F;redis&#x2F;redisbloom.so</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%8A%A0%E8%BD%BD%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%9D%97.jpg" alt=""></p>
<h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service redis_6379 start</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-过期、淘汰</title>
    <url>/2021/04/11/redis%E8%BF%87%E6%9C%9F%E5%92%8C%E6%B7%98%E6%B1%B0/</url>
    <content><![CDATA[<h2 id="key过期-删除策略"><a href="#key过期-删除策略" class="headerlink" title="key过期-删除策略"></a>key过期-删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</span><br><span class="line">优点：</span><br><span class="line">	保证内存被尽快释放</span><br><span class="line">缺点：</span><br><span class="line">	若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除）。</span><br><span class="line">优点：</span><br><span class="line">	删除操作只在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的.</span><br><span class="line">缺点：</span><br><span class="line">	若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</span><br></pre></td></tr></table></figure>

<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	每隔一段时间执行一次删除过期key操作</span><br><span class="line">优点：</span><br><span class="line">	通过限制删除操作的时长和频率，该策略是前两者的一个折中方案</span><br><span class="line">缺点：</span><br><span class="line">	在内存友好方面，不如&quot;定时过期&quot;（会造成一定的内存占用，但是没有“惰性过期”那么占用内存）在CPU时间友好方面，不如&quot;惰性过期&quot;（会定期的去进行比较和删除操作，cpu方面不如“惰性过期”，但是比“定时过期”好）</span><br></pre></td></tr></table></figure>

<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="内存不足-淘汰策略"><a href="#内存不足-淘汰策略" class="headerlink" title="内存不足-淘汰策略"></a>内存不足-淘汰策略</h2><p>redis内存满了使用的淘汰策略</p>
<p>​        设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。<br>当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。</p>
<p>​        当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。</p>
<!-- more -->

<p>以下的策略是可用的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># volatile-lru -&gt; </span><br><span class="line">	Evict using approximated LRU, only keys with an expire set.</span><br><span class="line">	在过期集合的键中，尝试回收最久未被访问的键（LRU）,使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-lru -&gt; </span><br><span class="line">	Evict any key using approximated LRU.</span><br><span class="line">	在所有的键中，尝试回收最久未被访问的键（LRU），使得新添加的数据有空间存放。</span><br><span class="line"># volatile-lfu -&gt; </span><br><span class="line">	Evict using approximated LFU, only keys with an expire set.</span><br><span class="line">	在过期集合的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-lfu -&gt; </span><br><span class="line">	Evict any key using approximated LFU.</span><br><span class="line">	在所有的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</span><br><span class="line"># volatile-random -&gt; </span><br><span class="line">	Remove a random key having an expire set.</span><br><span class="line">	在过期集合的键中，随机回收键，使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-random -&gt; </span><br><span class="line">	Remove a random key, any key.</span><br><span class="line">	在所有的键中，随机回收键，使得新添加的数据有空间存放。</span><br><span class="line"># volatile-ttl -&gt; </span><br><span class="line">	Remove the key with the nearest expire time (minor TTL)</span><br><span class="line">	在过期集合的键，优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</span><br><span class="line"># noeviction -&gt; </span><br><span class="line">	Don&#39;t evict anything, just return an error on write operations.</span><br><span class="line">	不淘汰，返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</span><br></pre></td></tr></table></figure>

<p>一般的经验规则:</p>
<ul>
<li>使用<strong>allkeys-lru</strong>策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.</li>
<li>使用<strong>allkeys-random</strong>：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。</li>
<li>使用<strong>volatile-ttl</strong>：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。</li>
</ul>
<p>当想要单一的实例实现缓存及持久化一些键时，allkeys-lru 和 volatile-random策略很有用。不过一般运行两个实例是解决这个问题的更好方法。<br>当内存有压力时，没有必要为键取设置过期时间，因为为了键设置过期时间也是需要消耗内存的。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>restTemplate常见操作</title>
    <url>/2020/11/29/restTemplate%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>常见的restTemplate操作</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种方式 xxForObject、xxForEntity、exchange</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装请求头</span></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);<span class="comment">//封装请求类型</span></span><br><span class="line">headers.add(<span class="string">"Accept"</span>, MediaType.APPLICATION_JSON.toString());<span class="comment">//封装可接收类型,"Accept", MediaType.APPLICATION_JSON_VALUE</span></span><br><span class="line"><span class="comment">//封装请求参数</span></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map); </span><br><span class="line"><span class="comment">//封装请求实体（请求参数、请求头）</span></span><br><span class="line">HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(jsonStr, headers);</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">Map result = restTemplate.postForObject(expressUrl, entity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送携带query参数的uri，使用此api进行编码生成uri</span></span><br><span class="line">UriComponentsBuilder builder = UriComponentsBuilder</span><br><span class="line">                .fromUriString(getUsersUrl)</span><br><span class="line">                .queryParam(<span class="string">"nameOrEmail"</span>, nameOrEmail);</span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(builder.build().encode().toUri(), HttpMethod.PUT, <span class="keyword">new</span> HttpEntity&lt;&gt;(headers), String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送文件</span></span><br><span class="line">httpHeaders.setAccept(Arrays.asList(MediaType.MULTIPART_FORM_DATA));</span><br><span class="line">httpHeaders.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line"><span class="comment">//设置请求体，注意是LinkedMultiValueMap</span></span><br><span class="line">FileSystemResource fileSystemResource = <span class="keyword">new</span> FileSystemResource(filePath+<span class="string">"/"</span>+fileName);<span class="comment">//获取文件资源</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; form = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();<span class="comment">//一个key可以存多个value</span></span><br><span class="line">form.add(<span class="string">"file"</span>, fileSystemResource);<span class="comment">//封装资源文件 </span></span><br><span class="line">form.add(<span class="string">"filename"</span>,fileName);<span class="comment">//封装文件名称</span></span><br><span class="line"><span class="comment">//用HttpEntity封装整个请求报文</span></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = <span class="keyword">new</span> HttpEntity&lt;&gt;(form, headers);</span><br><span class="line">String s = restTemplate.postForObject(url, files, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>https请求报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.web.client.ResourceAccessException: I/O error on GET request <span class="keyword">for</span> <span class="string">"https://ecs.gac.com.cn:3351/ecs-console/api/bill/searchBillCount"</span>: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; nested exception is javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">    </span><br><span class="line">cn.kjjk.kjpayservice.KjPayServiceApplicationTests.main(KjPayServiceApplicationTests.java:<span class="number">58</span>)</span><br><span class="line">Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	</span><br><span class="line">Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure>

<p>处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate  = <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> HttpsClientRequestFactory());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsClientRequestFactory</span> <span class="keyword">extends</span> <span class="title">SimpleClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareConnection</span><span class="params">(HttpURLConnection connection, String httpMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(connection <span class="keyword">instanceof</span> HttpsURLConnection)) &#123;<span class="comment">// http协议</span></span><br><span class="line">                <span class="comment">//throw new RuntimeException("An instance of HttpsURLConnection is expected");</span></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(connection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;<span class="comment">// https协议，修改协议版本</span></span><br><span class="line">                SSLContext ctx = SSLContext.getInstance(<span class="string">"TLSv1.2"</span>);</span><br><span class="line">                X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line">                org.apache.http.conn.ssl.SSLSocketFactory ssf = <span class="keyword">new</span> org.apache.http.conn.ssl.SSLSocketFactory(ctx, org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line">                ((HttpsURLConnection) connection).setSSLSocketFactory(ctx.getSocketFactory());</span><br><span class="line">                HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(httpsConnection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>redis-命令</title>
    <url>/2021/04/10/redis%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli #链接客户端</span><br><span class="line">select dbnum #选择数据库</span><br><span class="line">flushdb #清除当前数据库数据</span><br><span class="line">flushall #清除所有数据库数据</span><br><span class="line">scan #游标扫描匹配的key</span><br><span class="line">KEYS  # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">dbsize #返回当前数据库的 key 的数量</span><br><span class="line">del # 删除给定的一个或多个 key</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>简介:String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M<br>简单使用举例: set key value、get key等<br>应用场景：共享session、分布式锁，计数器、限流。<br>内部编码有3种，int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">      summary: Append a value to a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。</span><br><span class="line">      # 如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。</span><br><span class="line">      # 返回追加 value 之后， 键 key 的值的长度。</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">      summary: Count set bits in a string</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 对指定的bit索引位置区间的bit值进行统计</span><br><span class="line">  </span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">      summary: Perform bitwise operations between strings</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 在多个键（包含字符串值）之间执行按位操作并将结果存储在目标键中，operation支持四个按位运算：AND，OR，XOR和NOT</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">      summary: Find first bit set or clear in a string</span><br><span class="line">      since: 2.8.7</span><br><span class="line">      # 查找字符串中第一个设置为1或0的bit的索引位，从指定索引的左边开始寻找</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">      summary: Decrement the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值减去一。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行减一操作之后的值。</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">      summary: Decrement the integer value of a key by the given number</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 储存的整数值减去减量 decrement 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键在执行减法操作之后的值。</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">      summary: Get the value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值</span><br><span class="line">      # 如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">      summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回指定bit索引偏移量的值</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">      summary: Get a substring of the string stored at a key</span><br><span class="line">      since: 2.4.0</span><br><span class="line">      # 返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。</span><br><span class="line">      # 负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</span><br><span class="line">      # GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">      summary: Set the string value of a key and return its old value</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。</span><br><span class="line">      # 返回给定键 key 的旧值。</span><br><span class="line">      # 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil </span><br><span class="line">      # 当键 key 存在但不是字符串类型时， 命令返回一个错误。</span><br><span class="line">      </span><br><span class="line">  INCR key</span><br><span class="line">      summary: Increment the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上一。</span><br><span class="line">      # 如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行加一操作之后的值。</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">      summary: Increment the integer value of a key by the given amount</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回在加上增量 increment 之后， 键 key 当前的值。</span><br><span class="line">      </span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">      summary: Increment the float value of a key by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为键 key 储存的值加上浮点数增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么 INCRBYFLOAT 会先将键 key 的值设为 0 ， 然后再执行加法操作。</span><br><span class="line">      # 如果命令执行成功， 那么键 key 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</span><br><span class="line">      # 无论是键 key 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</span><br><span class="line">      # 此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</span><br><span class="line">      # 当以下任意一个条件发生时， 命令返回一个错误：1）键 key 的值不是字符串类型。 2）键 key 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</span><br><span class="line">      </span><br><span class="line">  MGET key [key ...]</span><br><span class="line">      summary: Get the values of all the given keys</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回给定的一个或多个字符串键的值</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 同时为多个键设置值。</span><br><span class="line">      # 如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</span><br><span class="line">      # MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</span><br><span class="line">      # MSET 命令总是返回 OK </span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 当且仅当所有给定键都不存在时， 为所有给定键设置值。</span><br><span class="line">      # 即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</span><br><span class="line">      # MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</span><br><span class="line">      # 当所有给定键都设置成功时， 命令返回 1 ； 如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">      summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</span><br><span class="line">      # 命令在设置成功时返回 OK </span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">      summary: Set the string value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将字符串值 value 关联到 key 。</span><br><span class="line">      # 如果 key 已经持有其他值， SET 就覆写旧值， 无视类型</span><br><span class="line">      # 当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</span><br><span class="line">      #从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</span><br><span class="line">            EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</span><br><span class="line">            PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</span><br><span class="line">            NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</span><br><span class="line">            XX ： 只在键已经存在时， 才对键进行设置操作。</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">      summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">      summary: Set the value and expiration of a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。</span><br><span class="line">      # 如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。</span><br><span class="line">      # SETEX 和SET EXPIRE这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">      summary: Set the value of a key, only if the key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。</span><br><span class="line">      # 若键 key 已经存在， 则 SETNX 命令不做任何动作</span><br><span class="line">      # SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</span><br><span class="line">      # 设置成功时返回 1 ， 设置失败时返回 0 。</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">      summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。</span><br><span class="line">      # 不存在的键 key 当作空白字符串处理。</span><br><span class="line">      # SETRANGE 命令会确保字符串足够长以便将 value 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, &quot;\x00&quot; )进行填充。</span><br><span class="line">      # 因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。</span><br><span class="line">      </span><br><span class="line">  STRLEN key</span><br><span class="line">      summary: Get the length of the value stored in a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回键 key 储存的字符串值的长度。</span><br><span class="line">      # 当键 key 不存在时， 命令返回 0 。</span><br><span class="line">      # 当 key 储存的不是字符串值时， 返回一个错误。</span><br></pre></td></tr></table></figure>

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><blockquote>
<p>简介：在Redis中，哈希类型是指v（值）本身又是一个键值对（k-v）结构<br>简单使用举例：hset key field value 、hget key field<br>内部编码：ziplist（压缩列表） 、hashtable（哈希表）<br>应用场景：缓存用户信息等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">      summary: Delete one or more hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</span><br><span class="line">      # 被成功移除的域的数量，不包括被忽略的域。</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">      summary: Determine if a hash field exists</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 检查给定域 field 是否存在于哈希表 hash 当中。</span><br><span class="line">      # 在给定field存在时返回 1 ， 在给定field不存在时返回 0 。</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">      summary: Get the value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表中给定域的值。</span><br><span class="line">      # 如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">      summary: Get all the fields and values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，所有的域和值</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">      summary: Increment the integer value of a hash field by the given number</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 为哈希表 key 中的域 field 的值加上增量 increment 。</span><br><span class="line">      # 增量也可以为负数，相当于对给定域进行减法操作。</span><br><span class="line">      # 如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</span><br><span class="line">      # 如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</span><br><span class="line">      # 对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</span><br><span class="line">      # 本操作的值被限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      </span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">      summary: Increment the float value of a hash field by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为哈希表 key 中的域 field 加上浮点数增量 increment </span><br><span class="line">      # 如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</span><br><span class="line">      # 如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</span><br><span class="line">      # 当以下任意一个条件发生时，返回一个错误：1)域 field 的值不是字符串类型 2)域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数</span><br><span class="line">      </span><br><span class="line">  HKEYS key</span><br><span class="line">      summary: Get all the fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中的所有域。</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">      summary: Get the number of fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中域的数量。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">      summary: Get the values of all the given hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，一个或多个给定域的值。</span><br><span class="line">      # 如果给定的域不存在于哈希表，那么返回一个 nil 值。</span><br><span class="line">      # 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">      summary: Set multiple hash fields to multiple values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 同时将多个 field-value (域-值)对设置到哈希表 key 中</span><br><span class="line">      # 此命令会覆盖哈希表中已存在的域。</span><br><span class="line">      # 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate hash fields and associated values</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代哈希键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line">      # 返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">      summary: Set the string value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将哈希表 hash 中域 field 的值设置为 value 。</span><br><span class="line">      # 如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</span><br><span class="line">      # 如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。</span><br><span class="line">      # 当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 </span><br><span class="line">      </span><br><span class="line">  HSETNX key field value</span><br><span class="line">      summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。</span><br><span class="line">      # 如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</span><br><span class="line">      # 如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</span><br><span class="line">      # 在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">      summary: Get the length of the value of a hash field</span><br><span class="line">      since: 3.2.0</span><br><span class="line">      # 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</span><br><span class="line">      # 如果给定的键或者域不存在， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">      summary: Get all the values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中所有域的值。</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote>
<p>简介：列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。<br>简单实用举例：lpush key value [value …] 、lrange key start end<br>内部编码：ziplist（压缩列表）、linkedlist（链表）<br>应用场景：消息队列，文章列表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BLPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</span><br><span class="line">      # 如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值</span><br><span class="line">      </span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BRPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">      summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</span><br><span class="line">      # 当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</span><br><span class="line">      # 超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">      summary: Get an element from a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中，下标为 index 的元素。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">      summary: Insert an element before or after another element in a list</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后 。</span><br><span class="line">      # 当 pivot 不存在于列表 key 时，不执行任何操作，返回 -1 。</span><br><span class="line">      # 当 key 不存在时， key 被视为空列表，不执行任何操作，返回 0 。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">      summary: Get the length of a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 的长度。</span><br><span class="line">      # 如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">      summary: Remove and get the first element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的头元素。</span><br><span class="line">      # 列表的头元素。 当 key 不存在时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">      summary: Prepend one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表头</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">      summary: Prepend a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">      summary: Get a range of elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表</span><br><span class="line">      # 如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">      summary: Remove elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 根据参数 count 的值，移除列表中与参数 value 相等的元素。</span><br><span class="line">      # count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</span><br><span class="line">      # count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</span><br><span class="line">      # count &#x3D; 0 : 移除表中所有与 value 相等的值。</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">      summary: Set the value of an element in a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将列表 key 下标为 index 的元素的值设置为 value 。</span><br><span class="line">      # 当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">      summary: Trim a list to the specified range</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">      summary: Remove and get the last element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的尾元素。</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">      summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</span><br><span class="line">      #     将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</span><br><span class="line">      #     将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</span><br><span class="line">      # 如果 source 不存在，值 nil 被返回，并且不执行其他动作。</span><br><span class="line">      # 如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">      summary: Append one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表尾(最右边)。</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">      summary: Append a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>简介：集合（set）类型也是用来保存多个的字符串元素，但是不允许重复元素<br>简单使用举例：sadd key element [element …]、smembers key<br>内部编码：intset（整数集合）、hashtable（哈希表）<br>应用场景：用户标签,生成随机数抽奖、社交需求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">      summary: Add one or more members to a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</span><br><span class="line">      # 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</span><br><span class="line">      # 当 key 不是集合类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">      summary: Get the number of members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 的基数(集合中元素的数量)。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">      summary: Subtract multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合之间的差集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">      summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">      summary: Intersect multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的交集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line">      # 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">      summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">      summary: Determine if a given value is a member of a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 判断 member 元素是否集合 key 的成员。</span><br><span class="line">      # 如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">      summary: Get all the members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 中的所有成员。</span><br><span class="line">      # 不存在的 key 被视为空集合。</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">      summary: Move a member from one set to another</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 member 元素从 source 集合移动到 destination 集合。</span><br><span class="line">      # 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</span><br><span class="line">      # 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</span><br><span class="line">      # 当 source 或 destination 不是集合类型时，返回一个错误。</span><br><span class="line">      # 如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</span><br><span class="line"></span><br><span class="line">  SPOP key</span><br><span class="line">      summary: Remove and return a random member from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回集合中的一个随机元素。</span><br><span class="line">      # 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</span><br><span class="line">      # 被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">      summary: Get one or multiple random members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</span><br><span class="line">      # 从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</span><br><span class="line">      #     如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</span><br><span class="line">      #     如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</span><br><span class="line">      # 该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</span><br><span class="line">      # 当 key 不是集合类型，返回一个错误。</span><br><span class="line">      # 被成功移除的元素的数量，不包括被忽略的元素。</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate Set elements</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代set键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">      summary: Add multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的并集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">      summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line">      # 结果集中的元素数量。</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><blockquote>
<p>简介：已排序的字符串集合，同时元素不能重复<br>简单格式举例：zadd key score member [score member …]，zrank key member<br>底层内部编码：ziplist（压缩列表）、skiplist（跳跃表）<br>应用场景：排行榜，社交需求（如用户点赞）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">      summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 将一个或多个 member 元素及其 score 值加入到有序集 key 当中</span><br><span class="line">      # 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数。</span><br><span class="line">      # 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">      summary: Get the number of members in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">      summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">      summary: Increment the score of a member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 为有序集 key 的成员 member 的 score 值加上增量 increment 。</span><br><span class="line">      # 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</span><br><span class="line">      # 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</span><br><span class="line">      # 当 key 不是有序集类型时，返回一个错误。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数</span><br><span class="line">      # member 成员的新 score 值，以字符串形式表示。</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</span><br><span class="line">      # WEIGHTS指定对应key的权重，redis该key对应值得分值乘上权重系数，再根据AGGREGATE聚合函数统计，默认相加</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">      summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递增(从小到大)来排序。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order )来排列。</span><br><span class="line">      # 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</span><br><span class="line">      # 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</span><br><span class="line">      # 如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</span><br><span class="line">      # 命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</span><br><span class="line">      # 可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</span><br><span class="line">      # 合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</span><br><span class="line">      # 特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX &lt;zset&gt; - + ， 命令将返回有序集合中的所有元素。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score</span><br><span class="line">      since: 1.0.5</span><br><span class="line">      # 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</span><br><span class="line">      # 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</span><br><span class="line">      # 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</span><br><span class="line">      # min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</span><br><span class="line">      # 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</span><br><span class="line">      # 使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</span><br><span class="line">      # 如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">      summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">      summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 移除有序集 key 中，指定排名(rank)区间内的所有成员。</span><br><span class="line">      # 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">      summary: Remove all members in a sorted set within the given scores</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</span><br><span class="line">      # 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      #参见ZRANGEBYLEX，列表排列从大到小</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</span><br><span class="line">      # 使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代zset键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">      summary: Get the score associated with the given member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，成员 member 的 score 值。</span><br><span class="line">      # 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</span><br><span class="line">      # 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</span><br><span class="line">      # 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</span><br><span class="line">      #     默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br></pre></td></tr></table></figure>

<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @generic</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">      summary: Delete a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 删除给定的一个或多个 key 。</span><br><span class="line">      # 不存在的 key 会被忽略。</span><br><span class="line">      # 被删除 key 的数量。</span><br><span class="line">   </span><br><span class="line">  DUMP key</span><br><span class="line">      summary: Return a serialized version of the value stored at the specified key.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</span><br><span class="line">      # 序列化生成的值有以下几个特点：</span><br><span class="line">      #     它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</span><br><span class="line">      #     值的编码格式和 RDB 文件保持一致。</span><br><span class="line">      #     RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</span><br><span class="line">      # 序列化的值不包括任何生存时间信息。</span><br><span class="line">      # 如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">      summary: Determine if a key exists</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 检查给定 key 是否存在。</span><br><span class="line">      # 若 key 存在，返回 1 ，否则返回 0 。</span><br><span class="line"></span><br><span class="line">  EXPIRE key seconds</span><br><span class="line">      summary: Set a key&#39;s time to live in seconds</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</span><br><span class="line">      # 在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</span><br><span class="line">      # 可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</span><br><span class="line">      # 在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</span><br><span class="line">      # 使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</span><br><span class="line"></span><br><span class="line">  EXPIREAT key timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</span><br><span class="line">      # 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</span><br><span class="line">      # 如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</span><br><span class="line"></span><br><span class="line">  KEYS pattern</span><br><span class="line">      summary: Find all keys matching the given pattern</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">      #     KEYS * 匹配数据库中所有 key 。</span><br><span class="line">      #     KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span><br><span class="line">      #     KEYS h*llo 匹配 hllo 和 heeeeello 等。</span><br><span class="line">      #     KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</span><br><span class="line">      # KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</span><br><span class="line"></span><br><span class="line">  MIGRATE host port key destination-db timeout [COPY] [REPLACE]</span><br><span class="line">      summary: Atomically transfer a key from a Redis instance to another one.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</span><br><span class="line">      # 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</span><br><span class="line">      # 命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</span><br><span class="line">      # timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</span><br><span class="line">      # MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。当 IOERR 出现时，有以下两种可能：</span><br><span class="line">      #     key 可能存在于两个实例</span><br><span class="line">      #     key 可能只存在于当前实例</span><br><span class="line">      # 唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</span><br><span class="line">      # 如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）</span><br><span class="line"></span><br><span class="line">  MOVE key db</span><br><span class="line">      summary: Move a key to another database</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将当前数据库的 key 移动到给定的数据库 db 当中。</span><br><span class="line">      # 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</span><br><span class="line">      # 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</span><br><span class="line">      # 移动成功返回 1 ，失败则返回 0 。</span><br><span class="line">      </span><br><span class="line">  OBJECT subcommand [arguments [arguments ...]]</span><br><span class="line">      summary: Inspect the internals of Redis objects</span><br><span class="line">      since: 2.2.3</span><br><span class="line">      # OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</span><br><span class="line">      # OBJECT 命令有多个子命令：</span><br><span class="line">      #     OBJECT REFCOUNT &lt;key&gt; 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</span><br><span class="line">      #     OBJECT ENCODING &lt;key&gt; 返回给定 key 锁储存的值所使用的内部表示(representation)。</span><br><span class="line">      #     OBJECT IDLETIME &lt;key&gt; 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。</span><br><span class="line">      # 对象可以以多种方式编码：</span><br><span class="line">      #     字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</span><br><span class="line">      #     列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</span><br><span class="line">      #     集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</span><br><span class="line">      #     哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</span><br><span class="line">      #     有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</span><br><span class="line">      # 假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</span><br><span class="line">      # REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</span><br><span class="line"></span><br><span class="line">  PERSIST key</span><br><span class="line">      summary: Remove the expiration from a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</span><br><span class="line">      # 当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 </span><br><span class="line"></span><br><span class="line">  PEXPIRE key milliseconds</span><br><span class="line">      summary: Set a key&#39;s time to live in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PEXPIREAT key milliseconds-timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp specified in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PTTL key</span><br><span class="line">      summary: Get the time to live for a key in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</span><br><span class="line">      #     当 key 不存在时，返回 -2 。</span><br><span class="line">      #     当 key 存在但没有设置剩余生存时间时，返回 -1 。</span><br><span class="line">      #     否则，以毫秒为单位，返回 key 的剩余生存时间。</span><br><span class="line">      # 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</span><br><span class="line"></span><br><span class="line">  RANDOMKEY -</span><br><span class="line">      summary: Return a random key from the keyspace</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 从当前数据库中随机返回(不删除)一个 key 。</span><br><span class="line">      # 当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  RENAME key newkey</span><br><span class="line">      summary: Rename a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</span><br><span class="line">      # 当 newkey 已经存在时， RENAME 命令将覆盖旧值。</span><br><span class="line">      # 改名成功时提示 OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line">  RENAMENX key newkey</span><br><span class="line">      summary: Rename a key, only if the new key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 当且仅当 newkey 不存在时，将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 不存在时，返回一个错误。</span><br><span class="line">      # 修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</span><br><span class="line">     </span><br><span class="line">  RESTORE key ttl serialized-value [REPLACE]</span><br><span class="line">      summary: Create a key using the provided serialized value, previously obtained using DUMP.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 反序列化给定的序列化值，并将它和给定的 key 关联。</span><br><span class="line">      # 参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</span><br><span class="line">      # RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</span><br><span class="line">      # 如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate the keys space</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</span><br><span class="line">      #     SCAN 命令用于迭代当前数据库中的数据库键。</span><br><span class="line">      #     SSCAN 命令用于迭代集合键中的元素。</span><br><span class="line">      #     HSCAN 命令用于迭代哈希键中的键值对。</span><br><span class="line">      #     ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]</span><br><span class="line">      summary: Sort the elements in a list, set or sorted set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</span><br><span class="line">      # 排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</span><br><span class="line">      # 最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</span><br><span class="line">      #     SORT key 返回键值从小到大排序的结果。</span><br><span class="line">      #     SORT key DESC 返回键值从大到小排序的结果。</span><br><span class="line">      # 因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符。</span><br><span class="line">      # 如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</span><br><span class="line">      # 排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</span><br><span class="line">      #     offset 指定要跳过的元素数量。</span><br><span class="line">      #     count 指定跳过 offset 个指定的元素之后，要返回多少个对象。</span><br><span class="line">      # 其他玩法请自行查阅资料</span><br><span class="line"></span><br><span class="line">  TTL key</span><br><span class="line">      summary: Get the time to live for a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</span><br><span class="line">      # 当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</span><br><span class="line"></span><br><span class="line">  TYPE key</span><br><span class="line">      summary: Determine the type stored at key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回 key 所储存的值的类型。</span><br><span class="line"></span><br><span class="line">  WAIT numslaves timeout</span><br><span class="line">      summary: Wait for the synchronous replication of all the write commands sent in the context of the current connection</span><br><span class="line">      since: 3.0.0</span><br><span class="line">      # 等待在当前连接上下文中发送的所有写命令的同步复制</span><br></pre></td></tr></table></figure>

<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">      summary: Discard all commands issued after MULTI</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 取消事务，放弃执行事务块内的所有命令。</span><br><span class="line">      # 如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">      summary: Execute all commands issued after MULTI</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 执行所有事务块内的命令。</span><br><span class="line">      # 假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">      summary: Mark the start of a transaction block</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 标记一个事务块的开始。</span><br><span class="line">      # 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">      summary: Forget about all watched keys</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 取消 WATCH 命令对所有 key 的监视。</span><br><span class="line">      # 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</span><br><span class="line">      # 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">      summary: Watch the given keys to determine execution of the MULTI&#x2F;EXEC block</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br></pre></td></tr></table></figure>

<h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BF.ADD key ...options...</span><br><span class="line">    # 添加key到bloom中</span><br><span class="line"></span><br><span class="line">BF.EXISTS key ...options...</span><br><span class="line">	# 判断是否存在对应的key</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-集群</title>
    <url>/2021/04/13/redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="一、主从复制"><a href="#一、主从复制" class="headerlink" title="一、主从复制"></a>一、<code>主从复制</code></h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul>
<li>一个master可以拥有多个slave。</li>
<li>master的复制是异步非阻塞的。</li>
<li>客户端可以使用wait命令请求同步复制某些特定数据。</li>
<li>正常连接情况下，master通过命令流来保持对slave的数据更新。</li>
<li>master与slave之间得到连接断开，slave在尝试与master重连后，会尝试获取与master断开期间丢失的命令流</li>
<li>当断开期间的数据无法重新同步时，slave会请求全量更新，master将以rdb快照方式将全量数据推送给slave，之后再进行增量更新。</li>
</ul>
<a id="more"></a>

<h3 id="2、复制原理"><a href="#2、复制原理" class="headerlink" title="2、复制原理"></a>2、复制原理</h3><ul>
<li>每个master都有一个replicationId用来表示与slave处于同一个主从复制中；<br>同时存在一个偏移量，用来记录上次发送给slave的数据，每次复制数据后该偏移量都会增加，即使没有slave链接master，它的offset也会增加。一对Replication ID, offset表示一个版本的数据</li>
<li>当slave连接到master后，会使用psync命令发送自己存储的旧replicationId和offset，master从积压的缓冲区找到对应版本的数据，开始增量复制推送给slave，如果缓冲区没有的话，master会进行全量RBD复制</li>
<li>全量复制，master后台fork一个进行产生一个rdb文件在本地磁盘，将rdb文件传输给slave保存在本地磁盘，slave加载到内存执行，无磁盘复制可以使用repl-diskless-sync 配置参数</li>
</ul>
<h3 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建文件夹，拷贝redis配置，方便后续测试</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis</span><br><span class="line">cp /etc/redis/* /</span><br><span class="line"></span><br><span class="line"><span class="comment">#注释日志输出，以便控制台观看</span></span><br><span class="line">vi 6379.conf</span><br><span class="line"><span class="comment">#logfile /var/log/redis_6379.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭aof值测试rdb</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭后台启动，前台启动方便查看</span></span><br><span class="line">daemonize no</span><br></pre></td></tr></table></figure>

<h3 id="4、启动redis"><a href="#4、启动redis" class="headerlink" title="4、启动redis"></a>4、启动redis</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server ./6379.conf </span><br><span class="line">redis-server ./6380.conf </span><br><span class="line">redis-server ./6380.conf</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8redis-01.jpg" alt=""></p>
<h3 id="5、slave追随master"><a href="#5、slave追随master" class="headerlink" title="5、slave追随master"></a>5、slave追随master</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">方式一：在进入6380、6381客户端，使用`replicaof host port`命令（5.0之前命令为`slaveof host port`），让从节点追随主节点</span><br><span class="line"></span><br><span class="line">方式二：在启动服务端时，使用`redis-server ./6380.conf --replicaof host port`命令，让从节点追随主节点</span><br><span class="line"></span><br><span class="line">方式三：在配置文件指定 <span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<p>从节点控制台日志</p>
<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E4%B8%BB%E8%8A%82%E7%82%B9-%E4%BB%8E%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97-03.jpg" alt=""></p>
<p>主节点控制台日志</p>
<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E4%B8%BB%E8%8A%82%E7%82%B9-%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97-04.jpg" alt=""></p>
<h3 id="6、错误"><a href="#6、错误" class="headerlink" title="6、错误"></a>6、错误</h3><p>此时发现客户端宕机，重新启动客户端报如下错误</p>
<h4 id="6-1、问题1："><a href="#6-1、问题1：" class="headerlink" title="6.1、问题1："></a>6.1、问题1：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING overcommit_memory is <span class="built_in">set</span> to 0! Background save may fail under low memory condition. To fix this issue add <span class="string">'vm.overcommit_memory = 1'</span> to /etc/sysctl.conf and <span class="keyword">then</span> reboot or run the <span class="built_in">command</span> <span class="string">'sysctl vm.overcommit_memory=1'</span> <span class="keyword">for</span> this to take effect.</span><br><span class="line">4562:M 13 Apr 2021 21:45:46.588 <span class="comment"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').</span></span><br><span class="line"></span><br><span class="line">警告:overcommit_memory设置为0!在内存不足的情况下，后台保存可能失败。要解决这个问题，添加‘vm’。overcommit_memory = 1<span class="string">' /etc/sysctl.conf，然后重启或执行'</span>sysctl vm. conf <span class="string">'命令。overcommit_memory=1'</span>让它生效。</span><br><span class="line"><span class="comment">#警告:你的内核已经启用了透明的大页面(THP)支持。这会造成Redis的延迟和内存使用问题。要解决这个问题，以root权限运行'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'命令，并将其添加到/etc/rc.本地，以便在重新启动后保留设置。禁用THP后必须重新启动Redis(设置为'madvise'或'never')。</span></span><br></pre></td></tr></table></figure>

<p>执行<code>sysctl vm.overcommit_memory=1</code>解决以上问题</p>
<h4 id="6-2、问题2："><a href="#6-2、问题2：" class="headerlink" title="6.2、问题2："></a>6.2、问题2：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING you have Transparent Huge Pages (THP) support enabled <span class="keyword">in</span> your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the <span class="built_in">command</span> <span class="string">'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'</span> as root, and add it to your /etc/rc.local <span class="keyword">in</span> order to retain the setting after a reboot. Redis must be restarted after THP is disabled (<span class="built_in">set</span> to <span class="string">'madvise'</span> or <span class="string">'never'</span>).</span><br><span class="line"></span><br><span class="line">您的内核中启用了透明的大页面(THP)支持。这会造成Redis的延迟和内存使用问题。要解决这个问题，以root权限运行<span class="string">'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'</span>命令，并将其添加到/etc/rc.本地，以便在重新启动后保留设置。禁用THP后必须重新启动Redis(设置为<span class="string">'madvise'</span>或<span class="string">'never'</span>)。</span><br></pre></td></tr></table></figure>

<p>执行<code>echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>解决以上问题</p>
<h4 id="6-3、问题3："><a href="#6-3、问题3：" class="headerlink" title="6.3、问题3："></a>6.3、问题3：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is <span class="built_in">set</span> to the lower value of 128.</span><br><span class="line"></span><br><span class="line">由于/proc/sys/net/core/somaxconn被设置为较低的值128,TCP backlog设置511无法执行。</span><br></pre></td></tr></table></figure>

<p>执行<code>echo 511 &gt; /proc/sys/net/core/somaxconn</code>解决以上问题</p>
<h4 id="6-4、问题4："><a href="#6-4、问题4：" class="headerlink" title="6.4、问题4："></a>6.4、问题4：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">5499:M 13 Apr 2021 21:58:45.198 <span class="comment"># Server initialized</span></span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * Loading RDB produced by version 6.0.9</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * RDB age 1191 seconds</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * RDB memory usage when created 1.85 Mb</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 <span class="comment"># The RDB file contains module data I can't load: no matching module 'MBbloom--'</span></span><br></pre></td></tr></table></figure>

<p>此时仍无法启动，需要到持久化目录<code>/var/lib/redis/6381</code>下处理rdb文件<code>mv dump.rdb dump.rdb.bak</code>，此时可以正常启动</p>
<h3 id="7、slave升级为master"><a href="#7、slave升级为master" class="headerlink" title="7、slave升级为master"></a>7、slave升级为master</h3><p>当主节点宕机时，我们需要手动进行故障转移，将从节点升级为主节点</p>
<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7%E5%88%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA-05.jpg" alt="从节点监控到主节点宕机"></p>
<p>从节点客户端执行<code>replicaof no one</code>指令，将自己从slave升级为master</p>
<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E5%B0%86%E8%87%AA%E5%B7%B1%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%BB%E8%8A%82%E7%82%B9-06.jpg" alt="从节点升级为主节点"></p>
<h3 id="8、配置"><a href="#8、配置" class="headerlink" title="8、配置"></a>8、配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slave在首次接收master数据时，可以在slave中配置同步期间是否接收旧数据的访问，在首次同步之后，旧数据会被删除，然后再主线程加载新数据，此时slave会阻塞</span></span><br><span class="line">replica-serve-stale-data yes  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从节点是否开启只读模式</span></span><br><span class="line">replica-read-only yes </span><br><span class="line"></span><br><span class="line"><span class="comment">#是否采用无磁盘模式传输，no表示走磁盘，yes走网络传输</span></span><br><span class="line">repl-diskless-sync no </span><br><span class="line"></span><br><span class="line"><span class="comment">#增量复制，当redis挂掉之后又恢复，主节点可以增量传输数据过来，但是增量的数据与当前的数据存在偏差，从节点可以通过传送offset从主节点再次拉回数据，此配置大小会关系到redis内存维护的队列大小，此操作的成功与否，数据量大于这个值会造成溢出</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果至少有 3 个 slave ，并且滞后小于 10 秒，则写入将被接受,如果条件不满足master的写操作将被拒绝。</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果master节点设置了密码，需要在此处进行配置对应表的访问密码</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置追随的master节点</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p>1、从节点追随主节点之后，旧数据会被删除，同时非阻塞方式同步主节点数据</p>
<p><img src="/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E5%89%8D%E5%90%8E%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96-05.jpg" alt=""></p>
<p>2、从节点只能读，不能写（可修改配置改变）</p>
<p>3、主节点出现故障时，需要人工维护升级新的主节点</p>
<h2 id="二、哨兵模式"><a href="#二、哨兵模式" class="headerlink" title="二、哨兵模式"></a>二、<code>哨兵模式</code></h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过连接master获取slave的信息</span><br><span class="line">2.通过psubscribe正则方式订阅发布的信息,从而发现其他哨兵节点</span><br><span class="line">3.监控主从节点是否正常</span><br><span class="line">3.自动故障转移</span><br><span class="line">4.使用投票机制选举master</span><br></pre></td></tr></table></figure>

<h3 id="2、Sentinel相互发现"><a href="#2、Sentinel相互发现" class="headerlink" title="2、Sentinel相互发现"></a>2、Sentinel相互发现</h3><ul>
<li>每个Sentinel会以每两秒一次的频率，通过发布与订阅功能，向被它监视的所有master和slave的 sentinel:hello 频道发送一条信息，信息中包含了该Sentinel的IP 地址、端口号和运行ID （runid）。</li>
<li>每个Sentinel都订阅了被它监视的所有master和slave的sentinel:hello 频道,查找之前未出现过的sentinel（looking for unknown sentinels）。当一个Sentinel 发现一个新的Sentinel时，它会将新的Sentinel添加到一个列表中，这个列表保存了Sentinel已知的，监视同一个主服务器的所有其他Sentinel。</li>
<li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li>
<li>在将一个新Sentinel添加到监视主服务器的列表上面之前，Sentinel会先检查列表中是否已经包含了和要添加的Sentinel拥有相同运行ID或者相同地址（包括IP地址和端口号）的 Sentinel ，如果是的话，Sentinel会先移除列表中已有的那些拥有相同运行ID或者相同地址的Sentinel， 然后再添加新Sentinel。</li>
</ul>
<h3 id="3、Sentinel对master的故障判定"><a href="#3、Sentinel对master的故障判定" class="headerlink" title="3、Sentinel对master的故障判定"></a>3、Sentinel对master的故障判定</h3><p>1)、 Sentinel以每秒钟一次的频率向它所知的master、slave以及其他 Sentinel 实例发送一个 PING 命令,如果距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，那么这个实例会被 Sentinel 标记为主观下线。一个有效回复可以是：+PONG 、-LOADING 或者 -MASTERDOWN ，其余回复或者没有回复都算是无效回复。<br>2)、当master标记为ODOWN(主观下线)后，用通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。<br>        2.1)、当有足够数量的 Sentinel（至少要达到配置文件指定的数量quorum）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。<br>        2.2)、当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主观下线状态就会被移除<br>3)、在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有master和slave发送 INFO 命令。 当一个master被 Sentinel 标记为客观下线时， Sentinel 向下线master的所有slave发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>
<h3 id="4、选举新的master"><a href="#4、选举新的master" class="headerlink" title="4、选举新的master"></a>4、选举新的master</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先标记master为ODOWN状态的Sentinel使用以下规则从slave中来选取新的master：</span><br><span class="line">1、被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</span><br><span class="line">2、与失效主服务器连接断开的时长超过 down-after-milliseconds 选项指定的时长十倍的从服务器都会被淘汰。</span><br><span class="line">3、在经历了以上两轮淘汰之后剩下来的从服务器中， 选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； </span><br><span class="line">4、如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</span><br></pre></td></tr></table></figure>

<h3 id="5、准备"><a href="#5、准备" class="headerlink" title="5、准备"></a>5、准备</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件参考源码目录下/usr/local/redis-6.0.9/sentinel.conf</span></span><br><span class="line"></span><br><span class="line">创建配置文件</span><br><span class="line">vi 26379.conf</span><br><span class="line"></span><br><span class="line">port 26379 <span class="comment"># 指定当前哨兵端口号</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 <span class="comment"># 指定哨兵需要监控的主节点ip port 投票达成一致数量</span></span><br></pre></td></tr></table></figure>

<h3 id="6、配置"><a href="#6、配置" class="headerlink" title="6、配置"></a>6、配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果需要监控监控的master设置了密码，需要在此处设置</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、启动哨兵节点"><a href="#7、启动哨兵节点" class="headerlink" title="7、启动哨兵节点"></a>7、启动哨兵节点</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">启动方式一：redis-server ./26379.conf --sentinel</span><br><span class="line">启动方式二：redis-sentinel ./26381.conf</span><br></pre></td></tr></table></figure>
<p><img src="/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%90%AF%E5%8A%A8-01.jpg" alt=""></p>
<h3 id="8、选举新master节点"><a href="#8、选举新master节点" class="headerlink" title="8、选举新master节点"></a>8、选举新master节点</h3><p>当master节点宕机，哨兵节点过半以上检测到之后会重新选举新的master节点</p>
<p><img src="/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8C%82%E4%BA%86%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE-01.jpg" alt=""></p>
<p><img src="/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8C%82%E4%BA%86%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE.jpg" alt=""></p>
<p>slave节点升级为master节点</p>
<p><img src="/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9-6380%E8%A2%AB%E9%80%89%E4%B8%BE-6380%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<p>另一个slave检测到新的master主节点产生并追随</p>
<p><img src="/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9-6380%E8%A2%AB%E9%80%89%E4%B8%BE-6381%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、哨兵通过主节点获取从节点信息，同时发布订阅方式发现其他哨兵节点信息</p>
<p>2、主节点宕机后，哨兵节点重新选举新的主节点，做到故障转移，不需要人工处理</p>
<p>3、master节点存在已经过期的key，复制到了slave，那当master的“访问过期”和“定期过期”机制没有被触发时，该key没有被删除，客户端链接slave查询该key时出现什么情况？推测：判断过期返回不存在，过期的key不处理，等待master处理后同步del指令</p>
<h2 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h2><h3 id="1、概念-2"><a href="#1、概念-2" class="headerlink" title="1、概念"></a>1、概念</h3><h4 id="1-1、不同端的分区"><a href="#1-1、不同端的分区" class="headerlink" title="1.1、不同端的分区"></a>1.1、不同端的分区</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端分区:</span><br><span class="line">	由客户端根据一定的算法逻辑计算出该key应该与哪一个redis实例交互</span><br><span class="line">	用户客户端自己实现逻辑</span><br><span class="line">代理分区:</span><br><span class="line">	客户端不需要理会如何分区，请求发送给代理，有代理觉得链接哪一个redis实例</span><br><span class="line">	twemproxy、predixy</span><br><span class="line">查询路由:</span><br><span class="line">	客户端随机请求任意的redis实例，redis将请求转发给正确的redis节点处理</span><br><span class="line">	redis cluster</span><br></pre></td></tr></table></figure>

<h4 id="1-2、优缺点"><a href="#1-2、优缺点" class="headerlink" title="1.2、优缺点"></a>1.2、优缺点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区优点</span><br><span class="line">	可以让redis管理更大的内存</span><br><span class="line">	分布在不同的计算机利用不同计算机的计算能力，使redis的计算能力得到提升</span><br><span class="line">分区的缺点：</span><br><span class="line">	多个key不在统一分区无法使用聚合、事务等操作</span><br><span class="line">	动态扩容和收缩需要对数据进行再平衡（预分片可以解决这个问题）</span><br></pre></td></tr></table></figure>

<h4 id="1-3、预分片"><a href="#1-3、预分片" class="headerlink" title="1.3、预分片"></a>1.3、预分片</h4><p>​    因为redis实例占用的内存很小，在一台机子提前启用多台redis以分布式方式运行，随着数据不断增加，需要做的只是将redis实例迁移到另外的计算机中，不需要考虑重新分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.新的服务器启动新的redis实例</span><br><span class="line">2.配置为需要迁移的旧redis的slave（此操作可以同步数据）</span><br><span class="line">3.更新分片映射的旧实例ip为新实例ip</span><br><span class="line">4.客户端连接新的redis实例执行SLAVEOF NO ONE命令，将新实例升级为master</span><br><span class="line">5.停止旧的redis实例</span><br></pre></td></tr></table></figure>

<h3 id="2、分区算法"><a href="#2、分区算法" class="headerlink" title="2、分区算法"></a>2、分区算法</h3><h4 id="2-1、普通Hash算法（modula）"><a href="#2-1、普通Hash算法（modula）" class="headerlink" title="2.1、普通Hash算法（modula）"></a>2.1、普通Hash算法（modula）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如你有 N 个 &#96;redis&#96;实例，那么如何将一个&#96;key&#96;映射到&#96;redis&#96;上呢，你很可能会采用类似下面的通用方法计算 key的 hash 值，然后均匀的映射到到 N 个 &#96;redis&#96;上：</span><br><span class="line">　　&#96;hash(key)%N&#96;</span><br><span class="line">　　如果增加一个&#96;redis&#96;，映射公式变成了 &#96;hash(key)%(N+1)&#96;</span><br><span class="line">　　如果一个&#96;redis&#96;宕机了，映射公式变成了 &#96;hash(key)%(N-1)&#96;</span><br><span class="line">　　在这两种情况下，每一个&#96;redis&#96;管理的数据全部要重新计算移动，几乎所有的缓存都失效了。会导致数据库访问的压力陡增，严重情况，还可能导致数据库宕机。</span><br></pre></td></tr></table></figure>

<h4 id="2-2、随机分配算法-random"><a href="#2-2、随机分配算法-random" class="headerlink" title="2.2、随机分配算法(random)"></a>2.2、随机分配算法(random)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机将数据分发到Redis集群中，Client无法准确地从某台机器获取相对的数据，该做法常用于消息队列中。</span><br></pre></td></tr></table></figure>

<h4 id="2-3、一致性Hash算法-ketama"><a href="#2-3、一致性Hash算法-ketama" class="headerlink" title="2.3、一致性Hash算法(ketama)"></a>2.3、一致性Hash算法(ketama)</h4><ol>
<li>将内存想象成一个环，由于hash值有32位，因此将内存分出2 ^32（0~2 ^32-1）个地址</li>
<li>将节点的IP+算法确定唯一的哈希值，之后在内存中确定节点的位置</li>
<li>当保存数据时，根据key进行哈希运算，确定唯一的一个位置</li>
<li>根据当前<code>key</code>位置<strong>顺时针</strong>查找最近的<code>node</code>节点进行挂载（在内存中，加法计算快于减法运算，因此采用顺时针查找）</li>
</ol>
<p><img src="/images/linux/redis/redis-38.png" alt=""></p>
<p>将各个服务器使用<code>Hash</code>进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p>
<p>假设将中四台服务器使用ip地址哈希后在环空间的位置如下：</p>
<p><img src="/images/linux/redis/redis-39.png" alt=""></p>
<p>将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<p>假设4个存储对象 Object A、B、C、D，经过对 Key 的哈希计算后，它们的位置如下：</p>
<p><img src="/images/linux/redis/redis-40.png" alt=""></p>
<p>根据一致性哈希算法，数据A会被定为到<code>Node A</code>上，B被定为到<code>Node B</code>上，C被定为到<code>Node C</code>上，D被定为到<code>Node D</code>上。</p>
<h5 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h5><p>假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到<code>Node D</code>。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>如果在系统中增加一台服务器Node X，如下图所示：</p>
<p><img src="/images/linux/redis/redis-41.png" alt=""></p>
<p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<p>如果这时候新增了一个结点，对原来缓存的一部分数据的访问将会落到新增的结点上，但是这时候结点并没有数据缓存，<strong>它将去数据库中查找并缓存，原先已经缓存数据的结点需要通过淘汰算法（LRU）淘汰数据，它并没有从原缓存结点复制数据到新节点中。</strong></p>
<h5 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h5><p><strong>但一致性哈希算法也有一个严重的问题，就是数据倾斜</strong>。如果在分片的集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少。也就是说无法控制节点存储数据的分配。如下图，大部分数据都在 A 上了，B 的数据比较少。</p>
<p><img src="/images/linux/redis/redis-42.png" alt=""></p>
<p>节点数越少，越容易出现节点在哈希环上的分布不均匀，导致各节点映射的对象数量严重不均衡(数据倾斜)；相反，节点数越多越密集，数据在哈希环上的分布就越均匀。</p>
<p>以删除节点为例，假设删除了<code>Node B</code>节点，原来<code>Node B</code>节点的数据将转移到<code>Node C</code>上，这样<code>Node C</code>的内存使用率会骤增，如果<code>Node B</code>上存在热点数据，<code>Node C</code>会扛不住甚至会可能挂掉，挂掉之后数据又转移给<code>Node D</code>,如此循环会造成所有节点崩溃，也就是<strong>缓存雪崩</strong>。</p>
<p>为了解决雪崩现象和数据倾斜现象，提出了虚拟节点这个概念。就是将真实节点计算多个哈希形成多个虚拟节点并放置到哈希环上，<strong>定位算法不变，只是多了一步虚拟节点到真实节点映射的过程</strong></p>
<p>但实际部署的物理节点有限，我们可以用有限的物理节点，虚拟出足够多的虚拟节点(<code>Virtual Node</code>)，最终达到数据在哈希环上均匀分布的效果。</p>
<p>如下图，实际只部署了2个节点 Node A/B，每个节点都复制成3倍，结果看上去是部署了6个节点。可以想象，当复制倍数为 2^32 时，就达到绝对的均匀，通常可取复制倍数为32或更高。</p>
<p><img src="/images/linux/redis/redis-43.png" alt=""></p>
<p><strong>这就解决了雪崩的问题，当某个节点宕机后，其数据并没有全部分配给某一个节点，而是被分到了多个节点，数据倾斜的问题也随之解决</strong>。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>一致性哈希算法，既可以在客户端实现，也可以在中间件上实现（如 proxy）。在客户端实现中，当客户端初始化的时候，需要初始化一张预备的 Redis 节点的映射表：hash(key)=&gt; . 这有一个缺点，假设有多个客户端，当映射表发生变化的时候，多个客户端需要同时拉取新的映射表。</p>
<p>另一个种是中间件（proxy）的实现方法，即在客户端和 Redis 节点之间加多一个代理，代理经过哈希计算后将对应某个 key 的请求分发到对应的节点，一致性哈希算法就在中间件里面实现。可以发现，twemproxy 就是这么做的。</p>
<h4 id="2-4、哈希槽"><a href="#2-4、哈希槽" class="headerlink" title="2.4、哈希槽"></a>2.4、哈希槽</h4><p><strong><code>redis</code> 集群（<code>cluster</code>）并没有选用上面一致性哈希，而是采用了哈希槽（<code>slot</code>）的这种概念</strong>。主要的原因就是上面所说的，<strong>一致性哈希算法对于数据分布、节点位置的控制并不是很友好</strong>。</p>
<p>首先哈希槽其实是两个概念，第一个是哈希算法。<code>redis cluster</code> 的 <code>hash</code> 算法不是简单的<code>hash</code>()，而是 <code>crc16</code> 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。</p>
<p>其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 <code>redis cluster</code> 的槽位空间是自定义分配的，类似于 <code>windows</code> 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p>
<p><code>redis cluster</code> 包含了16384个哈希槽，每个 <code>key</code> 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。<strong>所以哈希槽这种概念很好地解决了一致性哈希的弊端</strong>。</p>
<p><strong>当有新节点加入时，它不再需要像一致性Hash算法那样把每个<code>key</code>取出来重新计算<code>hash</code>值，只需要从旧节点中将新节点应该缓存的槽位数据拷贝到新节点中即可。</strong></p>
<p>另外在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p>
<p><img src="/images/linux/redis/redis-28.png" alt=""></p>
<p><strong>弊端是聚合操作很难实现，并且不支持跨机器事务，但是提供了Hash Tag让用户控制需要计算的Key都集中在一个Redis中。</strong></p>
<h3 id="3、代理分区-TwemProxy"><a href="#3、代理分区-TwemProxy" class="headerlink" title="3、代理分区-TwemProxy"></a>3、代理分区-<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener"><code>TwemProxy</code></a></h3><h4 id="3-1、安装"><a href="#3-1、安装" class="headerlink" title="3.1、安装"></a>3.1、安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:twitter/twemproxy.git</span><br><span class="line"><span class="built_in">cd</span> twemproxy</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --<span class="built_in">enable</span>-debug=full</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#此操作是为了之后可以使用service twemproxy start/stop等命令操作</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/scripts</span><br><span class="line">cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">chmod +x twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看到需要在这个目录下创建此配置 OPTIONS="-d -c /etc/nutcracker/.yml"</span></span><br><span class="line">more twemproxy </span><br><span class="line"></span><br><span class="line">进入源码目录</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/conf</span><br><span class="line">cp ./* /etc/nutcracker</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/src</span><br><span class="line">cp nutcracker /usr/bin <span class="comment">#之后再操作系统任意地方可以使用nutcracker命令</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/nutcracker</span><br><span class="line">cp nutcracker.yml nutcracker.yml.bak</span><br></pre></td></tr></table></figure>

<h4 id="3-2、配置"><a href="#3-2、配置" class="headerlink" title="3.2、配置"></a>3.2、配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">nutcracker.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">alpha:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:22121</span></span><br><span class="line">  <span class="attr">hash:</span> <span class="string">fnv1a_64</span></span><br><span class="line">  <span class="attr">distribution:</span> <span class="string">ketama</span></span><br><span class="line">  <span class="attr">auto_eject_hosts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">redis:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">server_retry_timeout:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">server_failure_limit:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379:1</span> <span class="comment">#1指的是权重</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9380:1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3、手动启动redis"><a href="#3-3、手动启动redis" class="headerlink" title="3.3、手动启动redis"></a>3.3、手动启动redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接指定端口启动的话，会将当前目录作为持久目录</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis/6379_data</span><br><span class="line">redis-server --port 6379</span><br><span class="line"></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis/6380_data</span><br><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure>

<h4 id="3-4、启动twemproxy"><a href="#3-4、启动twemproxy" class="headerlink" title="3.4、启动twemproxy"></a>3.4、启动twemproxy</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service twemproxy start</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/twemproxy-%E5%90%AF%E5%8A%A803.jpg" alt=""></p>
<h4 id="3-5、通过代理连接redis"><a href="#3-5、通过代理连接redis" class="headerlink" title="3.5、通过代理连接redis"></a>3.5、通过代理连接redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据分区，不支持keys、watch、MULTI等命令</span></span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure>

<h3 id="4、代理分区-Predixy"><a href="#4、代理分区-Predixy" class="headerlink" title="4、代理分区-Predixy"></a>4、代理分区-<a href="https://github.com/joyieldInc/predixy/releases" target="_blank" rel="noopener"><code>Predixy</code></a></h3><p><a href="https://github.com/joyieldInc/predixy/blob/master/README_CN.md" target="_blank" rel="noopener">中文文档</a></p>
<h4 id="4-1、安装"><a href="#4-1、安装" class="headerlink" title="4.1、安装"></a>4.1、安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line">tar xf predixy-1.0.5-bin-amd64-linux.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="4-2、predixy相关配置"><a href="#4-2、predixy相关配置" class="headerlink" title="4.2、predixy相关配置"></a>4.2、predixy相关配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改predixy配置</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy/predixy-1.0.5/conf</span><br><span class="line">vi predixy.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">################################### GENERAL ####################################</span></span><br><span class="line"><span class="comment"># 开放predixy绑定的ip端口</span></span><br><span class="line">Bind 127.0.0.1:7617</span><br><span class="line"><span class="comment"># Bind 0.0.0.0:7617</span></span><br><span class="line"><span class="comment"># Bind /tmp/predixy</span></span><br><span class="line"><span class="comment">################################### SERVERS ####################################</span></span><br><span class="line"><span class="comment"># Include cluster.conf</span></span><br><span class="line"><span class="comment">#加载sentinel相关配置</span></span><br><span class="line">Include sentinel.conf</span><br><span class="line"><span class="comment"># Include try.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改predixy的sentinel配置</span></span><br><span class="line">vim sentinel.conf</span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">"&#123;&#125;"</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 127.0.0.1:26379  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26380  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26381  <span class="comment">#配置哨兵节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel001 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel002 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3、sentinel配置"><a href="#4-3、sentinel配置" class="headerlink" title="4.3、sentinel配置"></a>4.3、sentinel配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line"></span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line"></span><br><span class="line">port 26381</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br></pre></td></tr></table></figure>

<h4 id="4-4、启动sentinel"><a href="#4-4、启动sentinel" class="headerlink" title="4.4、启动sentinel"></a>4.4、启动sentinel</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server 26379.conf --sentinel</span><br><span class="line">redis-server 26380.conf --sentinel</span><br><span class="line">redis-server 26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<h4 id="4-5、启动redis主从"><a href="#4-5、启动redis主从" class="headerlink" title="4.5、启动redis主从"></a>4.5、启动redis主从</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir 36379</span><br><span class="line">mkdir 36380</span><br><span class="line">mkdir 46379</span><br><span class="line">mkdir 46380</span><br><span class="line">redis-sever --port 36379</span><br><span class="line">redis-server --port 36380 --replicaof 127.0.0.1 36379</span><br><span class="line">redis-sever --port 46379</span><br><span class="line">redis-server --port 46380 --replicaof 127.0.0.1 46379</span><br></pre></td></tr></table></figure>

<h4 id="4-6、启动predixy"><a href="#4-6、启动predixy" class="headerlink" title="4.6、启动predixy"></a>4.6、启动predixy</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy/predixy-1.0.5/bin</span><br><span class="line">./predixy ../conf/predixy.conf</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/%E5%90%AF%E5%8A%A8predixy-01jpg.jpg" alt=""></p>
<h4 id="4-7、通过代理连接redis"><a href="#4-7、通过代理连接redis" class="headerlink" title="4.7、通过代理连接redis"></a>4.7、通过代理连接redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代理分区，因为sentinel监控了两套主从，不支持keys、watch、MULTI等命令，使用单套主从则可以</span></span><br><span class="line">redis-cli -p 7167</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/redis/predixy%E4%BD%BF%E7%94%A8.jpg" alt=""></p>
<h3 id="5、查询路由分区-Redis-Cluster"><a href="#5、查询路由分区-Redis-Cluster" class="headerlink" title="5、查询路由分区-Redis-Cluster"></a>5、查询路由分区-<code>Redis-Cluster</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无需&#96;proxy&#96;代理，客户端直接与&#96;redis&#96;集群的每个节点连接，根据同样的&#96;hash&#96;算法计算出&#96;key&#96;对应的&#96;slot&#96;，然后直接在&#96;slot&#96;对应的&#96;redis&#96;节点上执行命令。</span><br><span class="line"></span><br><span class="line">在&#96;redis&#96;看来，响应时间是最苛刻的条件，增加一层带来的开销是&#96;redis&#96;不能接受的。因此，&#96;redis&#96;实现了客户端对节点的直接访问，**为了去中心化，节点之间通过&#96;gossip&#96;协议交换互相的状态，以及探测新加入的节点信息**。&#96;redis&#96;集群支持动态加入节点，动态迁移&#96;slot&#96;，以及自动故障转移。</span><br></pre></td></tr></table></figure>

<h4 id="5-1、slot分配"><a href="#5-1、slot分配" class="headerlink" title="5.1、slot分配"></a>5.1、slot分配</h4><p><strong>redis集群模式使用公式 <code>CRC16(key) % 16384</code> 来计算键<code>key</code>属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC16</code> 校验和 。集群中的每个节点负责处理一部分哈希槽。</strong></p>
<p><img src="/images/linux/redis/redis-28.png" alt=""></p>
<p> 举个例子， 一个集群可以有三个节点， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5500 号哈希槽。</li>
<li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li>
<li>节点 C 负责处理 11001 号至 16383 号哈希槽。</li>
<li>此时 <code>Redis Client</code> 需要根据一个<code>Key</code>获取对应的 <code>Value</code> 的数据，首先通过 <code>CRC16(key)%16384</code> 计算出 Slot 的值，假设计算的结果是 5000，将这个数据传送给 <code>Redis Cluster</code>，集群接收到以后会到一个对照表中查找这个 <code>Slot=5000</code> 属于那个缓存节点。发现属于“节点 A ”负责，于是顺着红线的方向调用节点 A中存放的 <code>Key-Value</code> 的内容并且返回给 <code>Redis Client</code>。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p><strong>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，且成本很低， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线</strong>。</p>
<h4 id="5-2、数据结构"><a href="#5-2、数据结构" class="headerlink" title="5.2、数据结构"></a>5.2、数据结构</h4><p><code>Redis Cluster</code>中的每个节点都保存了集群的配置信息，并且存储在<code>clusterState</code>中，结构如下：</p>
<p><img src="/images/linux/redis/redis-30.png" alt=""></p>
<p>上图的各个变量语义如下:</p>
<ul>
<li><code>clusterState</code> 记录了从集群中某个节点视角，来看集群配置状态；</li>
<li><code>currentEpoch</code> 表示整个集群中最大的版本号，集群信息每变更一次，改版本号都会自增。</li>
<li><code>nodes</code> 是一个列表，包含了本节点所感知的，集群所有节点的信息（<code>clusterNode</code>），也包含自身的信息。</li>
<li><code>clusterNode</code> 记录了每个节点的信息，其中包含了节点本身的版本 <code>Epoch</code>；自身的信息描述：节点对应的数据分片范围（<code>slot</code>）、为<code>master</code>时的<code>slave</code>列表、为<code>slave</code>时的<code>master</code>等。</li>
</ul>
<p><strong>每个节点包含一个全局唯一的<code>NodeId</code></strong>。</p>
<p>当集群的数据分片信息发生变更（数据在节点间迁移时），<code>Redis Cluster</code>仍然保持对外服务。</p>
<p>当集群中某个master出现宕机时，<code>Redis Cluster</code> 会自动发现，并触发故障转移的操作。会将<code>master</code>的某个<code>slave</code>晋升为新的 <code>master</code>。</p>
<p>由此可见，每个节点都保存着<code>Node</code>视角的集群结构。它描述了数据的分片方式，节点主备关系，并通过<code>Epoch</code>作为版本号实现集群结构信息的一致性，同时也控制着数据迁移和故障转移的过程。</p>
<h4 id="5-3、节点通信"><a href="#5-3、节点通信" class="headerlink" title="5.3、节点通信"></a>5.3、节点通信</h4><p>在<code>Redis Cluster</code>中，这个配置信息交互通过<code>Redis Cluster Bus</code>来完成（<code>独立端口</code>）。<code>Redis Cluster Bus</code>上交互的信息结构如下：</p>
<p><img src="/images/linux/redis/redis-31.png" alt=""></p>
<p><code>clusterMsg</code> 中的<code>type</code>指明了消息的类型，配置信息的一致性主要依靠<code>PING/PONG</code>。每个节点向其他节点频繁的周期性的发送<code>PING/PONG</code>消息。对于消息体中的<code>Gossip</code>部分，包含了<code>sender/receiver</code> 所感知的其他节点信息，接受者根据这些<code>Gossip</code> 跟新对集群的认识。</p>
<p>对于大规模的集群，如果每次<code>PING/PONG</code> 都携带着所有节点的信息，则网络开销会很大。此时<code>Redis Cluster</code> 在每次<code>PING/PONG</code>，只包含了随机的一部分节点信息。由于交互比较频繁，短时间的几次交互之后，集群的状态也会达成一致。</p>
<h4 id="5-4、一致性"><a href="#5-4、一致性" class="headerlink" title="5.4、一致性"></a>5.4、一致性</h4><p>当<code>Cluster</code> 结构不发生变化时，各个节点通过<code>gossip</code> 协议在几轮交互之后，便可以得知<code>Cluster</code>的结构信息，达到一致性的状态。但是当集群结构发生变化时（故障转移/分片迁移等），优先得知变更的节点通过Epoch变量，将自己的最新信息扩散到<code>Cluster</code>，并最终达到一致。</p>
<p><code>clusterNode</code> 的<code>Epoch</code>描述的单个节点的信息版本；<br><code>clusterState</code> 的<code>currentEpoch</code> 描述的是集群信息的版本，它可以辅助<code>Epoch</code> 的自增生成。因为<code>currentEpoch</code> 是维护在每个节点上的，在集群结构发生变更时，<code>Cluster</code> 在一定的时间窗口控制更新规则，来保证每个节点的<code>currentEpoch</code>都是最新的。<br>更新规则如下：</p>
<p>当某个节点率先知道了变更时，将自身的<code>currentEpoch</code> 自增，并使之成为集群中的最大值。再用自增后的<code>currentEpoch</code> 作为新的<code>Epoch</code> 版本；</p>
<ul>
<li>当某个节点收到了比自己大的<code>currentEpoch</code>时，更新自己的<code>currentEpoch</code>；</li>
<li>当收到的<code>Redis Cluster Bus</code> 消息中的某个节点的<code>Epoch</code> &gt; 自身的时，将更新自身的内容；</li>
<li>当<code>Redis Cluster Bus</code> 消息中，包含了自己没有的节点时，将其加入到自身的配置中。</li>
</ul>
<p>上述的规则保证了信息的更新都是单向的，最终朝着<code>Epoch</code>更大的信息收敛。同时<code>Epoch</code>也随着<code>currentEpoch</code>的增加而增加，最终将各节点信息趋于稳定。</p>
<p>为了使得集群在一部分节点下线或者无法与集群的大多数（<code>majority</code>）节点进行通讯的情况下， 仍然可以正常运作， <code>Redis</code> 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（<code>replica</code>）， 其中一个复制品为主节点（<code>master</code>）， 而其余的 N-1 个复制品为从节点（<code>slave</code>）。</p>
<p><strong>集群间节点支持主从关系</strong>，复制的逻辑基本复用了单机版的实现。不过还是有些地方需要注意。</p>
<ul>
<li>首先集群间节点建立主从关系不再使用原有的<code>SLAVEOF</code>命令和<code>SLAVEOF</code>配置，而是通过<code>cluster replicate</code>命令，这保证了主从节点需要先完成握手，才能建立主从关系。</li>
<li>集群是不能组成链式主从关系的，也就是说从节点不能有自己的从节点。不过对于集群外的没开启集群功能的节点，<code>redis</code>并不干预这些节点去复制集群内的节点，但是在集群故障转移时，这些集群外的节点，集群不会处理。</li>
<li>集群内节点想要复制另一个节点，需要保证本节点不再负责任何<code>slot</code>，不然<code>redis</code>也是不允许的。</li>
<li>集群内的从节点在与其他节点通信的时候，传递的消息中数据分布表和<code>epoch</code>是<code>master</code>的值。</li>
</ul>
<p><strong>集群主节点出现故障，发生故障转移，其他主节点会把故障主节点的从节点自动提为主节点，原来的主节点恢复后，自动成为新主节点的从节点</strong>。</p>
<p>这里先说明，把一个<code>master</code>和它的全部<code>slave</code>描述为一个<code>group</code>，故障转移是以<code>group</code>为单位的，集群故障转移的方式跟sentinel的实现很类似。</p>
<p><img src="/images/linux/redis/redis-32.png" alt=""></p>
<h4 id="5-5、均衡集群"><a href="#5-5、均衡集群" class="headerlink" title="5.5、均衡集群"></a>5.5、均衡集群</h4><p>在集群运行过程中，有的<code>master</code>的<code>slave</code>宕机，导致了该<code>master</code>成为孤儿<code>master</code>（<code>orphaned masters</code>），而有的<code>master</code>有很多<code>slave</code>。</p>
<p>此处孤儿<code>master</code>的定义是那些本来有<code>slave</code>，但是全部离线的<code>master</code>，对于那些原来就没有<code>slave</code>的<code>master</code>不能认为是孤儿<code>master</code>。</p>
<p><code>redis</code>集群支持均衡<code>slave</code>功能，官方称为<code>Replica migration</code>，而我觉得均衡集群的<code>slave</code>更好理解该概念。集群能把某个<code>slave</code>较多的<code>group</code>上的<code>slave</code>迁移到那些孤儿<code>master</code>上，该功能通过<code>cluster-migration-barrier</code>参数配置，默认为1。</p>
<p><code>slave</code>在每次定时任务都会检查是否需要迁移<code>slave</code>，即把自己变成孤儿<code>master</code>的<code>slave</code>。 满足以下条件，<code>slave</code>就会成为孤儿<code>master</code>的<code>slave</code>：</p>
<ul>
<li>自己所在的<code>group</code>是<code>slave</code>最多的<code>group</code>。</li>
<li>目前存在孤儿<code>master</code>。</li>
<li>自己所在的<code>group</code>的<code>slave</code>数目至少超过2个，只有自己一个的话迁移到其他<code>group</code>，自己原来的<code>group</code>的<code>master</code>又成了孤儿<code>master</code>。</li>
<li>自己所在的<code>group</code>的<code>slave</code>数量大于<code>cluster-migration-barrier</code>配置。</li>
<li>与<code>group</code>内的其他<code>slave</code>基于<code>memcmp</code>比较<code>node id</code>，自己的<code>node id</code>最小。这个可以防止多个<code>slave</code>并发复制孤儿<code>master</code>，从而原来的<code>group</code>失去过多的<code>slave</code>。</li>
</ul>
<h5 id="5-5-1、优势"><a href="#5-5-1、优势" class="headerlink" title="5.5.1、优势"></a>5.5.1、优势</h5><ol start="2">
<li>去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。</li>
<li>解耦 <strong>数据</strong> 和 <strong>节点</strong> 之间的关系，简化了节点 <strong>扩容</strong> 和 <strong>收缩</strong> 难度。</li>
<li><strong>节点自身</strong> 维护槽的 <strong>映射关系</strong>，不需要 <strong>客户端</strong> 或者 <strong>代理服务</strong> 维护 <strong>槽分区元数据</strong>。</li>
</ol>
<h5 id="5-5-2、劣势"><a href="#5-5-2、劣势" class="headerlink" title="5.5.2、劣势"></a>5.5.2、劣势</h5><ol>
<li><code>key</code> <strong>批量操作</strong> 支持有限。类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的<code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的<code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</li>
<li>只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</li>
<li><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</li>
<li>不支持<strong>多数据库空间</strong>，<strong>单机</strong>下的<code>Redis</code>可以支持 16 个数据库（db0 ~ db15），<strong>集群模式</strong>下只能使用<strong>一个</strong> 数据库空间，即 db0。</li>
<li><strong>复制结构</strong> 只支持一层，<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</li>
</ol>
<h4 id="5-6、集群搭建"><a href="#5-6、集群搭建" class="headerlink" title="5.6、集群搭建"></a>5.6、集群搭建</h4><h5 id="5-6-1、脚本启动"><a href="#5-6-1、脚本启动" class="headerlink" title="5.6.1、脚本启动"></a>5.6.1、脚本启动</h5><p>​    进入redis源码目录下/utils/create-cluster中执行create-cluster脚本</p>
<p>​    <code>cd /usr/local/redis-6.0.9/utils/create-cluster</code></p>
<h5 id="5-6-2、配置"><a href="#5-6-2、配置" class="headerlink" title="5.6.2、配置"></a>5.6.2、配置</h5><p>​    <code>vim create-cluster</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Settings</span></span><br><span class="line">BIN_PATH=<span class="string">"../../src/"</span></span><br><span class="line">CLUSTER_HOST=127.0.0.1</span><br><span class="line">PORT=30000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6 <span class="comment">#总的节点数量</span></span><br><span class="line">REPLICAS=1 <span class="comment">#每个master对应的slave数量</span></span><br><span class="line">PROTECTED_MODE=yes</span><br><span class="line">ADDITIONAL_OPTIONS=<span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>​        由以上配置可以看出，总节点数为6，每个master对应的slave数量为1，因此根据此配置启动后集群为三主三从模式；后续如果有需要可以修改此配置</p>
<h5 id="5-6-3、启动集群实例"><a href="#5-6-3、启动集群实例" class="headerlink" title="5.6.3、启动集群实例"></a>5.6.3、启动集群实例</h5><p>​    <code>./create-cluster start</code></p>
<p><img src="/images/linux/redis/cluster-%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8-01.jpg" alt=""></p>
<h5 id="5-6-4、脚本分配slot（hash槽位）"><a href="#5-6-4、脚本分配slot（hash槽位）" class="headerlink" title="5.6.4、脚本分配slot（hash槽位）"></a>5.6.4、脚本分配slot（hash槽位）</h5><p>​     <code>./create-cluster create</code></p>
<p><img src="/images/linux/redis/cluster-%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8-02.jpg" alt=""></p>
<h5 id="5-6-5、客户端-连接"><a href="#5-6-5、客户端-连接" class="headerlink" title="5.6.5、客户端-连接"></a>5.6.5、客户端-连接</h5><p>客户端在初始化的时候只需要知道一个节点的地址即可，客户端会先尝试向这个节点执行命令，比如<code>“get key”</code>，如果key所在的<code>slot</code>刚好在该节点上，则能够直接执行成功。如果<code>slot</code>不在该节点，则节点会返回MOVED错误，同时把该slot对应的节点告诉客户端。客户端可以去该节点执行命令。</p>
<p><img src="/images/linux/redis/redis-29.png" alt=""></p>
<h6 id="普通客户端模式-连接"><a href="#普通客户端模式-连接" class="headerlink" title="普通客户端模式-连接"></a>普通客户端模式-连接</h6><p>​    <code>redis-cli -p 30001</code></p>
<p><img src="/images/linux/redis/cluster-%E6%99%AE%E9%80%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BF%9E%E6%8E%A5-01.jpg" alt=""></p>
<p>​    key分配的slot不在当前连接的redis server时，服务端返回错误提示，让客户端自己进行跳转 <code>(error) MOVED 12706 127.0.0.1:30003</code></p>
<h6 id="集群客户端模式-连接"><a href="#集群客户端模式-连接" class="headerlink" title="集群客户端模式-连接"></a>集群客户端模式-连接</h6><p>​    <code>redis-cli -c -p 30001</code></p>
<p><img src="/images/linux/redis/cluster-%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BF%9E%E6%8E%A5.jpg" alt=""></p>
<p>​    key分配的slot不在当前连接的redis server时，集群模式客户端会帮助我们进行重定向跳转 <code>Redirected to slot [12706] located at 127.0.0.1:30003</code></p>
<h5 id="5-6-6、注意"><a href="#5-6-6、注意" class="headerlink" title="5.6.6、注意"></a>5.6.6、注意</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	不管是&#96;普通客户端模式&#96;还是&#96;集群客户端模式&#96;去连接服务，如果key不在一个slot仍无法使用事务等指令</span><br><span class="line">​	解决同类业务数据不在同个 redis哈希槽的问题，在key上加上&#123;tag&#125;来标识某个key，会计算第一次出现&#39;&#123;&#39;到第一次出现&#39;&#125;&#39;之间的subString内容的hash值，如果该内容为空，则计算整个key;这种方式是解决分区key不同分区的通用解决方案</span><br></pre></td></tr></table></figure>

<h5 id="5-6-7、停止实例"><a href="#5-6-7、停止实例" class="headerlink" title="5.6.7、停止实例"></a>5.6.7、停止实例</h5><p>​    停止所有正在运行的redis-cluster实例 <code>./create-cluster stop</code></p>
<h5 id="5-6-7、还原实例"><a href="#5-6-7、还原实例" class="headerlink" title="5.6.7、还原实例"></a>5.6.7、还原实例</h5><p>​    清除配置、日志、持久化文件 <code>./create-cluster clean</code></p>
<p><img src="/images/linux/redis/cluster-%E6%B8%85%E9%99%A4%E9%85%8D%E7%BD%AE%E8%BF%98%E5%8E%9F.jpg" alt=""></p>
<h5 id="5-6-8、手动启动"><a href="#5-6-8、手动启动" class="headerlink" title="5.6.8、手动启动"></a>5.6.8、手动启动</h5><p>修改redis配置，之后启动redis时加载此配置 <code>redis-server ./6379.conf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"><span class="comment">#redis.conf相关集群配置</span></span><br><span class="line"><span class="comment">#配置为cluster模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群节点配置信息，包括nodeid，集群信息。此文件非常关键，要确保故障转移或者重启的时候此文件还在，所以如果在docker环境下要外挂到外部存储</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点连接超时，如果集群规模小，都在同一个网络环境下，可以配置的短些，更快的做故障转移</span></span><br><span class="line">cluster-node-timeout 2000</span><br><span class="line"></span><br><span class="line"><span class="comment">#慢查询日志，用于性能分析，生产环境可设置为1000（毫秒）</span></span><br><span class="line">slowlog-log-slower-than 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存慢查询的队列长度 ，设置为1000</span></span><br><span class="line">slowlog-max-len 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为0，默认为10如果master slave都挂掉，slave跟master失联又超过这个数值*timeout的数值，就不会发起选举了。</span></span><br><span class="line"><span class="comment">#如果设置为0，就是永远都会尝试发起选举，尝试从slave变为mater</span></span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为no，默认为yes，故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况</span></span><br><span class="line"><span class="comment">#因此要设置为no，当主节点故障时只影 响它负责槽的相关命令执行，不会影响其他主节点的可用性</span></span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>



<h5 id="5-6-9、手动分配slot（hash槽）"><a href="#5-6-9、手动分配slot（hash槽）" class="headerlink" title="5.6.9、手动分配slot（hash槽）"></a>5.6.9、手动分配slot（hash槽）</h5><p>​    使用此方式可以自己指定参与集群的redis节点，设置slave节点数，适合真实环境下多服务器实例的集群搭建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<h5 id="5-6-10、移动slot"><a href="#5-6-10、移动slot" class="headerlink" title="5.6.10、移动slot"></a>5.6.10、移动slot</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实行重新分片命令，可任意连接一个redis实例进行操作</span></span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:30001</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span><br><span class="line">M: 1ba79d08eacd99fa3791d1824907a3e3e136cf06 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: d23ba04b97a59fa4bf3400510feb128ef0694520 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">S: 40b2868d28ac09031df1caa9847066eadebfa4f7 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e5bb13b4ea84f4fd5f23a944ae59a6768a34be28</span><br><span class="line">S: ddeb75d4235f26ce86fe30d3aa9edffde92d5a31 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">M: e3e285582cabc5360d74e99c778867526cecb2a1 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e5bb13b4ea84f4fd5f23a944ae59a6768a34be28 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="comment">#想要移动多少槽位？这里指定了2000</span></span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 2000</span><br><span class="line"><span class="comment"># 想要移动到哪个节点？这里指定了30002的节点id</span></span><br><span class="line">What is the receiving node ID? e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">    Moving slot 1998 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">    Moving slot 1999 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line"><span class="comment"># 是否执行表重新分片计划？yes</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">Moving slot 1997 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1998 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1999 from 127.0.0.1:30001 to 127.0.0.1:30002:</span><br></pre></td></tr></table></figure>

<p>如下图所示，有2000个槽位从30001的实例迁移到了30002的实例中</p>
<p><img src="/images/linux/redis/cluster-%E7%A7%BB%E5%8A%A8%E6%A7%BD%E4%BD%8D-02.jpg" alt=""></p>
<h5 id="5-6-11、集群客户端-帮助"><a href="#5-6-11、集群客户端-帮助" class="headerlink" title="5.6.11、集群客户端-帮助"></a>5.6.11、集群客户端-帮助</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos-3 create-cluster]<span class="comment"># redis-cli --cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  <span class="built_in">set</span>-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  <span class="built_in">help</span>           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, <span class="built_in">set</span>-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>db</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq 安装</title>
    <url>/2021/07/31/rocketmq%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、rocketmq"><a href="#一、rocketmq" class="headerlink" title="一、rocketmq"></a>一、rocketmq</h2><h3 id="1-1、文档"><a href="#1-1、文档" class="headerlink" title="1.1、文档"></a>1.1、文档</h3><p><a href="https://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">官网Quick Start</a></p>
<p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn" target="_blank" rel="noopener">github中文文档</a></p>
<h3 id="1-2、下载"><a href="#1-2、下载" class="headerlink" title="1.2、下载"></a>1.2、下载</h3><p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.9.0/rocketmq-all-4.9.0-source-release.zip" target="_blank" rel="noopener">apache官网下载地址yi</a></p>
<p><a href="https://github.com/apache/rocketmq/releases" target="_blank" rel="noopener">github源码下载地址</a></p>
<a id="more"></a>

<p>本次使用github下载的源码包进行安装</p>
<p>解压：<code>tar -zxf rocketmq-rocketmq-all-4.8.0.tar.gz</code></p>
<h3 id="1-3、编译"><a href="#1-3、编译" class="headerlink" title="1.3、编译"></a>1.3、编译</h3><p>进入解压后的主目录，使用maven编译项目：<code>mvn -Prelease-all -DskipTests clean install -U</code></p>
<p>进入分布式目录：<code>cd distribution</code>可以看到编译后的target目录</p>
<p><img src="/images/roketmq/rocketmq01.png" alt=""></p>
<p>进入target目录下：<code>cd target/rocketmq-4.8.0/rocketmq-4.8.0/bin</code> 可以看到可执行文件</p>
<p><img src="/images/roketmq/rocketmq02.png" alt=""></p>
<h3 id="1-4、启动"><a href="#1-4、启动" class="headerlink" title="1.4、启动"></a>1.4、启动</h3><h4 id="1-4-1、启动nameServer"><a href="#1-4-1、启动nameServer" class="headerlink" title="1.4.1、启动nameServer"></a>1.4.1、启动nameServer</h4><p>​    前台启动：<code>./mqnamesrv</code></p>
<p><img src="/images/roketmq/nameServer.png" alt=""></p>
<p>​    后台启动：<code>nohup sh mqnamesrv &amp;</code></p>
<p>​    通过日志查看执行结果：<code>tail -f ~/logs/rocketmqlogs/namesrv.log</code></p>
<p>​    端口：9876</p>
<h4 id="1-4-2启动Broker"><a href="#1-4-2启动Broker" class="headerlink" title="1.4.2启动Broker"></a>1.4.2启动Broker</h4><p>启动的同时指定连接的nameServer地址</p>
<p>​    前台启动：<code>./mqbroker -n localhost:9876</code></p>
<p>​    出现错误提示</p>
<p><img src="/images/roketmq/broker-error.png" alt=""></p>
<p><code>vim mqbroker</code>可以看到其执行的sh脚本</p>
<p><img src="/images/roketmq/vimbroker.png" alt=""></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改脚本</span></span><br><span class="line">vim runbroker.sh</span><br><span class="line"><span class="comment">#将原堆大小-Xms8g -Xmx8g -Xmn4g进行修改</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms512m -Xmx512m -Xmn256m"</span></span><br></pre></td></tr></table></figure>

<p>再次启动</p>
<p><img src="/images/roketmq/brokersuccess.png" alt=""></p>
<p>​    后台启动：<code>nohup sh mqbroker -n localhost:9876 &amp;</code></p>
<p>​    通过日志查看执行结果：<code>tail -f ~/logs/rocketmqlogs/broker.log</code></p>
<p>​    端口：10911</p>
<h3 id="1-5、测试"><a href="#1-5、测试" class="headerlink" title="1.5、测试"></a>1.5、测试</h3><p>使用<code>tool.sh</code>脚本执行测试程序</p>
<h4 id="1-5-1、测试发送"><a href="#1-5-1、测试发送" class="headerlink" title="1.5.1、测试发送"></a>1.5.1、测试发送</h4><p><code>./tools.sh org.apache.rocketmq.example.quickstart.Producer</code></p>
<p>失败-connect to null failed</p>
<p><img src="/images/roketmq/test-fail.png" alt=""></p>
<p><strong>原因：</strong>不知道<code>nameserver</code>在哪儿</p>
<p>在<code>tools</code>脚本中添加<code>export NAMESRV_ADDR=localhost:9876</code></p>
<p>再次执行</p>
<p><img src="/images/roketmq/test-result.png" alt=""></p>
<h4 id="1-5-2、测试接收"><a href="#1-5-2、测试接收" class="headerlink" title="1.5.2、测试接收"></a>1.5.2、测试接收</h4><p><code>./tools.sh org.apache.rocketmq.example.quickstart.Consumer</code></p>
<p><img src="/images/roketmq/test-result-consume.png" alt=""></p>
<h2 id="二、rocketmq-console（控制台）"><a href="#二、rocketmq-console（控制台）" class="headerlink" title="二、rocketmq-console（控制台）"></a>二、rocketmq-console（控制台）</h2><h3 id="2-1、下载"><a href="#2-1、下载" class="headerlink" title="2.1、下载"></a>2.1、<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">下载</a></h3><h3 id="2-2、中文文档"><a href="#2-2、中文文档" class="headerlink" title="2.2、中文文档"></a>2.2、<a href="https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md" target="_blank" rel="noopener">中文文档</a></h3><h3 id="2-3、编译"><a href="#2-3、编译" class="headerlink" title="2.3、编译"></a>2.3、编译</h3><p>解压<code>unzip rocketmq-externals-master.zip</code></p>
<p>进入主目录<code>cd /usr/local/rocketmq-externals-master/rocketmq-console</code></p>
<p><img src="/images/roketmq/console01.png" alt=""></p>
<p>使用maven进行编译：<code>mvn clean package -Dmaven.test.skip=true</code></p>
<h3 id="2-4、启动"><a href="#2-4、启动" class="headerlink" title="2.4、启动"></a>2.4、启动</h3><p>编译成功后在<code>rocketmq-console/target</code>目录下执行<code>rocketmq-console-ng-2.0.0.jar</code></p>
<p>启动时，直接动态添加<code>nameserver</code>地址或编辑<code>application.properties</code>添加属性</p>
<p><code>java -jar rocketmq-console-ng-2.0.0.jar --rocketmq.config.namesrvAddr=127.0.0.1:9876</code></p>
<p><img src="/images/roketmq/console02.png" alt=""></p>
<p>启动成功后访问服务器8080端口即可</p>
<p><img src="/images/roketmq/console03.png" alt=""></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>rocketmq 存储设计</title>
    <url>/2021/07/31/rocketmq%20%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md" target="_blank" rel="noopener">设计</a></h2><h3 id="消息存储整体架构"><a href="#消息存储整体架构" class="headerlink" title="消息存储整体架构"></a>消息存储整体架构</h3><img src="/images/roketmq/rocketmq_design_11.png" style="zoom:80%;" />

<a id="more"></a>

<p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成，默认文件会存储在家目录下<code>/root/store/</code>。</p>
<ul>
<li><p>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
</li>
<li><p>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p>
<p>默认情况下每个topic在broker上有一个consumerqueue的文件，里面包含了4个message queue文件。</p>
<img src="/images/roketmq/rocketmq_design_1.png" style="zoom: 80%;" />
</li>
<li><p>IndexFile：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p>
</li>
</ul>
<p>在上面的RocketMQ的消息存储整体架构图中可以看出，RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<h3 id="页缓存与内存映射"><a href="#页缓存与内存映射" class="headerlink" title="页缓存与内存映射"></a>页缓存与内存映射</h3><p>​        页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<p>​        在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p>​        另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<p>​        <code>所以为了使用零拷贝技术，RocketMQ的文件存储大小默认每个1G，超过1G会重新建立一个新文件、</code></p>
<h3 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h3><img src="/images/roketmq/rocketmq_design_2.png" style="zoom:80%;" />

<p>(1) 同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</p>
<p>(2) 异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><img src="/images/roketmq/rocketmq_architecture_1.png" style="zoom: 67%;" />

<p>RocketMQ消息队列集群主要包括NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p>
<ol>
<li>Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</li>
<li>消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</li>
<li>消息生产者Producer根据（2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</li>
<li>消息消费者Consumer根据（2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</li>
</ol>
<p>从上面（1）~（3）中可以看出在消息生产者, Broker和NameServer之间都会发生通信（这里只说了MQ的部分通信），因此如何设计一个良好的网络通信模块在MQ中至关重要，它将决定RocketMQ集群整体的消息传输能力与最终的性能。</p>
<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h4 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h4><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。</p>
<p>具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h4 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h4><p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p>
<p>1、Consumer端的心跳包发送</p>
<p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p>
<p>2、Consumer端实现负载均衡的核心类—RebalanceImpl</p>
<p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。这里，rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
<p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p>
<p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求（Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</p>
<p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p>
<p><img src="/images/roketmq/rocketmq_design_8.png" alt=""></p>
<p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p>
<p><img src="/images/roketmq/rocketmq_design_9.png" alt=""></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
</ul>
<p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空，这样子也就回答了上一篇中最后的那道思考题了。</p>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是：<code>在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</code></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>rocketmq 客户端相关概念及使用</title>
    <url>/2021/07/31/rocketmq%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、消息中间件的作用"><a href="#一、消息中间件的作用" class="headerlink" title="一、消息中间件的作用"></a>一、消息中间件的作用</h2><ul>
<li><p>应用解耦</p>
<p>AB应用不在互相依赖</p>
</li>
<li><p>流量削峰</p>
<p>流量达到高峰的时候，通常使用限流算法来控制流量涌入系统，避免系统被击瘫，但是这种方式损失了一部分请求</p>
<p>此时可以使用消息中间件来缓冲大量的请求，匀速消费，当消息队列中堆积消息过多时，我们可以动态上线增加消费端，来保证不丢失重要请求。</p>
</li>
<li><p>大数据处理</p>
<p>消息中间件可以把各个模块中产生的管理员操作日志、用户行为、系统状态等数据文件作为消息收集到主题中</p>
<p>数据使用方可以订阅自己感兴趣的数据内容互不影响，进行消费</p>
</li>
<li><p>异构系统</p>
<p>跨语言</p>
</li>
</ul>
<h2 id="二、消息收发模型"><a href="#二、消息收发模型" class="headerlink" title="二、消息收发模型"></a>二、消息收发模型</h2><img src="/images/roketmq/消息收发模型.png" alt="参考阿里云官方文档图片" style="zoom:80%;" />

<a id="more"></a>

<h2 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a>三、核心概念</h2><ul>
<li>Topic：消息主题，一级消息类型，生产者向其发送消息。</li>
<li>生产者：也称为消息发布者，负责生产并发送消息至Topic。</li>
<li>消费者：也称为消息订阅者，负责从Topic接收并消费消息。</li>
<li>消息：生产者向Topic发送并最终传送给消费者的数据和（可选）属性的组合。</li>
<li>消息属性：生产者可以为消息定义的属性，包含Message Key和Tag。</li>
<li>Group：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。</li>
</ul>
<p><a href="https://help.aliyun.com/document_detail/29533.html?spm=a2c4g.11186623.6.566.6e403227x3NxDw" target="_blank" rel="noopener">具体名词解释参考阿里云文档</a></p>
<h2 id="四、消息使用"><a href="#四、消息使用" class="headerlink" title="四、消息使用"></a>四、消息使用</h2><h3 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h3><p>消息消费模式由消费者来决定，可以由消费者设置MessageModel来决定消息模式。</p>
<p>默认情况下为<code>集群模式</code></p>
<h4 id="集群模式-默认"><a href="#集群模式-默认" class="headerlink" title="集群模式(默认)"></a>集群模式(默认)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br></pre></td></tr></table></figure>

<p>集群消息是指<strong>集群化部署消费者</strong></p>
<p>当使用集群消费模式时，MQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p>
<p><strong>特点</strong></p>
<ul>
<li>每条消息只需要被处理一次，broker只会把消息发送给消费集群中的一个消费者</li>
<li>在消息重投时，不能保证路由到同一台机器上</li>
<li>消费状态由broker维护</li>
</ul>
<h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<p>当使用广播消费模式时，MQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。</p>
<p><strong>特点</strong></p>
<ul>
<li><p>消费进度由consumer维护</p>
</li>
<li><p>保证每个消费者消费一次消息</p>
</li>
<li><p>消费失败的消息不会重投</p>
</li>
</ul>
<h3 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h3><h4 id="同步消息-单条、批量"><a href="#同步消息-单条、批量" class="headerlink" title="同步消息(单条、批量)"></a>同步消息(单条、批量)</h4><img src="/images/roketmq/同步发送.png" style="zoom: 67%;" />

<p>​            同步发送是指消息发送方发出一条消息后，会在收到服务端返回响应之后才发下一条消息的通讯方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"group01"</span>);</span><br><span class="line"><span class="comment">//nameServer地址</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步单条普通消息</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"topic01"</span>,<span class="string">"msg_body"</span>.getBytes());</span><br><span class="line">SendResult send = producer.send(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步多条普通消息发送</span></span><br><span class="line">List&lt;Message&gt; msgList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">msgList.add(<span class="keyword">new</span> Message(<span class="string">"topic01"</span>,<span class="string">"同步普通多条01"</span>.getBytes()));</span><br><span class="line">msgList.add(<span class="keyword">new</span> Message(<span class="string">"topic01"</span>,<span class="string">"同步普通多条02"</span>.getBytes()));</span><br><span class="line">msgList.add(<span class="keyword">new</span> Message(<span class="string">"topic01"</span>,<span class="string">"同步普通多条03"</span>.getBytes()));</span><br><span class="line">SendResult send = producer.send(msgList);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>



<h4 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h4><img src="/images/roketmq/异步发送.png" style="zoom:67%;" />

<p>​        异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。消息队列RocketMQ版的异步发送，需要您实现异步发送回调接口（SendCallback）。消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息。发送方通过回调接口接收服务端响应，并处理响应结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"group02"</span>);</span><br><span class="line"><span class="comment">//设置nameServer</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line"><span class="comment">//启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"topic02"</span>,<span class="string">"异步消息"</span>.getBytes());</span><br><span class="line"><span class="comment">//异步发送消息</span></span><br><span class="line">producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功回调:"</span> + sendResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"失败回调:"</span> + throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步回调不能关闭生产者，因为无法确定回调的消息什么时候执行，会出现异常</span></span><br><span class="line"><span class="comment">//producer.shutdown();</span></span><br></pre></td></tr></table></figure>



<h4 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h4><img src="/images/roketmq/单向发送.png" style="zoom:67%;" />

<p>​        发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"group02"</span>);</span><br><span class="line"><span class="comment">//设置nameServer</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">producer.start();</span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"topic02"</span>,<span class="string">"单向消息"</span>.getBytes());</span><br><span class="line"><span class="comment">//发送单向消息</span></span><br><span class="line">producer.sendOneway(message);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>二级消息类型，用来进一步区分某个Topic下的消息分类</p>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p>在消息中指定tag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"topic04"</span>,<span class="string">"tag04"</span>,<span class="string">"biz_key"</span>,<span class="string">"多属性消息"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p>在订阅中指定tag过滤规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// * 代表订阅Topic下的所有消息</span></span><br><span class="line"><span class="comment">//consumer.subscribe("topic04","*");</span></span><br><span class="line"><span class="comment">//consumer.subscribe("topic04","tag04||tag05");</span></span><br><span class="line">consumer.subscribe(<span class="string">"topic04"</span>,<span class="string">"tag04"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="sql表达式"><a href="#sql表达式" class="headerlink" title="sql表达式"></a>sql表达式</h4><p>消费者将收到包含TAGA或TAGB或TAGB的消息. 但限制是一条消息只能有一个标签，而这对于复杂的情况可能无效。 在这种情况下，可以使用SQL表达式筛选出消息.</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在<code>/rocketmq-rocketmq-all-4.8.0/distribution/target/rocketmq-4.8.0/rocketmq-4.8.0/conf/broker.conf</code>中添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enablePropertyFilter&#x3D;true</span><br></pre></td></tr></table></figure>

<p>启动broker 加载指定配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nohup ../bin/mqbroker -n 127.0.0.1:9876 -c broker.conf  &amp;</span><br></pre></td></tr></table></figure>

<p>rocketmq-console中可以看到</p>
<p><img src="/images/roketmq/%E9%85%8D%E7%BD%AE.png" alt=""></p>
<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setBody(<span class="string">"消息体123456"</span>.getBytes());</span><br><span class="line">message.setTopic(<span class="string">"topic05"</span>);</span><br><span class="line"><span class="comment">//指定额外参数</span></span><br><span class="line">message.putUserProperty(<span class="string">"userId"</span>,<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对额外参数进行sql过滤</span></span><br><span class="line">MessageSelector messageSelector = MessageSelector.bySql(<span class="string">"userId &gt;= 2"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"topic05"</span>,messageSelector);</span><br></pre></td></tr></table></figure>

<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>RocketMQ只定义了一些基本的语法来支持这个功能。 你也可以很容易地扩展它.</p>
<ol>
<li>数字比较, 像 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>BETWEEN</code>, <code>=</code>;</li>
<li>字符比较, 像 <code>=</code>, <code>&lt;&gt;</code>, <code>IN</code>;</li>
<li><code>IS NULL</code> 或者 <code>IS NOT NULL</code>;</li>
<li>逻辑运算<code>AND</code>, <code>OR</code>, <code>NOT</code>;</li>
</ol>
<p>常量类型是:</p>
<ol>
<li>数字, 像123, 3.1415;</li>
<li>字符串, 像‘abc’,必须使用单引号;</li>
<li><code>NULL</code>, 特殊常数;</li>
<li>布尔常量, <code>TRUE</code> 或<code>FALSE</code>;</li>
</ol>
<h2 id="五、消息类型"><a href="#五、消息类型" class="headerlink" title="五、消息类型"></a>五、消息类型</h2><h3 id="5-1、普通消息"><a href="#5-1、普通消息" class="headerlink" title="5.1、普通消息"></a>5.1、普通消息</h3><p>消息队列RocketMQ版中无特性的消息，区别于有特性的定时和延时消息、顺序消息和事务消息。以上例子都以普通消息为例。</p>
<h3 id="5-2、定时和延时消息"><a href="#5-2、定时和延时消息" class="headerlink" title="5.2、定时和延时消息"></a>5.2、定时和延时消息</h3><p>允许消息生产者对指定消息进行定时（延时）投递</p>
<h3 id="5-3、顺序消息"><a href="#5-3、顺序消息" class="headerlink" title="5.3、顺序消息"></a>5.3、顺序消息</h3><p>允许消息消费者按照消息发送的顺序对消息进行消费。</p>
<p>顺序发布和顺序消费是指对于指定的一个Topic，生产者按照一定的先后顺序发布消息；消费者按照既定的先后顺序订阅消息，即先发布的消息一定会先被客户端接收到。</p>
<p><strong>保证有序参与因素</strong></p>
<ul>
<li>FIFO</li>
<li>队列内保证有序</li>
<li>消费线程</li>
</ul>
<p>生产者</p>
<p>默认一个topic下有四个queue，需要保证消息可以顺序搭放入同一个queue中，再依靠FIFO原则进行消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderQueueProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException, MQBrokerException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"queue-group"</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"topic01"</span>,(<span class="string">"队列1消息"</span> + i).getBytes());</span><br><span class="line">            producer.send(message, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//默认有4个队列</span></span><br><span class="line">                    <span class="comment">//可以通过发送消息时，指定的arg进行规则判断，选取同个queue进行发送，常见的有hash取模</span></span><br><span class="line">                    <span class="keyword">return</span> mqs.get(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"arg"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"topic01"</span>,(<span class="string">"队列2消息"</span> + i).getBytes());</span><br><span class="line">            producer.send(message, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//默认有4个队列</span></span><br><span class="line">                    <span class="comment">//可以通过发送消息时，指定的arg进行规则判断，选取同个queue进行发送，常见的有hash取模</span></span><br><span class="line">                    <span class="keyword">return</span> mqs.get(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"arg"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"producer关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<p>使用顺序消息消费监听器，可以保证同个队列的消息以FIFO方式进行消费；</p>
<p>但是多个queue的消息同时消费时仍无法保证，此时需要指定消费的线程数为1，当消费完一个queue之后再去消费另一个queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"order-group"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line">        <span class="comment">//指定订阅规则</span></span><br><span class="line">        consumer.subscribe(<span class="string">"topic01"</span>,<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大开启消费线程数</span></span><br><span class="line">        consumer.setConsumeThreadMax(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//最小线程数</span></span><br><span class="line">        consumer.setConsumeThreadMin(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册顺序消息消费监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(messageExt.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"order consumer start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4、事务消息"><a href="#6-4、事务消息" class="headerlink" title="6.4、事务消息"></a>6.4、事务消息</h3><p><img src="/images/roketmq/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt=""></p>
<p>事务消息发送步骤如下：</p>
<ol>
<li>发送方将半事务消息发送至消息队列RocketMQ版服务端。</li>
<li>消息队列RocketMQ版服务端将消息持久化成功之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit或是Rollback），服务端收到Commit状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到Rollback状态则删除半事务消息，订阅方将不会接受该消息。</li>
</ol>
<p>事务消息回查步骤如下：</p>
<ol>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。</li>
</ol>
<p>实现类似XA或Open XA的分布事务功能，以达到事务最终一致性状态。</p>
<ul>
<li><p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
</li>
<li><p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，等待下一次回调。</p>
</li>
<li><p><strong>超时：</strong>如果超过回查次数，默认回滚消息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"t-group"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"192.168.1.18:9876"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事务监听器</span></span><br><span class="line">producer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">    <span class="comment">//处理本地事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//暂时为未知状态，等待broker调用checkLocalTransaction回查</span></span><br><span class="line">        <span class="comment">//return LocalTransactionState.UNKNOW;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理本地事务message:"</span> + message);</span><br><span class="line">            System.out.println(<span class="string">"处理本地事务arg:"</span> + arg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//回滚消息，broker端会删除半消息</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行事务成功，确认提交</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查本地事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"检查本地事务body:"</span> + messageExt.getBody());</span><br><span class="line">        System.out.println(<span class="string">"检查本地事务msgId:"</span> + messageExt.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">"检查本地事务tid:"</span> + messageExt.getTransactionId());</span><br><span class="line">        <span class="comment">//执行事务成功，确认提交</span></span><br><span class="line">        <span class="comment">//return LocalTransactionState.COMMIT_MESSAGE;</span></span><br><span class="line">        <span class="comment">//回滚消息，broker端会删除半消息</span></span><br><span class="line">        <span class="comment">//return LocalTransactionState.ROLLBACK_MESSAGE;</span></span><br><span class="line">        <span class="comment">//暂时为未知状态，等待broker调用checkLocalTransaction回查</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"topic01"</span>, <span class="string">"消息体"</span>.getBytes());</span><br><span class="line">TransactionSendResult result = producer.sendMessageInTransaction(message, <span class="string">"arg"</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h2 id="六、重试机制"><a href="#六、重试机制" class="headerlink" title="六、重试机制"></a>六、重试机制</h2><p>Producer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送的默认超时时间</span></span><br><span class="line"><span class="comment"> * Timeout for sending messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步发送时 重试次数，默认 2</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 同步发送时 重试次数，默认 2</span></span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">1</span>);	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当消息发送失败时，是否向其他broker发送请求 默认false</span></span><br><span class="line">producer.setRetryAnotherBrokerWhenNotStoreOK(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>Consumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费超时，单位分钟，默认当前线程阻塞15分钟</span></span><br><span class="line">consumer.setConsumeTimeout()</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送ack，消费失败,消费监听器返回稍后重试</span></span><br><span class="line">RECONSUME_LATER</span><br></pre></td></tr></table></figure>

<p>Broker</p>
<p>只有在消息模式为MessageModel.CLUSTERING集群模式时，Broker才会自动进行重试，广播消息不重试</p>
<p>重投使用<code>messageDelayLevel</code></p>
<p>默认值为<code>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</code></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>rocketmq 常见面试题</title>
    <url>/2021/07/31/rocketmq%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="为什么要使用MQ？"><a href="#为什么要使用MQ？" class="headerlink" title="为什么要使用MQ？"></a>为什么要使用MQ？</h2><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是<strong>同步执行</strong>经常出问题，所以引入了mq</p>
<p><strong>解耦</strong>：系统耦合度降低，没有强依赖关系</p>
<p><strong>异步</strong>：不需要同步执行的远程调用可以有效提高响应时间</p>
<p><strong>削峰</strong>：请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮</p>
<a id="more"></a>

<hr>
<h3 id="多个mq如何选型？"><a href="#多个mq如何选型？" class="headerlink" title="多个mq如何选型？"></a>多个mq如何选型？</h3><p><strong>RabbitMQ</strong>：erlang开发，延迟比较低</p>
<p><strong>RocketMQ</strong>：java开发，面向互联网集群化功能丰富</p>
<p><strong>kafka</strong>：Scala开发，面向日志功能丰富</p>
<p><strong>ActiveMQ</strong>：java开发，简单，稳定</p>
<p>小项目：ActiveMQ</p>
<p>大项目：RocketMQ或kafka、RabbitMq</p>
<hr>
<h2 id="RocketMQ中的Topic和ActiveMQ有什么区别？"><a href="#RocketMQ中的Topic和ActiveMQ有什么区别？" class="headerlink" title="RocketMQ中的Topic和ActiveMQ有什么区别？"></a>RocketMQ中的Topic和ActiveMQ有什么区别？</h2><p>ActiveMQ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有destination的概念，即消息目的地</span><br><span class="line">destination分为两类：</span><br><span class="line">- topic</span><br><span class="line">  - 广播消息</span><br><span class="line">- queue</span><br><span class="line">  - 队列消息</span><br></pre></td></tr></table></figure>



<p>RocketMQ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RocketMQ的Topic是一组Message Queue的集合&#x3D;&gt;对应在多个brokert的ConsumeQueue逻辑文件</span><br><span class="line">一条消息是广播消息还是队列消息由客户端消费决定</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="RocketMQ Broker中的消息被消费后会立即删除吗？"></a>RocketMQ Broker中的消息被消费后会立即删除吗？</h2><p>不会，每条消息都会持久化到CommitLog中，每个consumer连接到broker后会维持消费进度信息，当有消息消费后只是当前consumer的消费进度（CommitLog的offset）更新了。</p>
<hr>
<h2 id="消息会堆积吗？什么时候清理过期消息？"><a href="#消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="消息会堆积吗？什么时候清理过期消息？"></a>消息会堆积吗？什么时候清理过期消息？</h2><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p>
<ul>
<li>检查这个文件最后访问时间</li>
<li>判断是否大于过期时间</li>
<li>指定时间删除，默认凌晨4点</li>
</ul>
<hr>
<h2 id="rocketMq的消息堆积如何处理"><a href="#rocketMq的消息堆积如何处理" class="headerlink" title="rocketMq的消息堆积如何处理"></a>rocketMq的消息堆积如何处理</h2><p><strong>下游消费系统如果宕机了，导致几百万条消息在消息中间件里积压，此时怎么处理?</strong></p>
<p><strong>你们线上是否遇到过消息积压的生产故障?如果没遇到过，你考虑一下如何应对?</strong></p>
<p>具体表现为 ui中转圈圈</p>
<p>对于大规模消息发送接收可以使用pull模式，手动处理消息拉取速度,消费的时候统计消费时间以供参考</p>
<p>保证消息消费速度固定，即可通过上线更多consumer临时解决消息堆积问题</p>
<hr>
<h3 id="堆积时间过长消息超时了？"><a href="#堆积时间过长消息超时了？" class="headerlink" title="堆积时间过长消息超时了？"></a>堆积时间过长消息超时了？</h3><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时</p>
<hr>
<h3 id="堆积的消息会不会进死信队列？"><a href="#堆积的消息会不会进死信队列？" class="headerlink" title="堆积的消息会不会进死信队列？"></a>堆积的消息会不会进死信队列？</h3><p>不会，消息在消费失败后会进入重试队列（%RETRY%+consumergroup），多次（默认16）才会进入死信队列（%DLQ%+consumergroup）</p>
<hr>
<h2 id="RocketMQ消费模式有几种？"><a href="#RocketMQ消费模式有几种？" class="headerlink" title="RocketMQ消费模式有几种？"></a>RocketMQ消费模式有几种？</h2><p>消费模型由consumer决定，消费维度为Topic</p>
<h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>一组consumer同时消费一个topic，可以分配消费负载均衡策略分配consumer对应消费topic下的哪些queue</p>
<p>多个group同时消费一个topic时，每个group都会消费到数据</p>
<p>一条消息只会被一个group中的consumer消费，</p>
<h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p>
<hr>
<h2 id="消费消息时使用的是push还是pull？"><a href="#消费消息时使用的是push还是pull？" class="headerlink" title="消费消息时使用的是push还是pull？"></a>消费消息时使用的是push还是pull？</h2><p>在刚开始的时候就要决定使用哪种方式消费</p>
<p>两种：</p>
<p><code>DefaultLitePullConsumerImpl</code>  拉</p>
<p><code>DefaultMQPushConsumerImpl</code>推</p>
<p>两个实现 <code>DefaultLitePullConsumerImpl</code> <code>DefaultMQPushConsumerImpl</code>都实现了MQConsumerInner接口接口</p>
<p>名称上看起来是一个推，一个拉，但实际底层实现都是采用的<strong>长轮询机制</strong>，即拉取方式</p>
<p>DefaultMQPushConsumerImpl帮我们定义好了拉取数据的规则；DefaultMQPullConsumerImpl需要我们自己定义拉取规则</p>
<p>broker端属性 longPollingEnable 标记是否开启长轮询。可以配置hold住的时间长短，默认true为5s，false则为1s</p>
<hr>
<h2 id="为什么要主动拉取消息而不使用事件监听方式？"><a href="#为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="为什么要主动拉取消息而不使用事件监听方式？"></a>为什么要主动拉取消息而不使用事件监听方式？</h2><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况，如果改由consumer主动拉取的方式，则主动权在客户端，可以根据实际消费能力进行消费。</p>
<hr>
<h2 id="broker如何处理拉取请求的？"><a href="#broker如何处理拉取请求的？" class="headerlink" title="broker如何处理拉取请求的？"></a>broker如何处理拉取请求的？</h2><p>consumer首次请求broker</p>
<ul>
<li>broker中是否有符合条件的消息</li>
<li>有 -&gt; <ul>
<li>响应consumer</li>
<li>等待下次consumer的请求</li>
</ul>
</li>
<li>没有<ul>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
<li>挂起时间长短，写死在代码里的吗？长轮询写死，短轮询可以配</li>
<li>使用consumer的offset，<ul>
<li>DefaultMessageStore#ReputMessageService#run方法<ul>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
</ul>
</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><p>producer在发送同步/异步可靠消息后，会接收到SendResult，表示消息发送成功</p>
<p>SendResult其中属性sendStatus表示了broker是否真正完成了消息存储</p>
<p>当sendStatus!=”ok”的时候，应该重新发送消息，避免丢失</p>
<p>当producer.setRetryAnotherBrokerWhenNotStoreOK</p>
<h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><h3 id="引起重复消费的原因"><a href="#引起重复消费的原因" class="headerlink" title="引起重复消费的原因"></a>引起重复消费的原因</h3><p><strong>ACK</strong>(网络的不确定性)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费，从queue中剔除</span><br><span class="line"></span><br><span class="line">当ack因为网络原因无法发送到broker，broker会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer</span><br></pre></td></tr></table></figure>

<p><strong>group</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在CLUSTERING模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次</span><br><span class="line"></span><br><span class="line">也可能是因为consumer首次启动引起重复消费：需要设置&#96;consumer.setConsumeFromWhere&#96;，只对一个新的consumeGroup第一次启动时有效,设置从头消费还是从维护开始消费</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>数据库表：处理消息前，使用消息主键在表中带有约束的字段中insert</p>
<p>Map：单机时可以使用map <em>ConcurrentHashMap</em> -&gt; putIfAbsent   guava cache</p>
<p>Redis：使用主键或set操作</p>
<hr>
<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><ol>
<li><p>生产端如何保证投递出去的消息不丢失：消息在半路丢失，或者在MQ内存中宕机导致丢失，此时你如何基于MQ的功能保证消息不要丢失？</p>
</li>
<li><p>MQ自身如何保证消息不丢失？</p>
</li>
<li><p>消费端如何保证消费到的消息不丢失：如果你处理到一半消费端宕机，导致消息丢失，此时怎么办？</p>
<hr>
</li>
</ol>
<h2 id="如何让RocketMQ保证消息的顺序消费"><a href="#如何让RocketMQ保证消息的顺序消费" class="headerlink" title="如何让RocketMQ保证消息的顺序消费"></a>如何让RocketMQ保证消息的顺序消费</h2><p><strong>你们线上业务用消息中间件的时候，是否需要保证消息的顺序性?</strong></p>
<p><strong>如果不需要保证消息顺序，为什么不需要?假如我有一个场景要保证消息的顺序，你们应该如何保证?</strong></p>
<ul>
<li><p>同一topic</p>
</li>
<li><p>同一个QUEUE</p>
</li>
<li></li>
<li><p>发消息的时候一个线程去发送消息</p>
</li>
<li><p>消费的时候 一个线程 消费一个queue里的消息或者使用MessageListenerOrderly</p>
</li>
<li><p>多个queue 只能保证单个queue里的顺序</p>
<hr>
</li>
</ul>
<h2 id="RocketMQ-是如何保证数据的高容错性的"><a href="#RocketMQ-是如何保证数据的高容错性的" class="headerlink" title="RocketMQ 是如何保证数据的高容错性的?"></a>RocketMQ 是如何保证数据的高容错性的?</h2><ul>
<li>在不开启容错的情况下，轮询队列进行发送，如果失败了，重试的时候过滤失败的Broker</li>
<li>如果开启了容错策略，会通过RocketMQ的预测机制来预测一个Broker是否可用</li>
<li>如果上次失败的Broker可用那么还是会选择该Broker的队列</li>
<li>如果上述情况失败，则随机选择一个进行发送</li>
<li>在发送消息的时候会记录一下调用的时间与是否报错，根据该时间去预测broker的可用时间</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>spring security oauth2搭建</title>
    <url>/2020/11/29/spring%20security%20oauth2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>OAuth2是一套开放标准，Spring Cloud Security Oauth2是对它的一种实现。</p>
<a id="more"></a>

<h3 id="1-1-角色定义"><a href="#1-1-角色定义" class="headerlink" title="1.1 角色定义"></a>1.1 角色定义</h3><h4 id="1-1-1-客户端"><a href="#1-1-1-客户端" class="headerlink" title="1.1.1 客户端"></a>1.1.1 客户端</h4><p>​        本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，如：移动端、pc端等。</p>
<h4 id="1-1-2-资源拥有者"><a href="#1-1-2-资源拥有者" class="headerlink" title="1.1.2 资源拥有者"></a>1.1.2 资源拥有者</h4><p>​        通常为用户、也可为应用程序，即资源的拥有者。</p>
<h4 id="1-1-3-资源服务器"><a href="#1-1-3-资源服务器" class="headerlink" title="1.1.3  资源服务器"></a>1.1.3  资源服务器</h4><p>​        存储资源的服务器，一般为提供业务接口服务的程序。</p>
<h4 id="1-1-4-授权服务器"><a href="#1-1-4-授权服务器" class="headerlink" title="1.1.4 授权服务器"></a>1.1.4 授权服务器</h4><p>​        用于对资源拥有者的身份进行认证、对访问资源进行授权，认证成功发放令牌（access_token）给客户端，作为客户端访问资源服务器的凭证；授权服务器就是对客户端和资源拥有着进行认证授权，使其可以访问资源服务器获取资源。</p>
<h3 id="1-2-四种模式"><a href="#1-2-四种模式" class="headerlink" title="1.2 四种模式"></a>1.2 四种模式</h3><h4 id="1-2-1-授权码模式"><a href="#1-2-1-授权码模式" class="headerlink" title="1.2.1 授权码模式"></a>1.2.1 授权码模式</h4><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式，code保证了token的安全性，即使code被拦截，由于没有app_secret，也是无法通过code获得token的。</p>
<h4 id="1-2-2-隐式授权模式-简化模式"><a href="#1-2-2-隐式授权模式-简化模式" class="headerlink" title="1.2.2 隐式授权模式/简化模式"></a>1.2.2 隐式授权模式/简化模式</h4><p>和授权码模式类似，少了获取code的步骤，是直接获取令牌token的，适用于公开的浏览器单页应用，令牌直接从授权服务器返回，不支持刷新令牌，且没有code安全保证，令牌容易因为被拦截窃听而泄露。</p>
<h4 id="1-2-3-密码模式"><a href="#1-2-3-密码模式" class="headerlink" title="1.2.3 密码模式"></a>1.2.3 密码模式</h4><p>使用用户名/密码作为授权方式从授权服务器上获取令牌，一般不支持刷新令牌。</p>
<h4 id="1-2-4-客户端凭证模式"><a href="#1-2-4-客户端凭证模式" class="headerlink" title="1.2.4 客户端凭证模式"></a>1.2.4 客户端凭证模式</h4><p>一般用于资源服务器是应用的一个后端模块，客户端向认证服务器验证身份来获取令牌。</p>
<h2 id="二、授权服务搭建"><a href="#二、授权服务搭建" class="headerlink" title="二、授权服务搭建"></a>二、授权服务搭建</h2><h3 id="2-1-maven依赖"><a href="#2-1-maven依赖" class="headerlink" title="2.1 maven依赖"></a>2.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-配置类"><a href="#2-2-配置类" class="headerlink" title="2.2 配置类"></a>2.2 配置类</h3><h4 id="2-2-1-鉴权服务配置"><a href="#2-2-1-鉴权服务配置" class="headerlink" title="2.2.1 鉴权服务配置"></a>2.2.1 鉴权服务配置</h4><p>配置类添加@EnableAuthorizationServer，继承org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter类</p>
<p>需重写以下三个方法</p>
<h5 id="2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-："><a href="#2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-：" class="headerlink" title="2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ："></a>2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ：</h5><p>客户端详情信息服务配置，能够使用内存、jdbc方式来实现clientDetailsService（客户端详情服务），负责查找clientDetails。clientDetails能够在应用程序运行时进行更新，通过访问存储服务（如jdbcClientDetailsService）或自己实现ClientRegistrationService接口进行管理</p>
<p>关于clientDetails的几个属性如下：</p>
<ul>
<li>clientId:用来表示客户的id</li>
<li>secret：用来限制客户端的访问访问，如果为空（默认为空）的话，客户端拥有全部的访问范围</li>
<li>authorizedGrantType：客户端可以使用的授权类型，默认为空（client_credentials,password,authorization_code,implicit,refresh_token）</li>
<li>authorities：客户端可以使用的权限</li>
</ul>
<h5 id="2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-："><a href="#2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-：" class="headerlink" title="2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)："></a>2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)：</h5><p>令牌访问端点，用来配置令牌的访问端点和令牌服务</p>
<h5 id="2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-："><a href="#2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-：" class="headerlink" title="2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)："></a>2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)：</h5><p>令牌访问端点安全策略，用来配置令牌端点的安全约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfiguration</span>  <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizationCodeServices authorizationCodeServices;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.客户端详情信息服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂时使用内存方式</span></span><br><span class="line"><span class="comment">/*        clients.inMemory()</span></span><br><span class="line"><span class="comment">                //client_id</span></span><br><span class="line"><span class="comment">                .withClient("c1")</span></span><br><span class="line"><span class="comment">                //客户端秘钥</span></span><br><span class="line"><span class="comment">                .secret(passwordEncoder.encode("secret"))</span></span><br><span class="line"><span class="comment">                //可访问资源列表</span></span><br><span class="line"><span class="comment">                .resourceIds("r1")</span></span><br><span class="line"><span class="comment">                //允许该client授权的类型</span></span><br><span class="line"><span class="comment">                .authorizedGrantTypes("authorization_code","password","client_credentials","implicit","refresh_token")</span></span><br><span class="line"><span class="comment">                //允许授权范围</span></span><br><span class="line"><span class="comment">                .scopes("all")</span></span><br><span class="line"><span class="comment">                //如果使用授权码模式，false跳转到授权页面让用户进行授权，true直接发放令牌</span></span><br><span class="line"><span class="comment">                .autoApprove(false)</span></span><br><span class="line"><span class="comment">                //验证回调地址</span></span><br><span class="line"><span class="comment">                .redirectUris("http://baidu.com");*/</span></span><br><span class="line">        <span class="comment">//使用数据库方式</span></span><br><span class="line">        clients.withClientDetails(clientDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.1令牌管理服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices defaultTokenServices = <span class="keyword">new</span> DefaultTokenServices();</span><br><span class="line">        <span class="comment">//客户端信息服务</span></span><br><span class="line">        defaultTokenServices.setClientDetailsService(clientDetailsService);</span><br><span class="line">        <span class="comment">//是否产生刷新令牌</span></span><br><span class="line">        defaultTokenServices.setSupportRefreshToken(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//令牌存储策略</span></span><br><span class="line">        defaultTokenServices.setTokenStore(tokenStore);</span><br><span class="line">        <span class="comment">//令牌增强</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        defaultTokenServices.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">        <span class="comment">//令牌默认有效时间2小时</span></span><br><span class="line">        defaultTokenServices.setAccessTokenValiditySeconds(<span class="number">7200</span>);</span><br><span class="line">        <span class="comment">//刷新令牌默认有效时间</span></span><br><span class="line">        defaultTokenServices.setRefreshTokenValiditySeconds(<span class="number">259200</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultTokenServices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.2令牌访问端点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                <span class="comment">//密码模式需要(此处注入的管理类为security所配置)</span></span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                <span class="comment">//授权码模式需要</span></span><br><span class="line">                .authorizationCodeServices(authorizationCodeServices)</span><br><span class="line">                <span class="comment">//令牌管理服务</span></span><br><span class="line">                .tokenServices(tokenService())</span><br><span class="line">            	<span class="comment">//注入自己重写的userDetailsService进行自定义用户信息查询</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                <span class="comment">//允许post提交访问服务</span></span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.令牌访问端点安全策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> </span>&#123;</span><br><span class="line">        security</span><br><span class="line">                <span class="comment">//提供公有秘钥端点，用于jwt令牌 公开/oauth/token_key</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">// /oauth/check_token端点公开</span></span><br><span class="line">                .checkTokenAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">//允许表单认证</span></span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置授权码模式的授权码存储，暂时使用内存方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*    @Bean</span></span><br><span class="line"><span class="comment">    public AuthorizationCodeServices authorizationCodeServices()&#123;</span></span><br><span class="line"><span class="comment">        //设置授权码模式，暂时使用内存方式</span></span><br><span class="line"><span class="comment">        return new InMemoryAuthorizationCodeServices();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置授权码模式，暂时使用数据库方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDetailsService <span class="title">clientDetailsService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        JdbcClientDetailsService clientDetailsService = <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">        clientDetailsService.setPasswordEncoder(passwordEncoder);</span><br><span class="line">        <span class="keyword">return</span> clientDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-令牌存储策略配置"><a href="#2-2-2-令牌存储策略配置" class="headerlink" title="2.2.2 令牌存储策略配置"></a>2.2.2 令牌存储策略配置</h4><p>这里编写了三种令牌生成后的存储方式，根据自己的需求进行修改，后面的配置以jwt策略为准，在AuthorizationServerConfiguration类中的tokenService()进行令牌注入配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 令牌存储策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储时使用</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/*@Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore()&#123;</span></span><br><span class="line"><span class="comment">        //内存方式生成普通令牌</span></span><br><span class="line"><span class="comment">        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String SIGNING_KEY = <span class="string">"uaa123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jwt存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">accessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">//对称秘钥，资源服务器使用此秘钥来校验</span></span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">        RedisTokenStore tokenStore = new RedisTokenStore(redisConnectionFactory);</span></span><br><span class="line"><span class="comment">        //配置redis存储的key前缀</span></span><br><span class="line"><span class="comment">        tokenStore.setPrefix("myOauth2:");</span></span><br><span class="line"><span class="comment">        return tokenStore;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-security配置"><a href="#2-2-3-security配置" class="headerlink" title="2.2.3 security配置"></a>2.2.3 security配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">                .and().csrf().disable()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(web);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">       <span class="comment">/* BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();</span></span><br><span class="line"><span class="comment">        auth.inMemoryAuthentication().withUser("111").password(bCryptPasswordEncoder.encode("222")).authorities("user")</span></span><br><span class="line"><span class="comment">                .and().withUser("admin").password(bCryptPasswordEncoder.encode("admin")).authorities("admin");*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * oauth2 的密码模式需要在令牌访问端点注入此配置，管理security操作的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不使用加密方式的编码器，字符串比较</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="comment">//使用加密密码编码器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-四种模式的认证请求"><a href="#2-2-4-四种模式的认证请求" class="headerlink" title="2.2.4 四种模式的认证请求"></a>2.2.4 四种模式的认证请求</h4><h5 id="2-2-4-1-授权码模式（较安全模式）："><a href="#2-2-4-1-授权码模式（较安全模式）：" class="headerlink" title="2.2.4.1 授权码模式（较安全模式）："></a>2.2.4.1 授权码模式（较安全模式）：</h5><ul>
<li><p>申请授权码-GET：</p>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="/images/oauth2/用户登录授权.jpg" alt="授权码模式 用户登录授权" style="zoom: 50%;" />



</li>
</ul>
<p>客户端进行授权请求（此处授权的客户端信息为oauth2表格维护的客户端信息），用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，通过回调url返回code（授权码）<a href="https://www.baidu.com/?code=m4aOtl" target="_blank" rel="noopener">https://www.baidu.com/?code=m4aOtl</a></p>
<ul>
<li><p>申请token-POST:</p>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl</a></p>
</li>
</ul>
<p>根据授权码和客户端secret等信息获取token(此处的token使用的是jwt)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2MjY0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiMDQ1N2ZiNTgtMmY0Ny00NGJmLTk0NzMtMTRiNWU2ZmI4M2ZmIiwiY2xpZW50X2lkIjoiYzEifQ.EjYisjGOtqrTJQc7nqWBtaStphF1PxTe07_pC0oireM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiIwNDU3ZmI1OC0yZjQ3LTQ0YmYtOTQ3My0xNGI1ZTZmYjgzZmYiLCJleHAiOjE2MDY4Nzg0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNGQ4NjMxM2YtYjI3Zi00NTZiLWJlYzItMjc1NDY2N2UwMjIwIiwiY2xpZW50X2lkIjoiYzEifQ.1qItJNh8cGEiTEGJY1b2gBeeGq904lx8sZB7GaRMPmk"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"0457fb58-2f47-44bf-9473-14b5e6fb83ff"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-2-隐式授权模式-简化模式"><a href="#2-2-4-2-隐式授权模式-简化模式" class="headerlink" title="2.2.4.2 隐式授权模式/简化模式"></a>2.2.4.2 隐式授权模式/简化模式</h5><ul>
<li>申请token-GET：</li>
</ul>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="/images/oauth2/用户登录授权.jpg" style="zoom:50%;" />

<p>此模式不需要获取授权码，用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，回调url返回token</p>
<p><a href="https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906" target="_blank" rel="noopener">https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906</a></p>
<h5 id="2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险"><a href="#2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险" class="headerlink" title="2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)"></a>2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)</h5><ul>
<li>申请token-POST:</li>
</ul>
<p><a href="http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret" target="_blank" rel="noopener">http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjg0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNDRjZjNlN2QtNjIwYi00M2FhLThjMWItMGZkMWVkZjE3YTMwIiwiY2xpZW50X2lkIjoiYzEifQ.N_Wd2DKyEpzGBmnvnDrP-vx4lSzIjiInQRNTsJtxMkM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiI0NGNmM2U3ZC02MjBiLTQzYWEtOGMxYi0wZmQxZWRmMTdhMzAiLCJleHAiOjE2MDY4ODA0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNmJiOWQ5YTAtYzhiYi00ZDk4LTgwMGYtMzY1NGY5ZjU1MDgxIiwiY2xpZW50X2lkIjoiYzEifQ.AL2ODdEhSKwuzrkYCvikY6UBrljFBroPtFiI9UT5xs4"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"44cf3e7d-620b-43aa-8c1b-0fd1edf17a30"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token"><a href="#2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token" class="headerlink" title="2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)"></a>2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)</h5><ul>
<li>申请token-POST</li>
</ul>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwic2NvcGUiOlsiUk9MRV9BRE1JTiIsIlJPTEVfVVNFUiIsIlJPTEVfQVBJIl0sImV4cCI6MTYwNjYyODU2MSwianRpIjoiZDBmODBjNTEtMWU5Ny00ODA5LThjNmEtYmEzYjYzNTZhMGE5IiwiY2xpZW50X2lkIjoiYzEifQ.I7KIvzQLYqlkzMQqw2hOPZ-ev8cV4ehoDU9LsP4qAAM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_ADMIN ROLE_USER ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"d0f80c51-1e97-4809-8c6a-ba3b6356a0a9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"><a href="#三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）" class="headerlink" title="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"></a>三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）</h2><h3 id="3-1-maven依赖（同鉴权服务）"><a href="#3-1-maven依赖（同鉴权服务）" class="headerlink" title="3.1 maven依赖（同鉴权服务）"></a>3.1 maven依赖（同鉴权服务）</h3><h3 id="3-2-配置类"><a href="#3-2-配置类" class="headerlink" title="3.2 配置类"></a>3.2 配置类</h3><h4 id="3-2-1-资源服务配置"><a href="#3-2-1-资源服务配置" class="headerlink" title="3.2.1 资源服务配置"></a>3.2.1 资源服务配置</h4><p>对于token的校验可以请求远程auth服务，也可以使用其他tokenStore进行自我校验，本次使用jwt方式进行自我校验，不请求远程资源服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源服务配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//符合对应的scope才能访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不用记录session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//资源id</span></span><br><span class="line">        resources.resourceId(RESOURCE_ID)</span><br><span class="line">                <span class="comment">//验证令牌服务(远程校验)</span></span><br><span class="line"><span class="comment">//                .tokenServices(tokenService())</span></span><br><span class="line">                <span class="comment">//本服务自身校验jwt令牌</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .stateless(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//权限不足处理类</span></span><br><span class="line">                .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程请求校验令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResourceServerTokenServices <span class="title">tokenService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="string">"http://localhost:9305/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="string">"c1"</span>);</span><br><span class="line">        services.setClientSecret(<span class="string">"secret"</span>);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-令牌存储策略（同鉴权服务2-2-2）"><a href="#3-2-2-令牌存储策略（同鉴权服务2-2-2）" class="headerlink" title="3.2.2 令牌存储策略（同鉴权服务2.2.2）"></a>3.2.2 令牌存储策略（同鉴权服务2.2.2）</h4><h4 id="3-2-3-security配置"><a href="#3-2-3-security配置" class="headerlink" title="3.2.3 security配置"></a>3.2.3 security配置</h4><p>将方法权限的控制交给security</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/order/r1"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"order/r2"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                <span class="comment">//所有/order/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/order/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/order/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、网关资源校验服务"><a href="#四、网关资源校验服务" class="headerlink" title="四、网关资源校验服务"></a>四、网关资源校验服务</h2><p>网关进行token校验，合法后对用户和权限信息封装，再下发下游服务，下游服务可以不再集成oauth2依赖，获取网关封装的权限信息，再次封装入security的上下文中，通过security完成权限校验</p>
<ul>
<li>网关对鉴权服务的认证请求放行</li>
<li>网关的资源服务会对用户的请求进行合法性校验</li>
<li>网关过滤器对token进行封装自定义用户信息json格式下发下游服务</li>
<li>下游服务过滤器对自定义用户权限信息封装的security安全上下文中</li>
<li>security接管下游服务的权限控制</li>
</ul>
<h3 id="4-1-maven依赖"><a href="#4-1-maven依赖" class="headerlink" title="4.1 maven依赖"></a>4.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网关依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-配置类"><a href="#4-2-配置类" class="headerlink" title="4.2 配置类"></a>4.2 配置类</h3><h4 id="4-2-1-资源服务配置"><a href="#4-2-1-资源服务配置" class="headerlink" title="4.2.1 资源服务配置"></a>4.2.1 资源服务配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oauth2资源服务配置类</span></span><br><span class="line"><span class="comment"> *      网关整合都有的微服务资源拦截</span></span><br><span class="line"><span class="comment"> *      此类用于配置每个微服务的资源配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源id(实际使用时，每个服务对应自己的资源id)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * auth微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//权限不足处理类</span></span><br><span class="line">                    .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                    <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                    .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                	<span class="comment">//需要放行，否则用户无法获取token</span></span><br><span class="line">                    .antMatchers(<span class="string">"/auth/**"</span>).permitAll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pay微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">"/api/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-令牌存储策略配置（同鉴权服务2-2-2）"><a href="#4-2-2-令牌存储策略配置（同鉴权服务2-2-2）" class="headerlink" title="4.2.2 令牌存储策略配置（同鉴权服务2.2.2）"></a>4.2.2 令牌存储策略配置（同鉴权服务2.2.2）</h3><h3 id="4-2-3-security配置"><a href="#4-2-3-security配置" class="headerlink" title="4.2.3 security配置"></a>4.2.3 security配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * security拦截配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-过滤器封装token用户及权限信息"><a href="#4-2-4-过滤器封装token用户及权限信息" class="headerlink" title="4.2.4 过滤器封装token用户及权限信息"></a>4.2.4 过滤器封装token用户及权限信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该过滤器进行权限信息解析，封装到header路由转发都下级微服务</span></span><br><span class="line"><span class="comment"> *      下级微服务将权限信息放入security上下文中，从而可以使用security的权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取令牌内容</span></span><br><span class="line">        RequestContext currentContext = RequestContext.getCurrentContext();</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是oauth认证信息，无法访问</span></span><br><span class="line">        <span class="keyword">if</span> (!(authentication <span class="keyword">instanceof</span> OAuth2Authentication)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication;</span><br><span class="line">        Authentication userAuthentication = oAuth2Authentication.getUserAuthentication();</span><br><span class="line">        Object principal = userAuthentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装明文token，转发给微服务，放入header，名称为json-token</span></span><br><span class="line">        List&lt;String&gt; authList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        userAuthentication.getAuthorities().forEach(auth-&gt; authList.add(auth.getAuthority()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        OAuth2Request oAuth2Request = oAuth2Authentication.getOAuth2Request();</span><br><span class="line">        Map&lt;String, String&gt; requestParameters = oAuth2Request.getRequestParameters();</span><br><span class="line">        Map&lt;String,Object&gt; jsonToken = <span class="keyword">new</span> HashMap&lt;&gt;(requestParameters);</span><br><span class="line">        jsonToken.put(<span class="string">"principal"</span>,principal);</span><br><span class="line">        jsonToken.put(<span class="string">"authorities"</span>,authList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String jsonTokenStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonTokenStr = objectMapper.writeValueAsString(jsonToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将身份信息和权限信息放在json中，加入header中，转发给下级微服务</span></span><br><span class="line">        currentContext.addZuulRequestHeader(<span class="string">"json-token"</span>, Base64.getEncoder().encodeToString(jsonTokenStr.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-自定义处理类"><a href="#4-2-5-自定义处理类" class="headerlink" title="4.2.5 自定义处理类"></a>4.2.5 自定义处理类</h3><h4 id="4-2-5-1-权限不足处理类"><a href="#4-2-5-1-权限不足处理类" class="headerlink" title="4.2.5.1 权限不足处理类"></a>4.2.5.1 权限不足处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权拒绝处理器，覆盖默认的OAuth2AccessDeniedHandler</span></span><br><span class="line"><span class="comment"> * 当权限不足时走此类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">extends</span> <span class="title">OAuth2AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 授权拒绝处理，使用R包装</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request       request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response      response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> authException authException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException authException)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"授权失败，禁止访问 &#123;&#125;"</span>, request.getRequestURI());</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		response.setStatus(HttpStatus.FORBIDDEN.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(<span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足，禁止访问"</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-2-各种AuthenticationException细化处理"><a href="#4-2-5-2-各种AuthenticationException细化处理" class="headerlink" title="4.2.5.2 各种AuthenticationException细化处理"></a>4.2.5.2 各种AuthenticationException细化处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以根据 AuthenticationException 不同细化异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceAuthExceptionEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResourceAuthExceptionEntryPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		Result result = <span class="keyword">new</span> Result();</span><br><span class="line">		result.setCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		<span class="keyword">if</span> (authException != <span class="keyword">null</span>) &#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			result.setData(authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(authException.getCause() == <span class="keyword">null</span>)&#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			logger.error(<span class="string">"no right to access or token invalid!,msg:&#123;&#125;"</span>,authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			String exceptionStr = authException.getCause().toString();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"unauthorized"</span>)) &#123;<span class="comment">//oauth2.0认证,用户不存在</span></span><br><span class="line">				result.setCode(<span class="number">11</span>);</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_grant"</span>)) &#123;<span class="comment">//oauth2.0认证,密码错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_token"</span>)) &#123;<span class="comment">//oauth2.0认证,token无效</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">		 	&#125;  <span class="keyword">else</span> &#123;<span class="comment">//其他错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_ERROR.getIndex());</span><br><span class="line"></span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_ERROR.getText(),authException);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、下游资源微服务"><a href="#五、下游资源微服务" class="headerlink" title="五、下游资源微服务"></a>五、下游资源微服务</h2><h3 id="5-1-maven依赖"><a href="#5-1-maven依赖" class="headerlink" title="5.1 maven依赖"></a>5.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2 配置"></a>5.2 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限不足处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来解决匿名用户访问无权限资源时的异常处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/pay/r1"</span>).hasAuthority(<span class="string">"p3"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"pay/r2"</span>).hasAuthority(<span class="string">"p1"</span>)</span><br><span class="line">                <span class="comment">//所有/pay/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/pay/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/pay/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">        http.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line">    http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-自定义异常处理"><a href="#5-3-自定义异常处理" class="headerlink" title="5.3 自定义异常处理"></a>5.3 自定义异常处理</h3><h4 id="5-3-1-权限不足"><a href="#5-3-1-权限不足" class="headerlink" title="5.3.1 权限不足"></a>5.3.1 权限不足</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 权限不足效验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足"</span>);</span><br><span class="line">        HttpResponseUtil.responseJsonWriter(httpServletResponse,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-匿名用户无权限处理"><a href="#5-3-2-匿名用户无权限处理" class="headerlink" title="5.3.2 匿名用户无权限处理"></a>5.3.2 匿名用户无权限处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationEntryPoint</span>  <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"超过登录有效期，请重新登录！"</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        HttpResponseUtil.responseJsonWriter(response, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-封装自定义权限到security安全上下文"><a href="#5-4-封装自定义权限到security安全上下文" class="headerlink" title="5.4 封装自定义权限到security安全上下文"></a>5.4 封装自定义权限到security安全上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将网关下发的权限信息放入security上下文中，交由security进行权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析header中的token</span></span><br><span class="line">        String token = httpServletRequest.getHeader(<span class="string">"json-token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(token))&#123;</span><br><span class="line">            String jsonTokenStr = <span class="keyword">new</span> String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8);</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            JsonNode jsonNode = objectMapper.readTree(jsonTokenStr);</span><br><span class="line">            String principal = jsonNode.get(<span class="string">"principal"</span>).asText();</span><br><span class="line">            UserPo userPo = <span class="keyword">new</span> UserPo();</span><br><span class="line">            userPo.setUsername(principal);</span><br><span class="line">            Iterator&lt;JsonNode&gt; authorities = jsonNode.get(<span class="string">"authorities"</span>).iterator();</span><br><span class="line">            List&lt;String&gt; authList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (authorities.hasNext())&#123;</span><br><span class="line">                authList.add(authorities.next().asText());</span><br><span class="line">            &#125;</span><br><span class="line">            String[] authArr = authList.toArray(<span class="keyword">new</span> String[authList.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装新的权限token</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken =</span><br><span class="line">                    <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userPo,<span class="keyword">null</span>, AuthorityUtils.createAuthorityList(authArr));</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(httpServletRequest));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入security上下文</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-自定义security权限注解校验"><a href="#5-5-自定义security权限注解校验" class="headerlink" title="5.5 自定义security权限注解校验"></a>5.5 自定义security权限注解校验</h3><h4 id="5-5-1-处理类"><a href="#5-5-1-处理类" class="headerlink" title="5.5.1 处理类"></a>5.5.1 处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限判断工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"pms"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断接口是否有xxx:xxx权限</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> permission 权限</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isEmpty(permission))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> (authentication == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		UserPo userPo = (UserPo) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">		<span class="keyword">return</span> authorities.stream()</span><br><span class="line">			.map(GrantedAuthority::getAuthority)</span><br><span class="line">			.filter(StringUtils::hasText)</span><br><span class="line">			.anyMatch(x -&gt; PatternMatchUtils.simpleMatch(permission, x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-注解"><a href="#5-5-2-注解" class="headerlink" title="5.5.2 注解"></a>5.5.2 注解</h4><p>方法上添加注解进行权限控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"@pms.hasPermission('p1')"</span> )</span><br></pre></td></tr></table></figure>

<h2 id="六、数据库表格"><a href="#六、数据库表格" class="headerlink" title="六、数据库表格"></a>六、数据库表格</h2><p><a href="https://www.cnblogs.com/zxy-come-on/p/14047791.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxy-come-on/p/14047791.html</a></p>
]]></content>
      <categories>
        <category>安全框架</category>
        <category>ouath2</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>oauth2 - cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq 架构介绍、集群部署</title>
    <url>/2021/07/31/rocketmq%20%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="rocketmq-架构"><a href="#rocketmq-架构" class="headerlink" title="rocketmq-架构"></a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md" target="_blank" rel="noopener">rocketmq-架构</a></h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/images/roketmq/rocketmq_architecture_1.png" alt=""></p>
<a id="more"></a>

<p>RocketMQ架构上主要分为四部分，如上图所示:</p>
<ul>
<li><p>Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
</li>
<li><p>Consumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p>
</li>
<li><p>NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。</p>
<p>主要包括两个功能：</p>
<ul>
<li><code>Broker管理</code>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；</li>
<li><code>路由信息管理</code>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。</li>
</ul>
<p>NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</p>
</li>
<li><p>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p>
<img src="/images/roketmq/rocketmq_architecture_2.png" style="zoom:80%;" />

<ol>
<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</li>
<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>
<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li>
</ol>
</li>
</ul>
<h3 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h3><ul>
<li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li>
<li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li>
<li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li>
<li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li>
</ul>
<h3 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h3><p><img src="/images/roketmq/rocketmq_architecture_3.png" alt=""></p>
<ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<h2 id="nameServer-集群模式"><a href="#nameServer-集群模式" class="headerlink" title="nameServer-集群模式"></a>nameServer-集群模式</h2><p>因为其无状态，节点之间无需通信，所以需要几个节点直接启动即可；broker和客户端维护连接的nameSever列表即可。</p>
<p><code>nohup sh mqnamesrv &amp;</code></p>
<h2 id="broker-集群模式"><a href="#broker-集群模式" class="headerlink" title="broker-集群模式"></a>broker-集群模式</h2><h3 id="多主无从-异步复制模式"><a href="#多主无从-异步复制模式" class="headerlink" title="多主无从-异步复制模式"></a>多主无从-异步复制模式</h3><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>以下是rocketmq默认提供的双主无从模式配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2m-noslave</span></span><br><span class="line"><span class="comment"># broker-a.properties </span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-b.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-trace.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-trace</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br></pre></td></tr></table></figure>



<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>对于多个NameServer的集群，Broker启动命令中<code>-n</code>后面的地址列表用分号隔开即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 在centos-1，启动第一个Master，例如NameServer为：192.168.1.18:9876;192.168.1.19:9876</span></span><br><span class="line">nohup sh mqbroker -n 192.168.1.18:9876 -c ../conf/2m-noslave/broker-a.properties &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 在centos-1，启动第二个Master，例如NameServer为：192.168.1.18:9876;192.168.1.19:9876</span></span><br><span class="line">nohup sh mqbroker -n 192.168.1.19:9876 -c ../conf/2m-noslave/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>

<p>使用客户端<code>producer</code>连接任一<code>nameSevre</code>发送10条消息到top01，可以看到top01对应的数据分散到两个<code>broker</code>各自的四个不同queue上</p>
<img src="/images/roketmq/多主模式消息发送.png" style="zoom: 80%;" />

<p>开启<code>consumer</code>连接任一<code>nameServer</code>，获取topic01数据存在的broker信息，连接对应的broker进行消息消费</p>
<h3 id="多主多从-异步复制模式"><a href="#多主多从-异步复制模式" class="headerlink" title="多主多从-异步复制模式"></a>多主多从-异步复制模式</h3><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>以下是rocketmq默认提供的双主双从模式配置，手动添加namesrvAddr配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2m-2s-async</span></span><br><span class="line"><span class="comment"># broker-a.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#凌晨4点删除过期文件</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.1.18:9876;192.168.1.19:9876;192.168.1.20:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-a-s.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.1.18:9876;192.168.1.19:9876;192.168.1.20:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-b.properties </span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.1.18:9876;192.168.1.19:9876;192.168.1.20:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-b-s.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">192.168.1.18:9876;192.168.1.19:9876;192.168.1.20:9876</span></span><br></pre></td></tr></table></figure>

<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">ROCKETMQ_HOME=/usr/<span class="built_in">local</span>/rocketmq-4.8.0</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>



<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>对于多个NameServer的集群，Broker启动命令中<code>-n</code>后面的地址列表用分号隔开即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 在centos-1，启动第一个Master</span></span><br><span class="line">nohup sh mqbroker -c <span class="variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 在centos-2，启动第二个Maste</span></span><br><span class="line">nohup sh mqbroker -c <span class="variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 在centos-3，启动第一个Slave</span></span><br><span class="line">nohup sh mqbroker -c <span class="variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker<span class="_">-a</span>-s.properties &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 在centos-4，启动第二个Slave</span></span><br><span class="line">nohup sh mqbroker -c <span class="variable">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>



<img src="/images/roketmq/双主双从.png" style="zoom:80%;" />

<p>使用客户端<code>producer</code>连接任一<code>nameSevre</code>发送10条消息到top02，可以看到top02对应的数据分散到两个<code>broker</code>各自的四个不同queue上</p>
<img src="/images/roketmq/多主多从模式消息发送.png" style="zoom:80%;" />

<h3 id="多主多从-同步复制模式"><a href="#多主多从-同步复制模式" class="headerlink" title="多主多从-同步复制模式"></a>多主多从-同步复制模式</h3><ul>
<li>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2m-2s-sync</span></span><br><span class="line"><span class="comment"># broker-a.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-a-s.properties </span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-b.properties  </span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker-b-s.properties</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br></pre></td></tr></table></figure>



<h3 id="broker配置解释"><a href="#broker配置解释" class="headerlink" title="broker配置解释"></a>broker配置解释</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#网卡IP</span></span><br><span class="line"><span class="attr">brokerIP1</span>=<span class="string">192.168.1.131</span></span><br><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#nameServer地址 分号';'分割</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/home/local/rocketMQ/broker-a/store</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/home/local/rocketMQ/broker-a/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/home/local/rocketMQ/broker-a/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/home/local/rocketMQ/broker-a/store/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/home/local/rocketMQ/broker-a/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/home/local/rocketMQ/broker-a/store/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">SYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开端口 nameServer端口:9876、broker端口:10911</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;9876&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;10911&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;9876&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>spring security 认证</title>
    <url>/2021/02/08/spring%20security%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h3 id="认证流程图"><a href="#认证流程图" class="headerlink" title="认证流程图"></a>认证流程图</h3><p><img src="/images/security/%E8%AE%A4%E8%AF%81/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<a id="more"></a>

<h3 id="认证解析"><a href="#认证解析" class="headerlink" title="认证解析"></a>认证解析</h3><h4 id="用户发起认证"><a href="#用户发起认证" class="headerlink" title="用户发起认证"></a>用户发起认证</h4><p>​        经过<code>UsernamePasswordAuthenticationFilter</code>，调用其父类<code>AbstractAuthenticationProcessingFilter</code>的doFilter()方法</p>
<p>​        调用<code>UsernamePasswordAuthenticationFilter</code>的attemptAuthentication()方法尝试进行认证</p>
<p>​        将新构建的未认证的token（Authentication）交给AuthenticationManager接口的子类进行认证</p>
<p><img src="/images/security/%E8%AE%A4%E8%AF%81/1-attemptAuthentication.jpg" alt=""></p>
<h4 id="认证管理器处理认证"><a href="#认证管理器处理认证" class="headerlink" title="认证管理器处理认证"></a>认证管理器处理认证</h4><p>​    <code>AuthenticationManager</code>本身不包含任何的认证逻辑，其核心是管理所有的<code>AuthenticationProvider</code>，本质上认证是由<code>AuthenticationProvider</code>来实现认证。</p>
<p>​    用户认证调用了<code>AuthenticationManager</code>的authenticate()方法，由此进入 AbstractUserDetailsAuthenticationProvider（AuthenticationManager的实现类）的authenticate()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.根据自定义方式获取数据库用户信息</span><br><span class="line">	1.根据用户名从缓存寻找用户信息</span><br><span class="line">	2.没有缓存，调用子类DaoAuthenticationProvider.retrieveUser()-&gt;调用userDetailService的loadUserByUsername()走我们自定义的查询用户方法返回用户信息</span><br><span class="line">	</span><br><span class="line">b.校验用户状态(前置校验、额外校验、后置校验)</span><br><span class="line">	3.preAuthenticationChecks.check(user)对账号状态（isAccountNonLocked、isEnabled、isAccountNonExpired）进行校验	</span><br><span class="line">	4.additionalAuthenticationChecks(user,authenticationToken) 对其他认证信息进行检查（密码校验）</span><br><span class="line">	5.postAuthenticationChecks.check(user)对账号状态（isCredentialsNonExpired）进行校验</span><br><span class="line">	6.存在用户缓存信息的情况下需要更新缓存</span><br><span class="line">	</span><br><span class="line">c.生成用户认证信息authentication</span><br><span class="line">	7.createSuccessAuthentication()返回Authentication</span><br></pre></td></tr></table></figure>

<p>​        a.根据自定义方式获取数据库用户信息，如下图：</p>
<p><img src="/images/security/%E8%AE%A4%E8%AF%81/4-authenticate.jpg" alt=""></p>
<p>​        b.校验用户状态(前置校验、额外校验、后置校验)</p>
<p><img src="/images/security/%E8%AE%A4%E8%AF%81/5-authencation.jpg" alt=""></p>
<p>c.生成用户认证信息authentication</p>
<p><img src="/images/security/%E8%AE%A4%E8%AF%81/6-authencation.jpg" alt=""></p>
<h4 id="认证成功、失败handler"><a href="#认证成功、失败handler" class="headerlink" title="认证成功、失败handler"></a>认证成功、失败handler</h4><p>最后认证信息会传回<code>UsernamePasswordAuthenticationFilter</code>，并在其父类<code>AbstractAuthenticationProcessingFilter</code>的<code>doFilter()</code>中，根据认证成功设置SecurityContextHolder安全上下文用户信息，失败清除上下文用户信息，并设置调用相应的<code>handler</code>。</p>
<p><img src="/images/security/%E8%AE%A4%E8%AF%81/7-handler.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.自定义登录过滤器</span><br><span class="line">​	不同的登录形式我们可以继承AbstractAuthenticationProcessingFilter定义自己的登录过滤器（默认UsernamePasswordAuthenticationFilter）</span><br><span class="line">​	根据指定的url匹配到该过滤器，目的是生成自定义继承AbstractAuthenticationToken的子类token(默认UsernamePasswordAuthenticationToken)</span><br><span class="line"></span><br><span class="line">2.认证管理器</span><br><span class="line">​	调用环境指定的认证管理器对未认真的Authentication进行认证处理（默认ProviderManager）</span><br><span class="line"></span><br><span class="line">3.覆写provider、abstractAuthenticationToken、userDetailServicec</span><br><span class="line">​	实现AuthenticationProvider自定义自己的provider（默认DaoAuthenticationProvider），认证管理器根据我们重写的public boolean supports(Class&lt;?&gt; authentication)方法对当前环境的authentication进行判断，选取合适我的provider进行认证处理</span><br><span class="line">​	provider会调用自定义的userDerailService查询用户信息进行校验</span><br><span class="line"></span><br><span class="line">4.覆写成功、失败的handler</span><br><span class="line">​	认证期间，失败，会抛出对应的异常；成功，则生成已认证的Authentication返回</span><br><span class="line">​	覆写AuthenticationFailureHandler、AuthenticationSuccessHandler可以在认证成功或失败时进行自定义处理</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 鉴权</title>
    <url>/2021/02/08/spring%20security%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>FilterSecurityInterceptor</code>是过滤链的最后一环，一个请求完成了认证，且没有抛出异常之后就会到达<code>FilterSecurityInterceptor</code>所负责的鉴权部分，也就是说鉴权的入口就在<code>FilterSecurityInterceptor</code>。</p>
<p>​        它实现了<code>Filter</code>接口，我们一般直接继承这个过滤器或者继承他的父类，目的是为了注入自定义的授权管理器<code>AccessDecisionManager</code>、和权限元数据<code>FilterInvocationSecurityMetadataSource</code></p>
<p>​        它是在<code>WebSecurityConfigurerAdapter</code>的<code>init()</code>里配置的。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="进入FilterSecurityInterceptor的doFilter-、invoke-方法"><a href="#进入FilterSecurityInterceptor的doFilter-、invoke-方法" class="headerlink" title="进入FilterSecurityInterceptor的doFilter()、invoke()方法"></a>进入<code>FilterSecurityInterceptor</code>的doFilter()、invoke()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个FilterInvocation对象，这个FilterInvocation对象你可以当作它封装了request，它的主要工作就是拿请求里面的信息，比如请求的URI。</span></span><br><span class="line">		FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">		<span class="comment">//调用了自身的invoke方法，并将FilterInvocation对象传入。</span></span><br><span class="line">		invoke(fi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((fi.getRequest() != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">			<span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line">			<span class="comment">// once-per-request handling, so don't re-do security checking</span></span><br><span class="line">			fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">			<span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">				fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//根据资源权限配置来判断当前请求是否有权限访问对应的资源。</span></span><br><span class="line">			<span class="comment">//如果不能访问，则抛出相应的异常</span></span><br><span class="line">			InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//访问相关资源，通过SpringMvc的核心组件DispatcherServlet进行访问</span></span><br><span class="line">				fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用父类AbstractSecurityInterceptor的beforeInvocation-方法"><a href="#调用父类AbstractSecurityInterceptor的beforeInvocation-方法" class="headerlink" title="调用父类AbstractSecurityInterceptor的beforeInvocation()方法"></a>调用父类<code>AbstractSecurityInterceptor</code>的beforeInvocation()方法</h4><p>​                1、获取当前资源权限（我们自己定义的规则权限）</p>
<p>​                2、获取认证的authentication身份信息</p>
<p>​                3、调用决策器尝试进行认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationEventPublisherAware</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">					<span class="string">"Security invocation attempted for object "</span></span><br><span class="line">							+ object.getClass().getName()</span><br><span class="line">							+ <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">							+ getSecureObjectClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用子类的FilterInvocationSecurityMetadataSource.getAttributes(object)获取当前资源所需权限</span></span><br><span class="line">		Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">				.getAttributes(object);</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果Authentication.isAuthenticated()返回false或属性alwaysReauthenticate已设置为true，则检查当前身份验证令牌并将其传递给AuthenticationManager进行认证</span></span><br><span class="line">		<span class="comment">//返回认证的authentication身份信息，并放入安全上下文</span></span><br><span class="line">		Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Attempt authorization</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用访问决策器进行决策，尝试进行鉴权</span></span><br><span class="line">			<span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">			publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">					accessDeniedException));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>AccessDecisionManager</code>访问决策管理器是一个接口，它声明了三个方法，除了第一个鉴权方法以外，还有两个是辅助性的方法，其作用都是甄别 decide方法中参数的有效性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 解决传递参数的访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">            InsufficientAuthenticationException</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//指示此AccessDecisionManager是否能够处理通过传递的ConfigAttribute提出的授权请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//指示AccessDecisionManager实现是否能够为指示的安全对象类型提供访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/security/%E9%89%B4%E6%9D%83/%E5%86%B3%E7%AD%96%E5%99%A8.jpg" alt=""></p>
<p>​    从图中我们可以看到它主要有三个实现类，分别代表了三种不同的鉴权逻辑：</p>
<ul>
<li>AffirmativeBased：一票通过，只要有一票通过就算通过，默认是它。</li>
<li>UnanimousBased：一票反对，只要有一票反对就不能通过。</li>
<li>ConsensusBased：少数票服从多数票。</li>
</ul>
<p><code>这三个实现类，其实还不是真正判断请求能不能通过的类，真正判断请求是否通过的是投票器，然后实现类把投票器的结果综合起来来决定到底能不能通过。</code></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>以<code>AffirmativeBased</code>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="keyword">extends</span> <span class="title">AbstractAccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AffirmativeBased</span><span class="params">(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(decisionVoters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException </span>&#123;</span><br><span class="line">		<span class="comment">//拒绝数量</span></span><br><span class="line">		<span class="keyword">int</span> deny = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//遍历从构造传入的决策投票器集合</span></span><br><span class="line">		<span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">			<span class="comment">//调用该投票器的投票逻辑方法进行判断（AffirmativeBased默认传入WebExpressionVoter）</span></span><br><span class="line">			<span class="keyword">int</span> result = voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (result) &#123;</span><br><span class="line">				<span class="comment">//赞成</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//拒绝</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">                    deny++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拒绝数量大于0，抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(messages.getMessage(</span><br><span class="line">					<span class="string">"AbstractAccessDecisionManager.accessDenied"</span>, <span class="string">"Access is denied"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果全部都弃权，进入此方法，判断此决策器是否允许全部弃权，不允许则抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">		checkAllowIfAllAbstainDecisions();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当走完决策流程没有抛出<code>AccessDeniedException</code>异常，则权限校验通过</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>通过实现<code>AccessDeniedHandler</code>接口的handle()可以对<code>AccessDeniedException</code>异常抛出的权限被拒信息作出友好提示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line"><span class="comment">//WebSecurityConfigurerAdapter配置</span></span><br><span class="line">http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br></pre></td></tr></table></figure>



<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/images/security/%E9%89%B4%E6%9D%83/%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt=""></p>
<h2 id="自定义鉴权"><a href="#自定义鉴权" class="headerlink" title="自定义鉴权"></a>自定义鉴权</h2><h3 id="方式一-访问决策管理器实现鉴权"><a href="#方式一-访问决策管理器实现鉴权" class="headerlink" title="方式一 访问决策管理器实现鉴权"></a>方式一 访问决策管理器实现鉴权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionManager访问决策管理器实现类，直接在决策器decide()方法实现鉴权逻辑，空参构造，不注入投票器</span><br><span class="line">2、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">3、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​        总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>走自定义的鉴权规则</p>
<h3 id="方式二-投票器实现鉴权逻辑"><a href="#方式二-投票器实现鉴权逻辑" class="headerlink" title="方式二 投票器实现鉴权逻辑"></a>方式二 投票器实现鉴权逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionVoter&lt;FilterInvocation&gt;投票器实现类，vote()方法中实现鉴权逻辑</span><br><span class="line">2、自定义AccessDecisionManager访问决策管理器实现类，有参构造，注入自定义投票器</span><br><span class="line">3、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">4、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​    总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>调用<code>自定义投票器</code>走自定义的投票鉴权逻辑；这种方式较完整的仿照security流程</p>
<h3 id="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"><a href="#以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态" class="headerlink" title="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"></a>以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 UsernamePasswordAuthenticationFilter之前添加自定义OncePerRequestFilter过滤器实现类，目的是检查token状态是否正常(过期、系统已清除等)</span></span><br><span class="line">http.addFilterBefore(myJwtAuthenticationTokenRequestFilter,UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 过滤器链</title>
    <url>/2021/02/08/spring%20security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/</url>
    <content><![CDATA[<h3 id="过滤器链介绍"><a href="#过滤器链介绍" class="headerlink" title="过滤器链介绍"></a>过滤器链介绍</h3><p>spring security采用的是责任链的设计模式，它有一条很长的过滤器链。</p>
<p>客户端向服务端发送请求，然后应用根据请求的 <strong>URI</strong> 的路径来确定该请求的过滤器链（<strong>Filter</strong>）以及最终的具体 <strong>Servlet</strong> 控制器（<strong>Controller</strong>）</p>
<p><img src="/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E5%9F%BA%E7%A1%80%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<p>从上图我们可以看出 <strong>Spring Security</strong> 以一个单 <strong>Filter（FilterChainProxy）</strong> 存在于整个过滤器链中，而这个 <code>FilterChainProxy</code> 实际内部代理着众多的 <strong>Spring Security Filter（过滤器链）</strong> ，过滤器链的每个元素都是一组URL对应一组过滤器</p>
<h3 id="过滤器链形成"><a href="#过滤器链形成" class="headerlink" title="过滤器链形成"></a>过滤器链形成</h3><p>首先 众多的<strong>Filter</strong> 按照一定的顺序被 <code>SecurityBuilder</code> 的实现来组装为 <code>SecurityFilterChain</code> ，然后通过 <code>WebSecurity</code> 注入到 <code>FilterChainProxy</code> 中去，接着 <code>FilterChainProxy</code> 又在 <code>WebSecurityConfiguration</code> 中以 <code>springSecurityFilterChain</code> 的名称注册为 <strong>Spring Bean</strong> 。实际上还有一个隐藏层 <code>DelegatingFilterProxy</code> 代理了 <code>springSecurityFilterChain</code> 注入到最后整个 <strong>Servlet</strong> 过滤器链中，如下图</p>
<p><img src="/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<p><strong>Spring Security</strong> 允许有多条过滤器链并行，<strong>Spring Security</strong> 的 <code>FilterChainProxy</code> 可以代理多条过滤器链并根据不同的 <strong>URI</strong> 匹配策略进行分发。但是每个请求每次只能被分发到一条过滤器链，实际每条过滤链就是一个 <code>SecurityFilterChain</code>。如下图所示：</p>
<p><img src="/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/url%E5%8C%B9%E9%85%8D%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<h3 id="过滤器链中的过滤器"><a href="#过滤器链中的过滤器" class="headerlink" title="过滤器链中的过滤器"></a>过滤器链中的过滤器</h3><p><img src="/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%9B%BE.jpg" alt=""></p>
<p>过滤器说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1） WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</span><br><span class="line"></span><br><span class="line">（2） SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder 中，然后在该次请求处理完成之后，将SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder 中的信息清除，例如在 Session 中维护一个用户的安全信息就是这个过滤器处理的。</span><br><span class="line"></span><br><span class="line">（3） HeaderWriterFilter：用于将头信息加入响应中。</span><br><span class="line"></span><br><span class="line">（4） CsrfFilter：用于处理跨站请求伪造。</span><br><span class="line"></span><br><span class="line">（5）LogoutFilter：用于处理退出登录。</span><br><span class="line"></span><br><span class="line">（6）UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 &#x2F;login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。</span><br><span class="line"></span><br><span class="line">（7）DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</span><br><span class="line"></span><br><span class="line">（8）BasicAuthenticationFilter：检测和处理 http basic 认证。</span><br><span class="line"></span><br><span class="line">（9）RequestCacheAwareFilter：用来处理请求的缓存。</span><br><span class="line"></span><br><span class="line">（10）SecurityContextHolderAwareRequestFilter：主要是包装请求对象 request。 </span><br><span class="line"></span><br><span class="line">（11）AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在Authentication 对象，如果不存在为其提供一个匿名 Authentication。 </span><br><span class="line"></span><br><span class="line">（12）SessionManagementFilter：管理 session 的过滤器</span><br><span class="line"></span><br><span class="line">（13）ExceptionTranslationFilter：处理 AccessDeniedException 和AuthenticationException 异常。</span><br><span class="line"></span><br><span class="line">（14）FilterSecurityInterceptor：可以看做过滤器链的出口。</span><br><span class="line"></span><br><span class="line">（15）RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP HTTP HTTPS</title>
    <url>/2021/07/31/tcp%20http%20https/</url>
    <content><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><img src="/images/https/TCP三次握手四次挥手.jpg" style="zoom:80%;" />

<a id="more"></a>

<h3 id="TCP-建立连接（三次握手）"><a href="#TCP-建立连接（三次握手）" class="headerlink" title="TCP-建立连接（三次握手）"></a>TCP-建立连接（三次握手）</h3><img src="/images/https/三次握手.gif" style="zoom:80%;" />

<ul>
<li><p>client端发送一个SYN包告诉server端自己的初始序列号是X，进入SYN_SENT状态</p>
</li>
<li><p>server端收到SYN，返回客户端ACK（X+1）和自己的SYN seq=Y，进入SYN_RCVD状态</p>
</li>
<li><p>client端收到后回复server端ACK（Y+1），此时双方进入ESTABLISHED（TCP连接成功）状态，完成三次握手</p>
<blockquote>
<p>请求-确认-建立连接</p>
</blockquote>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="为什么需要三次握手才能建立连接呢？"><a href="#为什么需要三次握手才能建立连接呢？" class="headerlink" title="为什么需要三次握手才能建立连接呢？"></a>为什么需要三次握手才能建立连接呢？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</span><br><span class="line">第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</span><br><span class="line">第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</span><br><span class="line"></span><br><span class="line">所以三次握手就能确认双发收发功能都正常，缺一不可。</span><br></pre></td></tr></table></figure>

<h4 id="为什么要传送ACK呢？"><a href="#为什么要传送ACK呢？" class="headerlink" title="为什么要传送ACK呢？"></a>为什么要传送ACK呢？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为确保是同一个客户端的请求，建立可靠的TCP连接</span><br></pre></td></tr></table></figure>

<h4 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h4><p>​        如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>​        如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接</p>
<h3 id="TCP-释放连接（四次挥手）"><a href="#TCP-释放连接（四次挥手）" class="headerlink" title="TCP-释放连接（四次挥手）"></a>TCP-释放连接（四次挥手）</h3><img src="/images/https/四次挥手.gif" style="zoom:80%;" />

<ul>
<li>client端发送FIN包告诉server端即将断开连接，<code>client端</code>进入<code>FIN-WAIT-1（终止等待1）</code>状态</li>
<li>server端收到后回复client端ACK，此时<code>server端</code>进入<code>CLOSE-WAIT（关闭等待）</code>状态，客户端收到服务器的确认请求后，此时<code>client端</code>就进入<code>FIN-WAIT-2（终止等待2）</code>状态</li>
<li>server端没有数据需要发送时，发送FIN包给client端，<code>server端</code>进入了<code>LAST-ACK（最后确认）</code>状态</li>
<li>client端收到后回复server端ACK，此时<code>client端</code>进入了<code>TIME-WAIT（时间等待）</code>状态，<code>server端</code>收到ACK进入<code>CLOSED</code>状态，注意此时<code>client端</code>的TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</li>
</ul>
<blockquote>
<p>客户端请求断开-服务端确认</p>
<p>服务端请求断开-客户端确认</p>
</blockquote>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><p>​        MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>​        第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>​        第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>​        建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>​        而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<blockquote>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<hr>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP是建立TCP协议的。</span><br><span class="line">TCP是OSI七层协议中的第四层传输层协议，定义的是数据传输和连接方式的规范。</span><br><span class="line">HTTP是第七层的应用层协议，定义的是传输数据的内容的规范。</span><br><span class="line">HTTP协议中的数据是利用TCP协议传输的。</span><br></pre></td></tr></table></figure>



<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的<code>内容</code>都经过<code>对称加密</code>，但对称加密的<code>密钥</code>用服务器方的<code>证书</code>进行了<code>非对称加密</code>。</p>
<p><img src="/images/https/https.png" alt=""></p>
<ul>
<li><p>第一步：客户端告诉服务端其所能支持的<code>加密算法</code> + 客户端生成的随机数<code>client-random</code></p>
</li>
<li><p>第二步</p>
<ul>
<li>服务端从客户端传送的<code>加密算法</code>中选取一种，并返回告诉客户端 </li>
<li>服务端随机数<code>server-random</code></li>
<li><code>证书</code>（密文 + 签名 + 签名算法 ） =&gt;  CA的私钥（server.公钥） = 密文；算法hash（server.公钥） = 签名</li>
</ul>
</li>
<li><p>第三步</p>
<ul>
<li>客户端使用CA的公钥解密得到<code>server.公钥</code>，并根据协商好的算法对该公钥计算后与<code>签名比对</code>，成功则证明请求没有被伪造；</li>
<li>使用<code>server.公钥</code>对新生成的随机数<code>premaster-random</code>进行<code>加密</code></li>
</ul>
</li>
<li><p>第四步</p>
<ul>
<li>服务端使用<code>server.私钥</code>对客户端传送的密文进行解密，得到<code>permaster-random</code>，将三个随机数通过一定算法生成<code>对称加密的key</code>；</li>
<li>之后的http传输协议中，双方使用此key进行对称加密</li>
</ul>
</li>
</ul>
<p>为什么使用CA机构签发的证书？</p>
<p>如果不使用CA机构签发的证书，单纯由服务端使用私钥签发公钥；那么中间代理商可能获取服务端发出的公钥，再自己伪造私钥签发假公钥转发给客户端；客户端获取代理商分发的假公钥进行加密，被代理商截取之后使用自己的私钥解密，窥探到数据；代理商再替代客户端向服务端发送虚假数据。</p>
<img src="/images/https/没有CA的交互.png" style="zoom:80%;" />

<p>如果使用CA进行加签，当客户端使用公有的CA公钥对证书进行解密时，因为代理商无法拿到CA的私钥，只能使用CA公钥加密的数据，而CA公钥加密的数据在客户端无法使用CA公钥正确解密；所以当客户端使用得到的server.公钥，根据约定的加密算法计算的值与签名不对应，则证明请求被伪造。</p>
<p>合法的CA机构会和操作系统打交道，将CA公钥内置在操作系统中，浏览器获得证书后通过CA.公钥进行解密证书获得Server.公钥，这个步骤代理服务器没有CA.私钥，它没办法伪造一个不合格的证书。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper 实现配置中心、分布式锁</title>
    <url>/2021/07/31/zookeeper%20%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="客户端连接工具类"><a href="#客户端连接工具类" class="headerlink" title="客户端连接工具类"></a>客户端连接工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ZooKeeper zk;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk服务端地址，/可以添加上级节点目录，之后客户端的所有操作都基于此目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String connectAddr = <span class="string">"192.168.142.121:2181,192.168.142.122:2181,192.168.142.123:2181,192.168.142.124:2181/myLock"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultWatch watch = <span class="keyword">new</span> DefaultWatch();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeper <span class="title">getZk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zk == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ZooKeeper<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(zk == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        zk = <span class="keyword">new</span> ZooKeeper(connectAddr, <span class="number">3000</span>, watch);</span><br><span class="line">                        watch.setCountDownLatch(countDownLatch);</span><br><span class="line">                        countDownLatch.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><h3 id="监控回调类"><a href="#监控回调类" class="headerlink" title="监控回调类"></a>监控回调类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控回调类</span></span><br><span class="line"><span class="comment"> *  实现Watcher，process(WatchedEvent watchedEvent)方法可以获取节点的事件状态进行监控，例如节点的创建、改变、删除</span></span><br><span class="line"><span class="comment"> *  实现AsyncCallback.StatCallback的processResult方法可以对操作节点的状态进行监控,判断是否存在的方法触发</span></span><br><span class="line"><span class="comment"> *  实现AsyncCallback.DataCallback的processResult方法可以监控节点，获取节点修改数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchCallBack</span> <span class="keyword">implements</span> <span class="title">Watcher</span>, <span class="title">AsyncCallback</span>.<span class="title">StatCallback</span>, <span class="title">AsyncCallback</span>.<span class="title">DataCallback</span>  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放节点名和节点内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MyContent myContent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZk</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zk = zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyContent <span class="title">getMyContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyConfig</span><span class="params">(MyContent myContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myContent = myContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断节点是否存在</span></span><br><span class="line">        <span class="comment">//Watcher</span></span><br><span class="line">        <span class="comment">//StatCallback</span></span><br><span class="line">        zk.exists(myContent.getPathName(),<span class="keyword">this</span>,<span class="keyword">this</span>,<span class="string">"ctx-exists"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AsyncCallback.DataCallback</span></span><br><span class="line"><span class="comment">     * 数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="keyword">null</span>)&#123;</span><br><span class="line">            myContent.setContent(<span class="keyword">new</span> String(data));</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AsyncCallback.StatCallback</span></span><br><span class="line"><span class="comment">     * 状态回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">            zk.getData(myContent.getPathName(),<span class="keyword">this</span>,<span class="keyword">this</span>,<span class="string">"ctx-StatCallback"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Watcher</span></span><br><span class="line"><span class="comment">     * 节点事件回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        Event.EventType type = watchedEvent.getType();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> None:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                <span class="comment">//没有创建</span></span><br><span class="line">                zk.getData(myContent.getPathName(),<span class="keyword">this</span>,<span class="keyword">this</span>,<span class="string">"ctx-Watcher-nodeCreate"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                myContent.setContent(<span class="string">""</span>);</span><br><span class="line">                countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                <span class="comment">//节点数据改变</span></span><br><span class="line">                zk.getData(myContent.getPathName(),<span class="keyword">this</span>,<span class="keyword">this</span>,<span class="string">"ctx-Watcher-nodeChanged"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DataWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ChildWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PersistentWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        zk = ZkUtil.getZk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试使用zk实现发现配置功能</span></span><br><span class="line"><span class="comment">     *  当node节点被修改时，客户端客户监控更新本地配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  当获取不到数据时调用await()</span></span><br><span class="line"><span class="comment">     * 	调用zk的exists方法，使用Watcher和AsyncCallback.StatCallback两种监控</span></span><br><span class="line"><span class="comment">     * 		Watcher</span></span><br><span class="line"><span class="comment">     * 			=&gt;监控节点是否被删除、创建、改变</span></span><br><span class="line"><span class="comment">     * 						=&gt; 删除</span></span><br><span class="line"><span class="comment">     * 							=&gt; myConfig.setContent("")、重新创建闭锁对象，让客户端进入等待中</span></span><br><span class="line"><span class="comment">     * 						=&gt; 创建、改变</span></span><br><span class="line"><span class="comment">     * 							=&gt; 调用getData方法，使用watch和AsyncCallback.DataCallback</span></span><br><span class="line"><span class="comment">     * 								=&gt; watch继续监控节点变化</span></span><br><span class="line"><span class="comment">     * 								=&gt; DataCallback,修改数据，放行闭锁</span></span><br><span class="line"><span class="comment">     * 		AsyncCallback.StatCallback</span></span><br><span class="line"><span class="comment">     * 			=&gt; 调用getData方法，使用watch和AsyncCallback.DataCallback</span></span><br><span class="line"><span class="comment">     * 					=&gt; watch继续监控节点变化</span></span><br><span class="line"><span class="comment">     * 					=&gt; DataCallback,修改数据，放行闭锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 	调用countDownLatch.await()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WatchCallBack watchCallBack = <span class="keyword">new</span> WatchCallBack();</span><br><span class="line">        watchCallBack.setZk(zk);</span><br><span class="line">        <span class="comment">//用于存放节点名和节点内容</span></span><br><span class="line">        MyContent myConfig = <span class="keyword">new</span> MyContent();</span><br><span class="line">        myConfig.setPathName(<span class="string">"/xxx"</span>);</span><br><span class="line"></span><br><span class="line">        watchCallBack.setMyConfig(myConfig);</span><br><span class="line">        watchCallBack.await();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//内容为空</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(myConfig.getContent()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"no data"</span>);</span><br><span class="line">                watchCallBack.await();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(myConfig.getContent());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//控制获取节点内容输出的速度，方便查看</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="监控回调类-1"><a href="#监控回调类-1" class="headerlink" title="监控回调类"></a>监控回调类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tryLock()</span></span><br><span class="line"><span class="comment"> *   zk.create()</span></span><br><span class="line"><span class="comment"> *   countDownLatch.await()</span></span><br><span class="line"><span class="comment"> *      AsyncCallback.StringCallback.processResult</span></span><br><span class="line"><span class="comment"> *           zk.getChildren（）</span></span><br><span class="line"><span class="comment"> *              AsyncCallback.Children2Callback.processResult</span></span><br><span class="line"><span class="comment"> *                  zk.setData()和countDown()</span></span><br><span class="line"><span class="comment"> *                  zk.exists()</span></span><br><span class="line"><span class="comment"> *                      watch.process()</span></span><br><span class="line"><span class="comment"> *                          当nodeDelete时zk.getChildren()重复上面步骤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchCallback</span> <span class="keyword">implements</span> <span class="title">Watcher</span>, <span class="title">AsyncCallback</span>.<span class="title">StringCallback</span> , <span class="title">AsyncCallback</span>.<span class="title">Children2Callback</span>, <span class="title">AsyncCallback</span>.<span class="title">StatCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> MyContent myContent;</span><br><span class="line">    <span class="keyword">private</span> String curPathName;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZk</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zk = zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyContent <span class="title">getMyContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyContent</span><span class="params">(MyContent myContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myContent = myContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"lock----&gt;"</span> + myContent.getThreadName());</span><br><span class="line">            <span class="comment">//TODO 此处可增加节点内容数据判断，实现可重入操作</span></span><br><span class="line">            <span class="comment">//当前线程创建临时序列节点</span></span><br><span class="line">            zk.create(myContent.getPathName(),myContent.getContent().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL,<span class="keyword">this</span>,<span class="string">"ctx"</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//删除当前节点，让其他监控该节点的线程执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"unlock----&gt;"</span> + myContent.getThreadName());</span><br><span class="line">            zk.delete(curPathName,-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点发生事件时，通过此方法回调当前节点</span></span><br><span class="line"><span class="comment">     * watch监控回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        Event.EventType type = watchedEvent.getType();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> None:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                <span class="comment">//前一个节点被删除，获取父节点下的所有子节点 =&gt; Children2Callback中判断当前节点是否为第一个节点</span></span><br><span class="line">                <span class="comment">//非第一个节点挂了，当前节点也能收到回调，获取父节点下的所有子节点，重新监控当前节点前面的节点</span></span><br><span class="line">                zk.getChildren(<span class="string">"/"</span>,<span class="keyword">false</span>,<span class="keyword">this</span>,<span class="string">"ctx"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DataWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ChildWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PersistentWatchRemoved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AsyncCallback.StringCallback</span></span><br><span class="line"><span class="comment">     * create操作的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String pathName, Object ctx, String nodeName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建的节点名称不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isBlank(nodeName))&#123;</span><br><span class="line">            <span class="comment">//获取根节点下的子节点集合，并在Children2Callback回调中操作</span></span><br><span class="line">            <span class="comment">//当前操作是为了操作子节点，不需要监控当前根节点，所以watch设置为false</span></span><br><span class="line">            System.out.println(myContent.getThreadName() + <span class="string">"  创建 "</span> + nodeName);</span><br><span class="line">            curPathName = nodeName;</span><br><span class="line">            zk.getChildren(<span class="string">"/"</span>,<span class="keyword">false</span>,<span class="keyword">this</span>,<span class="string">"ctx"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  AsyncCallback.Children2Callback</span></span><br><span class="line"><span class="comment">     *  getChildren操作的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String pathName, Object ctx, List&lt;String&gt; childrenList, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取的节点列表是乱序的，需要将其进行排序操作</span></span><br><span class="line">        Collections.sort(childrenList);</span><br><span class="line">        <span class="comment">//截取pathName“/”后面的数据</span></span><br><span class="line">        <span class="comment">//判断当前节点是否为最靠前的节点，是的话才允许往后进行操作</span></span><br><span class="line">        <span class="keyword">int</span> index = childrenList.indexOf(curPathName.substring(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//将抢到锁的线程名称放入节点中，在创建节点的地方判断放行，实现可重入机制</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(myContent.getThreadName() + <span class="string">"---have lock "</span> + curPathName);</span><br><span class="line">                zk.setData(<span class="string">"/"</span>,myContent.getThreadName().getBytes(),-<span class="number">1</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no first"</span>);</span><br><span class="line">            <span class="comment">//非第一个节点时，判断当前节点的前一节点是否存在,当前节点通过watch监控</span></span><br><span class="line">            zk.exists(<span class="string">"/"</span> + childrenList.get(index - <span class="number">1</span>),<span class="keyword">this</span>,<span class="keyword">this</span>,<span class="string">"ctx"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在的节点状态回调</span></span><br><span class="line"><span class="comment">     * AsyncCallback.StatCallback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String pathName, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试运行-1"><a href="#测试运行-1" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        zk = ZkUtil.getZk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   WatchCallback watchCallback = <span class="keyword">new</span> WatchCallback();</span><br><span class="line">                   MyContent myContent = <span class="keyword">new</span> MyContent();</span><br><span class="line">                   myContent.setContent(<span class="string">""</span>);</span><br><span class="line">                   myContent.setPathName(<span class="string">"/test"</span>);</span><br><span class="line">                   myContent.setThreadName(Thread.currentThread().getName());</span><br><span class="line">                   watchCallback.setMyContent(myContent);</span><br><span class="line">                   watchCallback.setZk(zk);</span><br><span class="line"></span><br><span class="line">                   watchCallback.tryLock();</span><br><span class="line">                   <span class="comment">//不睡眠的话，可能第一个节点已经删除，第二个节点还没监控，等第二个节点开启监控时，第一个节点已经没了</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(<span class="string">"doing。。。"</span>);</span><br><span class="line">                   watchCallback.unLock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 安装</title>
    <url>/2021/07/31/zookeeper%E5%AE%89%E8%A3%85%E3%80%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>。</p>
<p><img src="/images/zk/zk01.png" alt=""></p>
<a id="more"></a>

<h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><h3 id="Data-model（数据模型）"><a href="#Data-model（数据模型）" class="headerlink" title="Data model（数据模型）"></a>Data model（数据模型）</h3><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p>
<p><img src="/images/zk/zk-02-1.jpg" alt=""></p>
<p>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 <code>1M</code>。</p>
<p><img src="/images/zk/zk-02-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="znode（数据节点）"><a href="#znode（数据节点）" class="headerlink" title="znode（数据节点）"></a>znode（数据节点）</h3><p>在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p>
<p>znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>每个 znode 由 2 部分组成:</p>
<ul>
<li><strong>stat</strong> ：状态信息</li>
<li><strong>data</strong> ： 节点存放的数据的具体内容</li>
</ul>
<table>
<thead>
<tr>
<th>znode 状态信息</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>cZxid</td>
<td>create ZXID，即该数据节点被创建时的事务 id</td>
</tr>
<tr>
<td>ctime</td>
<td>create time，即该节点的创建时间</td>
</tr>
<tr>
<td>mZxid</td>
<td>modified ZXID，即该节点最终一次更新时的事务 id</td>
</tr>
<tr>
<td>mtime</td>
<td>modified time，即该节点最后一次的更新时间</td>
</tr>
<tr>
<td>pZxid</td>
<td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号，当前节点的子节点每次变化时值增加 1</td>
</tr>
<tr>
<td>dataVersion</td>
<td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td>
</tr>
<tr>
<td>aclVersion</td>
<td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据节点内容长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点的子节点个数</td>
</tr>
</tbody></table>
<h3 id="ACL（权限控制）"><a href="#ACL（权限控制）" class="headerlink" title="ACL（权限控制）"></a>ACL（权限控制）</h3><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p>
<p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p>
<ul>
<li><strong>CREATE</strong> : 能创建子节点</li>
<li><strong>READ</strong> ：能获取节点数据和列出其子节点</li>
<li><strong>WRITE</strong> : 能设置/更新节点数据</li>
<li><strong>DELETE</strong> : 能删除子节点</li>
<li><strong>ADMIN</strong> : 能设置节点 ACL 的权限</li>
</ul>
<p>其中尤其需要注意的是，<strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p>
<p>对于身份认证，提供了以下几种方式：</p>
<ul>
<li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li>
<li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li>
<li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li>
<li><strong>ip</strong> : 对指定 ip 进行限制。</li>
</ul>
<h3 id="Watcher（事件监听器）"><a href="#Watcher（事件监听器）" class="headerlink" title="Watcher（事件监听器）"></a>Watcher（事件监听器）</h3><p>​        Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<h2 id="三、下载安装"><a href="#三、下载安装" class="headerlink" title="三、下载安装"></a>三、<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">下载安装</a></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line">ZK_HOME=/opt/apache-zookeeper-3.7.0-bin</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$ZK_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><h3 id="zoo-cfg"><a href="#zoo-cfg" class="headerlink" title="zoo.cfg"></a>zoo.cfg</h3><p>拷贝配置<code>cp zoo_sample.cfg zoo.cfg</code>，并需要修改<code>zoo.cfg</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment">#dataDir=/tmp/zookeeper</span></span><br><span class="line"><span class="comment">#数据存放文件路径</span></span><br><span class="line"><span class="string">dataDir=/var/zookeeper</span></span><br><span class="line"><span class="comment">#文件尾部插入zookeeper服务节点</span></span><br><span class="line"><span class="comment">#2888是leader接收write请求的端口</span></span><br><span class="line"><span class="comment">#3888是投票选举的端口</span></span><br><span class="line"><span class="string">server.1=192.168.142.121:2888:3888</span></span><br><span class="line"><span class="string">server.2=192.168.142.122:2888:3888</span></span><br><span class="line"><span class="string">server.3=192.168.142.123:2888:3888</span></span><br><span class="line"><span class="string">server.4=192.168.142.124:2888:3888</span></span><br></pre></td></tr></table></figure>

<h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p><code>myid</code>文件标识当前zookeeper是节点中的哪个服务，文件内容与上面的<code>server.x</code>的<code>x</code>对应</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种</span></span><br><span class="line">vim /var/zookeeper/myid</span><br><span class="line">1 <span class="comment">#填写服务节点对应的数字</span></span><br><span class="line"><span class="comment">#第二种</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /var/zookeeper/myid</span><br></pre></td></tr></table></figure>

<h2 id="五、远程复制"><a href="#五、远程复制" class="headerlink" title="五、远程复制"></a>五、远程复制</h2><p>将zookeeper复制到每一台机子上</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp -r /opt/apache-zookeeper-3.7.0-bin/ root@192.168.142.122:/opt/apache-zookeeper-3.7.0-bin/</span><br></pre></td></tr></table></figure>

<p>每台机子重复创建myid并设置属于自己的server.x的x值</p>
<h2 id="六、相关参数"><a href="#六、相关参数" class="headerlink" title="六、相关参数"></a>六、相关参数</h2><h3 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前台启动</span></span><br><span class="line">zkServer.sh start-foreground</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">zkServer.sh start</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">zkServer.sh stop</span><br><span class="line"><span class="comment">#版本信息</span></span><br><span class="line">zkServer.sh version</span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">zkServer.sh restart</span><br><span class="line"><span class="comment">#状态信息（版本+角色）</span></span><br><span class="line">zkServer.sh status</span><br><span class="line"><span class="comment">#启动命令参数</span></span><br><span class="line">zkServer.sh <span class="built_in">print</span>-cmd</span><br></pre></td></tr></table></figure>

<h3 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#客户端连接</span></span><br><span class="line">zkCli.sh</span><br><span class="line">zkCli.sh -server 192.168.142.121:2181</span><br></pre></td></tr></table></figure>

<h2 id="七、命令"><a href="#七、命令" class="headerlink" title="七、命令"></a>七、命令</h2><p>登录zk客户端可执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ZooKeeper -server host:port -client-configuration properties-file cmd args</span><br><span class="line">        addWatch [-m mode] path <span class="comment"># optional mode is one of [PERSISTENT, PERSISTENT_RECURSIVE] - default is PERSISTENT_RECURSIVE</span></span><br><span class="line">        addauth scheme auth</span><br><span class="line">        close </span><br><span class="line">        config [-c] [-w] [-s]</span><br><span class="line">        connect host:port</span><br><span class="line">        create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br><span class="line">        delete [-v version] path</span><br><span class="line">        deleteall path [-b batch size]</span><br><span class="line">        delquota [-n|-b|-N|-B] path</span><br><span class="line">        get [-s] [-w] path</span><br><span class="line">        getAcl [-s] path</span><br><span class="line">        getAllChildrenNumber path</span><br><span class="line">        getEphemerals path</span><br><span class="line">        <span class="built_in">history</span> </span><br><span class="line">        listquota path</span><br><span class="line">        ls [-s] [-w] [-R] path</span><br><span class="line">        printwatches on|off</span><br><span class="line">        quit </span><br><span class="line">        reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]</span><br><span class="line">        redo cmdno</span><br><span class="line">        removewatches path [-c|-d|-a] [-l]</span><br><span class="line">        <span class="built_in">set</span> [-s] [-v version] path data</span><br><span class="line">        setAcl [-s] [-v version] [-R] path acl</span><br><span class="line">        setquota -n|-b|-N|-B val path</span><br><span class="line">        <span class="built_in">stat</span> [-w] path</span><br><span class="line">        sync path</span><br><span class="line">        version </span><br><span class="line">        whoami</span><br></pre></td></tr></table></figure>



<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>#查看目录下文件节点信息<br><code>ls [-s] [-w] [-R] path</code></p>
<p><img src="/images/zk/ls.jpg" alt=""></p>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>#查看配置信息<br>config [-c] [-w] [-s]</p>
<p><img src="/images/zk/config.jpg" alt=""></p>
<h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>创建空节点</p>
<p>​    <code>-e</code>创建临时节点，当前客户端退出则消失</p>
<p>​    <code>-s</code>创建分布式节点，用于多线程竞争创建，创建时会在文件名后拼接递增的序列数值</p>
<p><img src="/images/zk/create.jpg" alt=""></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>获取节点参数值，图中<code>/node/data</code>为有值节点、<code>/node/test</code>为无值节点</p>
<p><img src="/images/zk/get.jpg" alt=""></p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>设置节点参数</p>
<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>当前客户端自登录链接以来执行的历史命令</p>
<p><img src="/images/zk/history.jpg" alt=""></p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>删除节点，不是<code>子节点</code>不能删除</p>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>节点状态信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zk: 192.168.142.121:2181(CONNECTED) 1] <span class="built_in">stat</span> /node</span><br><span class="line"><span class="comment"># cZxid 有64位，前32位表示Leader的纪元，后32位表示事务ID</span></span><br><span class="line"><span class="comment"># ZK顺序执行，Leader维护着一个自增事务ID：00000002</span></span><br><span class="line"><span class="comment"># 0x2 表示的是Leader的纪元</span></span><br><span class="line"><span class="comment"># cZxid 的 c 表示 create，cZxid表示也就是创建节点的事务ID</span></span><br><span class="line">cZxid = 0x10000000e</span><br><span class="line"><span class="comment"># 创建时间</span></span><br><span class="line">ctime = Mon May 17 13:58:57 CST 2021</span><br><span class="line"><span class="comment"># 修改节点的事务ID</span></span><br><span class="line">mZxid = 0x10000001d</span><br><span class="line">mtime = Mon May 17 14:54:09 CST 2021</span><br><span class="line"><span class="comment"># 当前这个节点下创建的最后一个节点的ID</span></span><br><span class="line">pZxid = 0x10000001b</span><br><span class="line">cversion = 7</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="comment">#临时持有者 0x0表示持久节点，临时节点则存对应的是sessionId</span></span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>不同版本HashMap和ConcurrentHashMap区分</title>
    <url>/2021/03/31/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACHashMap-ConcurrentHashMap%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="HashMap区别"><a href="#HashMap区别" class="headerlink" title="HashMap区别"></a>HashMap区别</h2><p>JDK7和JDK8中的HashMap底层数据结构有什么区别?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK7:数组 + 链表</span><br><span class="line">JDK8:数组 + 链表 + 红黑树</span><br><span class="line">     链表包括单向链表和双向链表，双线链表主要是为了链表操作方便，在插入、扩容链表转红黑树的过程中使用</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>JDK8中的HashMap为什么要使用红黑树？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当元素个数小于一个阈值时，链表在整体效率上要高于红黑树，当元素个数大于此阈值时，链表整体的查询效率要低于红黑树，此阈值在HashMap中为8。转换成红黑树可以平衡插入和查询效率。</span><br><span class="line"></span><br><span class="line">链表查询效率：O(N)</span><br><span class="line">链表插入效率：O(1)</span><br><span class="line"></span><br><span class="line">红黑树查询效率：O(logN)</span><br><span class="line">红黑树插入效率：O(logN)</span><br></pre></td></tr></table></figure>

<p>JDK8中的HashMap什么时候将链表转化成红黑树？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当链表中的元素大于8，并且数组的长度大于等于64时，才会将链表转化成红黑树。</span><br><span class="line">当数组的长度低于64时，通过扩容数组大小来缩小链表的长度。</span><br></pre></td></tr></table></figure>

<p>JDK8中的HashMap的put方法的实现过程？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.根据Key生成HashCode</span><br><span class="line">2.判断当前HashMap对象中的数组是否为空，如果为空则初始化数组</span><br><span class="line">3.根据逻辑与运算，算出HashCode基于当前数组对应的数组下标i</span><br><span class="line">4.判断数组的第i个位置的元素(tab[i])是否为空</span><br><span class="line">   a.如果为空，则将key,value封装为Node对象赋值给tab[i]</span><br><span class="line">   b.如果不为空：</span><br><span class="line">     I.如果put方法传入进来的key等于tab[i].key，那么存在相同的key</span><br><span class="line">     II.如果不等于tab[i].key，则:</span><br><span class="line">       1.如果tab[i]的类型是TreeNode，插入红黑树之前判断树中是否存在相同的key,然后Key和Value插入到红黑树中</span><br><span class="line">       2.如果tab[i]的类型不是TreeNode，则表示当前是个链表，遍历寻找相同的key，找不到则插入，然后判断是否Size大于8，大于则树化。</span><br><span class="line">     III.如果上诉步骤发现相同的key，则更新value值，返回oldValue</span><br><span class="line">5.modCount++</span><br><span class="line">6.HashMap的元素个数size + 1</span><br><span class="line">7.如果size大于扩容阈值，则进行扩容</span><br></pre></td></tr></table></figure>

<p>JDK8中HashMap的get方法的实现过程?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.根据Key生成HashCode</span><br><span class="line">2.如果数组为空，则直接返回空</span><br><span class="line">3.如果数组不为空，则利用HashCode&amp;（数组长度-1）计算Key所对应的数组下标i</span><br><span class="line">4.如果数组的第i个位置上没有元素，则直接返回空</span><br><span class="line">5.如果数组的第1个位置上的元素key等于get方法传进来的key，则返回该元素，并取该元素的value</span><br><span class="line">6.如果不等于则判断该元素有没有下一个元素，如果没有，返回空</span><br><span class="line">7.如果有则判断该元素的类型是链表节点还是红黑树节点</span><br><span class="line">  a.如果是链表则遍历链表</span><br><span class="line">  b.如果是红黑树则遍历红黑树</span><br><span class="line">8.找到则返回元素，没找到则返回空</span><br></pre></td></tr></table></figure>

<p>JDK7与JDK8中HashMap的不同点?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.JDK8使用了红黑树</span><br><span class="line">2.JDK7中链表插入使用的头插法，但是会造成循环链表CPU100%的问题，JDK8使用尾插法</span><br><span class="line">3.JDK7的Hash算法比JDK8复杂，散列性更好能提高链表查询效率，而JDK8增加红黑树查询性能得到保障，所以简化了Hash算法</span><br><span class="line">4.扩容的过程JDK7可能会对Key进行reHash(和Hash种子有关)，而JDK8&#x3D;的Key没有reHash的过程</span><br><span class="line">5.JDK8中的扩容条件和JDK7不同，在JDK7中，若tab[i]为空，则不进行扩容，而JDK8移除了该条件</span><br><span class="line">6.JDK8增加了API：putIfAbsent(Key,Value)</span><br><span class="line">7.扩容过程转移元素的逻辑不同，JDK7是一次转移一个元素，JDK8是算出尾部同一个位置的数组直接头结点迁移</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap区别"><a href="#ConcurrentHashMap区别" class="headerlink" title="ConcurrentHashMap区别"></a>ConcurrentHashMap区别</h2><p>JDK7中的ConcurrentHashMap是怎么保证并发安全的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用 Unsafe操作 + ReentrantLock + 分段思想</span><br><span class="line">Unsafe操作：</span><br><span class="line">1.compareAndSwapObject : CAS方式修改对象的属性</span><br><span class="line">2.putOrderedObject : 并发安全的给数组的某个位置赋值</span><br><span class="line">3.getObjectVolatile ： 并发安全的获取数组某个位置的元素</span><br><span class="line"></span><br><span class="line">分段思想是为了提高ConcurrentHashMap的并发量，分段越高则支持的最大并发量越高。</span><br><span class="line">并发量根据concurrencyLevel参数指定，内部类Segment表示一个段。</span><br><span class="line"></span><br><span class="line">每个Segment是一个小型的HashMap，Segment类继承ReentrantLock，所以自带重入锁，put方法时加锁，再插入值，然后解锁。</span><br></pre></td></tr></table></figure>

<p>JDK7中的ConcurrentHashMap的底层原理?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap底层是由两层嵌套数组实现的：</span><br><span class="line">1.ConcurrentHashMap对象中有一个属性segments，类型Segment[]</span><br><span class="line">2.Segment对象中有一个属性table,类型HashEntry[]</span><br><span class="line"></span><br><span class="line">当调用put方法时，根据Key计算出Segment[]数组下标，若为空，则初始化Segment对象，然后调用Segment对象的put方法.</span><br><span class="line">Segment对象的put方法会先加锁，然后根据Key计算出HashEntry[]数组下标，并放到链表中。</span><br><span class="line"></span><br><span class="line">加锁过程是通过CAS加锁，超过一定次数就会阻塞等待加锁。</span><br></pre></td></tr></table></figure>

<p>JDK8中的ConcurrentHashMap是怎么保证并发安全的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用 Unsafe操作 + synchronized关键字</span><br><span class="line">Unsave操作的使用和JDK7中的类似，主要负责并发安全的修改对象的属性活数组某个位置的值。</span><br><span class="line"></span><br><span class="line">synchronized主要负责对tab[i]元素时进行加锁(该位置不为空)，若该位置为空，则采用CAS赋值tab[i]</span><br><span class="line">tab[i]若是链表，则是链表头结点，若是红黑树，则是TreeBin对象。</span><br><span class="line"></span><br><span class="line">JDK8中也有分段锁的思想，只不过JDK7中段数是可以控制的，而JDK8中针对数组的每一个位置(tab[i]元素)</span><br></pre></td></tr></table></figure>

<p>JDK8中的ConcurrentHashMap的put方法的实现流程？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当向ConcurrentHashMap中put一个Key,Value时：</span><br><span class="line">1.首先根据Key计算对应的数组下标，如果该位置没有元素，则通过CAS去赋值该位置</span><br><span class="line">2.如果该位置有元素，则synchronized加锁</span><br><span class="line">3.加锁成功后，判断该元素的类型</span><br><span class="line">  a.如果是链表，则将新节点添加到链表中</span><br><span class="line">  b.如果是红黑树，则将新节点添加到红黑树中</span><br><span class="line">4.添加成功后，判断是否需要进行树化</span><br><span class="line">5.addCount，并发安全地对ConcurrentHashMap元素个数 + 1(采用了LongAdder思想)，然后判断是否需要扩容</span><br><span class="line">6.同时线程在put时如果发现当前ConcurrentHashMap正在进行扩容(tab[i]&#x3D;FWD类型的对象)，则会去帮助扩容(并发扩容)。</span><br></pre></td></tr></table></figure>

<p>JDK7和JDK8中，统计元素个数的实现逻辑有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK7:</span><br><span class="line">1.第一次遍历累加Segment[]数组中的count属性</span><br><span class="line">2.第二次遍历累加Segmeng[]数组中的count属性</span><br><span class="line">3.如果在两次遍历过程中，结果不相等，则再遍历第三次累加，和第二次的结果对比，若相等则返回</span><br><span class="line">4.若还是不等，则对Segment数组的上的所有元素加锁，然后计算</span><br><span class="line"></span><br><span class="line">JDK8：</span><br><span class="line">1.有一个baseCount的属性，供以CAS操作，并借鉴了LongAdder的设计思想</span><br><span class="line">2.当baseCount在CAS竞争激烈时，使用CounterCell[]数组提供多个篮子进行资源分散</span><br><span class="line">3.只要能对篮子中的值CAS成功后，即可</span><br><span class="line">4.最终统计时，通过累加baseCount + CounterCell[] 得到结果。</span><br></pre></td></tr></table></figure>

<p>JDK7和JDK8中，都支持多线程并发扩容吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">都支持多线程扩容。</span><br><span class="line">在JDK7中，扩容只是针对一个Segment对象中的HashEntry[]对象，所以能够达到多个线程同时扩容不同的Segment对象。</span><br><span class="line">在JDK8中，每个线程迁移指定步长下标的元素，并发操作，达到多线程同时扩容一个tab数组。</span><br><span class="line"></span><br><span class="line">JDK8的扩容性能更高，因为JDK8对任意一个线程都可以帮助扩容，而JDK7一个线程扩容一个Segment。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖二-源码跟踪</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%8C%EF%BC%88%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="第一步：最初的入口"><a href="#第一步：最初的入口" class="headerlink" title="第一步：最初的入口"></a>第一步：最初的入口</h3><p>ClassPathXmlApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//第一步，最初的入口</span></span><br><span class="line"><span class="number">144</span>			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="第二步：实例化所有剩余的-非延迟-init-单例"><a href="#第二步：实例化所有剩余的-非延迟-init-单例" class="headerlink" title="第二步：实例化所有剩余的(非延迟-init)单例"></a>第二步：实例化所有剩余的(非延迟-init)单例</h3><p>AbstractApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// 第二步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">517</span>				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>AbstractApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">879</span>		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：调用子类的doGetBean"><a href="#第四步：调用子类的doGetBean" class="headerlink" title="第四步：调用子类的doGetBean"></a>第四步：调用子类的doGetBean</h3><p>DefaultListableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 触发所有非惰性单例bean的初始化...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 略</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第四步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">897</span>					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"><a href="#第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）" class="headerlink" title="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"></a>第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）</h3><p>AbstractBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    	<span class="comment">// 第五步 获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="number">250</span>		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">                <span class="comment">//标记当前bean处于正在创建状态</span></span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// Create bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 第七步 创建实例</span></span><br><span class="line"><span class="number">322</span>					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//第九步，在第八步调用singletonFactory.getObject()执行此lambda方法</span></span><br><span class="line"><span class="number">324</span>							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							<span class="keyword">throw</span> ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No scope name defined for bean ´"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">								<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">								<span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"><a href="#第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）" class="headerlink" title="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"></a>第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第六步，获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">	    <span class="comment">//1.先从一级缓存中获取对象，若存在则返回</span></span><br><span class="line"><span class="number">182</span>		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">//2.若对象不存在，则从二级缓存中查找该对象</span></span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="comment">//3.若对象不存在一级、二级缓存中时，并且存在于三级缓存中时</span></span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//4.调用工厂对象的getObject()方法【() -&gt; getEarlyBeanReference(beanName, mbd, bean)】</span></span><br><span class="line">                            	<span class="comment">// 提前，实际上是调用了【AnnotationAwareAspectJAutoProxyCreator】</span></span><br><span class="line">                            	<span class="comment">// 第十八步，最终返回一个动态代理对象Proxy</span></span><br><span class="line"><span class="number">194</span>								singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//将该动态代理对象存放到二级缓存中</span></span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">//把该bean的函数接口从三级缓存中移除</span></span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"><a href="#第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）" class="headerlink" title="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"></a>第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//1.从缓存中获取bean实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//2.如果bean实例不存在缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 省略部分源码 */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//第八步，调用第七步传入的lambda表达式() -&gt; &#123; return createBean(beanName, mbd, args);&#125;</span></span><br><span class="line"><span class="number">234</span>             singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            	<span class="comment">/* 省略部分源码 */</span>    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//第二十步，添加到一级缓存中，然后调用链将回到初始化实例的函数</span></span><br><span class="line"><span class="number">260</span>             addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十步：创建一个bean实"><a href="#第十步：创建一个bean实" class="headerlink" title="第十步：创建一个bean实"></a>第十步：创建一个bean实</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="comment">// 略</span></span></span><br><span class="line"><span class="function">		<span class="keyword">try</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第十步，创建一个bean实例，填充bean实例、应用前置处理器等</span></span><br><span class="line"><span class="number">516</span>			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"><a href="#第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）" class="headerlink" title="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"></a>第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate the bean.</span></span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//第十一步,实例化对象，开辟内存空间</span></span><br><span class="line"><span class="number">556</span>			instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">//快速缓存单例，以便能够解决循环引用</span></span><br><span class="line">		<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    	<span class="comment">// 实例化完成后，判断是否需要提前暴露该对象，结果为true</span></span><br><span class="line">    	<span class="comment">// 满足条件：单例、开启允许循环依赖的配置、并且该Bean处于正在创建状态</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//第十二步，添加Bean的工厂对象到三级缓存中</span></span><br><span class="line"><span class="number">587</span>			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第十三步，填充属性，即给A的属性赋值（也就是属性B）</span></span><br><span class="line"><span class="number">593</span>			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">//第十九步，获取到二级缓存中提前暴露的A</span></span><br><span class="line"><span class="number">607</span>			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十三步：给给Bean的属性赋值"><a href="#第十三步：给给Bean的属性赋值" class="headerlink" title="第十三步：给给Bean的属性赋值"></a>第十三步：给给Bean的属性赋值</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">		<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">		<span class="comment">// to support styles of field injection.</span></span><br><span class="line">	    <span class="comment">//当像BeanFactoryAware这样的生命周期接口触发时，任何实例化的awarebeanpostprocessor都有机会在属性设置之前修改bean的状态</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">		PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">						&#125;</span><br><span class="line">						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					pvs = pvsToUse;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">			<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			&#125;</span><br><span class="line">			checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            <span class="comment">//第十三步，给Bean的属性赋值</span></span><br><span class="line"><span class="number">1442</span>			applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"><a href="#第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）" class="headerlink" title="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"></a>第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取属性名称</span></span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">				<span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">					Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">					<span class="keyword">if</span> (writeMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Autowire marker for property without write method: "</span> + pv);</span><br><span class="line">					&#125;</span><br><span class="line">					originalValue = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">new</span> MethodParameter(writeMethod, <span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">                	<span class="comment">//第十四步 使用解析器解析不同类型的值</span></span><br><span class="line"><span class="number">1697</span>				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				Object convertedValue = resolvedValue;</span><br><span class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">        <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第二十步，真正的属性赋值</span></span><br><span class="line"><span class="number">1730</span>		bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十五步："><a href="#第十五步：" class="headerlink" title="第十五步："></a>第十五步：</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">		<span class="comment">// to another bean to be resolved.</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">			RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">            <span class="comment">//第十五步</span></span><br><span class="line"><span class="number">113</span>			<span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十六步：调用子类的doGetBean"><a href="#第十六步：调用子类的doGetBean" class="headerlink" title="第十六步：调用子类的doGetBean"></a>第十六步：调用子类的doGetBean</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object bean;</span><br><span class="line">			Class&lt;?&gt; beanType = ref.getBeanType();</span><br><span class="line">			<span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String resolvedName;</span><br><span class="line">				<span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					NamedBeanHolder&lt;?&gt; namedBean = <span class="keyword">this</span>.beanFactory.resolveNamedBean(beanType);</span><br><span class="line">					bean = namedBean.getBeanInstance();</span><br><span class="line">					resolvedName = namedBean.getBeanName();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolvedName = String.valueOf(doEvaluate(ref.getBeanName()));</span><br><span class="line">                    <span class="comment">//第十六步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">330</span>					bean = <span class="keyword">this</span>.beanFactory.getBean(resolvedName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory.registerDependentBean(resolvedName, <span class="keyword">this</span>.beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				bean = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十七步-循环第五步创建B"><a href="#第十七步-循环第五步创建B" class="headerlink" title="第十七步:循环第五步创建B"></a>第十七步:循环第五步创建B</h3><p>AbstractBeanFactory</p>
<h2 id="归纳步骤："><a href="#归纳步骤：" class="headerlink" title="归纳步骤："></a>归纳步骤：</h2><h4 id="实例化A"><a href="#实例化A" class="headerlink" title="实例化A"></a>实例化A</h4><p>1.<code>第五步</code>getSingleton(beanName)从缓存获取<code>A</code>；</p>
<p>2.获取不到时，走<code>第七步</code>准备开始创建；</p>
<p>3.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>4.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>A</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取A的属性B"><a href="#获取A的属性B" class="headerlink" title="获取A的属性B"></a>获取A的属性B</h4><p>5.<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>；</p>
<p>6.走<code>第五步</code>获取<code>B</code>，返现<code>B</code>没有，继续重复流程创建<code>B</code>；</p>
<h4 id="实例化B"><a href="#实例化B" class="headerlink" title="实例化B"></a>实例化B</h4><p>7.走<code>第七步</code>准备开始创建B；</p>
<p>8.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>9.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>B</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取B的属性A"><a href="#获取B的属性A" class="headerlink" title="获取B的属性A"></a>获取B的属性A</h4><p>10.再次来到<code>第十三步</code>给<code>B</code>的赋值<code>属性A</code>时；</p>
<p>11.<code>第十六步</code>,调用子类的doGetBean(name, null, null, false)</p>
<p>11.再次走<code>第五步</code>获取<code>A</code></p>
<p>12.<code>十八步</code>获取到A的三级缓存生成对象放入<code>二级缓存</code>，如果有aop最终返回一个动态代理对象Proxy，移除三级缓存A的工厂；</p>
<p>13.<code>第二十步</code> 真正的属性赋值,将A赋值给B</p>
<p>14.<code>第二十一步</code>将<code>B</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<p>15.回到<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>时，走类似<code>10</code>之后的流程；</p>
<p>16.最终<code>A</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="getSingleton：获取各级缓存"><a href="#getSingleton：获取各级缓存" class="headerlink" title="getSingleton：获取各级缓存"></a>getSingleton：获取各级缓存</h3><h3 id="doCreateBean：创建bean主要方法"><a href="#doCreateBean：创建bean主要方法" class="headerlink" title="doCreateBean：创建bean主要方法"></a>doCreateBean：创建bean主要方法</h3><h3 id="populateBean：填充属性方法"><a href="#populateBean：填充属性方法" class="headerlink" title="populateBean：填充属性方法"></a>populateBean：填充属性方法</h3><h3 id="addSingleton：添加一级缓存方法"><a href="#addSingleton：添加一级缓存方法" class="headerlink" title="addSingleton：添加一级缓存方法"></a>addSingleton：添加一级缓存方法</h3><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>结合上面四个方法做个简单的总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.调用doGetBean()方法，想要获取A，于是调用getSingleton()方法，从缓存中查找A</span><br><span class="line">2.在getSingleton()方法中，从一级缓存中查找，没有，返回null</span><br><span class="line">3.doGet】Bean()方法中获取的A为null，于是走对应的处理逻辑，调用getSingleton()的重载方法(参数为ObjectFactory)</span><br><span class="line">4.在getSingleton()方法中，现将A的name添加到一个集合中，用于标记该bean正常创建中；然后回调匿名内部类的createBean方法</span><br><span class="line">5.进入AbstractAutowireCapableBeanFactory#doCreateBean，先反射调用构造器创建出A的实例，然后判断是否为单例、是否允许提前曝光引用（单例一般为true）、是否正在创建中（第四步的集合）；判断为true则将A添加到三级缓存中</span><br><span class="line">6.对A进行属性填充，此时检测到A依赖于B，于是开始查找B</span><br><span class="line">7.调用doGetBean()方法和上面A的过程一样，到缓存中查找B，没有则创建，然后给B填充属性</span><br><span class="line">8.此时B依赖于A，调用getSingle()获取A，依次从缓存中茶渣，此时从三级缓存中获取到A的工厂，通过公办工厂获取singletonObject，此时这个singleton指向就是上面在doCreate()方法中实例化的A（第七步）</span><br><span class="line">9.这样B就获取到了A的依赖，于是B顺利完成实例化，并将A从三级缓存移动到二级缓存中</span><br><span class="line">10.随后A继续它的属性填充工作，此时也获取到B，A也随之完成创建，回到getSingleton()方法中继续向下执行，将A从二级缓存移动到一级缓存中</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码登录</title>
    <url>/2021/04/17/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/images/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png" alt="二维码扫码登录"></p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC端</span><br><span class="line">	1、&#96;pc端&#96;请求&#96;服务端&#96;生成二维码，获取二维码id</span><br><span class="line">	4、&quot;未扫描&quot;状态下，&#96;pc端&#96;轮询&#96;服务端&#96;二维码状态，返回&quot;已扫描&quot;状态，显示等待用户在&#96;移动端&#96;确认</span><br><span class="line">	9、&quot;已扫描&quot;状态下，&#96;pc端&#96;轮询&#96;服务端&#96;二维码状态&quot;已确认&quot;状态，获取&#96;服务端&#96;返回的登录token，完成扫码登录</span><br><span class="line">	</span><br><span class="line">移动端</span><br><span class="line">	3、&#96;移动端&#96;扫描二维码获取&#96;PC端&#96;保存的二维码id</span><br><span class="line">	5、&#96;移动端&#96;调用服务端扫码接口传送&#96;移动端&#96;用户身份信息和二维码id</span><br><span class="line">	7、&#96;移动端&#96;调用服务端用户确认接口，传送临时token</span><br><span class="line">	</span><br><span class="line">服务端</span><br><span class="line">	2、接收pc端生成二维码的请求，绑定该pc终端信息并生成二维码id，状态“未扫描”</span><br><span class="line">	6、接收移动端扫码请求（app身份信息和二维码id），更改二维码状态为“已扫描”，返回临时token（保证之后的确认操作与扫描操作是同一设备）</span><br><span class="line">	8、接收移动端用户确认请求（临时token），修改二维码状态为“已确认”，根据&#96;PC&#96;的设备信息和&#96;移动端&#96;的用户信息生成用户的pc登录token</span><br><span class="line">	</span><br><span class="line">服务端接口</span><br><span class="line">	生成二维码接口，</span><br><span class="line">		入参：pc终端信息</span><br><span class="line">		返参：生成二维码id</span><br><span class="line">	扫码接口</span><br><span class="line">		入参：移动端身份信息、二维码id</span><br><span class="line">		返参：临时token（保证之后的确认操作与扫描操作是同一设备）</span><br><span class="line">	确认接口</span><br><span class="line">		入参：临时token、二维码id</span><br><span class="line">		返参：成功、失败</span><br><span class="line">	轮询状态接口</span><br><span class="line">		入参：二维码id</span><br><span class="line">		返参：二维码状态、</span><br><span class="line">			  登录token（已确认状态返回）</span><br><span class="line">			  </span><br><span class="line">前端二维码内容：二维码id或二维码id的一个url地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖一（图解）</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%80%EF%BC%88%E5%9B%BE%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>指的是DefaultSingletonBeanRegistry类中的三个Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存，存放初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存，存放已经被实例化，但是未初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三级缓存，存储创建Bean的匿名内部类工厂对象ObjectFactory&lt;?&gt;，通过存储lambda表达式（() -&gt; getEarlyBeanReference(beanName, mbd, bean)），解决创建动态代理逻辑性能，解耦 bean动态代理问题</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>spring通过三级缓存来解决循环依赖问题</p>
<a id="more"></a>

<h2 id="不含aop的流程图"><a href="#不含aop的流程图" class="headerlink" title="不含aop的流程图"></a>不含aop的流程图</h2><p><img src="/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg" alt=""></p>
<h2 id="含aop的流程图"><a href="#含aop的流程图" class="headerlink" title="含aop的流程图"></a>含aop的流程图</h2><p><img src="/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%ABaop2.jpg" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1：使用三级缓存的作用？"><a href="#1：使用三级缓存的作用？" class="headerlink" title="1：使用三级缓存的作用？"></a>1：使用三级缓存的作用？</h3><p>在三个级别的缓存中防止的对象是有区别的<br>    一级缓存存放的是：实例化和初始化都完成的对象<br>    二级缓存存放的是：实例化完成、初始化未完成的对象<br>    三级缓存存放的是：实例化和初始化都未完成，存放的是创建bean的匿名内部类（函数是接口ObjectFactory传入）</p>
<h3 id="2：只使用一级缓存？"><a href="#2：只使用一级缓存？" class="headerlink" title="2：只使用一级缓存？"></a>2：只使用一级缓存？</h3><p>​    在并发的情况下，可能取到实例化但是未初始化的对象</p>
<h3 id="3：只使用二级缓存？"><a href="#3：只使用二级缓存？" class="headerlink" title="3：只使用二级缓存？"></a>3：只使用二级缓存？</h3><p>​    三级缓存存放的是生成具体对象的一个匿名内部类，这个类可能是代理类，也可能是普通的实例对象，使用三级缓存就保证了不管是否需要代理，用的都是一个对象</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>共识性算法（一致性算法）</title>
    <url>/2022/02/08/%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、paxos"><a href="#一、paxos" class="headerlink" title="一、paxos"></a>一、paxos</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一种基于消息传递且具有高度容错性的共识性算法。</p>
<p>解决分布式共识性问题，即一个分布式系统中各个进程如何进某个值（决议）通过共识达成一致。</p>
<p>Paxos将系统中的角色分为<strong>提议者 (Proposer)</strong>，<strong>决策者 (Acceptor)</strong>，<strong>最终决策学习者 (Learner)</strong>：</p>
<ul>
<li><strong>Proposer-提议者</strong>：提出提案（Proposal），信息包括提案编号（Proposal ID）、提议值（Value）。</li>
<li><strong>Acceptor-决策者</strong>：参与决策，回应Proposer的提案。收到提案后可以接受提案，若Proposal获得多数Acceptors接受，则称该Proposal被批准。</li>
<li><strong>Learner-学习者</strong>：不参与决策，从Proposers/Acceptors学习最新达成一致的信息（Value）。</li>
</ul>
<blockquote>
<p>Proposer向Acceptor集合发送提案，Acceptor集合中的每个成员都有可能同意该提案且每个Acceptor 只能批准一个提案，只有当一半以上的成员同意了一个提案，就认为该提案被选定了。</p>
</blockquote>
<a id="more"></a>

<h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a><strong>拜占庭问题</strong></h2><p>拜占庭问题：是指 拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的， 只能依靠通讯员进行传递命令，但是通讯员中存在叛徒，<strong>「它们可以篡改消息」</strong>，叛徒可以欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定， 如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。</p>
<p>Paxos算法的前提假设是不存在拜占庭将军问题，即通讯安全不会丢失，且发出的消息不被修改。</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ul>
<li>一个<strong>Proposer-提议者</strong>选择一个提案编号（Proposal ID），让如prepare request中发送给其他<strong>Acceptor-决策者</strong></li>
<li>如果一个<strong>Acceptor-决策者</strong>接受了一个prepare request，其中的提案编号（Proposal ID）大于它之前回复过的prepare request，那么它会回复该请求，并承诺不接受比其小的提案编号（Proposal ID），并返回它已经接受的最大提案编号（Proposal ID）。</li>
</ul>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ul>
<li><p>如果<strong>Proposer-提议者</strong>收到了大多数<strong>Acceptor-决策者</strong>的回复，则会对这些<strong>Acceptor-决策者</strong>再发送一个accept request，其中包含<strong>提案编号（Proposal ID）、提议值（Value）</strong></p>
</li>
<li><p>如果一个<strong>Acceptor-决策者</strong>收到的提案编号（Proposal ID）不小于之前回复的其他请求的提案编号（Proposal ID），则接收此提议</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>paxos协议会拒绝小于等于当前提议ID（处理或者未处理）的提议，当半数以上通过，该提议才会被通过</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当有两个<strong>Proposer-提议者</strong>依次剔除提案时</p>
<ul>
<li><strong>Proposer P1</strong>发送<strong>提案编号1</strong>的prepare请求，收到过半响应，完成阶段一</li>
<li><strong>Proposer P2</strong>发送<strong>提案编号2</strong>的prepare请求，<strong>提案编号2</strong>大于<strong>提案编号1</strong>，收到过半响应，，完成阶段一</li>
<li><strong>P1</strong>进入第二阶段，发送accept请求被<strong>Acceptor-决策者</strong>忽略，此时<strong>P1</strong>重新进入节点一，发送<strong>提案编号3</strong></li>
<li>P2进入第二阶段，发送accept请求被<strong>Acceptor-决策者</strong>忽略，此时<strong>P1*2重新进入节点一，发送</strong>提案编号4**</li>
<li>此时陷入死循环</li>
<li>避免以上情况，Multi Paxos算法，选取一个主Proposer，只有主Proposer才能发起提案</li>
</ul>
<hr>
<h1 id="二、Raft"><a href="#二、Raft" class="headerlink" title="二、Raft"></a>二、Raft</h1><p>Raft算法是Paxos算法的一种简化实现。<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">点击查看动图</a></p>
<p>一个节点在任意状态时刻处于一下三种角色之一：</p>
<ul>
<li><strong>follower</strong>：所有节点都以follower的状态开始，如果没有收到leader消息则会变成candidate状态。</li>
<li><strong>candidate</strong>：会向其他节点拉选票，如果得到大部分的票则成为leader，这个过程是Leader选举。</li>
<li><strong>leader</strong>：所有对系统的修改都会先经过leader。</li>
</ul>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><ul>
<li><p>对于系统的修改都会先经过leader</p>
</li>
<li><p>每个修改都生成一条日志，这些日志处理未提交状态，不会影响真实值</p>
</li>
<li><p>leader将日志复制到follower节点，</p>
</li>
<li><p>当半数以上节点响应时，通知所有的follower正式提交</p>
</li>
<li><p>此时整个系统处于一致状态。</p>
</li>
</ul>
<h2 id="选举-Leader-Election"><a href="#选举-Leader-Election" class="headerlink" title="选举-Leader Election"></a>选举-Leader Election</h2><ul>
<li><p>每个节点生成随机选举超时时间，在这个时间内节点必须等待</p>
</li>
<li><p>当超过此时间时/节点没有监听到leader的心跳，节点变成Candidate，发起投票</p>
<ul>
<li>重置选举超时时间</li>
<li>发起选举投票（投自己一票）<ul>
<li>如果接收节点没有发起投票，则投给该Candidate，并重置自己的选举超时时间</li>
</ul>
</li>
</ul>
</li>
<li><p>当Candidate获取半数以上票数时，当选leader</p>
</li>
<li><p>平票或者票数不足时，本次term没有leader，等待有节点的计时器超时变成candidate开始新一轮的投票</p>
</li>
</ul>
<h1 id="三、ZAB"><a href="#三、ZAB" class="headerlink" title="三、ZAB"></a>三、ZAB</h1><p>ZAB（Zookeeper Atomic Broadcast）是分布式协调服务ZooKeeper，专门设计的一种支持崩溃恢复的一致性协议。</p>
<p>基于该协议，ZooKeeper 实现了一种 主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h3><ul>
<li><p>Leader ：负责整个Zookeeper 集群工作机制中的核心，主要工作有以下两个：</p>
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li><p>Follower ：它是 Leader 的追随者，其主要工作如下：</p>
<ul>
<li>处理客户端的非实物请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
</li>
<li><p>Observer ：是 zookeeper 自 3.3.0 开始引入的一个角色，它不参与事务请求 Proposal 的投票，也不参与 Leader 选举投票，只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p>
</li>
</ul>
<h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ul>
<li><strong>LOOKING</strong>：不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举。</li>
<li><strong>FOLLOWING</strong>： 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁。</li>
<li><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳。</li>
<li><strong>OBSERVING</strong>： 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="Leader写"><a href="#Leader写" class="headerlink" title="Leader写"></a>Leader写</h3><ul>
<li><p>当leader收到事务请求后，将请求事务转化成事务proposal。</p>
</li>
<li><p>由于leader会为每个follower创建一个队列，按照FIFO的策略，将该事务proposal放入响应队列，保证事务的顺序性。</p>
</li>
<li><p>follower收到后会将其以事务的形式写入到本地日志中，并且向leader发送Ack信息确认。</p>
</li>
<li><p>当有一半以上的follower返回Ack信息时，leader会提交该提案并且向其它节点（Follower 、Observer ）发送commit信息。</p>
</li>
</ul>
<blockquote>
<p>leader自己的ack也被计算、不统计Observer的ack、未commit的数据对客户端不可见</p>
</blockquote>
<p>整个过程类似于两阶段提交，但却有所不同，只需半数以上follower成功即可提交。</p>
<h3 id="Follower-Observer写"><a href="#Follower-Observer写" class="headerlink" title="Follower/Observer写"></a>Follower/Observer写</h3><ul>
<li>Follower/Observer均可接受写请求，但是不直接处理，而是将写请求转发给Leader处理</li>
<li>其余流程与Leader写一致</li>
</ul>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>Leader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。</p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><h3 id="ZXID"><a href="#ZXID" class="headerlink" title="ZXID"></a>ZXID</h3><p>一个全局有序的 64 位的数字</p>
<ul>
<li>高32位，存储epoch，代表选举周期，每次选举都会取出高32位+1，低32位置零</li>
<li>低32位，事务计数器，每个事务请求会导致其+1，保证全局递增</li>
</ul>
<p>每当选举一个新leader时，都会产生一个新的epoch。</p>
<p>使用新epoch的作用是，防止旧leader网络恢复等情况，重新连上集群，向其他的follower发送请求，follower对比epoch发现当前epoch大于旧leader的epoch，忽略这个请求。</p>
<h3 id="myid"><a href="#myid" class="headerlink" title="myid"></a>myid</h3><p>每个ZooKeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个ZooKeeper集群唯一的ID（整数），作为该节点在集群中的标识</p>
<blockquote>
<p>1</p>
</blockquote>
<p>zoo.cfg配置文件中，<code>server.x</code>的<code>x</code>对应的就是上面myid文件中的1</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#zoo.cfg配置文件</span><br><span class="line">server.1&#x3D;192.168.142.121:2888:3888</span><br><span class="line">server.2&#x3D;192.168.142.122:2888:3888</span><br><span class="line">server.3&#x3D;192.168.142.123:2888:3888</span><br><span class="line">server.4&#x3D;192.168.142.124:2888:3888</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul>
<li>每轮投票，每个节点维护自己的<strong>logicClock</strong>进行自增操作</li>
<li>初始化投票，通过广播把票投给自己</li>
<li>接收外部投票<ul>
<li>外部投票的<strong>logicClock</strong>大于自身，说明自身落后于其他节点的选举轮次，将票箱数据更改为外部投票数据并广播出去</li>
<li>外部投票的<strong>logicClock</strong>小于自身，说明自身选举轮次领先，忽略该外部投票</li>
<li>相等，进行投票PK<ul>
<li><strong>zxid</strong>大的优先，修改自己的数据广播出去</li>
<li><strong>zxid</strong>若相同，比较<strong>myid</strong>，小的优先，修改自己的数据广播出去</li>
</ul>
</li>
</ul>
</li>
<li>统计选票，当过半的节点认可自己的投票则终止投票，否则继续接受其他节点投票</li>
<li>更新节点状态，当过半的票投给自己，则修改状态为LEADING，否则修改为FOLLOWIN</li>
<li>数据同步<ul>
<li>follower将自己最大的zxid发送给新leader</li>
<li>新leader找出follower的zxid与自己zxid之间commit的数据同步给follower</li>
</ul>
</li>
<li>数据同步完毕后通知follower可以对外提供服务</li>
</ul>
<h1 id="四、Gossip"><a href="#四、Gossip" class="headerlink" title="四、Gossip"></a>四、Gossip</h1><p>一个节点想要分享一些信息给网络中的其他的一些节点。于是，它周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。</p>
<p>相比于Paxos、Raft、Zab等强一致性协议，Gossip可能会出现一段时间的不一致性，但会达到最终一致性。</p>
<h2 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h2><ul>
<li>固定周期，随机选择与它相连的N个节点传播消息</li>
<li>节点收到消息后，会在下一个周期选择除给它发消息外的其他相连节点传播消息。尽管需要一定时间，但是最终所有节点都拥有相同的消息</li>
</ul>
<h1 id="五、Distro"><a href="#五、Distro" class="headerlink" title="五、Distro"></a>五、Distro</h1><ul>
<li>nacos每个节点负责部分的写请求</li>
<li>每个节点会把自己负责的新增数据同步给其他节点</li>
<li>每个节点定时发送自己负责数据的校验值到其他节点来保持数据一致性</li>
<li>每个节点独立处理读请求</li>
<li>新加入的Distro节点会进行全量数据拉取（轮询所有节点发送请求拉取他们各自负责的数据）</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
        <category>共识性算法（一致性算法）</category>
      </categories>
      <tags>
        <tag>paxos</tag>
        <tag>raft</tag>
        <tag>zab</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-LCN</title>
    <url>/2021/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-LCN/</url>
    <content><![CDATA[<h2 id="LCN"><a href="#LCN" class="headerlink" title="LCN"></a><a href="https://github.com/codingapi/tx-lcn" target="_blank" rel="noopener">LCN</a></h2><p>Lock（锁定事务单元）、Confirm（确认事务）、Notify（通知事务）</p>
<p>TX-LCN定位于一款事务协调性框架，框架其本身并不操作事务，而是基于对事务的协调从而达到事务一致性的效果。</p>
<p><img src="/images/%E4%BA%8B%E5%8A%A1/LCN%E8%A7%92%E8%89%B2.jpg" alt=""></p>
<blockquote>
<p>TM：事务管理器</p>
<p>TC：事务客户端，相当于RM（资源管理器）</p>
</blockquote>
<a id="more"></a>

<h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ul>
<li>创建事务组<br>是指在事务发起方开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId的过程。</li>
<li>加入事务组<br>添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息通知给TxManager的操作。</li>
<li>通知事务组<br>是指在发起方执行完业务代码以后，将发起方执行结果状态通知给TxManager，TxManager将根据事务最终状态和事务组的信息来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方。</li>
</ul>
<p><img src="/images/%E4%BA%8B%E5%8A%A1/LCN%E9%80%9A%E8%BF%87%E6%8B%A6%E6%88%AA%E5%99%A8%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%BB%84id.jpg" alt=""></p>
<blockquote>
<p>调用链路中的TC通过拦截器获取请求头中的事务组id，封装到TracingContext中，当封装创建TxContext时，会从TracingContext中取出事务id，用于跟TM交互 </p>
</blockquote>
<h3 id="LCN事务模式"><a href="#LCN事务模式" class="headerlink" title="LCN事务模式"></a>LCN事务模式</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当本地事务提交回滚或者关闭连接时将会执行假操作（没有真正释放连接），该代理的连接将交由TM的LCN连接池管理，在全部TC响应结果后，TM异步通知TC们“提交”或者“回滚”。</p>
<ul>
<li>该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。</li>
<li>该模式缺陷在于代理的连接需要随事务发起方一共释放连接，增加了连接占用的时间。</li>
</ul>
<p><img src="/images/%E4%BA%8B%E5%8A%A1/LCN.jpg" alt=""></p>
<h4 id="TM-TxManager（事务管理器）"><a href="#TM-TxManager（事务管理器）" class="headerlink" title="TM-TxManager（事务管理器）"></a>TM-TxManager（事务管理器）</h4><p>集群模式下，直接启动多台TM</p>
<h5 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h5><p>数据库脚本位于txlcn-tm-5.0.2.RELEASE.jar包下的tx-manager.sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_tx_exception`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`group_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`unit_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`mod_id`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`transaction_state`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`registrar`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ex_state`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'0 待处理 1已处理'</span>,</span><br><span class="line">  <span class="string">`remark`</span> <span class="built_in">varchar</span>(<span class="number">10240</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime(<span class="number">0</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">967</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>

<h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tm--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi.txlcn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>txlcn-tm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi.txlcn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>txlcn-tc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi.txlcn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>txlcn-txmsg-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TM事务管理器的服务端WEB访问端口。提供一个可视化的界面。端口自定义。</span></span><br><span class="line"><span class="string">server.port=7970</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TM事务管理器，需要访问数据库，实现分布式事务状态记录。</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://localhost:3306/tx-manager?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TM事务管理器，是依赖Redis使用分布式事务协调的。尤其是TCC和TXC两种事务模型。</span></span><br><span class="line"><span class="string">spring.redis.host=127.0.0.1</span></span><br><span class="line"><span class="string">spring.redis.port=6379</span></span><br><span class="line"><span class="string">spring.redis.database=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为spring应用起名。</span></span><br><span class="line"><span class="string">spring.application.name=tx-lcn-transaction-manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TM事务管理器，提供的WEB管理平台的登录密码。无用户名。 默认是codingapi</span></span><br><span class="line"><span class="string">tx-lcn.manager.admin-key=msb</span></span><br><span class="line"><span class="comment"># 日志。如果需要TM记录日志。则开启，赋值为true，并提供后续的配置。</span></span><br><span class="line"><span class="string">tx-lcn.logger.enabled=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为日志功能，提供数据库连接。和之前配置的分布式事务管理依赖使用的数据源不同。</span></span><br><span class="line"><span class="string">tx-lcn.logger.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="string">tx-lcn.logger.jdbc-url=jdbc:mysql://localhost:3306/tx-manager?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="string">tx-lcn.logger.username=root</span></span><br><span class="line"><span class="string">tx-lcn.logger.password=root</span></span><br></pre></td></tr></table></figure>

<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagerServer</span></span><br></pre></td></tr></table></figure>



<h4 id="TC-TxClient（相当于RM资源管理器）"><a href="#TC-TxClient（相当于RM资源管理器）" class="headerlink" title="TC-TxClient（相当于RM资源管理器）"></a>TC-TxClient（相当于RM资源管理器）</h4><h5 id="pom-1"><a href="#pom-1" class="headerlink" title="pom"></a>pom</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi.txlcn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>txlcn-tc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi.txlcn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>txlcn-txmsg-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tx-lcn-order</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/tx_order?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"><span class="comment"># mybaits-plus配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/*Mapper.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8081/eureka</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#lcn事务管理器连接    </span></span><br><span class="line"><span class="attr">tx-lcn:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">manager-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8070</span> <span class="comment"># tm地址，多个tm以英文逗号分隔</span></span><br></pre></td></tr></table></figure>

<h5 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h5><p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDistributedTransaction</span></span><br></pre></td></tr></table></figure>

<p>业务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LcnTransaction</span></span><br></pre></td></tr></table></figure>



<h3 id="TCC事务模式"><a href="#TCC事务模式" class="headerlink" title="TCC事务模式"></a>TCC事务模式</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p> TCC事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。主要由三步操作，Try: 尝试执行业务、 Confirm:确认执行业务、 Cancel: 取消执行业务。</p>
<h4 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h4><p>上同</p>
<h4 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h4><h5 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h5><p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDistributedTransaction</span></span><br></pre></td></tr></table></figure>

<p>业务类，添加<code>@TccTransaction</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;orderName&#125;"</span>)</span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="meta">@TccTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">order</span><span class="params">(@PathVariable String orderName)</span> </span>&#123;</span><br><span class="line">    TxOrder order = <span class="keyword">new</span> TxOrder();</span><br><span class="line">    order.setOrderName(<span class="string">"tcc-order:"</span> + orderName);</span><br><span class="line">    orderService.save(order);</span><br><span class="line">    <span class="comment">//        System.out.println(1/0);</span></span><br><span class="line">    log.info(<span class="string">"tcc-order新增成功"</span>);</span><br><span class="line">    String payResult = restTemplate.getForObject(<span class="string">"http://tx-lcn-pay/tcc/pay/"</span> + orderName, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    log.info(<span class="string">"tcc-payResult ==&gt;"</span> + payResult);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"tcc-order新增成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * confirm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">confirmOrder</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"order confirm "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"新增订单成功-confirm"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cancel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cancelOrder</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"order cancel "</span>);</span><br><span class="line">    Map&lt;String, Object&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    columnMap.put(<span class="string">"order_name"</span>, <span class="string">"tcc-order:"</span> + orderName);</span><br><span class="line">    orderService.removeByMap(columnMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"新增订单成功-cancel"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式</category>
        <category>LCN</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-Seata</title>
    <url>/2021/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-seata/</url>
    <content><![CDATA[<h1 id="seata"><a href="#seata" class="headerlink" title="seata"></a><a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">seata</a></h1><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a><a href="http://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html" target="_blank" rel="noopener">server端</a></h2><h3 id="点击下载"><a href="#点击下载" class="headerlink" title="点击下载"></a><a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">点击下载</a></h3><h3 id="mysql-sql"><a href="#mysql-sql" class="headerlink" title="mysql-sql"></a><a href="https://github.com/seata/seata/tree/develop/script/server/db" target="_blank" rel="noopener">mysql-sql</a></h3><p>全局事务会话信息由3块内容构成，全局事务–&gt;分支事务–&gt;全局锁，对应表global_table、branch_table、lock_table</p>
<a id="more"></a>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is 'db' --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`distributed_lock`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`lock_key`</span>       <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`lock_value`</span>     <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`expire`</span>         <span class="built_in">BIGINT</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`lock_key`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`distributed_lock`</span> (lock_key, lock_value, <span class="keyword">expire</span>) <span class="keyword">VALUES</span> (<span class="string">'AsyncCommitting'</span>, <span class="string">' '</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`distributed_lock`</span> (lock_key, lock_value, <span class="keyword">expire</span>) <span class="keyword">VALUES</span> (<span class="string">'RetryCommitting'</span>, <span class="string">' '</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`distributed_lock`</span> (lock_key, lock_value, <span class="keyword">expire</span>) <span class="keyword">VALUES</span> (<span class="string">'RetryRollbacking'</span>, <span class="string">' '</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`distributed_lock`</span> (lock_key, lock_value, <span class="keyword">expire</span>) <span class="keyword">VALUES</span> (<span class="string">'TxTimeoutCheck'</span>, <span class="string">' '</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际操作中遇见<code>io.seata.core.exception.TmTransactionException: TransactionException[begin global request failed. xid=null, msg=Data truncation: Data too long for column &#39;transaction_service_group&#39; at row 1]</code>错误</p>
<p>global_table表的transaction_service_group字段在存放事务组名称“tx-seata-user-seata-service-group”时超过长度，手动调长了该字段长度</p>
</blockquote>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用.比如Seata Client端(TM,RM),发现Seata Server(TC)集群的地址,彼此通信.</p>
<p>启动包: seata–&gt;conf–&gt;registry.conf</p>
<p>file：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注册中心</span><br><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line">....</span><br><span class="line"> file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#配置中心</span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line">file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://seata.io/zh-cn/docs/user/registry/eureka.html" target="_blank" rel="noopener">eureka</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  type &#x3D; &quot;eureka&quot;</span><br><span class="line"> </span><br><span class="line">  eureka &#123;</span><br><span class="line">    #eureka地址</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;eureka&quot;</span><br><span class="line">    #当前seata-server服务名</span><br><span class="line">    application &#x3D; &quot;seata-server&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>放置着各种配置文件,你可以通过自己所需进行获取配置加载到对应的客户端.比如Seata Client端(TM,RM),Seata Server(TC),会去读取全局事务开关,事务会话存储模式等信息.</p>
<p>conf–&gt;file.conf，根据store.mode=”db或者redis”去加载存储于不同渠道的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## transaction log store, only used in seata-server</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db、redis</span><br><span class="line">  #mode &#x3D; &quot;file&quot;</span><br><span class="line">  mode &#x3D; &quot;db&quot;</span><br><span class="line">  ## rsa decryption public key</span><br><span class="line">  publicKey &#x3D; &quot;&quot;</span><br><span class="line">  ## file store property</span><br><span class="line">  file &#123;</span><br><span class="line">    ## store location dir</span><br><span class="line">    dir &#x3D; &quot;sessionStore&quot;</span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    maxBranchSessionSize &#x3D; 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    maxGlobalSessionSize &#x3D; 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    fileWriteBufferCacheSize &#x3D; 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    sessionReloadReadSize &#x3D; 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flushDiskMode &#x3D; async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store property</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp)&#x2F;HikariDataSource(hikari) etc.</span><br><span class="line">    datasource &#x3D; &quot;druid&quot;</span><br><span class="line">    ## mysql&#x2F;oracle&#x2F;postgresql&#x2F;h2&#x2F;oceanbase etc.</span><br><span class="line">    dbType &#x3D; &quot;mysql&quot;</span><br><span class="line">    driverClassName &#x3D; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    ## if using mysql to store the data, recommend add rewriteBatchedStatements&#x3D;true in jdbc connection param</span><br><span class="line">    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata?rewriteBatchedStatements&#x3D;true&quot;</span><br><span class="line">    user &#x3D; &quot;root&quot;</span><br><span class="line">    password &#x3D; &quot;123&quot;</span><br><span class="line">    minConn &#x3D; 5</span><br><span class="line">    maxConn &#x3D; 100</span><br><span class="line">    globalTable &#x3D; &quot;global_table&quot;</span><br><span class="line">    branchTable &#x3D; &quot;branch_table&quot;</span><br><span class="line">    lockTable &#x3D; &quot;lock_table&quot;</span><br><span class="line">    queryLimit &#x3D; 100</span><br><span class="line">    maxWait &#x3D; 5000</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## redis store property</span><br><span class="line">  redis &#123;</span><br><span class="line">    ## redis mode: single、sentinel</span><br><span class="line">    mode &#x3D; &quot;single&quot;</span><br><span class="line">    ## single mode property</span><br><span class="line">    single &#123;</span><br><span class="line">      host &#x3D; &quot;127.0.0.1&quot;</span><br><span class="line">      port &#x3D; &quot;6379&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ## sentinel mode property</span><br><span class="line">    sentinel &#123;</span><br><span class="line">      masterName &#x3D; &quot;&quot;</span><br><span class="line">      ## such as &quot;10.28.235.65:26379,10.28.235.65:26380,10.28.235.65:26381&quot;</span><br><span class="line">      sentinelHosts &#x3D; &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    database &#x3D; &quot;0&quot;</span><br><span class="line">    minConn &#x3D; 1</span><br><span class="line">    maxConn &#x3D; 10</span><br><span class="line">    maxTotal &#x3D; 100</span><br><span class="line">    queryLimit &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><ul>
<li><p>源码启动: 执行Server.java的main方法</p>
</li>
<li><p>命令启动: seata-server.sh -h 127.0.0.1 -p 8091 -m db -n 1 -e test</p>
<blockquote>
<p>-h: 注册到注册中心的ip<br>-p: Server rpc 监听端口<br>-m: 全局事务会话信息存储模式，file、db、redis，优先读取启动参数 (Seata-Server 1.3及以上版本支持redis)<br>-n: Server node，多个Server时，需区分各自节点，用于生成不同区间的transactionId，以免冲突<br>-e: 多环境配置参考 <a href="http://seata.io/en-us/docs/ops/multi-configuration-isolation.html" target="_blank" rel="noopener">http://seata.io/en-us/docs/ops/multi-configuration-isolation.html</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p> 高可用部署参考<a href="http://seata.io/zh-cn/docs/ops/deploy-ha.html" target="_blank" rel="noopener">http://seata.io/zh-cn/docs/ops/deploy-ha.html</a></p>
</blockquote>
<h3 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h3><p>Seata从0.6.1开始支持多配置隔离，假设我们现在有一个测试环境，在这个测试环境中，我们希望只读取与测试环境相对应的配置项。</p>
<h4 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h4><p>Seata提供了两种方法来设置不同的环境:<br><code>-e test</code>，其中test是环境的名称。(这只能用于服务器端)<br>例如(Linux)<br>Sh seata-server.sh -e test<br>使用SEATA_ENV作为环境变量的键，它的值将是环境的名称。(这只能用于客户端)[推荐]<br>例如(Linux)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/profile </span><br><span class="line"><span class="built_in">export</span> SEATA_ENV=<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>使用seataEnv作为jvm选项的键，它的值将是环境的名称。(这只能用于客户端)[推荐]<br><code>-DseataEnv=test</code></p>
<h4 id="2、为新配置文件命名"><a href="#2、为新配置文件命名" class="headerlink" title="2、为新配置文件命名"></a>2、为新配置文件命名</h4><p>将<code>file.conf</code>复制并重命名为<code>file-env.conf</code>，其中<code>env</code>是环境的名称。例如<code>file-test.conf</code><br>复制并重命名<code>registry.conf</code>到<code>registry-env.conf</code>，其中<code>env</code>是环境的名称。例如<code>registry-test.conf</code><br>在“registry-test.conf”文件中修改如下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">...</span><br><span class="line">file &#123;</span><br><span class="line">    name &#x3D; &quot;file-test.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">...</span><br><span class="line">file &#123;</span><br><span class="line">    name &#x3D; &quot;file-test.conf&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>设置完所有步骤后，就可以开始使用Seata配置隔离了。</p>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a><a href="http://seata.io/zh-cn/docs/dev/mode/at-mode.html" target="_blank" rel="noopener">AT模式</a></h3><p>两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源（与传统的2PC区别，一阶段不占用资源）。</li>
<li>二阶段：<ul>
<li>提交异步化，非常快速地完成。</li>
<li>回滚通过一阶段的回滚日志进行反向补偿。</li>
</ul>
</li>
</ul>
<h4 id="mysql-sql-1"><a href="#mysql-sql-1" class="headerlink" title="mysql-sql"></a><a href="https://github.com/seata/seata/tree/develop/script/client" target="_blank" rel="noopener">mysql-sql</a></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'branch transaction id'</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'global transaction id'</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'undo_log context,such as serialization'</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'rollback info'</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'0:normal status,1:defense status'</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'create datetime'</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'modify datetime'</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">'AT transaction mode undo table'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- seata --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注册中心-1"><a href="#注册中心-1" class="headerlink" title="注册中心"></a>注册中心</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application &#x3D; &quot;seata-server&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:6379&quot;</span><br><span class="line">    db &#x3D; 0</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    timeout &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout &#x3D; 6000</span><br><span class="line">    connectTimeout &#x3D; 2000</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">    aclToken &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:9603&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    region &#x3D; &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter &#x3D; &quot;DefaultDataCenter&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime &#x3D; &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="file模式（默认）"><a href="#file模式（默认）" class="headerlink" title="file模式（默认）"></a>file模式（默认）</h5><p>file加载模式：在在每个客户端的resource下增加<code>registry.conf</code>和<code>file.conf</code>文件</p>
<h5 id="eureka模式"><a href="#eureka模式" class="headerlink" title="eureka模式"></a><a href="http://seata.io/zh-cn/docs/user/registry/eureka.html" target="_blank" rel="noopener">eureka模式</a></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#客户端yml配置</span></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">seata-server</span> <span class="comment"># 此处配置对应Server端配置registry.eureka.application的值</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">eureka</span></span><br><span class="line">    <span class="attr">eureka:</span></span><br><span class="line">      <span class="attr">service-url:</span> <span class="string">http://localhost:8081/eureka</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a href="http://seata.io/zh-cn/docs/user/registry/nacos.html" target="_blank" rel="noopener">nacos模式</a></p>
<h4 id="配置中心-1"><a href="#配置中心-1" class="headerlink" title="配置中心"></a>配置中心</h4><p><code>registry.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    dataId &#x3D; &quot;seataServer.properties&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">    aclToken &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    appId &#x3D; &quot;seata-server&quot;</span><br><span class="line">    ## apolloConfigService will cover apolloMeta</span><br><span class="line">    apolloMeta &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8801&quot;</span><br><span class="line">    apolloConfigService &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8080&quot;</span><br><span class="line">    namespace &#x3D; &quot;application&quot;</span><br><span class="line">    apolloAccesskeySecret &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;seata&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    sessionTimeout &#x3D; 6000</span><br><span class="line">    connectTimeout &#x3D; 2000</span><br><span class="line">    username &#x3D; &quot;&quot;</span><br><span class="line">    password &#x3D; &quot;&quot;</span><br><span class="line">    nodePath &#x3D; &quot;&#x2F;seata&#x2F;seata.properties&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>file.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  # the client batch send request enable</span><br><span class="line">  enableClientBatchSendRequest &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  threadFactory &#123;</span><br><span class="line">    bossThreadPrefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    workerThreadPrefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    serverExecutorThread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    shareBossWorker &#x3D; false</span><br><span class="line">    clientSelectorThreadPrefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    clientSelectorThreadSize &#x3D; 1</span><br><span class="line">    clientWorkerThreadPrefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    bossThreadSize &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    workerThreadSize &#x3D; &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  #transaction service group mapping</span><br><span class="line">  vgroupMapping.my_test_tx_group &#x3D; &quot;default&quot;</span><br><span class="line">  #only support when registry.type&#x3D;file, please don&#39;t set multiple addresses</span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade, current not support</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  #disable seata</span><br><span class="line">  disableGlobalTransaction &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  rm &#123;</span><br><span class="line">    asyncCommitBufferLimit &#x3D; 10000</span><br><span class="line">    lock &#123;</span><br><span class="line">      retryInterval &#x3D; 10</span><br><span class="line">      retryTimes &#x3D; 30</span><br><span class="line">      retryPolicyBranchRollbackOnConflict &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    reportRetryCount &#x3D; 5</span><br><span class="line">    tableMetaCheckEnable &#x3D; false</span><br><span class="line">    reportSuccessEnable &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">  tm &#123;</span><br><span class="line">    commitRetryCount &#x3D; 5</span><br><span class="line">    rollbackRetryCount &#x3D; 5</span><br><span class="line">  &#125;</span><br><span class="line">  undo &#123;</span><br><span class="line">    dataValidation &#x3D; true</span><br><span class="line">    logSerialization &#x3D; &quot;jackson&quot;</span><br><span class="line">    logTable &#x3D; &quot;undo_log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  log &#123;</span><br><span class="line">    exceptionRate &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="file模式（默认）-1"><a href="#file模式（默认）-1" class="headerlink" title="file模式（默认）"></a>file模式（默认）</h5><p>file加载模式：在在每个客户端的resource下增加<code>registry.conf</code>和<code>file.conf</code>文件</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>加载需要控制的业务方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>



<h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>相关配置参照AT模式，TCC模式不依赖于底层数据资源的事务支持。</p>
<ul>
<li>一阶段 prepare 行为：调用 <strong>自定义</strong> 的 prepare 逻辑。</li>
<li>二阶段 commit 行为：调用 <strong>自定义</strong> 的 commit 逻辑。</li>
<li>二阶段 rollback 行为：调用 <strong>自定义</strong> 的 rollback 逻辑。</li>
</ul>
<p>所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>业务入口,添加<code>@GlobalTransactional</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@GetMapping("/add")</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">atUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userService.rmUser(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"tcc新增用户成功"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务接口层，维护tcc各阶段逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RmUserInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction</span>(name = <span class="string">"rmUserInterface"</span> , commitMethod = <span class="string">"rmUserCommit"</span> ,rollbackMethod = <span class="string">"rmUserRollback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rmUser</span><span class="params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rmUserCommit</span><span class="params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rmUserRollback</span><span class="params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跨服务之间调用的事务保证实现方式一致。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>Seata</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-多种理论模式</title>
    <url>/2021/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><h3 id="第一阶段（提交事务）"><a href="#第一阶段（提交事务）" class="headerlink" title="第一阶段（提交事务）"></a>第一阶段（提交事务）</h3><ul>
<li><p>事务询问</p>
<p>TM向所有的RM询问是否可以执行提交操作，并开始等待RM的响应。</p>
</li>
<li><p>预执行事务</p>
<p>RM预提交当前所有事务操作，并将相关信息写入Undo和Redo日志</p>
</li>
<li><p>事务反馈</p>
<p>RM提交事务后响应TM的询问。如果所有RM都提交成功，则返回一个“同意”消息；如果任一RM提交失败，则返回TM“终止”消息。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="第二阶段（执行事务）"><a href="#第二阶段（执行事务）" class="headerlink" title="第二阶段（执行事务）"></a>第二阶段（执行事务）</h3><ul>
<li><p>提交</p>
<p>当TM从所有RM获得的响应都为“同意”时，向所有RM发送“正式提交（commot）”的请求。</p>
</li>
<li><p>回滚</p>
<p>当TM接收到任一RM的“终止消息”时，向所有RM发送“回滚操作（rollback）”的请求；</p>
<p>RM利用之前写入Undo Log的日志进行回滚，并释放整个事务占用的资源。</p>
</li>
</ul>
<blockquote>
<p>定义：TM：事务管理器、RM：资源管理器</p>
<p>总结：第一阶段预提交事务，当有RM出错后，TM于第二阶段通知所有RM回滚预提交事务。</p>
<p>2PC可能出现的问题<br>    1、第一阶段持有连接未释放，占用资源高<br>    2、第一阶段预提交成功之后，在第二阶段RM的执行失败，无法进行回滚  </p>
</blockquote>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><h3 id="第一阶段（can-commit）"><a href="#第一阶段（can-commit）" class="headerlink" title="第一阶段（can commit）"></a>第一阶段（can commit）</h3><ul>
<li><p>询问是否能够提交</p>
<p>TM 向RM询问是否能够提交，RM全部响应“YES”后才进入第二阶段</p>
</li>
</ul>
<h3 id="第二阶段（pre-commit）"><a href="#第二阶段（pre-commit）" class="headerlink" title="第二阶段（pre commit）"></a>第二阶段（pre commit）</h3><ul>
<li><p>事务的预提交 </p>
<p>​    与2PC的第一阶段类似，进行事务的预提交 </p>
</li>
</ul>
<h3 id="第三阶段（do-commit-）"><a href="#第三阶段（do-commit-）" class="headerlink" title="第三阶段（do commit ）"></a>第三阶段（do commit ）</h3><ul>
<li>集体提交</li>
<li>集体回滚</li>
</ul>
<blockquote>
<p>定义：TM：事务管理器、RM：资源管理器</p>
<p>总结：<br>1、增加了can commit阶段，降低锁定资源的概率和时长（当RM异常的时候，无需像2PC一样一开始就锁定，而是确认RM都正常的情况下才执行预提交，锁定资源）<br>2、增加超时机制<br>    2.1、TM超时未抽到RM的反馈，主动给RM发送中断命令<br>    2.2、RM在第三阶段超时未收到TM命令，默认提交</p>
</blockquote>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><h3 id="Try-尝试执行业务"><a href="#Try-尝试执行业务" class="headerlink" title="Try: 尝试执行业务"></a>Try: 尝试执行业务</h3><h3 id="Confirm-确认执行业务"><a href="#Confirm-确认执行业务" class="headerlink" title="Confirm:确认执行业务"></a>Confirm:确认执行业务</h3><h3 id="Cancel-取消执行业务"><a href="#Cancel-取消执行业务" class="headerlink" title="Cancel: 取消执行业务"></a>Cancel: 取消执行业务</h3><p>具体实现参见<a href="https://yrlzero.gitee.io/2021/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-LCN/" target="_blank" rel="noopener">LCN</a>、<a href="https://yrlzero.gitee.io/2021/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-seata/" target="_blank" rel="noopener">SEATA</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="幂等性处理"><a href="#幂等性处理" class="headerlink" title="幂等性处理"></a>幂等性处理</h4><p>因为网络抖动等原因，分布式事务框架可能会<strong>重复调用同一个分布式事务中的一个分支事务的二阶段接口(Confirm/Cancel)</strong>。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性。如果二阶段接口不能保证幂等性，则会产生严重的问题，造成资源的重复使用或者重复释放，进而导致业务故障。</p>
<h4 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h4><p>当<code>没有</code>调用参与方<code>Try</code>方法的情况下，就<code>调用</code>了二阶段的<code>Cancel</code>方法，Cancel方法需要有办法识别出此时Try有没有执行。如果Try还没执行，表示这个Cancel操作是无效的，即本次Cancel属于空回滚；如果Try已经执行，那么执行的是正常的回滚逻辑</p>
<p>总而言之，Try方法没有执行成功，然而此时这笔分布式事务和分支事务已经落库。有两种情况会触发分布式事务的回滚：</p>
<ol>
<li>发起方认为当前分布式事务无法成功，主动通知TC回滚</li>
<li>TC发现分布式事务超时，被动触发回滚</li>
</ol>
<h4 id="资源悬挂"><a href="#资源悬挂" class="headerlink" title="资源悬挂"></a>资源悬挂</h4><p>Cannel在Try之前执行</p>
<p>这种一阶段比二阶段执行的还晚的情况看似不可能，但是仔细考虑RPC调用的时序，其实这种情况在复杂多变的网络中是完全可能的，下面的时序展示了这种可能性：</p>
<ol>
<li>发起方通过RPC调用参与者一阶段Try，但是发生网络阻塞导致RPC超时</li>
<li>RPC超时后，TC会回滚分布式事务(可能是发起方主动通知TC回滚或者是TC发现事务超时后回滚)，调用已注册的各个参与方的二阶段Cancel</li>
<li>参与方空回滚后，发起方对参与者的一阶段Try才开始执行，进行资源预留从而形成悬挂</li>
</ol>
<h3 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h3><p>增加事件处理表，通过<code>主事务ID</code>、<code>分支事务ID</code>、<code>分支事务处理状态（try、confirm、cancel三个状态）</code>进行数据控制</p>
<p>幂等性处理：第二阶段进行事件表状态判断，第一阶段状态已执行的情况下，才执行第二阶段；第二阶段已经存在的情况下，不重复执行</p>
<p>空回滚：在执行第二阶段之前，对第一阶段是否执行进行判断</p>
<p>资源悬挂：通过事件状态进行控制，没有第一阶段状态时，第二阶段不执行具体业务逻辑；插入第二阶段记录，等待第一阶段到来时，判断到第二阶段状态时不处理</p>
<h2 id="消息队列-事件表"><a href="#消息队列-事件表" class="headerlink" title="消息队列+事件表"></a>消息队列+事件表</h2><p>当一个请求涉及到多个微服务系统时，可以采取消息队列加事件表的形式进行处理。</p>
<img src="/images/事务/消息队列+本地事物表.jpg" style="zoom: 150%;" />

<p>以接收第三方支付回调请求，更新支付流水记录、订单状态为例：</p>
<h3 id="支付系统"><a href="#支付系统" class="headerlink" title="支付系统"></a>支付系统</h3><ul>
<li><p>接收第三方请求，处理本地事务</p>
</li>
<li><p>插入支付事件到事件表，状态为“新建”</p>
<blockquote>
<p>当前两个动作为一个事务，当处理失败一起回滚后，返回错误响应给第三方，等待第三方再次调起（支付回调接口有多次重试机制）</p>
</blockquote>
</li>
</ul>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><ul>
<li><p>查询事件表，“新建”状态的支付事件</p>
</li>
<li><p>更新时间表状态为“已发送”</p>
</li>
<li><p>发送消息到消息队列</p>
<blockquote>
<p>当前三个动作为一个事务，消息发送失败可以让事务回滚，该“新建”时间等待下一次定时任务周期调起处理</p>
</blockquote>
</li>
</ul>
<h3 id="订单系统"><a href="#订单系统" class="headerlink" title="订单系统"></a>订单系统</h3><ul>
<li><p>消息监听者消费消息</p>
</li>
<li><p>将消息插入事件表，状态为“已接收”，同时解决幂等性问题（业务key唯一索引）</p>
<blockquote>
<p>当前几个动作为一个事务，失败回滚，同时响应给mq，让其重试</p>
<p>事件表唯一键冲突时，提交消息，不让mq重试</p>
</blockquote>
</li>
</ul>
<h3 id="定时任务-1"><a href="#定时任务-1" class="headerlink" title="定时任务"></a>定时任务</h3><ul>
<li><p>查询“已接收”状态的事件进行</p>
</li>
<li><p>根据事件处理本地事务</p>
</li>
<li><p>修改事件状态为“已处理”</p>
<blockquote>
<p>当前几个动作为一个事务，失败回滚，该“已接收”状态事件等待下一次定时任务周期调起处理</p>
</blockquote>
</li>
</ul>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>参见<a href="https://yrlzero.gitee.io/2021/07/31/rocketmq%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/#6-4%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF" target="_blank" rel="noopener">rocketmq事务消息章节</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>多种理论模式</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>四种引用-强软弱虚</title>
    <url>/2020/12/12/%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A/</url>
    <content><![CDATA[<h2 id="一、强引用"><a href="#一、强引用" class="headerlink" title="一、强引用"></a>一、强引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</span><br><span class="line">在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。</span><br><span class="line">当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，及时该对象以后永远都不会被用到jvm也不会回收。</span><br><span class="line">因此强引用时造成java内存泄露的主要原因之一。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="二、软引用"><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一种相对强引用弱化了一些的引用，需要java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</span><br><span class="line">当系统内存充足时，它不会被回收，当系统内存不足时，会被回收。</span><br><span class="line">通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用时候就保留，不够用就回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如有一个应用需要读取大量的本地图片,如果每次读取图片都从硬盘读取则会严重影响性能,如果一次性全部加载到内存中有可能造成内存溢出</span><br><span class="line"></span><br><span class="line">此时可以使用软引用解决这个问题。</span><br><span class="line">思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，</span><br><span class="line">在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM的问题。</span><br><span class="line">Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="三、弱引用"><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.WeakReference类来实现。</span><br><span class="line">它比软引用的生存期更短，只要垃圾回收机制一运行，不管内存空间是否充足，都会被回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;M&gt; tl &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">tl.set(new M());</span><br><span class="line">tl.remove();</span><br><span class="line"></span><br><span class="line">ThreadLocal的应用中，每个线程有自己的ThreadLocalMap，根据ThreadLocal对象找到其对应的值。</span><br><span class="line">ThreadLocalMap里面存放的Entry继承了WeakReference，当创建Entry是会调用super(key)方法进行创建，key指向tl对象，也就是说这个key是一个弱引用。</span><br><span class="line">若是强引用，即使tl&#x3D;null,但是key的引用依然指向ThreadLocal对象，只要ThreadLocalMap在就不会被回收，所以会有内存泄漏，而是用弱引用则不会。</span><br><span class="line">当tl没有额外的强引用指向时，即使key引用了tl，因为key是弱引用，遇到GC时tl也会开始回收。</span><br><span class="line"></span><br><span class="line">注意：当key被回收时，无法根据key找到对应的value，只要ThreadLocalMap在就不会被回收，也会存在泄漏，所以必须使用tl.remove()进行移除</span><br></pre></td></tr></table></figure>

<h2 id="四、虚引用"><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.PhantomRefrnce类来实现，如果一个对象仅持有虚引用，那么它和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</span><br><span class="line">它不能单独使用，也不能单独访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</span><br><span class="line">主要作用是跟踪对象被垃圾回收的状态，提供一种确保对象被finalize以后做某些事情的机制，一般是来管理堆外内存的。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NIO有个DirectByteBuffer是用来操作堆外内存的，堆外内存由操作系统管理，gc无法回收，当DirectByteBuffer为null时，可以通过虚引用的方式检测到，此时Reference&lt;? extends M&gt; poll &#x3D; QUEUE.poll();可以获得GC回收的通知，进而去执行自定义的逻辑清理堆外内存。</span><br><span class="line"></span><br><span class="line">堆外内存操作：</span><br><span class="line">Unsafe类</span><br><span class="line">	&#x2F;&#x2F;分配内存</span><br><span class="line">	public long allocateMemory(long bytes)&#123;</span><br><span class="line">		return theInternalUnsafe.allocateMemory(bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;回收内存</span><br><span class="line">	public void freeMemory(long address)&#123;</span><br><span class="line">		theInternalUnsafe.freeMemory(address);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>强软弱虚</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池-基本概念</title>
    <url>/2020/12/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="一、常见线程池"><a href="#一、常见线程池" class="headerlink" title="一、常见线程池"></a>一、常见线程池</h2><h3 id="1-Executors-newFixedThreadPool"><a href="#1-Executors-newFixedThreadPool" class="headerlink" title="1.Executors.newFixedThreadPool()"></a>1.Executors.newFixedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值是相等的，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造方法</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-Executors-newSingleThreadExecutor"><a href="#2-Executors-newSingleThreadExecutor" class="headerlink" title="2.Executors.newSingleThreadExecutor()"></a>2.Executors.newSingleThreadExecutor()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值为1，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造</span><br><span class="line">	return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure>

<h3 id="3-Executors-newCachedThreadPool"><a href="#3-Executors-newCachedThreadPool" class="headerlink" title="3.Executors.newCachedThreadPool()"></a>3.Executors.newCachedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程corePoolSize的值为0，maximumPoolSize的值为Integer,MAX_VALUE，使用的队列是SynchronousQueue。有任务时就创建线程运行，当线程空闲60s就销毁线程</span><br><span class="line">构造</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="二、线程池底层调用"><a href="#二、线程池底层调用" class="headerlink" title="二、线程池底层调用"></a>二、线程池底层调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line">--&gt; 调用自身七参构造方法public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br><span class="line">	 int corePoolSize:线程池中常驻核心线程数</span><br><span class="line">	 int maximumPoolSize：线程池能够容纳同时执行你的最大线程数，此值必须大于等于1</span><br><span class="line">	 long keepAliveTime：多余的空闲线程存活时间，当前线程池超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止</span><br><span class="line">	 TimeUnit unit：keepAliveTime的单位</span><br><span class="line">	 BlockingQueue&lt;Runnable&gt; workQueue：任务队列，被提交但尚未被执行的任务</span><br><span class="line">	 ThreadFactory threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认即可</span><br><span class="line">	 RejectedExecutionHandler handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize）时如何来拒绝</span><br></pre></td></tr></table></figure>

<h2 id="三、线程池底层原理"><a href="#三、线程池底层原理" class="headerlink" title="三、线程池底层原理"></a>三、<a href="https://yrlzero.gitee.io/2021/05/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/#1%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6" target="_blank" rel="noopener">线程池底层原理</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）在创建了线程池后，等待提交过来的任务请求</span><br><span class="line">2）当调用execute()方法添加一个请求任务时，线程会做如下判断</span><br><span class="line">	2.1）如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</span><br><span class="line">	2.2）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</span><br><span class="line">	2.3）如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</span><br><span class="line">	2.4）如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</span><br><span class="line">3）当一个线程完成任务时，它会从队列中取下一个任务来执行</span><br><span class="line">4）当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</span><br><span class="line">	4.1) 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</span><br><span class="line">	4.2）所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小</span><br></pre></td></tr></table></figure>

<h2 id="四、线程池拒绝策略"><a href="#四、线程池拒绝策略" class="headerlink" title="四、线程池拒绝策略"></a>四、线程池拒绝策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行</span><br><span class="line"></span><br><span class="line">CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低任务流量</span><br><span class="line"></span><br><span class="line">DiscardOldestPolicy:抛弃任务中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</span><br><span class="line"></span><br><span class="line">DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案</span><br></pre></td></tr></table></figure>

<h2 id="五、自定义创建线程"><a href="#五、自定义创建线程" class="headerlink" title="五、自定义创建线程"></a>五、自定义创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">		<span class="number">2</span>,</span><br><span class="line">		<span class="number">5</span>,</span><br><span class="line">		<span class="number">1L</span>,</span><br><span class="line">		TimeUnit.SECONDS,</span><br><span class="line">		<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">		Executors.defaultThreadFactory(),</span><br><span class="line">		<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么不能使用常见的这三个线程池？</span><br><span class="line">因为newFixedThreadPool和newSingleThreadExecutor允许创建的队列长度Integer.MAX_VALUE，长度为21亿，可能会堆积大量请求，容易造成OOM；</span><br><span class="line">而newCachedThreadPool 和 newScheduledThreadPool允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，容易造成OOM</span><br><span class="line"></span><br><span class="line">如何设置线程数？</span><br><span class="line">CPU密集型，该任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量，CPU核数+1个线程（经验值，用于补充中间可能涉及的IO耗时）。</span><br><span class="line">IO密集型 与CPU密集型相对，一个完整请求，CPU运算操作完成之后还有很多IO操作，IO操作占比很多大，等待时间较长；线程等待时间所占比例越高，需要的线程越多；</span><br><span class="line">	由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，</span><br><span class="line">	1.常见公式，如果几乎都是IO耗时，那么CPU耗时无限趋近于0：CPU核数*2或者CPU核数*2+1经（验值，用于补充中间可能涉及的IO耗时）</span><br><span class="line">	2. 最佳线程数&#x3D;CPU核心数*(1&#x2F;CPU利用率)&#x3D;CPU核心数*(1+(IO耗时&#x2F;CPU耗时))</span><br><span class="line"></span><br><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</span><br><span class="line">的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line">说明： Executors 返回的线程池对象的弊端如下：</span><br><span class="line">	1） FixedThreadPool 和 SingleThreadPool :</span><br><span class="line">			允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。</span><br><span class="line">	2） CachedThreadPool 和 ScheduledThreadPool :</span><br><span class="line">			允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端推送</title>
    <url>/2022/02/07/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="一、短轮询"><a href="#一、短轮询" class="headerlink" title="一、短轮询"></a>一、短轮询</h1><p>客户端使用定时器不停向服务端发送请求</p>
<p>短轮询实现简单，但频繁请求，消耗带宽，耗费服务器资源</p>
<h1 id="二、长轮询"><a href="#二、长轮询" class="headerlink" title="二、长轮询"></a>二、长轮询</h1><p>当没有数据时，服务端不返回请求，挂起请求，等待数据处理完毕才返回。</p>
<p>长轮询使得HTTP请求变成一个长连接，长时间没有响应可能触发超时等错误，需要额外策略处理，实现比短轮询复杂</p>
<h2 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h2><p>spring基于 Servlet 3.0提供了DeferredResult ，可以实现对于请求的异步处理，释放容器连接，支持更高并发。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/deferredResultUser"</span>)</span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;ResponseEntity&lt;List&lt;User&gt;&gt;&gt; deferredResultListUser() &#123;</span><br><span class="line">    <span class="comment">//创建延迟返回结果对象</span></span><br><span class="line">    DeferredResult&lt;ResponseEntity&lt;List&lt;User&gt;&gt;&gt; deferredResult =</span><br><span class="line">        <span class="keyword">new</span> DeferredResult&lt;&gt;(<span class="comment">/*超时时间，单位毫秒*/</span><span class="number">20000L</span>,<span class="comment">/*超时返回的结果数据*/</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_MODIFIED));</span><br><span class="line">    </span><br><span class="line">    deferredResult.onTimeout(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"调用超时"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"调用完成"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步处理逻辑</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//当调用setResult时，响应客户端请求</span></span><br><span class="line">            deferredResult.setResult(<span class="keyword">new</span> ResponseEntity&lt;&gt;(userService.listUser(), HttpStatus.OK));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挂起请求释放tomcat容器线程，直到调用setResult或者超时</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、SSE"><a href="#三、SSE" class="headerlink" title="三、SSE"></a>三、SSE</h1><p>基于HTTP无法做到服务器主动向客户端推送数据，SSE使用了一种变通的方式，不返回一次性的数据包，而是一个数据流，数据不断的像客户端发送，客户端不会关闭连接。</p>
<p>SSE方式的推送是单向的，由服务端不断的流向客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/sse"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SseEmitter <span class="title">sse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SseEmitter emitter = <span class="keyword">new</span> SseEmitter();</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                emitter.send(<span class="string">"123"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">                emitter.send(<span class="string">"456"</span>);</span><br><span class="line">                emitter.complete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、Websoket"><a href="#四、Websoket" class="headerlink" title="四、Websoket"></a>四、Websoket</h1><p>WebSocket 相对于SSE来说，它可以双向通讯。</p>
<p>其借助Http(s)完成握手，再升级为websoket协议进行通讯操作</p>
<h2 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h2><p>WebSocket是个规范，在实际的实现中有HTML5规范中的WebSocket API、WebSocket的子协议STOMP。</p>
<p>STOMP(Simple Text Oriented Messaging Protocol)</p>
<ul>
<li>是一个简单文本定向消息协议</li>
<li>分为生产者（发送消息）、消息代理、消费者（订阅消费）</li>
</ul>
<p>依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-websocket&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订阅消息</span></span><br><span class="line"><span class="comment">//通过stompClient.subscribe订阅目标(destination)发送的消息（广播接收信息）</span></span><br><span class="line">stompClient.subscribe(<span class="string">'/mass/getResponse'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> message=<span class="built_in">JSON</span>.parse(response.body);</span><br><span class="line">	....</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">stompClient.send(<span class="string">"/massRequest"</span>,&#123;&#125;,<span class="built_in">JSON</span>.stringify(postValue));</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">/*开启使用Stomp协议来传输基于消息broker的消息</span></span><br><span class="line"><span class="comment">这时控制器支持使用@MessageMapping,就像使用@RequestMapping一样*/</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*注册STOMP协议的节点(endpoint),并映射指定的url,</span></span><br><span class="line"><span class="comment">        * 添加一个访问端点“/endpointMark”,客户端打开双通道时需要的url,</span></span><br><span class="line"><span class="comment">        * 允许所有的域名跨域访问，指定使用SockJS协议。*/</span></span><br><span class="line">        registry.addEndpoint(<span class="string">"/endpointMark"</span>)</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*配置一个消息代理(内存中的消息队列)*/</span></span><br><span class="line">        registry.enableSimpleBroker(</span><br><span class="line">                <span class="string">"/mass"</span>,<span class="string">"/queue"</span>);</span><br><span class="line">        registry.setUserDestinationPrefix(<span class="string">"/queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息群发，接受发送至自massRequest的请求*/</span></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/massRequest"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/mass/getResponse"</span>)</span><br><span class="line"><span class="comment">//SendTo 发送至 Broker 下的指定订阅路径mass ,</span></span><br><span class="line"><span class="comment">// Broker再根据getResponse发送消息到订阅了/mass/getResponse的用户处</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChatRoomResponse <span class="title">mass</span><span class="params">(ChatRoomRequest chatRoomRequest)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"name = "</span> + chatRoomRequest.getName());</span><br><span class="line">	System.out.println(<span class="string">"chatValue = "</span> + chatRoomRequest.getChatValue());</span><br><span class="line">	ChatRoomResponse response=<span class="keyword">new</span> ChatRoomResponse();</span><br><span class="line">	response.setName(chatRoomRequest.getName());</span><br><span class="line">	response.setChatValue(chatRoomRequest.getChatValue());</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>配置centos固定ip</title>
    <url>/2020/11/29/%E9%85%8D%E7%BD%AEcentos%E5%9B%BA%E5%AE%9Aip/</url>
    <content><![CDATA[<h2 id="a-修改-etc-sysconfig-network配置文件："><a href="#a-修改-etc-sysconfig-network配置文件：" class="headerlink" title="a. 修改/etc/sysconfig/network配置文件："></a>a. 修改/etc/sysconfig/network配置文件：</h2><p>vi /etc/sysconfig/network</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Created by anaconda</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件："><a href="#b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件：" class="headerlink" title="b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件："></a>b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件：</h2><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line"></span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">IPADDR&#x3D;192.168.243.131</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line"></span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">UUID&#x3D;193e7f5e-e25b-40ef-b292-0fe5c8970af5</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">ZONE&#x3D;public</span><br><span class="line"></span><br><span class="line">DNS1&#x3D;8.8.8.8</span><br><span class="line">DNS2&#x3D;4.2.2.2</span><br></pre></td></tr></table></figure>

<h2 id="c-重启网关"><a href="#c-重启网关" class="headerlink" title="c. 重启网关:"></a>c. 重启网关:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>线程池-执行原理</title>
    <url>/2021/05/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>Java中的线程池核心实现类是<code>ThreadPoolExecutor</code>。</p>
<img src="/images/多线程/接口父类.jpg" style="zoom: 80%;" />

<a id="more"></a>

<h3 id="顶级接口Executor"><a href="#顶级接口Executor" class="headerlink" title="顶级接口Executor"></a>顶级接口<code>Executor</code></h3><ul>
<li>顶层接口<code>Executor</code>提供了一种思想：将任务提交和任务执行进行解耦。</li>
<li>用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到<code>执行器(Executor)</code>中，由<code>Executor</code>框架完成线程的调配和任务的执行部分。</li>
</ul>
<h3 id="接口ExecutorService"><a href="#接口ExecutorService" class="headerlink" title="接口ExecutorService"></a>接口<code>ExecutorService</code></h3><p>​    接口增加了一些能力：</p>
<ul>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法。</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ul>
<h3 id="抽象类AbstractExecutorService"><a href="#抽象类AbstractExecutorService" class="headerlink" title="抽象类AbstractExecutorService"></a>抽象类<code>AbstractExecutorService</code></h3><p>​        上层的抽象类：</p>
<ul>
<li>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</li>
</ul>
<h3 id="实现类ThreadPoolExecutor"><a href="#实现类ThreadPoolExecutor" class="headerlink" title="实现类ThreadPoolExecutor"></a>实现类<code>ThreadPoolExecutor</code></h3><p>​        实现最复杂的运行部分：</p>
<ul>
<li>ThreadPoolExecutor将会一方面维护自身的生命周期。</li>
<li>另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>​        线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadpoolexecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>​        线程池的运行主要分成两部分：任务管理、线程管理。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p>
<ul>
<li>（1）直接申请线程执行该任务；</li>
<li>（2）缓冲到队列中等待线程执行；</li>
<li>（3）拒绝该任务。</li>
</ul>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<hr>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><p>​        线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。</p>
<p>线程池内部使用变量<code>ctl</code>来维护两个值：<code>runState</code>(运行状态，使用ctl的高3位来维护)、<code>workerCount</code>(线程数量，使用ctl的低29位来维护)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量，<code>ThreadPoolExecutor</code>提供了如下变量和方法以供操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer.SIZE = 32</span></span><br><span class="line"><span class="comment">//29，基础操作位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; </span><br><span class="line"><span class="comment">// 工作线程容量大小</span></span><br><span class="line"><span class="comment">// 左位移29位再减一，保证高3位为0，低29位为1，</span></span><br><span class="line"><span class="comment">// 二进制：0001 1111 1111 1111 1111 1111 1111 1111; 十进制：536870911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// runState存储在高位的状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"><span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//通过状态和线程数生成ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="runState"><a href="#runState" class="headerlink" title="runState"></a><code>runState</code></h3><p>标识线程池运行状态，使用<code>ctl</code>变量的高3位来保存。</p>
<p>runState提供主要的生命周期控制，主要状态如下：</p>
<table>
<thead>
<tr>
<th align="left">运行状态</th>
<th align="left">数值</th>
<th align="left">状态描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行（RUNNING）</td>
<td align="left">-1 &lt;&lt; 29</td>
<td align="left">能接受新任务，并处理排队的任务</td>
</tr>
<tr>
<td align="left">关机（SHUTDOWN）</td>
<td align="left">0 &lt;&lt; 29</td>
<td align="left">不接受新任务，但可以继续处理队列中的任务</td>
</tr>
<tr>
<td align="left">停止（STOP）</td>
<td align="left">1 &lt;&lt; 29</td>
<td align="left">不接受新任务，也不会处理排队的任务，并且中断正在进行的任务</td>
</tr>
<tr>
<td align="left">整理（TIDYING）</td>
<td align="left">2 &lt;&lt; 29</td>
<td align="left">所有任务已终止，workerCount为零，线程转换为TIDYING状态之后将运行terminate（）方法(钩子方法)</td>
</tr>
<tr>
<td align="left">终止（TERMINATED）</td>
<td align="left">3 &lt;&lt; 29</td>
<td align="left">在terminated（）方法执行，进入此状态，在awaitTermination（）中等待的线程将返回</td>
</tr>
</tbody></table>
<p>以上的状态是数值有序的，可以进行有序的比较，RUNNING最小，TERMINATED最大，但不必达到每个状态，变化如下图：</p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/runState%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpg" alt=""></p>
<blockquote>
<p>1、RUNNING -&gt; SHUTDOWN：在调用shutdown（）时，可能隐式在finalize（）中使用</p>
<p>2、(RUNNING or SHUTDOWN) -&gt; STOP：在调用shutdownNow（）时</p>
<p>3、SHUTDOWN -&gt; TIDYING：当队列和有效工作线程都为空时</p>
<p>4、STOP -&gt; TIDYING：有效工作线程都为空时</p>
<p>5、TIDYING -&gt; TERMINATED：当terminate（）调用完成时</p>
</blockquote>
<h3 id="workerCount"><a href="#workerCount" class="headerlink" title="workerCount"></a><code>workerCount</code></h3><p>指线程池当前工作的有效线程数，使用<code>ctl</code>变量的低29位保存。所以workerCount限制约为5亿（2 ^ 29-1）个线程。</p>
<h2 id="三、执行流程"><a href="#三、执行流程" class="headerlink" title="三、执行流程"></a>三、执行流程</h2><h3 id="1、任务调度"><a href="#1、任务调度" class="headerlink" title="1、任务调度"></a>1、任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-01.jpg" alt=""></p>
<h3 id="2、任务申请"><a href="#2、任务申请" class="headerlink" title="2、任务申请"></a>2、任务申请</h3><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h4 id="execute-提交Runnable任务"><a href="#execute-提交Runnable任务" class="headerlink" title="execute-提交Runnable任务"></a>execute-提交Runnable任务</h4><p>调用<code>ThreadPoolExecutor</code>的<code>execute(Runnable command)</code>方法提交任务到线程池，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池当前ctl数值（该值保存了线程池状态、有效工作线程数量）</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过以下三步进行任务提交</span></span><br><span class="line">    <span class="comment">//1、当前工作线程数 &lt; 核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//创建核心线程并执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、工作线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="comment">//线程池处于运行状态 &amp;&amp; 任务放入队列成功（当队列满时，调用offer()会返回false）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.1、 线程池不是运行状态并且队列移除任务成功，执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//2.2、 线程池为运行状态 且 线程池不是运行状态但队列移除任务失败</span></span><br><span class="line">        <span class="comment">// 当前工作线程数量为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//创建当前任务为空的非核心线程，空任务的work会去队列获取任务并执行</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//2.3、 如果2.1和2.2都不执行，那么任务会被放入队列中等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、工作线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="comment">// 线程池非运行状态 || 队列满了</span></span><br><span class="line">    <span class="comment">// 尝试创建非核心线程并执行任务，失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前工作线程数 &lt; 核心线程数<br>    创建<code>核心线程并执行任务</code><br>工作线程数 &gt;= 核心线程数<br>    线程池处于运行状态 &amp;&amp; 任务放入队列成功<br>        线程池不是运行状态并且队列移除任务成功<br>            执行<code>拒绝策略</code><br>        线程池为运行状态 且 线程池不是运行状态但队列移除任务失败 且 当前工作线程数量为空<br>            创建当前<code>任务为空的非核心线程</code>，空任务的work会去队列获取任务并执行<br>    线程池非运行状态 || 队列满了<br>        尝试创建<code>非核心线程并执行任务</code>，失败则执行<code>拒绝策略</code></p>
</blockquote>
<h4 id="submit-提交Callable任务"><a href="#submit-提交Callable任务" class="headerlink" title="submit-提交Callable任务"></a>submit-提交Callable任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法为抽象父类AbstractExecutorService的实现方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取Runnable实现类</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>submit可以提交callable任务，callable任务可以获取线程执行的返回结果</p>
<p>通过newTaskFor(task)方法创建FutureTask（Runnable实现类）交给execute(ftask)方法执行</p>
<p>​    FutureTask<V>实现RunnableFuture<V>接口，RunnableFuture<V>接口继承了Runnable,和Future<V>；因此给交给execute执行</p>
</blockquote>
<h4 id="addWorker-创建线程执行任务"><a href="#addWorker-创建线程执行任务" class="headerlink" title="addWorker-创建线程执行任务"></a>addWorker-创建线程执行任务</h4><table>
<thead>
<tr>
<th>重载方法</th>
<th>描述</th>
<th>execute()方法中触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>addWorker(command, true)</td>
<td>创建核心线程，执行任务</td>
<td>1.当前工作线程数 &lt; 核心线程数</td>
</tr>
<tr>
<td>addWorker(command, false)</td>
<td>创建非核心线程，执行任务</td>
<td>1.工作线程数 &gt;= 核心线程数<br/>2.且 线程池非运行状态 || 队列满了</td>
</tr>
<tr>
<td>addWorker(null, false)</td>
<td>创建非核心线程，当前任务为空</td>
<td>1.线程池为运行状态 或者 (线程池不是运行状态但队列移除任务失败)<br/>2.当前工作线程数量为空</td>
</tr>
</tbody></table>
<p>此方法较长需要分成两部分来分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//########### 第一部分 ############</span></span><br><span class="line">    <span class="comment">//循环使用CAS、重读ctl等操作，判断是否可以创建worker </span></span><br><span class="line">    <span class="comment">// 失败则返回false跳出此方法，成功则跳出循环执行第二部分代码</span></span><br><span class="line">    retry:</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池运行状态</span></span><br><span class="line">		<span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 以下三种条件满足任一一种，返回false，退出方法</span></span><br><span class="line">        <span class="comment">// 1.运行状态非RUNNING，且不为SHUTDOWN，返回false</span></span><br><span class="line">		<span class="comment">// 2.运行状态等于SHUTDOWN，firstTask不为null，返回false</span></span><br><span class="line">		<span class="comment">// 3.运行状态等于SHUTDOWN，firstTask为null,队列为空，返回false</span></span><br><span class="line">		<span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">			! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">			   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			   ! workQueue.isEmpty()))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取工作线程数量</span></span><br><span class="line">			<span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 工作线程数 &gt;= 最大线程数，返回false，退出方法</span></span><br><span class="line">			<span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                <span class="comment">//core为true，判断工作线程数 &gt;= 核心线程数，返回false，退出方法</span></span><br><span class="line">                <span class="comment">//core为false，判断工作线程数 &gt;= 最大线程数，返回false，退出方法</span></span><br><span class="line">				wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// CAS增长workerCount，成功则跳出内外层循环，执行第二部分代码</span></span><br><span class="line">			<span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">				<span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// Re-read ctl 重新获取ctl</span></span><br><span class="line">			c = ctl.get();  </span><br><span class="line">             <span class="comment">// 运行状态改变，跳过此次内层循环剩余的操作，继续外层循环（检查运行状态）</span></span><br><span class="line">			<span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">				<span class="keyword">continue</span> retry;</span><br><span class="line">			<span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// cas失败、工作线程数量改变则重新内循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//###########第二部分############</span></span><br><span class="line">    <span class="comment">// 线程启动标志位</span></span><br><span class="line">	<span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 线程是否加入workers标志位</span></span><br><span class="line">	<span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">	Worker w = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建worker</span></span><br><span class="line">		w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">		<span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">		<span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">			mainLock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取到锁以后仍需检查ctl，可能在上一个获取到锁处理的线程可能会改变runState</span></span><br><span class="line">                <span class="comment">// 如 ThreadFactory 创建失败 或线程池被 shut down等</span></span><br><span class="line">				<span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//当前状态为RUNNING || （当前状态为SHUTDOWN &amp;&amp; 任务为null）</span></span><br><span class="line">				<span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">					(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查线程是否活跃（已经启动则抛出异常）</span></span><br><span class="line">					<span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//加入工作线程集合中</span></span><br><span class="line">					workers.add(w);</span><br><span class="line">					<span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//工作线程集合数量 &gt; 线程池最大大小</span></span><br><span class="line">					<span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">						largestPoolSize = s;</span><br><span class="line">					<span class="comment">//workers标志位</span></span><br><span class="line">					workerAdded = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">				mainLock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//加入works成功</span></span><br><span class="line">			<span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">//启动线程</span></span><br><span class="line">				t.start();</span><br><span class="line">                <span class="comment">//线程启动标志位</span></span><br><span class="line">				workerStarted = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//启动失败</span></span><br><span class="line">		<span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">//回滚创建的工作线程 </span></span><br><span class="line">            <span class="comment">// 加锁，1.从workers移除w、2.cas回减ctl的sorkCount数量化、3.重新检查线程池状态是否终止</span></span><br><span class="line">			addWorkerFailed(w);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//返回线程启动标志位</span></span><br><span class="line">	<span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一部分：循环使用CAS、重读ctl等操作，判断是否可以<code>创建worker</code>，失败则返回false跳出此方法，成功则跳出循环执行第二部分代码</p>
<p>第二部分：加锁同步<code>创建work</code>并<code>启动执行任务</code></p>
</blockquote>
<h4 id="work-工作线程"><a href="#work-工作线程" class="headerlink" title="work-工作线程"></a>work-工作线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程<code>Worker</code>，其为<code>ThreadPoolExecutor</code>的私有内部类。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/work%E7%B1%BBuml%E5%9B%BE.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//此工作程序正在其中运行的线程，如果ThreadFactory创建失败，则为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//要运行的初始任务，可能为null</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//每个worker的完成任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//有参构造</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程在启动前被打断</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程启动调用runWorker(this)执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state. 值0代表解锁状态。</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state. 值1表示锁定状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否锁锁定状态，true：是、false：否</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//aqs-尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//aqs-尝试释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断已启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">// 初始化是 state = -1，不会被interrupt</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Worker</code>实现了<code>Runnable</code>接口，并持有一个线程<code>thread</code>，一个初始化的任务<code>firstTask</code>。</p>
<ol>
<li><code>thread</code>是在调用构造方法时通过<code>ThreadFactory</code>来创建的线程，可以用来执行任务；</li>
<li><code>firstTask</code>用它来保存传入的第一个任务，这个任务可以有，也可以为null。<ul>
<li><code>firstTask</code>非空，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；</li>
<li><code>firstTask</code>为null，那么就需要创建一个线程去执行任务队列（workQueue）中的任务，也就是非核心线程的创建。</li>
</ul>
</li>
</ol>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/work%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt=""></p>
<h4 id="runWorker-真正执行任务"><a href="#runWorker-真正执行任务" class="headerlink" title="runWorker-真正执行任务"></a>runWorker-真正执行任务</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>当 <code>worker.thread.start()</code>调用work的<code>run()</code>，该方法调用了<code>runWorker(this)</code>去真正执行任务</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务。</li>
<li>getTask()方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li>
<li>执行任务。 </li>
<li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li>
</ol>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/runWorker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt=""></p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//异常标识，true：异常、false：非异常</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先尝试执行firstTask，若没有的话，则调用getTask()从队列中获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用aqs的acquire(1)方法获取锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//（线程池是否停止 || （当前线程是否被中断 &amp;&amp; 线程池是否停止 ））</span></span><br><span class="line">            <span class="comment">// &amp;&amp; 当前线程没有被中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//中断当前线程</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 运行run之前的扩展方法，不执行任何操作，但可以在子类中对其进行自定义，子类通常应在此方法的末尾调用super.beforeExecute()</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 真正执行run方法</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 运行run之后的扩展方法</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//累加该worker的完成任务数</span></span><br><span class="line">                <span class="comment">//这里加了锁，因此没有线程安全的问题，volatile修饰保证其他线程的可见性</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//使用aqs的acquire(1)方法获取锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常执行修改完成异常标识为false</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//异常或者获取不到任务时,处理线程退出工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.首先尝试执行<code>firstTask</code>，若没有的话，则调用<code>getTask()</code>从队列中获取任务<br>2.加锁<br>3.如果线程池非运行状态，中断当前线程<br>4.调用<code>beforeExecute(wt, task)</code>前置处理方法<br>5.执行任务调用<code>task.run()</code><br>6.调用<code>afterExecute(task, thrown)</code>后置处理方法<br>7.累加该<code>worker</code>的<code>completedTasks</code>(完成任务数)<br>8.解锁<br>9.异常或者获取不到任务时,调用<code>processWorkerExit(w, completedAbruptly)</code>处理<code>worker</code></p>
</blockquote>
<h4 id="getTask-从队列中获取任务"><a href="#getTask-从队列中获取任务" class="headerlink" title="getTask()-从队列中获取任务"></a>getTask()-从队列中获取任务</h4><p><code>runWorker()</code>的主要任务就是一直loop循环，来一个任务处理一个任务，没有任务就去<code>getTask()</code>，<code>getTask()</code>可能会阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上一次队列的poll()方法是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下两个条件满足任一，cas减少工作线程数，返回退出方法</span></span><br><span class="line">        <span class="comment">//1、线程池关闭了，运行状态非RUNNING &amp;&amp; 运行状态为（STOP、TIDYING、TERMINATED）</span></span><br><span class="line">		<span class="comment">//2、运行状态非RUNNING &amp;&amp; 工作队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//减少ctl的workerCount字段。仅在线程突然终止时调用此方法</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 是否允许核心线程超时 || 工作线程数量 &gt; 核心线程数</span></span><br><span class="line">        <span class="comment">// 是否允许超时标识，true：调用workQueue.poll()；false：调用workQueue.take()</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（ 工作线程数量 &gt; 最大线程数 || （是否超时 &amp;&amp; 超时未获取任务）） </span></span><br><span class="line">        <span class="comment">//		&amp;&amp; （工作线程数量大于1 || 工作队列为空）</span></span><br><span class="line">        <span class="comment">//满足条件则减少工作线程后退出方法，否则重试</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//使用超时等待方法，移除获取，没有值为null</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            <span class="comment">//当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span></span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//队列的poll()方法超时返回null，才会来到此处</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断线程池是否为运行状态，不是的话cas减少工作线程数，返回退出方法<br>判断满足以下任一条件则减少工作线程后退出方法，否则重试<br>    工作线程数量 &gt; 最大线程数 并且 工作线程数量大于1<br>    工作线程数量 &gt; 最大线程数 并且  工作队列为空<br>    允许核心线程超时 并且 上一次队列的poll()方法超时 并且 工作线程数量大于1<br>    允许核心线程超时 并且 上一次队列的poll()方法超时 并且  工作队列为空</p>
<p>（允许核心线程超时 || 工作线程数量 &gt; 核心线程数）使用超时等待方法workQueue.poll()，移除获取，没有值为null；否则使用workQueue.take()为空时阻塞等待获取</p>
</blockquote>
<h4 id="processWorkerExit-处理异常或者无任务执行的worker"><a href="#processWorkerExit-处理异常或者无任务执行的worker" class="headerlink" title="processWorkerExit()-处理异常或者无任务执行的worker"></a>processWorkerExit()-处理异常或者无任务执行的worker</h4><p>当<code>runWorker()</code>的获取不到任务或者出现异常时，会调用<code>processWorkerExit(w, completedAbruptly)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//completedAbruptly为异常调用标识，true：异常调用、false：非异常调用（获取不到任务）</span></span><br><span class="line">    <span class="comment">//如果是异常终止的，那么减少worker的数量</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//累加当前worker的完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//从线程池worker集合中移除该worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果满足条件的话，那么将线程池转换为TERMINATED状态</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前线程池仍然是运行中的状态，那么就看一下是否需要新增另外一个worker替换此worker</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//非异常（任务为null）调用进入此判断</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//是否允许核心线程超时 ? 0 : 核心线程数</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 允许线程超时 &amp;&amp; 队列不为空</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当允许核心线程超时时，worker(工作线程)数量 &gt;= 1时，直接返回，无需创建新的worker</span></span><br><span class="line">            <span class="comment">// 当核心线程不允许超时时，worker(工作线程)数量 &gt;= 核心线程数，直接返回，无需创建新的worker</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试新增work</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>减少工作线程数量，移除该worker，如果当前线程池仍然是运行中的状态<br>    1。当此方法为非异常调用时<br>        当允许核心线程超时时，worker(工作线程)数量 &gt;= 1时，直接返回，无需创建新的worker<br>        当核心线程不允许超时时，worker(工作线程)数量 &gt;= 核心线程数，直接返回，无需创建新的worker<br>        其余情况创建新worker替代旧worker<br>    2.当此方法为异常调用时<br>        创建新worker替代旧worker</p>
</blockquote>
<h3 id="3、线程管理"><a href="#3、线程管理" class="headerlink" title="3、线程管理"></a>3、线程管理</h3><p>​        线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用<code>HashSet</code>来维持对线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>​        <code>Worker</code>是通过继承<code>AQS</code>，使用<code>AQS</code>来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用<code>AQS</code>，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。</li>
<li>如果正在执行任务，则不应该中断线程。 </li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 </li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/worker%E8%8E%B7%E5%8F%96%E9%94%81.png" alt=""></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>链路追踪</title>
    <url>/2020/12/06/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>sleuth收集跟踪信息通过http请求发送给zipkin server，zipkin将跟踪信息存储，以及提供RESTful API接口，zipkin ui通过调用api进行数据展示。默认内存存储，可以用mysql，ES等存储。</p>
<a id="more"></a>

<h2 id="二、Sleuth"><a href="#二、Sleuth" class="headerlink" title="二、Sleuth"></a>二、Sleuth</h2><p>Sleuth是Spring cloud的分布式跟踪解决方案。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>span(跨度)，基本工作单元。一次链路调用，创建一个span，</p>
<p>span用一个64位id唯一标识。包括：id，描述，时间戳事件，spanId,span父id。</p>
<p>span被启动和停止时，记录了时间信息，初始化span叫：root span，它的span id和trace id相等。</p>
</li>
<li><p>trace(跟踪)，一组共享“root span”的span组成的树状结构 称为 trace，trace也有一个64位ID，trace中所有span共享一个trace id。类似于一颗 span 树。</p>
</li>
<li><p>annotation（标签），annotation用来记录事件的存在，其中，核心annotation用来定义请求的开始和结束。</p>
<ul>
<li>CS(Client Send客户端发起请求)。客户端发起请求描述了span开始。</li>
<li>SR(Server Received服务端接到请求)。服务端获得请求并准备处理它。SR-CS=网络延迟。</li>
<li>SS（Server Send服务器端处理完成，并将结果发送给客户端）。表示服务器完成请求处理，响应客户端时。SS-SR=服务器处理请求的时间。</li>
<li>CR（Client Received 客户端接受服务端信息）。span结束的标识。客户端接收到服务器的响应。CR-CS=客户端发出请求到服务器响应的总时间。</li>
</ul>
</li>
</ol>
<p>taceId标识是同一条链路<br>spanId标识是一个服务的一次请求<br>parentId将当前请求与上一请求串联，被调用方的parentId是调用方的spanId</p>
<p><img src="/images/cloud/sleuth/%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg" alt=""></p>
<h2 id="三、zipkin"><a href="#三、zipkin" class="headerlink" title="三、zipkin"></a>三、zipkin</h2><p>zipkin是twitter开源的分布式跟踪系统</p>
<p>下载最新的稳定版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;search.maven.org&#x2F;remote_content?g&#x3D;io.zipkin&amp;a&#x3D;zipkin-server&amp;v&#x3D;LATEST&amp;c&#x3D;exec</span><br></pre></td></tr></table></figure>

<p>命令下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;zipkin.io&#x2F;quickstart.sh | bash -s</span><br></pre></td></tr></table></figure>

<p>启动 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.22</span><span class="number">.2</span>-exec.jar</span><br></pre></td></tr></table></figure>

<h2 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--链路追踪--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- zipkin --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#链路跟踪</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://admin:admin@localhost:9411/</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">rate:</span> <span class="number">1</span> <span class="comment">#采样比例1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、服务调用"><a href="#五、服务调用" class="headerlink" title="五、服务调用"></a>五、服务调用</h2><p>通过user服务调用pay服务</p>
<p>调用情况：</p>
<p><img src="/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8.jpg" alt=""></p>
<p>调用详情：</p>
<p><img src="/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt=""></p>
<p>依赖情况：</p>
<p><img src="/images/cloud/sleuth/%E4%BE%9D%E8%B5%96%E6%83%85%E5%86%B5.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>链路追踪</tag>
        <tag>sleuth</tag>
        <tag>zipkin</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（queue）</title>
    <url>/2020/12/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="各种队列介绍"><a href="#各种队列介绍" class="headerlink" title="各种队列介绍"></a>各种队列介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue 由数组结构组成的有界阻塞队列</span><br><span class="line">LinkedBlockingQueue 由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE 21亿）阻塞队列</span><br><span class="line">PriorityBlockingQueue 支持优先级排序的无界阻塞队列</span><br><span class="line">DelayQueue 使用时间优先级队列实现的延迟无界阻塞队列</span><br><span class="line">SynchronousQueue 不存储、匀速的阻塞队列，容量为零的队列（用于一个线程给另一个线程下达任务）</span><br><span class="line">LinkedTransferQueue 由链表结构组成的无界阻塞队列 transfer将元素放入队列之后会阻塞，等待元素被拿走</span><br><span class="line">LinkedBlockingDeque 由链表结构组成的双向阻塞队列</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><h4 id="操作失败会抛出异常的方法（add、remove、element）"><a href="#操作失败会抛出异常的方法（add、remove、element）" class="headerlink" title="操作失败会抛出异常的方法（add、remove、element）"></a>操作失败会抛出异常的方法（add、remove、element）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean add(E e)：添加元素，当阻塞队列满的时候再进行add会抛Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line"></span><br><span class="line">E remove()：移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line"></span><br><span class="line">E element()：获取队列排头的元素，没有值时Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br></pre></td></tr></table></figure>

<h4 id="操作失败返回false-null的方法（offer、poll、peek）"><a href="#操作失败返回false-null的方法（offer、poll、peek）" class="headerlink" title="操作失败返回false null的方法（offer、poll、peek）"></a>操作失败返回false null的方法（offer、poll、peek）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean offer(E e)：当阻塞队列满的时候再进行offer会返回false</span><br><span class="line"></span><br><span class="line">boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException：当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span><br><span class="line"></span><br><span class="line">E poll()：移除值并返回，当阻塞队列空的时候再进行poll会返回null</span><br><span class="line"></span><br><span class="line">E peek()：获取队列排头的元素，没有值时为null</span><br></pre></td></tr></table></figure>

<h4 id="一直阻塞的方法（put、take）"><a href="#一直阻塞的方法（put、take）" class="headerlink" title="一直阻塞的方法（put、take）"></a>一直阻塞的方法（put、take）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put(E e) throws InterruptedException：当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span><br><span class="line"></span><br><span class="line">E take() throws InterruptedException：当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span><br></pre></td></tr></table></figure>

<h4 id="以ArrayBlockingQueue为例"><a href="#以ArrayBlockingQueue为例" class="headerlink" title="以ArrayBlockingQueue为例"></a>以ArrayBlockingQueue为例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockIngQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞队列，先进先出</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会抛异常的方法：add、element、remove</span></span><br><span class="line">        exceptionBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//会阻塞的方法：put、take</span></span><br><span class="line">        block(blockingQueue);</span><br><span class="line">		<span class="comment">//返回true、false、null的方法：offer、peek、poll</span></span><br><span class="line">        booleanBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//超时返回true、false的方法：offer</span></span><br><span class="line">        timeout(blockingQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作d失败等待超时返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">block</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span></span><br><span class="line">        <span class="comment">//blockingQueue.put("d");</span></span><br><span class="line">        <span class="comment">//获取并移除队列的值</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.take());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">booleanBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"d"</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时为null</span></span><br><span class="line">        System.out.println(blockingQueue.peek());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行poll会返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败会抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//######### 抛异常方法 ###########</span></span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行add会抛Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.element());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">// Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-Pod</title>
    <url>/2022/11/15/k8s-pod/</url>
    <content><![CDATA[<h1 id="一、工作负载-workloads"><a href="#一、工作负载-workloads" class="headerlink" title="一、工作负载(workloads)"></a><strong>一、工作负载(workloads)</strong></h1><p>参考链接：<a href="https://kubernetes.io/zh/docs/concepts/workloads/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/workloads/</a></p>
<p>工作负载（workload）是在kubernetes集群中运行的应用程序。</p>
<p>无论你的工作负载是单一服务还是多个一同工作的服务构成，在kubernetes中都可以使用pod来运行它。</p>
<p>在 Kubernetes 中，Pod 代表的是集群上处于运行状态的一组 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers" target="_blank" rel="noopener">容器</a> 的集合。</p>
<a id="more"></a>

<p>workloads分为pod与controllers</p>
<ul>
<li>pod通过控制器实现应用的运行，如何伸缩，升级等</li>
<li>controllers 在集群中管理pod</li>
<li>pod与控制器之间通过label-selector相关联，是唯一的关联方式</li>
</ul>
<p>在pod的YAML里指定pod标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">定义标签</span><br><span class="line">  labels: </span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>

<p>在控制器的YAML里指定标签选择器匹配标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">通过标签选择器选择对应的pod</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br></pre></td></tr></table></figure>

<h1 id="二、pod介绍"><a href="#二、pod介绍" class="headerlink" title="二、pod介绍"></a><strong>二、pod介绍</strong></h1><h2 id="2-1-pod定义与分类"><a href="#2-1-pod定义与分类" class="headerlink" title="2.1 pod定义与分类"></a><strong>2.1 pod定义与分类</strong></h2><p>参考链接: <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/workloads/pods/</a></p>
<h3 id="2-1-1-Pod定义"><a href="#2-1-1-Pod定义" class="headerlink" title="2.1.1 Pod定义"></a><strong>2.1.1 Pod定义</strong></h3><ul>
<li>Pod(豌豆荚) 是Kubernetes集群管理（创建、部署）与调度的最小计算单元，表示处于运行状态的一组容器。</li>
<li>Pod不是进程，而是容器运行的环境。</li>
<li>一个Pod可以封装</li>
</ul>
<p><strong>一个容器或多个容器(主容器或sidecar边车容器)</strong></p>
<ul>
<li>一个pod内的多个容器之间共享部分命名空间，例如：Net Namespace,UTS Namespace,IPC Namespace及存储资源</li>
<li>用户pod默认会被调度运行在node节点之上(不运行在master节点上，但也有例外情况)</li>
<li>pod内的IP不是固定的，集群外不能直接访问pod</li>
</ul>
<h3 id="2-1-2-Pod分类"><a href="#2-1-2-Pod分类" class="headerlink" title="2.1.2 Pod分类"></a><strong>2.1.2 Pod分类</strong></h3><ul>
<li>静态Pod</li>
</ul>
<p>​    也称之为“无控制器管理的自主式pod”，直接由特定节点上的 kubelet 守护进程管理， 不需要API 服务器看到它们，尽管大多数 Pod 都是通过控制面（例如，Deployment） 来管理的，对于静态 Pod 而言，kubelet 直接监控每个 Pod，并在其失效时重启之。</p>
<ul>
<li><p>控制器管理的pod</p>
<p> 控制器可以控制pod的副本数，扩容与裁剪，版本更新与回滚等</p>
</li>
</ul>
<h2 id="2-2-查看pod方法"><a href="#2-2-查看pod方法" class="headerlink" title="2.2 查看pod方法"></a><strong>2.2 查看pod方法</strong></h2><p>pod是一种计算资源，可以通过kubectl get pod来查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod       # pod或pods都可以，不指定namespace,默认是名为default的namespace</span></span><br><span class="line">    </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod -n kube-system</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-pod的YAML资源清单格式"><a href="#2-3-pod的YAML资源清单格式" class="headerlink" title="2.3 pod的YAML资源清单格式"></a><strong>2.3 pod的YAML资源清单格式</strong></h2><p>先看一个yaml格式的pod定义文件解释</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml格式的pod定义文件完整内容：</span></span><br><span class="line">apiVersion: v1       <span class="comment">#必选，api版本号，例如v1</span></span><br><span class="line">kind: Pod           <span class="comment">#必选，Pod</span></span><br><span class="line">metadata:           <span class="comment">#必选，元数据</span></span><br><span class="line">  name: string       <span class="comment">#必选，Pod名称</span></span><br><span class="line">  namespace: string    <span class="comment">#Pod所属的命名空间,默认在default的namespace</span></span><br><span class="line">  labels:            <span class="comment"># 自定义标签</span></span><br><span class="line">    name: string     <span class="comment">#自定义标签名字，key和value分别限制最长63个字符</span></span><br><span class="line">  annotations:        <span class="comment">#自定义注释列表</span></span><br><span class="line">    name: string</span><br><span class="line">spec:         <span class="comment">#必选，Pod中容器的详细定义(期望)</span></span><br><span class="line">  containers:      <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  - name: string     <span class="comment">#必选，容器名称</span></span><br><span class="line">    image: string    <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] <span class="comment">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class="line">    <span class="built_in">command</span>: [string]    <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    args: [string]     <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    workingDir: string     <span class="comment">#容器的工作目录</span></span><br><span class="line">    volumeMounts:    <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    - name: string     <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      mountPath: string    <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      readOnly: boolean    <span class="comment">#是否为只读模式</span></span><br><span class="line">    ports:       <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    - name: string     <span class="comment">#端口号名称</span></span><br><span class="line">      containerPort: int   <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      hostPort: int    <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      protocol: string     <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    env:       <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    - name: string     <span class="comment">#环境变量名称</span></span><br><span class="line">      value: string    <span class="comment">#环境变量的值</span></span><br><span class="line">    resources:       <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      limits:      <span class="comment">#资源限制的设置</span></span><br><span class="line">        cpu: string    <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        memory: string     <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      requests:      <span class="comment">#资源请求的设置</span></span><br><span class="line">        cpu: string    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        memory: string     <span class="comment">#内存清求，容器启动的初始可用数量</span></span><br><span class="line">    livenessProbe:     <span class="comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class="line">      <span class="built_in">exec</span>:      <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="built_in">command</span>: [string]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      httpGet:       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       timeoutSeconds: 0   <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       periodSeconds: 0    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:<span class="literal">false</span></span><br><span class="line">    restartPolicy: [Always | Never | OnFailure] <span class="comment"># Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class="line">    nodeSelector: obeject  <span class="comment"># 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class="line">    imagePullSecrets:    <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">    - name: string</span><br><span class="line">    hostNetwork: <span class="literal">false</span>     <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">    volumes:       <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">    - name: string     <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">      emptyDir: &#123;&#125;     <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">      hostPath: string     <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">        path: string     <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">      secret:      <span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br></pre></td></tr></table></figure>

<p>YAML格式查找帮助方法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain namespace</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain pod</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain pod.spec</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain pod.spec.containers</span></span><br></pre></td></tr></table></figure>

<h1 id="三、pod创建与验证"><a href="#三、pod创建与验证" class="headerlink" title="三、pod创建与验证"></a><strong>三、pod创建与验证</strong></h1><h2 id="3-1-命令创建pod-v1-18变化"><a href="#3-1-命令创建pod-v1-18变化" class="headerlink" title="3.1 命令创建pod(v1.18变化)"></a><strong>3.1 命令创建pod(v1.18变化)</strong></h2><ul>
<li>k8s之前版本中, kubectl run命令用于创建deployment控制器</li>
<li>在v1.18版本中, kubectl run命令改为创建pod</li>
</ul>
<h3 id="3-1-1-创建一个名为pod-nginx的pod"><a href="#3-1-1-创建一个名为pod-nginx的pod" class="headerlink" title="3.1.1 创建一个名为pod-nginx的pod"></a><strong>3.1.1 创建一个名为pod-nginx的pod</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl run nginx1 --image=nginx:1.15-alpine</span></span><br><span class="line">pod/nginx1 created</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-验证"><a href="#3-1-2-验证" class="headerlink" title="3.1.2 验证"></a><strong>3.1.2 验证</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx1           1/1     Running   0          41s</span><br></pre></td></tr></table></figure>

<h2 id="3-2-YAML创建pod"><a href="#3-2-YAML创建pod" class="headerlink" title="3.2 YAML创建pod"></a><strong>3.2 YAML创建pod</strong></h2><h3 id="3-2-1-准备yaml文件"><a href="#3-2-1-准备yaml文件" class="headerlink" title="3.2.1 准备yaml文件"></a><strong>3.2.1 准备yaml文件</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod1.yml</span></span><br><span class="line">apiVersion: v1                  <span class="comment"># api版本</span></span><br><span class="line">kind: Pod                       <span class="comment"># 资源类型为Pod</span></span><br><span class="line">metadata:                       </span><br><span class="line">  name: pod-stress              <span class="comment"># 自定义pod的名称</span></span><br><span class="line">spec:</span><br><span class="line">  containers:                   <span class="comment"># 定义pod里包含的容器</span></span><br><span class="line">  - name: c1                    <span class="comment"># 自定义pod中的容器名</span></span><br><span class="line">    image: polinux/stress       <span class="comment"># 启动容器的镜像名</span></span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]         <span class="comment"># 自定义启动容器时要执行的命令(类似dockerfile里的CMD)</span></span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>] <span class="comment"># 自定义启动容器执行命令的参数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># polinux/stress这个镜像用于压力测试,在启动容器时传命令与参数就是相当于分配容器运行时需要的压力</span></span><br></pre></td></tr></table></figure>

<p>通过yaml文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod1.yml</span></span><br><span class="line">pod/pod-stress created</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-查看pod信息"><a href="#3-2-2-查看pod信息" class="headerlink" title="3.2.2 查看pod信息"></a><strong>3.2.2 查看pod信息</strong></h3><p>查看pod信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-stress    1/1     Running   0          45s</span><br></pre></td></tr></table></figure>

<p>查看pod详细信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME         READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-stress   1/1     Running   0          71s   10.244.194.72   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>描述pod详细信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod pod-stress </span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  102s  default-scheduler  Successfully assigned default/pod-stress to k8s-worker1</span><br><span class="line">  Normal  Pulling    102s  kubelet            Pulling image <span class="string">"polinux/stress"</span></span><br><span class="line">  Normal  Pulled     83s   kubelet            Successfully pulled image <span class="string">"polinux/stress"</span> <span class="keyword">in</span> 18.944533343s</span><br><span class="line">  Normal  Created    83s   kubelet            Created container c1</span><br><span class="line">  Normal  Started    82s   kubelet            Started container c1</span><br></pre></td></tr></table></figure>

<h2 id="3-3-删除pod"><a href="#3-3-删除pod" class="headerlink" title="3.3 删除pod"></a><strong>3.3 删除pod</strong></h2><h3 id="3-3-1-单个pod删除"><a href="#3-3-1-单个pod删除" class="headerlink" title="3.3.1 单个pod删除"></a><strong>3.3.1 单个pod删除</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete pod pod-stress</span></span><br><span class="line">pod <span class="string">"pod-stress"</span> deleted</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete -f pod1.yml</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-多个pod删除"><a href="#3-3-2-多个pod删除" class="headerlink" title="3.3.2 多个pod删除"></a><strong>3.3.2 多个pod删除</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法1: 后接多个pod名</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete pod pod名1 pod名2 pod名3 ......</span></span><br><span class="line"><span class="comment">#方法2: 通过awk截取要删除的pod名称，然后管道给xargs</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |awk 'NR&gt;1 &#123;print $1&#125;' |xargs kubectl  delete pod</span></span><br><span class="line"><span class="comment">#方法3: 如果要删除的pod都在同一个非default的命名空间，则可直接删除命名空间</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete ns xxxx</span></span><br></pre></td></tr></table></figure>



<h2 id="3-4-镜像拉取策略"><a href="#3-4-镜像拉取策略" class="headerlink" title="3.4 镜像拉取策略"></a><strong>3.4 镜像拉取策略</strong></h2><p>由imagePullPolicy参数控制</p>
<ul>
<li><p>Always : 不管本地有没有镜像，都要从仓库中下载镜像</p>
</li>
<li><p>Never : 从来不从仓库下载镜像, 只用本地镜像,本地没有就算了</p>
</li>
<li><p>IfNotPresent: 如果本地存在就直接使用, 不存在才从仓库下载</p>
</li>
</ul>
<p>默认的策略是：</p>
<ul>
<li><p>当镜像标签版本是latest，默认策略就是Always</p>
</li>
<li><p>如果指定特定版本默认拉取策略就是IfNotPresent。</p>
</li>
</ul>
<p>1, 将上面的pod删除再创建，使用下面命令查看信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete -f pod1.yml</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod1.yml</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod pod-stress</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  102s  default-scheduler  Successfully assigned default/pod-stress to k8s-worker1</span><br><span class="line">  Normal  Pulling    102s  kubelet            Pulling image <span class="string">"polinux/stress"</span></span><br><span class="line">  Normal  Pulled     83s   kubelet            Successfully pulled image <span class="string">"polinux/stress"</span> <span class="keyword">in</span> 18.944533343s</span><br><span class="line">  Normal  Created    83s   kubelet            Created container c1</span><br><span class="line">  Normal  Started    82s   kubelet            Started container c1</span><br></pre></td></tr></table></figure>

<p>说明: 可以看到第二行信息还是通过<code>pulling image</code>下载镜像</p>
<p>2, 修改YAML</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod1.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-stress</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]</span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]</span><br><span class="line">    imagePullPolicy: IfNotPresent <span class="comment">#增加了这一句,如果本地存在就直接使用, 不存在才从仓库下载</span></span><br></pre></td></tr></table></figure>

<p>3，再次删除再创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod pod-stress</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  17s   default-scheduler  Successfully assigned default/pod-stress to k8s-worker1</span><br><span class="line">  Normal  Pulled     17s   kubelet            Container image <span class="string">"polinux/stress"</span> already present on machine</span><br><span class="line">  Normal  Created    17s   kubelet            Created container c1</span><br><span class="line">  Normal  Started    17s   kubelet            Started container c1</span><br></pre></td></tr></table></figure>

<p><strong>说明: 第二行信息是说镜像已经存在，直接使用了</strong></p>
<h2 id="3-5-pod的标签"><a href="#3-5-pod的标签" class="headerlink" title="3.5 pod的标签"></a><strong>3.5 pod的标签</strong></h2><ul>
<li>为pod设置label,用于控制器通过label与pod关联</li>
<li>语法与前面学的node标签几乎一致</li>
</ul>
<h3 id="3-5-1-通过命令管理Pod标签"><a href="#3-5-1-通过命令管理Pod标签" class="headerlink" title="3.5.1 通过命令管理Pod标签"></a><strong>3.5.1 通过命令管理Pod标签</strong></h3><p>查看pod的标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-stress     1/1    Running   0          7m25s   &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>打标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl label pod pod-stress region=huanai zone=A env=test bussiness=game</span></span><br><span class="line">pod/pod-stress labeled</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">pod-stress    1/1     Running   0          8m54s   bussiness=game,env=<span class="built_in">test</span>,region=huanai,zone=A</span><br></pre></td></tr></table></figure>

<p>通过等值关系标签查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -l zone=A</span></span><br><span class="line">NAME         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-stress   1/1     Running   0          9m22s</span><br></pre></td></tr></table></figure>

<p>通过集合关系标签查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -l "zone in (A,B,C)"</span></span><br><span class="line">NAME         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-stress   1/1     Running   0          9m55s</span><br></pre></td></tr></table></figure>

<p>删除标签后再验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl label pod pod-stress region- zone- env- bussiness-</span></span><br><span class="line">pod/pod-stress labeled</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-stress    1/1     Running   0          16m     &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>pod的label与node的label操作方式几乎相同</li>
<li>node的label用于pod调度到指定label的node节点</li>
<li>pod的label用于controller关联控制的pod</li>
</ul>
<h3 id="3-5-2-通过YAML创建Pod时添加标签"><a href="#3-5-2-通过YAML创建Pod时添加标签" class="headerlink" title="3.5.2 通过YAML创建Pod时添加标签"></a><strong>3.5.2 通过YAML创建Pod时添加标签</strong></h3><h4 id="修改yaml"><a href="#修改yaml" class="headerlink" title="修改yaml"></a>修改yaml</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod1.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-stress</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    env: dev</span><br><span class="line">    app: nginx<span class="comment"># 直接在原来的yaml里加上多个标签</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]</span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br></pre></td></tr></table></figure>

<h4 id="直接apply应用"><a href="#直接apply应用" class="headerlink" title="直接apply应用"></a>直接apply应用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod1.yaml</span></span><br><span class="line">pod/pod-stress1 configured  <span class="comment"># 这里是configured,表示修改了</span></span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS             RESTARTS   AGE     LABELS</span><br><span class="line">pod-stress   1/1     Running            0          3m5s    app=nginx,env=dev <span class="comment"># 标签有了</span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-pod资源限制"><a href="#3-6-pod资源限制" class="headerlink" title="3.6 pod资源限制"></a><strong>3.6 pod资源限制</strong></h2><p>准备2个不同限制方式的创建pod的yaml文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod2.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: namespace1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-stress2</span><br><span class="line">  namespace: namespace1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: <span class="string">"200Mi"</span></span><br><span class="line">      requests:</span><br><span class="line">        memory: <span class="string">"100Mi"</span></span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]    <span class="comment"># 启动容器时执行的命令</span></span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]  <span class="comment"># 产生1个进程分配150M内存1秒后释放</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod3.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: namespace1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-stress3</span><br><span class="line">  namespace: namespace1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: <span class="string">"200Mi"</span></span><br><span class="line">      requests:</span><br><span class="line">        memory: <span class="string">"150Mi"</span></span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]</span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"250M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]</span><br></pre></td></tr></table></figure>

<p>创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod2.yml</span></span><br><span class="line">namespace/namespace1 created</span><br><span class="line">pod/pod-stress2 created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod3.yml</span></span><br><span class="line">namespace/namespace1 unchanged</span><br><span class="line">pod/pod-stress3 created</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get namespace  |grep namespace1</span></span><br><span class="line">namespace1        Active   1m28s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod -n namespace1</span></span><br><span class="line">NAME          READY   STATUS      RESTARTS   AGE</span><br><span class="line">pod-stress2   1/1     Running     0          2m2s</span><br><span class="line">pod-stress3   0/1     OOMKilled   4          115s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看会发现pod-stress3这个pod状态变为OOMKilled，因为它是内存不足所以显示Container被杀死</span></span><br></pre></td></tr></table></figure>

<p>说明:  一旦pod中的容器挂了，容器会有重启策略， 如下：</p>
<ul>
<li>Always：表示容器挂了总是重启，这是默认策略 </li>
<li>OnFailures：表容器状态为错误时才重启，也就是容器正常终止时才重启 </li>
<li>Never：表示容器挂了不予重启 </li>
<li>对于Always这种策略，容器只要挂了，就会立即重启，这样是很耗费资源的。所以Always重启策略是这么做的：第一次容器挂了立即重启，如果再挂了就要延时10s重启，第三次挂了就等20s重启…… 依次类推 </li>
</ul>
<h2 id="3-7-pod包含多个容器"><a href="#3-7-pod包含多个容器" class="headerlink" title="3.7 pod包含多个容器"></a>3.7 pod包含多个容器</h2><p>准备yml文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod4.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-stress4</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: <span class="string">"200Mi"</span></span><br><span class="line">      requests:</span><br><span class="line">        memory: <span class="string">"100Mi"</span></span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]</span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]</span><br><span class="line">    </span><br><span class="line">  - name: c2</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: <span class="string">"200Mi"</span></span><br><span class="line">      requests:</span><br><span class="line">        memory: <span class="string">"100Mi"</span></span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"stress"</span>]</span><br><span class="line">    args: [<span class="string">"--vm"</span>, <span class="string">"1"</span>, <span class="string">"--vm-bytes"</span>, <span class="string">"150M"</span>, <span class="string">"--vm-hang"</span>, <span class="string">"1"</span>]</span><br></pre></td></tr></table></figure>

<p>应用yml文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod4.yml</span></span><br><span class="line">pod/pod-stress4 created</span><br></pre></td></tr></table></figure>

<p>查看pod在哪个节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods  -o wide</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-stress4   2/2     Running   0          70s     10.244.159.136   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="comment">#可以看到有2个容器,运行在k8s-master1节点</span></span><br></pre></td></tr></table></figure>

<p>在k8s-master1上验证,确实产生了2个容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># docker ps -a |grep stress</span></span><br><span class="line">d7827a963f9d        df58d15b053d              <span class="string">"stress --vm 1 --vm-…"</span>   2 hours ago         Up 2 hours                                      k8s_c2_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0</span><br><span class="line">ae8e8f8d095b        df58d15b053d              <span class="string">"stress --vm 1 --vm-…"</span>   2 hours ago         Up 2 hours                                      k8s_c1_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0</span><br><span class="line">e66461900426        easzlab/pause-amd64:3.2   <span class="string">"/pause"</span>                 2 hours ago         Up 2 hours                                      k8s_POD_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0</span><br></pre></td></tr></table></figure>

<h2 id="3-8-对pod里的容器进行操作"><a href="#3-8-对pod里的容器进行操作" class="headerlink" title="3.8 对pod里的容器进行操作"></a><strong>3.8 对pod里的容器进行操作</strong></h2><h3 id="3-8-1-命令帮助"><a href="#3-8-1-命令帮助" class="headerlink" title="3.8.1 命令帮助"></a><strong>3.8.1 命令帮助</strong></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -h</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-不用交互直接执行命令"><a href="#3-8-2-不用交互直接执行命令" class="headerlink" title="3.8.2 不用交互直接执行命令"></a><strong>3.8.2 不用交互直接执行命令</strong></h3><p>格式为: <code>kubectl exec pod名 -c 容器名 -- 命令</code></p>
<p><strong>注意:</strong> </p>
<ul>
<li><p>-c 容器名为可选项,如果是1个pod中1个容器,则不用指定;</p>
</li>
<li><p>如果是1个pod中多个容器,不指定默认为第1个。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec pod-stress4 -c c2  -- touch /111</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec pod-stress4 -c c2  -- ls /111</span></span><br><span class="line">/111</span><br></pre></td></tr></table></figure>

<p>不指定容器名,则默认为pod里的第1个容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec  pod-stress4  -- touch /222</span></span><br><span class="line">Defaulting container name to c1.</span><br><span class="line">Use <span class="string">'kubectl describe pod/pod-stress4 -n default'</span> to see all of the containers <span class="keyword">in</span> this pod.</span><br></pre></td></tr></table></figure>

<h3 id="3-8-3-和容器交互操作"><a href="#3-8-3-和容器交互操作" class="headerlink" title="3.8.3 和容器交互操作"></a><strong>3.8.3 和容器交互操作</strong></h3><p>和docker exec几乎一样</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it pod-stress4 -c c1 -- /bin/bash</span></span><br><span class="line">bash-5.0<span class="comment"># touch /333</span></span><br><span class="line">bash-5.0<span class="comment"># ls</span></span><br><span class="line">222    bin    etc    lib    mnt    proc   run    srv    tmp    var</span><br><span class="line">333    dev    home   media  opt    root   sbin   sys    usr</span><br><span class="line">bash-5.0<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h2 id="3-9-验证pod中多个容器网络共享"><a href="#3-9-验证pod中多个容器网络共享" class="headerlink" title="3.9 验证pod中多个容器网络共享"></a><strong>3.9 验证pod中多个容器网络共享</strong></h2><p> 编写YAML</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-nginx.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: c1</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line"></span><br><span class="line">  - name: c2</span><br><span class="line">    image: nginx:1.15-alpine</span><br></pre></td></tr></table></figure>

<p>应用YAML</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-nginx.yaml</span></span><br><span class="line">pod/nginx2 created</span><br></pre></td></tr></table></figure>

<p>查看pod信息与状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod nginx2</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age              From               Message</span><br><span class="line">  ----    ------     ----             ----               -------</span><br><span class="line">  Normal  Scheduled  25s              default-scheduler  Successfully assigned default/nginx2 to k8s-worker1</span><br><span class="line">  Normal  Pulling    24s              kubelet            Pulling image <span class="string">"nginx:1.15-alpine"</span></span><br><span class="line">  Normal  Pulled     5s               kubelet            Successfully pulled image <span class="string">"nginx:1.15-alpine"</span> <span class="keyword">in</span> 18.928009025s</span><br><span class="line">  Normal  Created    5s               kubelet            Created container c1</span><br><span class="line">  Normal  Started    5s               kubelet            Started container c1</span><br><span class="line">  Normal  Pulled     2s (x2 over 5s)  kubelet            Container image <span class="string">"nginx:1.15-alpine"</span> already present on machine</span><br><span class="line">  Normal  Created    2s (x2 over 5s)  kubelet            Created container c2</span><br><span class="line">  Normal  Started    2s (x2 over 5s)  kubelet            Started container c2</span><br><span class="line">  </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |grep nginx2</span></span><br><span class="line">nginx2   1/2     CrashLoopBackOff   3          2m40s</span><br><span class="line"><span class="comment">#有一个启不来，因为一个容器中两个pod是共用网络的，所以不能两个都占用80端口</span></span><br></pre></td></tr></table></figure>

<p>有一个启不来，因为一个pod中两个容器是共用网络的，所以不能两个都占用80端口</p>
<p>通过查找k8s-worker1上面的容器，然后docker logs或crictl logs containerID查看，得到如下的报错，说明是端口被占用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-worker1 ~]<span class="comment"># docker logs k8s_c2_nginx2_default_51fd8e81-1c4b-4557-9498-9b25ed8a4c99_4</span></span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: bind() to 0.0.0.0:80 failed (98: Address in use)</span></span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address <span class="keyword">in</span> use)</span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: bind() to 0.0.0.0:80 failed (98: Address in use)</span></span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address <span class="keyword">in</span> use)</span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: bind() to 0.0.0.0:80 failed (98: Address in use)</span></span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address <span class="keyword">in</span> use)</span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: bind() to 0.0.0.0:80 failed (98: Address in use)</span></span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address <span class="keyword">in</span> use)</span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: bind() to 0.0.0.0:80 failed (98: Address in use)</span></span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address <span class="keyword">in</span> use)</span><br><span class="line">2020/11/21 04:29:12 [emerg] 1<span class="comment">#1: still could not bind()</span></span><br><span class="line">nginx: [emerg] still could not <span class="built_in">bind</span>()</span><br></pre></td></tr></table></figure>

<h1 id="四、pod调度"><a href="#四、pod调度" class="headerlink" title="四、pod调度"></a><strong>四、pod调度</strong></h1><h2 id="4-1-pod调度流程"><a href="#4-1-pod调度流程" class="headerlink" title="4.1 pod调度流程"></a><strong>4.1 pod调度流程</strong></h2><p><img src="/images/k8s-pod/%E6%88%AA%E5%9B%BE16.png" alt="截图16"></p>
<ul>
<li><p>Step1<br>通过kubectl命令应用资源清单文件（yaml格式）向api server 发起一个create pod 请求</p>
</li>
<li><p>Step2<br>api server接收到pod创建请求后，生成一个包含创建信息资源清单文件</p>
</li>
<li><p>Step3<br>apiserver 将资源清单文件中信息写入etcd数据库</p>
</li>
<li><p>Step4<br>Scheduler启动后会一直watch API Server，获取 podSpec.NodeName为空的Pod,即判断pod.spec.Node == null? 若为null，表示这个Pod请求是新的，需要创建，因此先进行调度计算（共计2步：1、过滤不满足条件的，2、选择优先级高的），找到合适的node，然后将信息在etcd数据库中更新分配结果：pod.spec.Node = nodeA (设置一个具体的节点)</p>
</li>
<li><p>Step5<br>kubelet 通过watch etcd数据库(即不停地看etcd中的记录)，发现有新的Node出现，如果这条记录中的Node与所在节点编号相同，即这个Pod由scheduler分配给自己，则调用node中的Container Runtime，进而创建container，并将创建后的结果返回到给api server用于更新etcd数据库中数据状态。</p>
</li>
</ul>
<h2 id="4-2-调度约束方法"><a href="#4-2-调度约束方法" class="headerlink" title="4.2 调度约束方法"></a><strong>4.2 调度约束方法</strong></h2><p>我们为了实现容器主机资源平衡使用, 可以使用约束把pod调度到指定的node节点</p>
<ul>
<li><p>nodeName 用于将pod调度到指定的node名称上</p>
</li>
<li><p>nodeSelector 用于将pod调度到匹配Label的node上</p>
</li>
</ul>
<h3 id="4-2-1-nodeName"><a href="#4-2-1-nodeName" class="headerlink" title="4.2.1  nodeName"></a><strong>4.2.1  nodeName</strong></h3><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-nodename.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-nodename</span><br><span class="line">spec:</span><br><span class="line">  nodeName: k8s-worker1 <span class="comment"># 通过nodeName调度到k8s-worker1节点</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.15-alpine</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-nodename.yml</span></span><br><span class="line">pod/pod-nodename created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod pod-nodename |tail -6</span></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason   Age    From     Message</span><br><span class="line">  ----    ------   ----   ----     -------</span><br><span class="line">  Normal  Pulled   2m47s  kubelet  Container image <span class="string">"nginx:1.15-alpine"</span> already present on machine</span><br><span class="line">  Normal  Created  2m47s  kubelet  Created container nginx</span><br><span class="line">  Normal  Started  2m47s  kubelet  Started container nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#倒数第3行没有使用scheduler,而是直接给运行了,说明nodeName约束生效</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-nodeSelector"><a href="#4-2-2-nodeSelector" class="headerlink" title="4.2.2 nodeSelector"></a><strong>4.2.2 nodeSelector</strong></h3><p>为k8s-worker1打标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl label nodes k8s-worker1 bussiness=game</span></span><br><span class="line">node/k8s-worker1 labeled</span><br></pre></td></tr></table></figure>

<p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-nodeselector.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-nodeselect</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:    <span class="comment"># nodeSelector节点选择器</span></span><br><span class="line">    bussiness: game   <span class="comment"># 指定调度到标签为bussiness=game的节点</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.15-alpine</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-nodeselector.yml</span></span><br><span class="line">pod/pod-nodeselect created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod pod-nodeselect |tail -6</span></span><br><span class="line"> Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  20s   default-scheduler  Successfully assigned default/pod-nodeselect to k8s-worker1</span><br><span class="line">  Normal  Pulled     19s   kubelet            Container image <span class="string">"nginx:1.15-alpine"</span> already present on machine</span><br><span class="line">  Normal  Created    19s   kubelet            Created container nginx</span><br><span class="line">  Normal  Started    19s   kubelet            Started container nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#仍然经过了scheduler,但确实分配到了 k8s-worker1上</span></span><br></pre></td></tr></table></figure>

<h1 id="五、pod的生命周期"><a href="#五、pod的生命周期" class="headerlink" title="五、pod的生命周期"></a><strong>五、pod的生命周期</strong></h1><h2 id="5-1-Pod生命周期"><a href="#5-1-Pod生命周期" class="headerlink" title="5.1 Pod生命周期"></a><strong>5.1 Pod生命周期</strong></h2><ul>
<li>有些pod(比如运行httpd服务),正常情况下会一直运行中,但如果手动删除它,此pod会终止</li>
<li>也有些pod(比如执行计算任务)，任务计算完后就会自动终止</li>
</ul>
<p>上面两种场景中,pod从创建到终止的过程就是pod的生命周期。</p>
<p><img src="/images/k8s-pod/%E6%88%AA%E5%9B%BE17.png" alt="截图17"></p>
<h3 id="5-1-1-容器启动"><a href="#5-1-1-容器启动" class="headerlink" title="5.1.1 容器启动"></a>5.1.1 容器启动</h3><ol>
<li>pod中的容器在创建前,由初始化容器(init container)来进行初始化环境</li>
<li>初化完后,主容器(main container)开始启动</li>
<li>主容器启动后,有一个<strong>post start</strong>的操作(启动后的触发型操作,或者叫启动后钩子)</li>
<li>post start后,就开始做健康检查<ul>
<li>第一个健康检查叫存活状态检查(liveness probe )，用来检查主容器存活状态的</li>
<li>第二个健康检查叫准备就绪检查(readiness probe)，用来检查主容器是否启动就绪</li>
</ul>
</li>
</ol>
<h3 id="5-1-2-容器终止"><a href="#5-1-2-容器终止" class="headerlink" title="5.1.2 容器终止"></a><strong>5.1.2 容器终止</strong></h3><ol>
<li>可以在容器终止前设置<strong>pre stop</strong>操作(终止前的触发型操作,或者叫终止前钩子)</li>
<li>当出现特殊情况不能正常销毁pod时,大概等待30秒会强制终止</li>
<li>终止容器后还可能会重启容器(视容器重启策略而定)。</li>
</ol>
<h3 id="5-1-3-容器重启策略"><a href="#5-1-3-容器重启策略" class="headerlink" title="5.1.3 容器重启策略"></a><strong>5.1.3 容器重启策略</strong></h3><ul>
<li><p>Always：表示容器挂了总是重启，这是默认策略 </p>
</li>
<li><p>OnFailures：表示容器状态为错误时才重启，也就是容器正常终止时不重启 </p>
</li>
<li><p>Never：表示容器挂了不予重启 </p>
</li>
<li><p>对于Always这种策略，容器只要挂了，就会立即重启，这样是很耗费资源的。所以Always重启策略是这么做的：第一次容器挂了立即重启，如果再挂了就要延时10s重启，第三次挂了就等20s重启…… 依次类推 </p>
</li>
</ul>
<h2 id="5-2-HealthCheck健康检查"><a href="#5-2-HealthCheck健康检查" class="headerlink" title="5.2 HealthCheck健康检查"></a><strong>5.2 HealthCheck健康检查</strong></h2><p>当Pod启动时，容器可能会因为某种错误(服务未启动或端口不正确)而无法访问等。</p>
<h3 id="5-2-1-Health-Check方式"><a href="#5-2-1-Health-Check方式" class="headerlink" title="5.2.1 Health Check方式"></a><strong>5.2.1 Health Check方式</strong></h3><p>kubelet拥有两个检测器，它们分别对应不同的触发器(根据触发器的结构执行进一步的动作)</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Liveness Probe(存活状态探测)</td>
<td>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener">重启策略</a>决定未来。如果容器不提供存活探针， 则默认状态为 Success。</td>
</tr>
<tr>
<td>readiness Probe(就绪型探测)</td>
<td>指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。注：检查后不健康，将容器设置为Notready;如果使用service来访问,流量不会转发给此种状态的pod</td>
</tr>
<tr>
<td>startup Probe</td>
<td>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener">重启策略</a>进行重启。 如果容器没有提供启动探测，则默认状态为 Success。</td>
</tr>
</tbody></table>
<blockquote>
<p>liveness主要用来确定何时重启容器。liveness探测的结果会存储在livenessManager中。<br>kubelet在syncPod时，发现该容器的liveness探针检测失败时，会将其加入待启动的容器列表中，在之后的操作中会重新创建该容器。</p>
<p>readiness主要来确定容器是否已经就绪。只有当Pod中的容器都处于就绪状态，也就是pod的condition里的Ready为true时，kubelet才会认定该Pod处于就绪状态。而pod是否处于就绪状态的作用是控制哪些Pod应该作为service的后端。如果Pod处于非就绪状态，那么它们将会被从service的endpoint中移除。</p>
<p>liveness和readiness除了最终的作用不同，另外一个很大的区别是它们的初始值不同。liveness的初始值为成功，而readiness的初始值为失败。</p>
</blockquote>
<h3 id="5-2-2-Probe探测方式"><a href="#5-2-2-Probe探测方式" class="headerlink" title="5.2.2 Probe探测方式"></a><strong>5.2.2 Probe探测方式</strong></h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Exec</td>
<td>执行命令</td>
</tr>
<tr>
<td>HTTPGet</td>
<td>http请求某一个URL路径</td>
</tr>
<tr>
<td>TCP</td>
<td>tcp连接某一个端口</td>
</tr>
<tr>
<td>gRPC</td>
<td>使用 <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a> 执行一个远程过程调用。 目标应该实现 <a href="https://grpc.io/grpc/core/md_doc_health-checking.html" target="_blank" rel="noopener">gRPC健康检查</a>。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/feature-gate/" target="_blank" rel="noopener">特性门控</a>时才能使用。</td>
</tr>
</tbody></table>
<h3 id="5-2-3-liveness-exec案例"><a href="#5-2-3-liveness-exec案例" class="headerlink" title="5.2.3 liveness-exec案例"></a><strong>5.2.3 liveness-exec案例</strong></h3><p>准备YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-liveness-exec.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: liveness-exec</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5 <span class="comment"># pod启动延迟5秒后探测</span></span><br><span class="line">      periodSeconds: 5 <span class="comment"># 每5秒探测1次</span></span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-liveness-exec.yml</span></span><br></pre></td></tr></table></figure>

<p>通过下面的命令观察</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod liveness-exec</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age   From               Message</span><br><span class="line">  ----     ------     ----  ----               -------</span><br><span class="line">  Normal   Scheduled  40s   default-scheduler  Successfully assigned default/liveness-exec to k8s-worker1</span><br><span class="line">  Normal   Pulled     38s   kubelet    Container image <span class="string">"busybox"</span> already present on machine</span><br><span class="line">  Normal   Created    37s   kubelet     Created container liveness</span><br><span class="line">  Normal   Started    37s   kubelet     Started container liveness</span><br><span class="line">  Warning  Unhealthy  3s    kubelet     Liveness probe failed: cat: can<span class="string">'t open '</span>/tmp/healthy<span class="string">': No such file or directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#看到40s前被调度以k8s-worker1节点,3s前健康检查出问题</span></span><br></pre></td></tr></table></figure>

<p>过几分钟再观察</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod liveness-exec</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age                  From               Message</span><br><span class="line">  ----     ------     ----                 ----               -------</span><br><span class="line">  Normal   Scheduled  3m42s                default-scheduler  Successfully assigned default/liveness-exec to k8s-worker1</span><br><span class="line">  Normal   Pulled     70s (x3 over 3m40s)  kubelet     Container image <span class="string">"busybox"</span> already present on machine</span><br><span class="line">  Normal   Created    70s (x3 over 3m39s)  kubelet     Created container liveness</span><br><span class="line">  Normal   Started    69s (x3 over 3m39s)  kubelet     Started container liveness</span><br><span class="line">  Warning  Unhealthy  26s (x9 over 3m5s)   kubelet     Liveness probe failed: cat: can<span class="string">'t open '</span>/tmp/healthy<span class="string">': No such file or directory</span></span><br><span class="line"><span class="string">  Normal   Killing    26s (x3 over 2m55s)  kubelet     Container liveness failed liveness probe, will be restarted</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">[root@k8s-master1 ~]# kubectl get pod</span></span><br><span class="line"><span class="string">NAME            READY   STATUS    RESTARTS   AGE</span></span><br><span class="line"><span class="string">liveness-exec   1/1     Running   3          4m12s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#看到重启3次,慢慢地重启间隔时间会越来越长</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展: 容器重启策略验证</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: liveness-exec</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Never<span class="comment"># 把容器重启策略由默认的always改为Never</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5                         </span><br><span class="line">      periodSeconds: 5     </span><br><span class="line"> <span class="comment">#容器健康检查出现问题后，不再重启，也不会继续sleep 600秒，而是直接关闭了</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-liveness-httpget案例"><a href="#5-2-4-liveness-httpget案例" class="headerlink" title="5.2.4  liveness-httpget案例"></a><strong>5.2.4  liveness-httpget案例</strong></h3><p>编写YMAL文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-liveness-httpget.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: liveness-httpget</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:    			<span class="comment"># 指定容器端口，这一段不写也行，端口由镜像决定 </span></span><br><span class="line">    - name: http		<span class="comment"># 自定义名称，不需要与下面的port: http对应</span></span><br><span class="line">      containerPort: 80	<span class="comment"># 类似dockerfile里的expose 80</span></span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:                          <span class="comment"># 使用httpGet方式</span></span><br><span class="line">        port: http                      <span class="comment"># http协议,也可以直接写80端口</span></span><br><span class="line">        path: /index.html               <span class="comment"># 探测家目录下的index.html</span></span><br><span class="line">      initialDelaySeconds: 3            <span class="comment"># 延迟3秒开始探测</span></span><br><span class="line">      periodSeconds: 5                  <span class="comment"># 每隔5s钟探测一次</span></span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-liveness-httpget.yml</span></span><br></pre></td></tr></table></figure>

<p>验证查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME               READY   STATUS             RESTARTS   AGE</span><br><span class="line">liveness-httpget   1/1     Running            0          9s</span><br></pre></td></tr></table></figure>

<p>交互删除nginx里的主页文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it liveness-httpget -- rm -rf /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE</span><br><span class="line">liveness-httpget   1/1     Running   1          11m</span><br><span class="line"></span><br><span class="line"><span class="comment">#只restart一次</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-5-liveness-tcp案例"><a href="#5-2-5-liveness-tcp案例" class="headerlink" title="5.2.5  liveness-tcp案例"></a><strong>5.2.5  liveness-tcp案例</strong></h3><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-liveness-tcp.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: liveness-tcp</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:                        <span class="comment"># 使用tcp连接方式</span></span><br><span class="line">        port: 80                        <span class="comment"># 连接80端口进行探测</span></span><br><span class="line">      initialDelaySeconds: 3</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-liveness-tcp.yml</span></span><br><span class="line">pod/liveness-tcp created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME               READY   STATUS             RESTARTS   AGE</span><br><span class="line">liveness-tcp       1/1     Running            0          14s</span><br></pre></td></tr></table></figure>

<p>交互关闭nginx</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it liveness-tcp -- /usr/sbin/nginx -s stop</span></span><br></pre></td></tr></table></figure>

<p>再次验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE</span><br><span class="line">liveness-tcp       1/1     Running   1          5m13s</span><br><span class="line"></span><br><span class="line"><span class="comment">#也只重启1次,重启后重新初始化了</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-6-readiness案例"><a href="#5-2-6-readiness案例" class="headerlink" title="5.2.6 readiness案例"></a><strong>5.2.6 readiness案例</strong></h3><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-readiness-httpget.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: readiness-httpget</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: readiness</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    readinessProbe:                     <span class="comment"># 这里由liveness换成了readiness</span></span><br><span class="line">      httpGet:</span><br><span class="line">        port: http</span><br><span class="line">        path: /index.html</span><br><span class="line">      initialDelaySeconds: 3</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-readiness-httpget.yml</span></span><br><span class="line">pod/readiness-httpget created</span><br></pre></td></tr></table></figure>

<p>验证查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                READY   STATUS             RESTARTS   AGE</span><br><span class="line">readiness-httpget   1/1     Running            0          10s</span><br></pre></td></tr></table></figure>

<p>交互删除nginx主页</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it readiness-httpget -- rm -rf /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<p>再次验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">readiness-httpget   0/1     Running   0          2m49s</span><br><span class="line"></span><br><span class="line">READY状态为0/1</span><br></pre></td></tr></table></figure>

<p>交互创建nginx主页文件再验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it readiness-httpget -- touch /usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                READY   STATUS             RESTARTS   AGE</span><br><span class="line">readiness-httpget   1/1     Running            0          3m10s</span><br><span class="line"></span><br><span class="line"><span class="comment">#READY状态又为1/1了</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-7-readiness-liveness综合案例"><a href="#5-2-7-readiness-liveness综合案例" class="headerlink" title="5.2.7 readiness+liveness综合案例"></a><strong>5.2.7 readiness+liveness综合案例</strong></h3><p> 编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-readiness-liveiness.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: readiness-liveness-httpget</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: readiness-liveness</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        port: http</span><br><span class="line">        path: /index.html</span><br><span class="line">      initialDelaySeconds: 1</span><br><span class="line">      periodSeconds: 3</span><br><span class="line">    readinessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        port: http</span><br><span class="line">        path: /index.html</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-readiness-liveiness.yml</span></span><br><span class="line">pod/readiness-liveness-httpget created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod |grep readiness-liveness-httpget</span></span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">readiness-liveness-httpget   0/1     Running            0          6s</span><br></pre></td></tr></table></figure>

<h2 id="5-3-post-start"><a href="#5-3-post-start" class="headerlink" title="5.3 post-start"></a><strong>5.3 post-start</strong></h2><p> 编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pod-poststart.yml</span></span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: poststart</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: poststart</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    lifecycle:                                       <span class="comment"># 生命周期事件</span></span><br><span class="line">      postStart:</span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">"mkdir"</span>,<span class="string">"-p"</span>,<span class="string">"/usr/share/nginx/html/haha"</span>]</span><br></pre></td></tr></table></figure>

<p>应用YMAL文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pod-poststart.yml</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">poststart                    1/1     Running            0          25s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it poststart -- ls /usr/share/nginx/html -l</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root 494 Apr 16 13:08 50x.html</span><br><span class="line">drwxr-xr-x 2 root root   6 Aug  5 05:33 haha有创建此目录</span><br><span class="line">-rw-r--r-- 1 root root 612 Apr 16 13:08 index.html</span><br></pre></td></tr></table></figure>

<h2 id="5-4-pre-stop"><a href="#5-4-pre-stop" class="headerlink" title="5.4 pre-stop"></a><strong>5.4 pre-stop</strong></h2><p>容器终止前执行的命令</p>
<p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim prestop.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: prestop</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: prestop</span><br><span class="line">    image: nginx:1.15-alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    lifecycle:                                       <span class="comment"># 生命周期事件</span></span><br><span class="line">      preStop:                                       <span class="comment"># preStop</span></span><br><span class="line">        <span class="built_in">exec</span>:</span><br><span class="line">          <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"sleep 60000000"</span>]     <span class="comment"># 容器终止前sleep 60000000秒</span></span><br></pre></td></tr></table></figure>

<p> 应用YAML文件创建pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f prestop.yml</span></span><br><span class="line">pod/prestop created</span><br></pre></td></tr></table></figure>

<p>删除pod验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete -f prestop.yml</span></span><br><span class="line">pod <span class="string">"prestop"</span> deleted会在这一步等待一定的时间(大概30s-60s左右)才能删除,说明验证成功</span><br></pre></td></tr></table></figure>

<p><strong>结论:</strong> 当出现特殊情况不能正常销毁pod时,大概等待30秒会强制终止</p>
<h2 id="5-5-pod故障排除"><a href="#5-5-pod故障排除" class="headerlink" title="5.5 pod故障排除"></a><strong>5.5 pod故障排除</strong></h2><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Pending（悬决）</td>
<td>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。</td>
</tr>
<tr>
<td>Running（运行中）</td>
<td>pod已经绑定到一个节点，并且已经创建了所有容器。至少有一个容器正在运行中，或正在启动或重新启动。</td>
</tr>
<tr>
<td>completed（完成）</td>
<td>Pod中的所有容器都已成功终止，不会重新启动。</td>
</tr>
<tr>
<td>Failed（失败）</td>
<td>Pod的所有容器均已终止，且至少有一个容器已在故障中终止。也就是说，容器要么以非零状态退出，要么被系统终止。</td>
</tr>
<tr>
<td>Unknown（未知）</td>
<td>由于某种原因apiserver无法获得Pod的状态，通常是由于Master与Pod所在主机kubelet通信时出错。</td>
</tr>
<tr>
<td>CrashLoopBackOff</td>
<td>多见于CMD语句错误或者找不到container入口语句导致了快速退出,可以用kubectl logs 查看日志进行排错</td>
</tr>
</tbody></table>
<ul>
<li><code>kubectl describe pod  pod名</code></li>
<li><code>kubectl logs pod  [-c CONTAINER]</code></li>
<li><code>kubectl exec POD [-c CONTAINER] --COMMAND [args...]</code></li>
</ul>
<h1 id="六、自动水平拉伸pod"><a href="#六、自动水平拉伸pod" class="headerlink" title="六、自动水平拉伸pod"></a><strong>六、自动水平拉伸pod</strong></h1><p>deployment可以实现自动伸缩，使其pod的数量介于指定范围之间，CPU使用维持在指定比例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment my-nginx --min&#x3D;4 --max&#x3D;15 --cpu-percent&#x3D;80 -n mynamespace</span><br><span class="line">kubectl -n mynamespace set resources deployment&#x2F;my-ngiinx --limit&#x3D;cpu&#x3D;200m.memory&#x3D;512Mi</span><br><span class="line"></span><br><span class="line">#移除自动伸缩</span><br><span class="line">kubectl delete horizontalpodautoscalers.autoscaling -n mynamespace my-nginx</span><br><span class="line">#修改副本数量</span><br><span class="line">kubectl edit horizontalpodautoscalers.autoscaling -n mynamespace my-nginx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-YAML</title>
    <url>/2022/11/15/k8s-yaml/</url>
    <content><![CDATA[<h1 id="一、YAML介绍"><a href="#一、YAML介绍" class="headerlink" title="一、YAML介绍"></a><strong>一、YAML介绍</strong></h1><p>  YAML 的意思是：仍是一种标记语言，但为了强调这种语言以数据做为中心，而不是以标记语言为重点。是一个可读性高，用来表达数据序列的格式。</p>
<h1 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a><strong>二、基本语法</strong></h1><p>1.低版本缩进时不允许使用Tab键，只允许使用空格 </p>
<p>2.缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
<p>3.# 标识注释，从这个字符一直到行尾，都会被解释器忽略</p>
<a id="more"></a>

<h1 id="三、YAML-支持的数据结构"><a href="#三、YAML-支持的数据结构" class="headerlink" title="三、YAML  支持的数据结构"></a><strong>三、YAML  支持的数据结构</strong></h1><ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表 （list）</li>
<li>纯量（scalars）：单个的、不可再分的值  </li>
</ul>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>对象的一组键值对，使用冒号结构表示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">name: Steve</span><br><span class="line">age: 18</span><br></pre></td></tr></table></figure>

<p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash: &#123; name: Steve, age: 18 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>一组连词线开头的行，构成一个数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animal</span><br><span class="line">- Cat</span><br><span class="line">- Dog</span><br></pre></td></tr></table></figure>

<p>数组也可以采用行内表示法  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animal: [Cat, Dog]</span><br></pre></td></tr></table></figure>

<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>对象和数组可以结合使用，形成复合结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">languages:</span><br><span class="line">- Ruby </span><br><span class="line">- Perl </span><br><span class="line">- Python</span><br><span class="line">websites:</span><br><span class="line">YAML: yaml.org </span><br><span class="line">Ruby: ruby-lang.org </span><br><span class="line">Python: python.org </span><br><span class="line">Perl: use.perl.org</span><br></pre></td></tr></table></figure>

<h2 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于纯量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串  布尔值  整数 浮点数 Null </span><br><span class="line">时间  日期</span><br><span class="line"></span><br><span class="line">数值直接以字面量的形式表示</span><br><span class="line">number: 12.30</span><br><span class="line"></span><br><span class="line">布尔值用true和false表示</span><br><span class="line">isSet: true</span><br><span class="line"></span><br><span class="line">null用 ~ 表示</span><br><span class="line">parent: ~</span><br><span class="line"></span><br><span class="line">时间采用 ISO8601 格式</span><br><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br><span class="line"></span><br><span class="line">日期采用复合 iso8601 格式的年、月、日表示</span><br><span class="line">date: 1976-07-31</span><br><span class="line"></span><br><span class="line">YAML 允许使用两个感叹号，强制转换数据类型</span><br><span class="line">e: !!str 123</span><br><span class="line">f: !!str true</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串默认不使用引号表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str: 这是一行字符串</span><br></pre></td></tr></table></figure>

<p>如果字符串之中包含空格或特殊字符，需要放在引号之中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str: &#39;内容：  字符串&#39;</span><br></pre></td></tr></table></figure>

<p>单引号和双引号都可以使用，双引号不会对特殊字符转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1: &#39;内容\n字符串&#39;</span><br><span class="line">s2: &quot;内容\n字符串&quot;</span><br></pre></td></tr></table></figure>

<p>单引号之中如果还有单引号，必须连续使用两个单引号转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str: &#39;labor&#39;&#39;s day&#39;</span><br></pre></td></tr></table></figure>

<p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为 空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str: 这是一段</span><br><span class="line"> 多行</span><br><span class="line"> 字符串</span><br></pre></td></tr></table></figure>

<p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this: |</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br><span class="line">that</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br></pre></td></tr></table></figure>

<h1 id="四、Kubernetes集群中资源对象描述方法"><a href="#四、Kubernetes集群中资源对象描述方法" class="headerlink" title="四、Kubernetes集群中资源对象描述方法"></a><strong>四、Kubernetes集群中资源对象描述方法</strong></h1><p>在kubernetes中，一般使用ymal格式的文件来创建符合我们预期期望的pod,这样的yaml文件称为资源清单文件。</p>
<h2 id="4-1-常用字段"><a href="#4-1-常用字段" class="headerlink" title="4.1 常用字段"></a><strong>4.1 常用字段</strong></h2><table>
<thead>
<tr>
<th>参数名</th>
<th>字段类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>String</td>
<td>这里是指的是K8S API的版本，目前基本上是v1，可以用 kubectl api-versions命令查询</td>
</tr>
<tr>
<td>kind</td>
<td>String</td>
<td>这里指的是yam文件定义的资源类型和角色，比如:Pod</td>
</tr>
<tr>
<td>metadata</td>
<td>Object</td>
<td>元数据对象，固定值就写 metadata</td>
</tr>
<tr>
<td>metadata.name</td>
<td>String</td>
<td>元数据对象的名字，这里由我们编写，比如命名Pod的名字</td>
</tr>
<tr>
<td>metadata.namespace</td>
<td>String</td>
<td>元数据对象的命名空间，由我们自身定义</td>
</tr>
<tr>
<td>Spec</td>
<td>Object</td>
<td>详细定义对象，固定值就写Spec</td>
</tr>
<tr>
<td>spec. containers[]</td>
<td>list</td>
<td>这里是Spec对象的容器列表定义，是个列表</td>
</tr>
<tr>
<td>spec containers [].name</td>
<td>String</td>
<td>这里定义容器的名字</td>
</tr>
<tr>
<td>spec.containers [].image</td>
<td>String</td>
<td>这里定义要用到的镜像名称</td>
</tr>
<tr>
<td>spec.containers [].imagePullPolicy</td>
<td>String</td>
<td>定义镜像拉取策路，有 Always、 Never、Ifnotpresent三个值可选：(1) Always:意思是每次都尝试重新拉取镜像；(2) Never:表示仅使用本地镜像；(3) IfNotPresent:如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没设置的话，默认是 Always。</td>
</tr>
<tr>
<td>spec containers [].command[]</td>
<td>List</td>
<td>指定容器启动命令，因为是数组可以指定多个。不指定则使用镜像打包时使用的启动命令。</td>
</tr>
<tr>
<td>spec.containers [].args</td>
<td>List</td>
<td>指定容器启动命令参数，因为是数组可以指定多个.</td>
</tr>
<tr>
<td>spec.containers [].workDir</td>
<td>String</td>
<td>指定容器的工作目录</td>
</tr>
<tr>
<td>spec.containers[]. volumeMounts[]</td>
<td>List</td>
<td>指定容器内部的存储卷配置</td>
</tr>
<tr>
<td>spec.containers[]. volumeMounts[].name</td>
<td>String</td>
<td>指定可以被容器挂载的存储卷的名称</td>
</tr>
<tr>
<td>spec.containers[]. volumeMounts[].mountPath</td>
<td>String</td>
<td>指定可以被容器挂载的存储卷的路径</td>
</tr>
<tr>
<td>spec.containers[]. volumeMounts[].readOnly</td>
<td>String</td>
<td>设置存储卷路径的读写模式，ture或者 false，默认为读写模式</td>
</tr>
<tr>
<td>spec.containers [].ports[]</td>
<td>String</td>
<td>指容器需要用到的端口列表</td>
</tr>
<tr>
<td>spec.containers [].ports[].name</td>
<td>String</td>
<td>指定端口名称</td>
</tr>
<tr>
<td>spec.containers [].ports[].containerPort</td>
<td>String</td>
<td>指定容器需要监听的端口号</td>
</tr>
<tr>
<td>spec.containers [].ports[].hostPort</td>
<td>String</td>
<td>指定容器所在主机需要监听的端口号，默认跟上面 containerPort相同，注意设置了 hostPort同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同，这样会冲突)</td>
</tr>
<tr>
<td>spec.containers [].ports[].protocol</td>
<td>String</td>
<td>指定端口协议，支持TCP和UDP，默认值为TCP</td>
</tr>
<tr>
<td>spec.containers [].env[]</td>
<td>List</td>
<td>指定容器运行前需设的环境变量列表</td>
</tr>
<tr>
<td>spec.containers [].env[].name</td>
<td>String</td>
<td>指定环境变量名称</td>
</tr>
<tr>
<td>spec.containers [].env[].value</td>
<td>String</td>
<td>指定环境变量值</td>
</tr>
<tr>
<td>spec.containers[].resources</td>
<td>Object</td>
<td>指定资源 限制和资源请求的值（这里开始就是设置容器的资源上限）</td>
</tr>
<tr>
<td>spec.containers[].resources.limits</td>
<td>Object</td>
<td>指定设置容器运行时资源的运行上限</td>
</tr>
<tr>
<td>spec.containers[].resources.limits.cpu</td>
<td>String</td>
<td>指定CPU限制，单位为core数，将用于docker run – cpu-shares参数</td>
</tr>
<tr>
<td>spec.containers[].resources.limits.memory</td>
<td>String</td>
<td>指定MEM内存的限制，单位为MiB、GiB</td>
</tr>
<tr>
<td>spec.containers[].resources.requests</td>
<td>Object</td>
<td>指定容器启动和调度时的限制设置</td>
</tr>
<tr>
<td>spec.containers[].resources.requests.cpu</td>
<td>String</td>
<td>CPU请求，单位为core数，容器启动时初始化可用数量</td>
</tr>
<tr>
<td>spec.containers[].resources.requests.memory</td>
<td>String</td>
<td>内存请求，单位为MiB、GiB，容器启动时初始化可用数量</td>
</tr>
<tr>
<td>sepc.restartPolicy</td>
<td>String</td>
<td>定义Pod的重启策略，可选值为Always、OnFailure,默认值为Always。1.Always:Pod一旦终止运行，则无论容器时如何终止的，kubelet服务都将重启它。2.OnFailure:只有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束（退出码为0），则kubelet将不会重启它。3.Never:Pod终止后，kubelet将退出码报告给Master,不会重启该Pod。</td>
</tr>
<tr>
<td>spec.nodeSelector</td>
<td>Object</td>
<td>定义Node的Label过滤标签，以key:value格式指定。</td>
</tr>
<tr>
<td>spec.imagePullSecrets</td>
<td>Object</td>
<td>定义pull镜像时使用secret名称，以name:secretkey格式指定。</td>
</tr>
<tr>
<td>spec.hostNetwork</td>
<td>Boolean</td>
<td>定义是否使用主机网络模式，默认值为false。设置true表示使用宿主机网络，不使用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本。</td>
</tr>
</tbody></table>
<h2 id="4-2-举例说明"><a href="#4-2-举例说明" class="headerlink" title="4.2 举例说明"></a><strong>4.2 举例说明</strong></h2><h3 id="4-2-1-使用声明式文件YAML创建namespace"><a href="#4-2-1-使用声明式文件YAML创建namespace" class="headerlink" title="4.2.1 使用声明式文件YAML创建namespace"></a><strong>4.2.1 使用声明式文件YAML创建namespace</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br></pre></td></tr></table></figure>



<h3 id="4-2-2-使用声明式文件YAML创建pod"><a href="#4-2-2-使用声明式文件YAML创建pod" class="headerlink" title="4.2.2 使用声明式文件YAML创建pod"></a><strong>4.2.2 使用声明式文件YAML创建pod</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: k8sonline1</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-命名空间</title>
    <url>/2022/11/15/k8s%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="一、命名空间-namespace-作用"><a href="#一、命名空间-namespace-作用" class="headerlink" title="一、命名空间(namespace)作用"></a><strong>一、命名空间(namespace)作用</strong></h1><ul>
<li>Namespace是对一组资源和对象的抽象集合.</li>
<li>常见的 pod, service, deployment 等都是属于某一个namespace的（默认是 default）</li>
<li>不是所有资源都属于namespace，如nodes, persistent volume，namespace 等资源则不属于任何 namespace</li>
</ul>
<h1 id="二、查看namespace"><a href="#二、查看namespace" class="headerlink" title="二、查看namespace"></a><strong>二、查看namespace</strong></h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get namespaces       # namespaces可以简写为namespace或ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   130m         <span class="comment"># 所有未指定Namespace的对象都会被默认分配在default命名空间</span></span><br><span class="line">kube-node-lease   Active   130m         </span><br><span class="line">kube-public       Active   130m         <span class="comment"># 此命名空间下的资源可以被所有人访问</span></span><br><span class="line">kube-system       Active   130m         <span class="comment"># 所有由Kubernetes系统创建的资源都处于这个命名空间</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="三、查看namespace里的资源"><a href="#三、查看namespace里的资源" class="headerlink" title="三、查看namespace里的资源"></a><strong>三、查看namespace里的资源</strong></h1><p>使用<code>kubectl get all --namespace=命名空间名称</code>可以查看此命名空间下的所有资源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get all --namespace=kube-system</span></span><br><span class="line">NAME                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/calico-kube-controllers-7fdc86d8ff-cskfq     1/1     Running   3          5d1h</span><br><span class="line">pod/calico-node-9dpc9                            1/1     Running   2          5d1h</span><br><span class="line">pod/calico-node-jdmxw                            1/1     Running   3          5d1h</span><br><span class="line">pod/calico-node-krwps                            1/1     Running   2          5d1h</span><br><span class="line">pod/calico-node-tttlr                            1/1     Running   2          5d1h</span><br><span class="line">pod/coredns-65dbdb44db-mm7cr                     1/1     Running   2          5d1h</span><br><span class="line">pod/dashboard-metrics-scraper-545bbb8767-q66bc   1/1     Running   2          5d1h</span><br><span class="line">pod/kubernetes-dashboard-65665f84db-nll6k        1/1     Running   4          5d1h</span><br><span class="line">pod/metrics-server-869ffc99cd-8f4jd              1/1     Running   3          5d1h</span><br><span class="line"></span><br><span class="line">NAME                                TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   10.2.246.128   &lt;none&gt;        8000/TCP                 5d1h</span><br><span class="line">service/kube-dns                    ClusterIP   10.2.0.2       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   5d1h</span><br><span class="line">service/kubernetes-dashboard        NodePort    10.2.213.30    &lt;none&gt;        443:21351/TCP            5d1h</span><br><span class="line">service/metrics-server              ClusterIP   10.2.232.121   &lt;none&gt;        443/TCP                  5d1h</span><br><span class="line"></span><br><span class="line">NAME                         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                 AGE</span><br><span class="line">daemonset.apps/calico-node   4         4         4       4            4           beta.kubernetes.io/os=linux   5d1h</span><br><span class="line"></span><br><span class="line">NAME                                        READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/calico-kube-controllers     1/1     1            1           5d1h</span><br><span class="line">deployment.apps/coredns                     1/1     1            1           5d1h</span><br><span class="line">deployment.apps/dashboard-metrics-scraper   1/1     1            1           5d1h</span><br><span class="line">deployment.apps/kubernetes-dashboard        1/1     1            1           5d1h</span><br><span class="line">deployment.apps/metrics-server              1/1     1            1           5d1h</span><br><span class="line"></span><br><span class="line">NAME                                                   DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/calico-kube-controllers-7fdc86d8ff     1         1         1       5d1h</span><br><span class="line">replicaset.apps/coredns-65dbdb44db                     1         1         1       5d1h</span><br><span class="line">replicaset.apps/dashboard-metrics-scraper-545bbb8767   1         1         1       5d1h</span><br><span class="line">replicaset.apps/kubernetes-dashboard-65665f84db        1         1         1       5d1h</span><br><span class="line">replicaset.apps/metrics-server-869ffc99cd              1         1         1       5d1h</span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl get 资源类型 --namespace=命名空间名称</code>可以查看此命名空间下的对应的资源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod --namespace=kube-system</span></span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-7fdc86d8ff-cskfq     1/1     Running   3          5d1h</span><br><span class="line">calico-node-9dpc9                            1/1     Running   2          5d1h</span><br><span class="line">calico-node-jdmxw                            1/1     Running   3          5d1h</span><br><span class="line">calico-node-krwps                            1/1     Running   2          5d1h</span><br><span class="line">calico-node-tttlr                            1/1     Running   2          5d1h</span><br><span class="line">coredns-65dbdb44db-mm7cr                     1/1     Running   2          5d1h</span><br><span class="line">dashboard-metrics-scraper-545bbb8767-q66bc   1/1     Running   2          5d1h</span><br><span class="line">kubernetes-dashboard-65665f84db-nll6k        1/1     Running   4          5d1h</span><br><span class="line">metrics-server-869ffc99cd-8f4jd              1/1     Running   3          5d1h</span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl get 资源类型 -A</code> ，查看所有命名空间的资源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get pods -A</span></span><br><span class="line">NAMESPACE          NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-apiserver   calico-apiserver-665569779-4wr5l           1/1     Running   0          6h27m</span><br><span class="line">calico-apiserver   calico-apiserver-665569779-r76t6           1/1     Running   0          6h27m</span><br><span class="line">calico-system      calico-kube-controllers-78687bb75f-46l2t   1/1     Running   0          6h29m</span><br><span class="line">calico-system      calico-node-f9gx6                          1/1     Running   0          5h58m</span><br><span class="line">calico-system      calico-node-rsk4w                          1/1     Running   0          5h58m</span><br><span class="line">calico-system      calico-node-xfr2n                          1/1     Running   0          6h29m</span><br><span class="line">calico-system      calico-typha-75444c4b8-4x7pp               1/1     Running   0          5h58m</span><br><span class="line">calico-system      calico-typha-75444c4b8-nmmj5               1/1     Running   0          6h29m</span><br><span class="line">calico-system      csi-node-driver-4l2ts                      2/2     Running   0          5h56m</span><br><span class="line">calico-system      csi-node-driver-92q4k                      2/2     Running   0          6h28m</span><br><span class="line">calico-system      csi-node-driver-kcw5b                      2/2     Running   0          5h57m</span><br><span class="line">kube-system        coredns-558bd4d5db-5j4gq                   1/1     Running   0          16h</span><br><span class="line">kube-system        coredns-558bd4d5db-79qsm                   1/1     Running   0          16h</span><br><span class="line">kube-system        etcd-k8s-master01                          1/1     Running   0          16h</span><br><span class="line">kube-system        kube-apiserver-k8s-master01                1/1     Running   0          16h</span><br><span class="line">kube-system        kube-controller-manager-k8s-master01       1/1     Running   0          16h</span><br><span class="line">kube-system        kube-proxy-v2ltp                           1/1     Running   0          16h</span><br><span class="line">kube-system        kube-proxy-wzxps                           1/1     Running   0          5h58m</span><br><span class="line">kube-system        kube-proxy-zr77d                           1/1     Running   0          5h58m</span><br><span class="line">kube-system        kube-scheduler-k8s-master01                1/1     Running   0          16h</span><br><span class="line">tigera-operator    tigera-operator-6f669b6c4f-qmdbc           1/1     Running   0          6h37m</span><br></pre></td></tr></table></figure>

<h1 id="四、创建namespace"><a href="#四、创建namespace" class="headerlink" title="四、创建namespace"></a><strong>四、创建namespace</strong></h1><h2 id="4-1-命令创建"><a href="#4-1-命令创建" class="headerlink" title="4.1 命令创建"></a><strong>4.1 命令创建</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl create namespace ns1</span></span><br><span class="line">namespace/ns1 created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   5d1h</span><br><span class="line">kube-node-lease   Active   5d1h</span><br><span class="line">kube-public       Active   5d1h</span><br><span class="line">kube-system       Active   5d1h</span><br><span class="line">ns1               Active   10s</span><br></pre></td></tr></table></figure>

<h2 id="4-2-YAML文件创建"><a href="#4-2-YAML文件创建" class="headerlink" title="4.2 YAML文件创建"></a><strong>4.2 YAML文件创建</strong></h2><ul>
<li>k8s中几乎所有的资源都可以通这YAML编排来创建</li>
</ul>
<p>编写创建namespace的YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim create_ns2.yml</span></span><br><span class="line">apiVersion: v1                          <span class="comment"># api版本号</span></span><br><span class="line">kind: Namespace                         <span class="comment"># 类型为namespace</span></span><br><span class="line">metadata:                               <span class="comment"># 定义namespace的元数据属性</span></span><br><span class="line">  name: ns2                             <span class="comment"># 定义name属性为ns2</span></span><br></pre></td></tr></table></figure>

<p>使用kubctl apply -f应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f create_ns2.yml</span></span><br><span class="line">namespace/ns2 created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   5d2h</span><br><span class="line">kube-node-lease   Active   5d2h</span><br><span class="line">kube-public       Active   5d2h</span><br><span class="line">kube-system       Active   5d2h</span><br><span class="line">ns1               Active   10m</span><br><span class="line">ns2               Active   46s</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 kubectl edit 资源类型 资源名 编辑资源的YAML语法</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl edit namespace ns1</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li>也可使用 <code>kubectl get 资源类型 资源名 -o yaml</code>来查看</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get ns ns1 -o yaml</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li>还可通过<code>kubectl explain 资源类型</code>来查看语法文档</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain namespace                # 查看namespace相关语法参数</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain namespace.metadata       # 查看namespace下级metadata的相关语法参数</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl explain namespace.metadata.name  # 查看namespace下级metadata再下级name的相关语法参数</span></span><br></pre></td></tr></table></figure>

<h1 id="五、删除namespace"><a href="#五、删除namespace" class="headerlink" title="五、删除namespace"></a><strong>五、删除namespace</strong></h1><p><strong>注意:</strong> </p>
<ul>
<li>删除一个namespace会自动删除所有属于该namespace的资源(类似mysql中drop库会删除库里的所有表一样，请慎重操作)</li>
<li>default,kube-system,kube-public命名空间不可删除</li>
</ul>
<h2 id="5-1-命令删除"><a href="#5-1-命令删除" class="headerlink" title="5.1 命令删除"></a><strong>5.1 命令删除</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete namespace ns1</span></span><br><span class="line">namespace <span class="string">"ns1"</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="5-2-YAML文件删除"><a href="#5-2-YAML文件删除" class="headerlink" title="5.2 YAML文件删除"></a><strong>5.2 YAML文件删除</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete -f create_ns2.yml</span></span><br><span class="line">namespace <span class="string">"ns2"</span> deleted</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   5d2h</span><br><span class="line">kube-node-lease   Active   5d2h</span><br><span class="line">kube-public       Active   5d2h</span><br><span class="line">kube-system       Active   5d2h</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-node</title>
    <url>/2022/11/15/k8s-node/</url>
    <content><![CDATA[<h1 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a><strong>查看集群信息</strong></h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl cluster-info</span></span><br><span class="line">Kubernetes control plane is running at https://192.168.1.19:6443</span><br><span class="line">CoreDNS is running at https://192.168.1.19:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use <span class="string">'kubectl cluster-info dump'</span>.</span><br></pre></td></tr></table></figure>

<h1 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a><strong>查看节点信息</strong></h1><h2 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a><strong>节点信息</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master01   Ready    control-plane,master   11h   v1.21.0</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 64m   v1.21.0</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 63m   v1.21.0</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get node</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master01   Ready    control-plane,master   11h   v1.21.0</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 64m   v1.21.0</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 63m   v1.21.0</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="节点详情信息"><a href="#节点详情信息" class="headerlink" title="节点详情信息"></a><strong>节点详情信息</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get nodes -o wide</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME</span><br><span class="line">k8s-master01   Ready    control-plane,master   11h   v1.21.0   192.168.1.19   &lt;none&gt;        CentOS Linux 7 (Core)   5.19.8-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 64m   v1.21.0   192.168.1.16   &lt;none&gt;        CentOS Linux 7 (Core)   5.19.8-1.el7.elrepo.x86_64   docker://20.10.9</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 64m   v1.21.0   192.168.1.17   &lt;none&gt;        CentOS Linux 7 (Core)   5.19.8-1.el7.elrepo.x86_64   docker://20.10.9</span><br></pre></td></tr></table></figure>

<h2 id="节点详细的描述信息"><a href="#节点详细的描述信息" class="headerlink" title="节点详细的描述信息"></a><strong>节点详细的描述信息</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl describe node k8s-master01</span></span><br><span class="line">Name:               k8s-master01</span><br><span class="line">Roles:              control-plane,master</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    kubernetes.io/arch=amd64</span><br><span class="line">                    kubernetes.io/hostname=k8s-master01</span><br><span class="line">                    kubernetes.io/os=linux</span><br><span class="line">                    node-role.kubernetes.io/control-plane=</span><br><span class="line">                    node-role.kubernetes.io/master=</span><br><span class="line">                    node.kubernetes.io/exclude-from-external-load-balancers=</span><br><span class="line">Annotations:        csi.volume.kubernetes.io/nodeid: &#123;<span class="string">"csi.tigera.io"</span>:<span class="string">"k8s-master01"</span>&#125;</span><br><span class="line">                    kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock</span><br><span class="line">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class="line">                    projectcalico.org/IPv4Address: 192.168.1.19/24</span><br><span class="line">                    projectcalico.org/IPv4VXLANTunnelAddr: 10.244.32.128</span><br><span class="line">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class="literal">true</span></span><br><span class="line">CreationTimestamp:  Sat, 10 Sep 2022 23:17:35 +0800</span><br><span class="line">Taints:             node-role.kubernetes.io/master:NoSchedule</span><br><span class="line">Unschedulable:      <span class="literal">false</span></span><br><span class="line">Lease:</span><br><span class="line">  HolderIdentity:  k8s-master01</span><br><span class="line">  AcquireTime:     &lt;<span class="built_in">unset</span>&gt;</span><br><span class="line">  RenewTime:       Sun, 11 Sep 2022 11:06:35 +0800</span><br><span class="line">Conditions:</span><br><span class="line">  Type                 Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----                 ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  NetworkUnavailable   False   Sun, 11 Sep 2022 09:32:20 +0800   Sun, 11 Sep 2022 09:32:20 +0800   CalicoIsUp                   Calico is running on this node</span><br><span class="line">  MemoryPressure       False   Sun, 11 Sep 2022 11:03:56 +0800   Sat, 10 Sep 2022 23:17:34 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure         False   Sun, 11 Sep 2022 11:03:56 +0800   Sat, 10 Sep 2022 23:17:34 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure          False   Sun, 11 Sep 2022 11:03:56 +0800   Sat, 10 Sep 2022 23:17:34 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready                True    Sun, 11 Sep 2022 11:03:56 +0800   Sun, 11 Sep 2022 09:32:07 +0800   KubeletReady                 kubelet is posting ready status</span><br><span class="line">Addresses:</span><br><span class="line">  InternalIP:  192.168.1.19</span><br><span class="line">  Hostname:    k8s-master01</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  17394Mi</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             8117452Ki</span><br><span class="line">  pods:               110</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  16415037823</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             8015052Ki</span><br><span class="line">  pods:               110</span><br><span class="line">System Info:</span><br><span class="line">  Machine ID:                 4d61410eef834edf9b7843c926bbe691</span><br><span class="line">  System UUID:                75bc4d56-c008-db5f-4848-59f0939491af</span><br><span class="line">  Boot ID:                    1d543183-4871-45f1-a263-92d73fb9ca31</span><br><span class="line">  Kernel Version:             5.19.8-1.el7.elrepo.x86_64</span><br><span class="line">  OS Image:                   CentOS Linux 7 (Core)</span><br><span class="line">  Operating System:           linux</span><br><span class="line">  Architecture:               amd64</span><br><span class="line">  Container Runtime Version:  docker://20.10.9</span><br><span class="line">  Kubelet Version:            v1.21.0</span><br><span class="line">  Kube-Proxy Version:         v1.21.0</span><br><span class="line">PodCIDR:                      10.244.0.0/24</span><br><span class="line">PodCIDRs:                     10.244.0.0/24</span><br><span class="line">Non-terminated Pods:          (14 <span class="keyword">in</span> total)</span><br><span class="line">  Namespace                   Name                                        CPU Requests  CPU Limits  Memory Requests  Memory Limits  Age</span><br><span class="line">  ---------                   ----                                        ------------  ----------  ---------------  -------------  ---</span><br><span class="line">  calico-apiserver            calico-apiserver-665569779-4wr5l            0 (0%)        0 (0%)      0 (0%)           0 (0%)         93m</span><br><span class="line">  calico-apiserver            calico-apiserver-665569779-r76t6            0 (0%)        0 (0%)      0 (0%)           0 (0%)         93m</span><br><span class="line">  calico-system               calico-kube-controllers-78687bb75f-46l2t    0 (0%)        0 (0%)      0 (0%)           0 (0%)         96m</span><br><span class="line">  calico-system               calico-node-xfr2n                           0 (0%)        0 (0%)      0 (0%)           0 (0%)         96m</span><br><span class="line">  calico-system               calico-typha-75444c4b8-nmmj5                0 (0%)        0 (0%)      0 (0%)           0 (0%)         96m</span><br><span class="line">  calico-system               csi-node-driver-92q4k                       0 (0%)        0 (0%)      0 (0%)           0 (0%)         94m</span><br><span class="line">  kube-system                 coredns-558bd4d5db-5j4gq                    100m (5%)     0 (0%)      70Mi (0%)        170Mi (2%)     11h</span><br><span class="line">  kube-system                 coredns-558bd4d5db-79qsm                    100m (5%)     0 (0%)      70Mi (0%)        170Mi (2%)     11h</span><br><span class="line">  kube-system                 etcd-k8s-master01                           100m (5%)     0 (0%)      100Mi (1%)       0 (0%)         11h</span><br><span class="line">  kube-system                 kube-apiserver-k8s-master01                 250m (12%)    0 (0%)      0 (0%)           0 (0%)         11h</span><br><span class="line">  kube-system                 kube-controller-manager-k8s-master01        200m (10%)    0 (0%)      0 (0%)           0 (0%)         11h</span><br><span class="line">  kube-system                 kube-proxy-v2ltp                            0 (0%)        0 (0%)      0 (0%)           0 (0%)         11h</span><br><span class="line">  kube-system                 kube-scheduler-k8s-master01                 100m (5%)     0 (0%)      0 (0%)           0 (0%)         11h</span><br><span class="line">  tigera-operator             tigera-operator-6f669b6c4f-qmdbc            0 (0%)        0 (0%)      0 (0%)           0 (0%)         103m</span><br><span class="line">Allocated resources:</span><br><span class="line">  (Total limits may be over 100 percent, i.e., overcommitted.)</span><br><span class="line">  Resource           Requests    Limits</span><br><span class="line">  --------           --------    ------</span><br><span class="line">  cpu                850m (42%)  0 (0%)</span><br><span class="line">  memory             240Mi (3%)  340Mi (4%)</span><br><span class="line">  ephemeral-storage  100Mi (0%)  0 (0%)</span><br><span class="line">  hugepages-1Gi      0 (0%)      0 (0%)</span><br><span class="line">  hugepages-2Mi      0 (0%)      0 (0%)</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h1><h2 id="平滑删除pod"><a href="#平滑删除pod" class="headerlink" title="平滑删除pod"></a><strong>平滑删除pod</strong></h2><p>移除节点前，需要将节点上的资源，迁移到其他节点上</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl drain 即将删除节点名称 --delete-local-data --force --ignore-daemonsets</span><br></pre></td></tr></table></figure>

<h2 id="删除node"><a href="#删除node" class="headerlink" title="删除node"></a><strong>删除node</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除节点</span></span><br><span class="line">kubectl delete nodes 节点名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#在被删除节点中清空集群信息</span></span><br><span class="line">kubeadm reset -f</span><br><span class="line">system stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl start docker</span><br><span class="line">iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables =t mangle -F &amp;&amp; sudo iptables -X</span><br><span class="line">ipvsadm -C</span><br></pre></td></tr></table></figure>

<h1 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h1><h2 id="创建token加入节点"><a href="#创建token加入节点" class="headerlink" title="创建token加入节点"></a><strong>创建token加入节点</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在master查看token</span></span><br><span class="line">kubeadm token list</span><br><span class="line"><span class="comment">#通过openssl查看哈希值</span></span><br><span class="line">openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null |openssl dgst -sha256 -hex | sed <span class="string">'s/^.* //'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在集群中创建token，命令后边指定 --ttl 0则token不受时间限制，否则24小时过期</span></span><br><span class="line"></span><br><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br><span class="line"></span><br><span class="line"><span class="comment">#在节点端执行返回的join命令加入集群</span></span><br><span class="line">kubeadm join host:6443 --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxx</span><br></pre></td></tr></table></figure>

<h1 id="work节点管理集群"><a href="#work节点管理集群" class="headerlink" title="work节点管理集群"></a><strong>work节点管理集群</strong></h1><ul>
<li><p>如果是kubeasz安装，所有节点(包括master与node)都已经可以对集群进行管理</p>
</li>
<li><p>如果是kubeadm安装，在node节点上管理时，即使已经安装了kubectl，仍会报如下错误</p>
<blockquote>
<p>[root@k8s-node01 ~]# kubectl get nodes </p>
<p>The connection to the server localhost:8080 was refused - did you specify the right host or port?</p>
</blockquote>
</li>
</ul>
<p>只要把master上的管理文件<code>/etc/kubernetes/admin.conf</code>拷贝到node节点的<code>$HOME/.kube/config</code>就可以让node节点也可以实现kubectl命令管理</p>
<p>1, 在node节点的用户家目录创建.kube目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-node01 ~]<span class="comment"># mkdir /root/.kube</span></span><br></pre></td></tr></table></figure>

<p>2, 在master节点做如下操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp /etc/kubernetes/admin.conf root@k8s-node01:/root/.kube/config</span><br></pre></td></tr></table></figure>

<p>3, 在worker node节点验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-node01 ~]<span class="comment"># kubectl get node</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master01   Ready    control-plane,master   11h   v1.21.0</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 75m   v1.21.0</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 75m   v1.21.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s架构及组件</title>
    <url>/2022/11/15/k8s%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>kubernetes是具有中心节点的分布式架构,存在master节点、node节点</p>
<p><img src="/images/k8s%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BB%84%E4%BB%B6/kubernetes%E6%9E%B6%E6%9E%84.png" alt="截图11"></p>
<p>各个组件的基本功能：</p>
<ul>
<li>API Server：作为K8s通讯的核心组件，K8s内部交互以及接收发送指令的组件。</li>
<li>controller-manager：作为K8s的核心组件，主要做资源调度，根据集群情况分配资源</li>
<li>etcd：一个key-value的数据库，存储存储集群的状态信息</li>
<li>scheduler：负责调度每个工作节点</li>
<li>cloud-controller-manager：负责调度其他云服务产品</li>
<li>kubelet：管理Pods上面的容器。</li>
<li>kube-proxy：负责处理其他Slave或客户端的请求。</li>
<li>Pod：可以理解为就是运行的容器</li>
</ul>
<p>master是集群管理中心，它的组件可以集群内任意节点上运行，但是为了方便管理，一般是在某一台主机上运行所有的master组件，并且不在该主机是上运行用户容器</p>
<a id="more"></a>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="master组件"><a href="#master组件" class="headerlink" title="master组件"></a>master组件</h2><ul>
<li>kube-apiserver：用于暴露kubernests API，任何的资源请求/调用都是通过kube-apiserver提供的接口进行</li>
<li>kube-controller-manager：控制器管理器，用于对控制器进行管理，是集群中处理常规任务的后台线程</li>
<li>kube-scheduler：监视新创建没有分配到node的pod，为pod选择一个node运行</li>
<li>etcd：是k8s提供的默认存储系统，保存所有集群数据</li>
</ul>
<h2 id="node组件"><a href="#node组件" class="headerlink" title="node组件"></a>node组件</h2><p>用于运行以及维护pod，管理volume（CVI）和网络（CNI），维护pod及service等信息</p>
<ul>
<li>kubelet：负责维护容器的生命周期（创建pod，销毁pod），同时也负责volume（CVI）和网络（CNI）管理</li>
<li>kube-proxy<ul>
<li>通过在主机上维护网络规则并执行连续转发来实现service（iptables/ipvs）</li>
<li>随时与apiserver通信，把service或pod改变提交给apiserver，保存至etcd中，负责service实现从内部pod到service、从外部node到service的访问</li>
</ul>
</li>
<li>container-runtime<ul>
<li>容器运行时（container runtime）</li>
<li>负责镜像管理以及pod和容器的真正运行</li>
<li>支持docker、container、Rkt、pouch、kata等多种运行时</li>
</ul>
</li>
</ul>
<h2 id="Add-ons附件"><a href="#Add-ons附件" class="headerlink" title="Add-ons附件"></a>Add-ons附件</h2><p>Add-ons（附件）使功能更加丰富，没有它也不影响实际使用，可以与主体程序很好结合起来使用</p>
<ul>
<li>coredns/kube-dns：负责为整个集群提供DNS服务</li>
<li>Ingress Controller：为服务提供集群外部访问</li>
<li>Heapster/Metries-server：提供集群资源监控（监控容器可以使用prometheus）</li>
<li>Dashboard：提供集群GUI</li>
<li>Federation：提供跨可用区的集群</li>
<li>Fluentd-elastisearch：提供集群日志采集、存储与查询</li>
</ul>
]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-标签</title>
    <url>/2022/11/15/k8s%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a><strong>标签</strong></h1><p>k8s集群如果由大量节点组成，可将节点打上对应的标签，然后通过标签进行筛选及查看,更好的进行资源对象的相关选择与匹配</p>
<h2 id="查看节点标签信息"><a href="#查看节点标签信息" class="headerlink" title="查看节点标签信息"></a><strong>查看节点标签信息</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes --show-labels</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION   LABELS</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h   v1.21.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master01,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=,node.kubernetes.io/exclude-from-external-load-balancers=</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 78m   v1.21.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node01,kubernetes.io/os=linux</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 77m   v1.21.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node02,kubernetes.io/os=linux</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a><strong>设置标签</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定为某个node添加标签</span></span><br><span class="line">kubectl label node k8s-node02 key1=value1</span><br></pre></td></tr></table></figure>

<p><img src="/images/k8s%E6%A0%87%E7%AD%BE/%E6%88%AA%E5%9B%BE12.png" alt="截图12"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定为某个node添加多个标签</span></span><br><span class="line"> kubectl label node k8s-node01 key1=value1 key2=value2</span><br></pre></td></tr></table></figure>

<p><img src="/images/k8s%E6%A0%87%E7%AD%BE/%E6%88%AA%E5%9B%BE13.png" alt="截图13"></p>
<h2 id="指定标签查询node"><a href="#指定标签查询node" class="headerlink" title="指定标签查询node"></a><strong>指定标签查询node</strong></h2><p>注意-L和-l大小写区别</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h   v1.21.0</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 91m   v1.21.0</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 90m   v1.21.0</span><br><span class="line">======================================================================</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -L key2</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION   KEY2</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h   v1.21.0   </span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 98m   v1.21.0   value2</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 98m   v1.21.0 </span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -l key2</span></span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-node01   Ready    &lt;none&gt;   100m   v1.21.0</span><br><span class="line">======================================================================</span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -L key1,key2</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION   KEY1     KEY2</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h   v1.21.0            </span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 98m   v1.21.0   value1   value2</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 97m   v1.21.0   value1 </span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -l key1,key2</span></span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-node01   Ready    &lt;none&gt;   101m   v1.21.0</span><br><span class="line">================================================================================</span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -L key1</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE    VERSION   KEY1</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h    v1.21.0   </span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 101m   v1.21.0   value1</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 101m   v1.21.0   value1</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -l key1</span></span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-node01   Ready    &lt;none&gt;   102m   v1.21.0</span><br><span class="line">k8s-node02   Ready    &lt;none&gt;   101m   v1.21.0</span><br></pre></td></tr></table></figure>

<h2 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a><strong>修改标签</strong></h2><p><code>kubectl label node 节点名称 标签key=标签value --overwrite=true</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -L key1,key2</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE    VERSION   KEY1     KEY2</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h    v1.21.0            </span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 103m   v1.21.0   value1   value2</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 102m   v1.21.0   value1   </span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl label node k8s-node02 key1=v2 --overwrite=true</span></span><br><span class="line">node/k8s-node02 labeled</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 kubernetes]<span class="comment"># kubectl get nodes -L key1,key2                        </span></span><br><span class="line">NAME           STATUS   ROLES                  AGE    VERSION   KEY1     KEY2</span><br><span class="line">k8s-master01   Ready    control-plane,master   12h    v1.21.0            </span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 104m   v1.21.0   value1   value2</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 103m   v1.21.0   v2</span><br></pre></td></tr></table></figure>

<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h2><p>使用key加一个减号的写法来取消标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl label node k8s-node02 key1-</span><br></pre></td></tr></table></figure>

<p><img src="/images/k8s%E6%A0%87%E7%AD%BE/%E6%88%AA%E5%9B%BE14.png" alt="截图14"></p>
<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a><strong>标签选择器</strong></h2><p>标签选择器主要有2类:</p>
<ul>
<li>等值关系: =, !=</li>
<li>集合关系: KEY in (VALUE1, VALUE2……)</li>
</ul>
<p><img src="/images/k8s%E6%A0%87%E7%AD%BE/%E6%88%AA%E5%9B%BE15.png" alt="截图15"></p>
<h1 id="通过标签操作pod"><a href="#通过标签操作pod" class="headerlink" title="通过标签操作pod"></a>通过标签操作pod</h1><ul>
<li>为pod设置label,用于控制器通过label与pod关联</li>
<li>语法与前面学的node标签几乎一致</li>
</ul>
<p>查看pod的标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-stress     1/1    Running   0          7m25s   &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>打标签</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl label pod pod-stress region=huanai zone=A env=test bussiness=game</span></span><br><span class="line">pod/pod-stress labeled</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">pod-stress    1/1     Running   0          8m54s   bussiness=game,env=<span class="built_in">test</span>,region=huanai,zone=A</span><br></pre></td></tr></table></figure>

<p>通过等值关系标签查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -l zone=A</span></span><br><span class="line">NAME         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-stress   1/1     Running   0          9m22s</span><br></pre></td></tr></table></figure>

<p>通过集合关系标签查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -l "zone in (A,B,C)"</span></span><br><span class="line">NAME         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-stress   1/1     Running   0          9m55s</span><br></pre></td></tr></table></figure>

<p>删除标签后再验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl label pod pod-stress region- zone- env- bussiness-</span></span><br><span class="line">pod/pod-stress labeled</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods --show-labels</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-stress    1/1     Running   0          16m     &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p><strong>小结:</strong></p>
<ul>
<li>pod的label与node的label操作方式几乎相同</li>
<li>node的label用于pod调度到指定label的node节点</li>
<li>pod的label用于controller关联控制的pod</li>
</ul>
]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-部署安装</title>
    <url>/2022/11/15/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="虚拟机环境准备"><a href="#虚拟机环境准备" class="headerlink" title="虚拟机环境准备"></a>虚拟机环境准备</h1><h2 id="主机准备"><a href="#主机准备" class="headerlink" title="主机准备"></a>主机准备</h2><table>
<thead>
<tr>
<th>虚拟机主机名</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>k8s-master01</td>
<td>master</td>
</tr>
<tr>
<td>k8s-node01</td>
<td>node</td>
</tr>
<tr>
<td>k8s-node02</td>
<td>node</td>
</tr>
</tbody></table>
<h2 id="修改主机名称"><a href="#修改主机名称" class="headerlink" title="修改主机名称"></a>修改主机名称</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改主机名称</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname 修改之后的主机名</span><br><span class="line"><span class="comment">#重启生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="修改ip地址"><a href="#修改ip地址" class="headerlink" title="修改ip地址"></a>修改ip地址</h2><p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code>，添加主机ip和网关ip</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=eb71b764-a576-4cd4-8513-975a5cb1c5c5</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6_PRIVACY=no</span><br><span class="line">IPADDR=<span class="string">"192.168.1.19"</span></span><br><span class="line">GATEWAY=<span class="string">"192.168.1.1"</span></span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=4.2.2.2</span><br></pre></td></tr></table></figure>

<p>重启网关 <code>service network restart</code></p>
<h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#停止防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#查看防火墙是否启动，此时应该是not running</span></span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>

<h2 id="SELINUX配置"><a href="#SELINUX配置" class="headerlink" title="SELINUX配置"></a>SELINUX配置</h2><p>将/etc/selinux/config文件SELINUX参数修改为disabled</p>
<p><code>sed -ri &#39;s/SELINUX=enforcing/SELINUX=disabled/&#39; /etc/selinux/config</code></p>
<img src="/images/k8s部署安装/截图.png" alt="截图" style="zoom:67%;" />

<h2 id="主机时间同步"><a href="#主机时间同步" class="headerlink" title="主机时间同步"></a>主机时间同步</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install ntpdate</span><br><span class="line">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="升级操作系统内核"><a href="#升级操作系统内核" class="headerlink" title="升级操作系统内核"></a>升级操作系统内核</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、导入elrepo gpg key</span></span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、安装elrepo YUM源仓库</span></span><br><span class="line">yum -y install https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、安装kernel-ml版本，ml为长期稳定版本，lt为长期维护版本</span></span><br><span class="line">yum --enablerepo=<span class="string">"elrepo-kernel"</span> -y install kernel-ml.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、设置grub2默认引导为0</span></span><br><span class="line">grub2-set-default 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、重新生成grub2引导文件</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#6、更新后，需要重启，使用升级的内核生效。</span></span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启后，需要验证内核是否为更新对应的版本</span></span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>升级前后内核对比</p>
<img src="/images/k8s部署安装/截图2.png" alt="截图2"  />

<h2 id="配置内核转发及网桥过滤"><a href="#配置内核转发及网桥过滤" class="headerlink" title="配置内核转发及网桥过滤"></a>配置内核转发及网桥过滤</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、添加网桥过滤及内核转发配置文件</span></span><br><span class="line">vim /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness = 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、加载br_netfilter模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、查看是否加载</span></span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、加载网桥过滤及内核转发配置文件</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<h2 id="安装ipset及ipvsadm"><a href="#安装ipset及ipvsadm" class="headerlink" title="安装ipset及ipvsadm"></a>安装ipset及ipvsadm</h2><p>主要用于实现service转发</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、安装ipset及ipvsadm</span></span><br><span class="line">yum -y install ipset ipvsadm</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、配置ipvsadm模块加载方式</span></span><br><span class="line"><span class="comment">#添加需要加载的模块</span></span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、授权、运行、检查是否加载</span></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br></pre></td></tr></table></figure>

<h2 id="关闭SWAP分区"><a href="#关闭SWAP分区" class="headerlink" title="关闭SWAP分区"></a>关闭SWAP分区</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#永远关闭swap分区，需要重启操作系统</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#注释掉下面语句</span></span><br><span class="line"><span class="comment">#/dev/mapper/centos-swap swap                    swap    defaults        0 0</span></span><br></pre></td></tr></table></figure>

<p>修改完成后需要重启操作系统，如不重启，可临时关闭，命令为<code>swapoff -a</code></p>
<h1 id="docker准备"><a href="#docker准备" class="headerlink" title="docker准备"></a>docker准备</h1><h2 id="获取YUM源"><a href="#获取YUM源" class="headerlink" title="获取YUM源"></a>获取YUM源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h2 id="查看可安装版本"><a href="#查看可安装版本" class="headerlink" title="查看可安装版本"></a>查看可安装版本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64 --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<h2 id="安装指定版本并设置启动及开机自启动"><a href="#安装指定版本并设置启动及开机自启动" class="headerlink" title="安装指定版本并设置启动及开机自启动"></a>安装指定版本并设置启动及开机自启动</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install --<span class="built_in">setopt</span>=obsoletes=0 docker-ce-20.10.9-3.el7</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="修改cgroup方式"><a href="#修改cgroup方式" class="headerlink" title="修改cgroup方式"></a>修改cgroup方式</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在/etc/docker/daemon.json添加如下内容</span></span><br><span class="line"></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="kubernetes-安装"><a href="#kubernetes-安装" class="headerlink" title="kubernetes 安装"></a>kubernetes 安装</h1><h2 id="添加K8S的YUM源"><a href="#添加K8S的YUM源" class="headerlink" title="添加K8S的YUM源"></a>添加K8S的YUM源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二选一将谷歌YUM源或者阿里云YUM源，内容添加进文件中</span></span><br><span class="line">vim /etc/yum.repos.d/k8s.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#谷歌YUM源</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">#阿里云YUM源</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure>

<p>查看yum源：<code>yum repolist</code></p>
<p>发现加载出错，解决方法，修改/etc/yum.repos.d/k8s.repo文件中的repo_gpgcheck=0跳过验证</p>
<blockquote>
<p>已加载插件：fastestmirror, langpacks</p>
<p>kubernetes/signature                                                                                                                                  |  844 B  00:00:00</p>
<p>从 <a href="https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</a> 检索密钥</p>
<p>从 <a href="https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</a> 检索密钥</p>
<p>kubernetes/signature                                                                                                                                  | 1.4 kB  00:00:00 !!!</p>
<p><a href="https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/repodata/repomd.xml" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/repodata/repomd.xml</a>: [Errno -1] repomd.xml signature could not be verified for kubernetes</p>
<p>正在尝试其它镜像。</p>
<p>One of the configured repositories failed (Kubernetes),</p>
<p>and yum doesn’t have enough cached data to continue. At this point the only</p>
<p>safe thing yum can do is fail. There are a few ways to work “fix” this:</p>
</blockquote>
<p>此时yum源拉取正常</p>
<p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/%E6%88%AA%E5%9B%BE3.png" alt="截图3"></p>
<h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看指定版本</span></span><br><span class="line">yum list kubeadm.x86_64 --showduplicates | sort -r</span><br><span class="line">yum list kubelet.x86_64 --showduplicates | sort -r</span><br><span class="line">yum list kubectl.x86_64 --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装指定版本的kubeadm、kubelet、kubectl</span></span><br><span class="line">yum -y install --<span class="built_in">setopt</span>=obsoletes=0 kubeadm-1.21.0-0  kubelet-1.21.0-0 kubectl-1.21.0-0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已安装:</p>
<p>kubeadm.x86_64 0:1.21.0-0           kubectl.x86_64 0:1.21.0-0           kubelet.x86_64 0:1.21.0-0</p>
<p>作为依赖被安装:</p>
<p>conntrack-tools.x86_64 0:1.4.4-7.el7                   cri-tools.x86_64 0:1.24.2-0</p>
<p>kubernetes-cni.x86_64 0:0.8.7-0                        libnetfilter_cthelper.x86_64 0:1.0.0-11.el7</p>
<p>libnetfilter_cttimeout.x86_64 0:1.0.0-7.el7            libnetfilter_queue.x86_64 0:1.0.2-2.el7_2</p>
<p>socat.x86_64 0:1.7.3.2-2.el7</p>
<p>完毕！</p>
</blockquote>
<h2 id="配置kubelet"><a href="#配置kubelet" class="headerlink" title="配置kubelet"></a>配置kubelet</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为了实现docker使用的cgroupdriver与kubelet使用的cgroup的一致性，建议修改如下文件内容。</span></span><br><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--cgroup-driver=systemd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置kubelet为开机自启动即可，由于没有生成配置文件，集群初始化后自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>

<h2 id="集群镜像准备"><a href="#集群镜像准备" class="headerlink" title="集群镜像准备"></a>集群镜像准备</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看镜像版本，添加--kubernetes-version=v1.21.0查看指定版本</span></span><br><span class="line">kubeadm config images list --kubernetes-version=v1.21.0</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.21.0</span><br><span class="line">k8s.gcr.io/pause:3.4.1</span><br><span class="line">k8s.gcr.io/etcd:3.4.13-0</span><br><span class="line">k8s.gcr.io/coredns/coredns:v1.8.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建镜像下载脚本，执行后拉取镜像，并将镜像保存为tar包，由于国内可能没办法拉取镜像，可以通过vpn，或者将k8s.gcr.io替换成mirrorgcrio拉取docker</span></span><br><span class="line"><span class="comment">#替换镜像源，k8s.gcr.io =&gt; registry.cn-hangzhou.aliyuncs.com/google_containers</span></span><br><span class="line">vim image_download.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">images_list=<span class="string">'</span></span><br><span class="line"><span class="string">k8s.gcr.io/kube-apiserver:v1.21.0</span></span><br><span class="line"><span class="string">k8s.gcr.io/kube-controller-manager:v1.21.0</span></span><br><span class="line"><span class="string">k8s.gcr.io/kube-scheduler:v1.21.0</span></span><br><span class="line"><span class="string">k8s.gcr.io/kube-proxy:v1.21.0</span></span><br><span class="line"><span class="string">k8s.gcr.io/pause:3.4.1</span></span><br><span class="line"><span class="string">k8s.gcr.io/etcd:3.4.13-0</span></span><br><span class="line"><span class="string">k8s.gcr.io/coredns/coredns:v1.8.0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$images_list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        docker pull <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">docker save -o k8s-1-21-0.tar <span class="variable">$images_list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">sh image_download.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决 k8s.gcr.io相关镜像无法拉取问题</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.21.0</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.21.0</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.21.0</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.21.0</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.4.1</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.4.13-0</p>
<p>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:v1.8.0</p>
<p>#记得重新打tag，否则kubeadm init 时会重新拉取镜像</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.21.0 k8s.gcr.io/kube-apiserver:v1.21.0</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.21.0 k8s.gcr.io/kube-controller-manager:v1.21.0</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.21.0 k8s.gcr.io/kube-scheduler:v1.21.0</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.21.0 k8s.gcr.io/kube-proxy:v1.21.0</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.4.1 k8s.gcr.io/pause:3.4.1</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.4.13-0 k8s.gcr.io/etcd:3.4.13-0</p>
<p>docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:v1.8.0 k8s.gcr.io/coredns:v1.8.0</p>
</blockquote>
<h2 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在k8s-master01主机执行初始化命令</span></span><br><span class="line"><span class="comment">#执行init命令的主机将成为master</span></span><br><span class="line">kubeadm init --kubernetes-version=v1.21.0 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.1.19</span><br></pre></td></tr></table></figure>

<p>输出内容记得保存</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubeadm init --kubernetes-version=v1.21.0 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.1.19</span></span><br><span class="line">[init] Using Kubernetes version: v1.21.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action <span class="keyword">in</span> beforehand using <span class="string">'kubeadm config images pull'</span></span><br><span class="line">[certs] Using certificateDir folder <span class="string">"/etc/kubernetes/pki"</span></span><br><span class="line">[certs] Generating <span class="string">"ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver"</span> certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed <span class="keyword">for</span> DNS names [k8s-master01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.1.19]</span><br><span class="line">[certs] Generating <span class="string">"apiserver-kubelet-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"front-proxy-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/ca"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"etcd/server"</span> certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed <span class="keyword">for</span> DNS names [k8s-master01 localhost] and IPs [192.168.1.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"etcd/peer"</span> certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed <span class="keyword">for</span> DNS names [k8s-master01 localhost] and IPs [192.168.1.19 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">"etcd/healthcheck-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"apiserver-etcd-client"</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">"sa"</span> key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder <span class="string">"/etc/kubernetes"</span></span><br><span class="line">[kubeconfig] Writing <span class="string">"admin.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"kubelet.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"controller-manager.conf"</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">"scheduler.conf"</span> kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">"/var/lib/kubelet/kubeadm-flags.env"</span></span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">"/var/lib/kubelet/config.yaml"</span></span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-apiserver"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-controller-manager"</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">"kube-scheduler"</span></span><br><span class="line">[etcd] Creating static Pod manifest <span class="keyword">for</span> <span class="built_in">local</span> etcd <span class="keyword">in</span> <span class="string">"/etc/kubernetes/manifests"</span></span><br><span class="line">[<span class="built_in">wait</span>-control-plane] Waiting <span class="keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="string">"/etc/kubernetes/manifests"</span>. This can take up to 4m0s</span><br><span class="line">[kubelet-check] Initial timeout of 40s passed.</span><br><span class="line">[apiclient] All control plane components are healthy after 62.001527 seconds</span><br><span class="line">[upload-config] Storing the configuration used <span class="keyword">in</span> ConfigMap <span class="string">"kubeadm-config"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap <span class="string">"kubelet-config-1.21"</span> <span class="keyword">in</span> namespace kube-system with the configuration <span class="keyword">for</span> the kubelets <span class="keyword">in</span> the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 37exic.msprw2ejmhr9sgnm</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="keyword">in</span> order <span class="keyword">for</span> nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation <span class="keyword">for</span> all node client certificates <span class="keyword">in</span> the cluster</span><br><span class="line">[bootstrap-token] Creating the <span class="string">"cluster-info"</span> ConfigMap <span class="keyword">in</span> the <span class="string">"kube-public"</span> namespace</span><br><span class="line">[kubelet-finalize] Updating <span class="string">"/etc/kubernetes/kubelet.conf"</span> to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.19:6443 --token 37exic.msprw2ejmhr9sgnm \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:55753d0edf239649301c3463300e1e5777340926b0c1f1bbc1cf86034bac4c4e</span><br></pre></td></tr></table></figure>

<h2 id="集群应用客户端管理集群文件准备"><a href="#集群应用客户端管理集群文件准备" class="headerlink" title="集群应用客户端管理集群文件准备"></a>集群应用客户端管理集群文件准备</h2><p>从初始化脚本执行后的控制台可以得到以下信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#要开始使用集群</span></span><br><span class="line"><span class="comment">#普通用户的身份,则运行以下命令</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者，如果是root用户，您可以运行</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>

<p>以上命令执行之后，可以使用kubectl命令</p>
<img src="/images/k8s部署安装/截图4.png" alt="截图4" style="zoom:80%;" />

<p>因为缺少网络设施，coredns处于pending状态</p>
<h2 id="集群网络准备"><a href="#集群网络准备" class="headerlink" title="集群网络准备"></a>集群网络准备</h2><p><a href="https://projectcalico.docs.tigera.io/about/about-calico" target="_blank" rel="noopener">https://projectcalico.docs.tigera.io/about/about-calico</a></p>
<p>calico可以为k8s集群提供基础的网络设施</p>
<img src="/images/k8s部署安装/截图5.png" alt="截图5" style="zoom:67%;" />

<h3 id="calico安装"><a href="#calico安装" class="headerlink" title="calico安装"></a>calico安装</h3><p>1、安装 Tigera Calico 操作符和自定义资源定义。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</span><br></pre></td></tr></table></figure>

<p>2、通过创建必要的自定义资源来安装 Calico</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为需要修改default IP pool CIDR to match your pod network CIDR，所以不建议直接执行</span></span><br><span class="line"><span class="comment">#kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.24.1/manifests/custom-resources.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自行创建</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/calicofir</span><br><span class="line">wget  https://docs.projectcalico.org/manifests/custom-resources.yaml</span><br><span class="line"><span class="comment">#修改文件中的cidr地址为集群初始化指定的--pod.network.dir中指定的10.244.0.0.0/16</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/%E6%88%AA%E5%9B%BE6.png" alt="截图6"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f custom-resources.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/%E6%88%AA%E5%9B%BE7.png" alt="截图7"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看命名空间</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">calico-system     Active   79s</span><br><span class="line">default           Active   10h</span><br><span class="line">kube-node-lease   Active   10h</span><br><span class="line">kube-public       Active   10h</span><br><span class="line">kube-system       Active   10h</span><br><span class="line">tigera-operator   Active   9m3s</span><br><span class="line"></span><br><span class="line"> <span class="comment">#查看calico-system命名空间下的pod</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get pods -n calico-system</span></span><br><span class="line">NAME                                       READY   STATUS              RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-78687bb75f-46l2t   0/1     Pending             0          94s</span><br><span class="line">calico-node-xfr2n                          0/1     PodInitializing     0          94s</span><br><span class="line">calico-typha-75444c4b8-nmmj5               1/1     Running             0          94s</span><br><span class="line">csi-node-driver-92q4k                      0/2     ContainerCreating   0          4s</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控calico-system相关pod安装情况</span></span><br><span class="line">watch kubectl get pods -n calico-system</span><br><span class="line">Every 2.0s: kubectl get pods -n calico-system                                                                                                                     Sun Sep 11 09:39:03 2022</span><br><span class="line"></span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-78687bb75f-46l2t   1/1     Running   0          8m26s</span><br><span class="line">calico-node-xfr2n                          1/1     Running   0          8m26s</span><br><span class="line">calico-typha-75444c4b8-nmmj5               1/1     Running   0          8m26s</span><br><span class="line">csi-node-driver-92q4k                      2/2     Running   0          6m56s</span><br></pre></td></tr></table></figure>

<p>此时再看coredns处于Running状态表明联网成功。</p>
<img src="/images/k8s部署安装/截图8.png" alt="截图8" style="zoom:80%;" />

<h3 id="calico客户端安装"><a href="#calico客户端安装" class="headerlink" title="calico客户端安装"></a>calico客户端安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载二进制文件</span></span><br><span class="line">安装</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/calicofir</span><br><span class="line">curl -L https://github.com/projectcalico/calico/releases/download/v3.21.4/calicoctl-linux-amd64 -o calicoctl</span><br><span class="line"><span class="comment">#添加权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/calicofir/calicoctl</span><br><span class="line">calicoctl version</span><br></pre></td></tr></table></figure>

<h2 id="工作节点加入集群"><a href="#工作节点加入集群" class="headerlink" title="工作节点加入集群"></a>工作节点加入集群</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在之前初始化后控制台打印输出以下语句，将其粘贴到需要加入集群的主机上执行</span></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.19:6443 --token 37exic.msprw2ejmhr9sgnm \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:55753d0edf239649301c3463300e1e5777340926b0c1f1bbc1cf86034bac4c4e</span><br></pre></td></tr></table></figure>

<p>在node01和node02主机分别执行一次</p>
<p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/%E6%88%AA%E5%9B%BE9.png" alt="截图9"></p>
<p>回到master01主机查看，添加成功，等待拉取镜像安装</p>
<p><img src="/images/k8s%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/%E6%88%AA%E5%9B%BE10.png" alt="截图10"></p>
<h2 id="集群可用性验证"><a href="#集群可用性验证" class="headerlink" title="集群可用性验证"></a>集群可用性验证</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有节点</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME           STATUS   ROLES                  AGE     VERSION</span><br><span class="line">k8s-master01   Ready    control-plane,master   10h     v1.21.0</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;                 9m31s   v1.21.0</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;                 8m59s   v1.21.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看集群健康情况</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get cs</span></span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                       ERROR</span><br><span class="line">controller-manager   Unhealthy   Get <span class="string">"http://127.0.0.1:10252/healthz"</span>: dial tcp 127.0.0.1:10252: connect: connection refused   </span><br><span class="line">scheduler            Unhealthy   Get <span class="string">"http://127.0.0.1:10251/healthz"</span>: dial tcp 127.0.0.1:10251: connect: connection refused   </span><br><span class="line">etcd-0               Healthy     &#123;<span class="string">"health"</span>:<span class="string">"true"</span>&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看k8s集群pod运行情况</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get pods -n kube-system</span></span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-5j4gq               1/1     Running   0          10h</span><br><span class="line">coredns-558bd4d5db-79qsm               1/1     Running   0          10h</span><br><span class="line">etcd-k8s-master01                      1/1     Running   0          10h</span><br><span class="line">kube-apiserver-k8s-master01            1/1     Running   0          10h</span><br><span class="line">kube-controller-manager-k8s-master01   1/1     Running   0          10h</span><br><span class="line">kube-proxy-v2ltp                       1/1     Running   0          10h</span><br><span class="line">kube-proxy-wzxps                       1/1     Running   0          11m</span><br><span class="line">kube-proxy-zr77d                       1/1     Running   0          11m</span><br><span class="line">kube-scheduler-k8s-master01            1/1     Running   0          10h</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看calico网络工具运行情况</span></span><br><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl get pods -n calico-system</span></span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-78687bb75f-46l2t   1/1     Running   0          43m</span><br><span class="line">calico-node-f9gx6                          1/1     Running   0          12m</span><br><span class="line">calico-node-rsk4w                          1/1     Running   0          13m</span><br><span class="line">calico-node-xfr2n                          1/1     Running   0          43m</span><br><span class="line">calico-typha-75444c4b8-4x7pp               1/1     Running   0          12m</span><br><span class="line">calico-typha-75444c4b8-nmmj5               1/1     Running   0          43m</span><br><span class="line">csi-node-driver-4l2ts                      2/2     Running   0          10m</span><br><span class="line">csi-node-driver-92q4k                      2/2     Running   0          42m</span><br><span class="line">csi-node-driver-kcw5b                      2/2     Running   0          11m</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-kubectl</title>
    <url>/2022/11/15/k8s-kubectl/</url>
    <content><![CDATA[<h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><img src="/images/k8s-kubectl/kubectl命令帮助1.png" alt="kubectl命令帮助1" style="zoom:80%;" />

<a id="more"></a>

<p><img src="/images/k8s-kubectl/kubectl%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A92.png" alt="kubectl命令帮助2"></p>
<h1 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 calicofir]<span class="comment"># kubectl -h</span></span><br><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes</span><br><span class="line">Service</span><br><span class="line">  run           在集群中运行一个指定的镜像</span><br><span class="line">  <span class="built_in">set</span>           为 objects 设置一个指定的特征</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       查看资源的文档</span><br><span class="line">  get           显示一个或更多 resources</span><br><span class="line">  edit          在服务器上编辑一个资源</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size <span class="keyword">for</span> a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     Auto-scale a Deployment, ReplicaSet, StatefulSet, or ReplicationController</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   修改 certificate 资源.</span><br><span class="line">  cluster-info  显示集群信息</span><br><span class="line">  top           显示 Resource (CPU/Memory) 使用.</span><br><span class="line">  cordon        标记 node 为 unschedulable</span><br><span class="line">  uncordon      标记 node 为 schedulable</span><br><span class="line">  drain         Drain node <span class="keyword">in</span> preparation <span class="keyword">for</span> maintenance</span><br><span class="line">  taint         更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs          输出容器在 pod 中的日志</span><br><span class="line">  attach        Attach 到一个运行中的 container</span><br><span class="line">  <span class="built_in">exec</span>          在一个 container 中执行一个命令</span><br><span class="line">  port-forward  Forward one or more <span class="built_in">local</span> ports to a pod</span><br><span class="line">  proxy         运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line">  debug         Create debugging sessions <span class="keyword">for</span> troubleshooting workloads and nodes</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch         Update field(s) of a resource</span><br><span class="line">  replace       通过 filename 或者 stdin替换一个资源</span><br><span class="line">  <span class="built_in">wait</span>          Experimental: Wait <span class="keyword">for</span> a specific condition on one or many resources.</span><br><span class="line">  kustomize     Build a kustomization target from a directory or URL.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         更新在这个资源上的 labels</span><br><span class="line">  annotate      更新一个资源的注解</span><br><span class="line">  completion    Output shell completion code <span class="keyword">for</span> the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, <span class="keyword">in</span> the form of <span class="string">"group/version"</span></span><br><span class="line">  config        修改 kubeconfig 文件</span><br><span class="line">  plugin        Provides utilities <span class="keyword">for</span> interacting with plugins.</span><br><span class="line">  version       输出 client 和 server 的版本信息</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kubectl [flags] [options]</span><br><span class="line"></span><br><span class="line">Use <span class="string">"kubectl &lt;command&gt; --help"</span> <span class="keyword">for</span> more information about a given <span class="built_in">command</span>.</span><br><span class="line">Use <span class="string">"kubectl options"</span> <span class="keyword">for</span> a list of global <span class="built_in">command</span>-line options (applies to all commands).</span><br></pre></td></tr></table></figure>



<h1 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/bash_completion</span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure>

<p>以上命令执行后可以进行命令补全，但是退出终端重新进入后失效，需要执行以下操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl completion bash &gt; /root/.kube/completion.bash.inc</span><br><span class="line">vim <span class="variable">$HOME</span>/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#在$PATH前一行添加</span></span><br><span class="line"><span class="built_in">source</span> /root/.kube/completion.bash.inc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-service</title>
    <url>/2022/11/15/k8s-service/</url>
    <content><![CDATA[<h1 id="一、-service作用"><a href="#一、-service作用" class="headerlink" title="一、 service作用"></a>一、 service作用</h1><p>使用kubernetes集群运行工作负载时，由于Pod经常处于用后即焚状态，Pod经常被重新生成，因此Pod对应的IP地址也会经常变化，导致无法直接访问Pod提供的服务，Kubernetes中使用了Service来解决这一问题，即在Pod前面使用Service对Pod进行代理，无论Pod怎样变化 ，只要有Label，就可以让Service能够联系上Pod，把PodIP地址添加到Service对应的端点列表（Endpoints）实现对Pod IP跟踪，进而实现通过Service访问Pod目的。</p>
<ul>
<li><p>通过service为pod客户端提供访问pod方法，即可客户端访问pod入口</p>
</li>
<li><p>通过标签动态感知pod IP地址变化等</p>
</li>
<li><p>防止pod失联</p>
</li>
<li><p>定义访问pod访问策略</p>
</li>
<li><p>通过label-selector相关联</p>
</li>
<li><p>通过Service实现Pod的负载均衡（TCP/UDP 4层）</p>
</li>
<li><p>底层实现由kube-proxy通过userspace、iptables、ipvs三种代理模式</p>
<a id="more"></a>

</li>
</ul>
<h1 id="二、kube-proxy三种代理模式"><a href="#二、kube-proxy三种代理模式" class="headerlink" title="二、kube-proxy三种代理模式"></a>二、kube-proxy三种代理模式</h1><ul>
<li><p>kubernetes集群中有三层网络，一类是真实存在的，例如Node Network、Pod Network,提供真实IP地址;一类是虚拟的，例如Cluster Network或Service Network，提供虚拟IP地址，不会出现在接口上，仅会出现在Service当中</p>
</li>
<li><p>kube-proxy始终watch（监控）kube-apiserver上关于Service相关的资源变动状态，一旦获取相关信息，kube-proxy就把相关信息转化为当前节点之上能够实现Service资源调度到特定Pod之上的规则，进而实现访问Service就能够获取Pod所提供的服务</p>
</li>
<li><p>kube-proxy三种代理模式：UserSpace模式、iptables模式、ipvs模式</p>
</li>
</ul>
<h2 id="2-1-UserSpace模式"><a href="#2-1-UserSpace模式" class="headerlink" title="2.1 UserSpace模式"></a>2.1 UserSpace模式</h2><p>userspace 模式是 kube-proxy 使用的第一代模式，该模式在 kubernetes v1.0 版本开始支持使用。</p>
<p>userspace 模式的实现原理图示如下：</p>
<img src="/images/k8s-service/截图19.png" alt="截图19" style="zoom:67%;" />

<p>kube-proxy 会为每个 Service 随机监听一个端口(proxy port)，并增加一条 iptables 规则。所以通过 ClusterIP:Port 访问 Service 的报文都 redirect 到 proxy port，kube-proxy 从它监听的 proxy port 收到报文以后，走 round robin(默认) 或是 session affinity(会话亲和力，即同一 client IP 都走同一链路给同一 pod 服务)，分发给对应的 pod。</p>
<p>由于 userspace 模式会造成所有报文都走一遍用户态（也就是 Service 请求会先从用户空间进入内核 iptables，然后再回到用户空间，由 kube-proxy 完成后端 Endpoints 的选择和代理工作），需要在内核空间和用户空间转换，流量从用户空间进出内核会带来性能损耗，所以这种模式效率低、性能不高，不推荐使用。</p>
<img src="/images/k8s-service/截图20.png" alt="截图20" style="zoom: 67%;" />

<h2 id="2-2-iptables模式"><a href="#2-2-iptables模式" class="headerlink" title="2.2 iptables模式"></a>2.2 iptables模式</h2><p>iptables 模式是 kube-proxy 使用的第二代模式，该模式在 kubernetes v1.1 版本开始支持，从 v1.2 版本开始成为 kube-proxy 的默认模式。</p>
<p>iptables 模式的负载均衡模式是通过底层 netfilter/iptables 规则来实现的，通过 Informer 机制 Watch 接口实时跟踪 Service 和 Endpoint 的变更事件，并触发对 iptables 规则的同步更新。</p>
<p>iptables 模式的实现原理图示如下：</p>
<img src="/images/k8s-service/截图21.png" alt="截图21" style="zoom: 67%;" />

<p>通过图示我们可以发现在 iptables 模式下，kube-proxy 只是作为 controller，而不是 server，真正服务的是内核的 netfilter，体现在用户态的是 iptables。所以整体的效率会比 userspace 模式高。</p>
<img src="/images/k8s-service/截图22.png" alt="截图22" style="zoom:67%;" />



<h2 id="2-3-ipvs模式"><a href="#2-3-ipvs模式" class="headerlink" title="2.3 ipvs模式"></a>2.3 ipvs模式</h2><p>ipvs 模式被 kube-proxy 采纳为第三代模式，模式在 kubernetes v1.8 版本开始引入，在 v1.9 版本中处于 beta 阶段，在 v1.11 版本中正式开始使用。</p>
<p>ipvs(IP Virtual Server) 实现了传输层负载均衡，也就是 4 层交换，作为 Linux 内核的一部分。<code>ipvs</code>运行在主机上，在真实服务器前充当负载均衡器。ipvs 可以将基于 TCP 和 UDP 的服务请求转发到真实服务器上，并使真实服务器上的服务在单个 IP 地址上显示为虚拟服务。</p>
<p>ipvs 模式的实现原理图示如下：</p>
<img src="/images/k8s-service/截图23.png" alt="截图23" style="zoom:67%;" />

<img src="/images/k8s-service/截图24.png" alt="截图23" style="zoom:67%;" />

<p>ipvs 和 iptables 都是基于 netfilter 的，那么 ipvs 模式有哪些更好的性能呢？</p>
<ul>
<li>ipvs 为大型集群提供了更好的可拓展性和性能</li>
<li>ipvs 支持比 iptables 更复杂的负载均衡算法（包括：最小负载、最少连接、加权等）</li>
<li>ipvs 支持服务器健康检查和连接重试等功能</li>
<li>可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合</li>
</ul>
<p>ipvs 依赖于 iptables。ipvs 会使用 iptables 进行包过滤、airpin-masquerade tricks(地址伪装)、SNAT 等功能，但是使用的是 iptables 的扩展 ipset，并不是直接调用 iptables 来生成规则链。通过 ipset 来存储需要 DROP 或 masquerade 的流量的源或目标地址，用于确保 iptables 规则的数量是恒定的，这样我们就不需要关心有多少 Service 或是 Pod 了。</p>
<p>使用 ipset 相较于 iptables 有什么优点呢？iptables 是线性的数据结构，而 ipset 引入了带索引的数据结构，当规则很多的时候，ipset 依然可以很高效的查找和匹配。我们可以将 ipset 简单理解为一个 IP(段) 的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个“可变的集合进行操作”，这样就可以大大减少 iptables 规则的数量，从而减少性能损耗。</p>
<p>举一个例子，如果我们要禁止成千上万个 IP 访问我们的服务器，如果使用 iptables 就需要一条一条的添加规则，这样会在 iptables 中生成大量的规则；如果用 ipset 就只需要将相关的 IP 地址(网段)加入到 ipset 集合中，然后只需要设置少量的 iptables 规则就可以实现这个目标。</p>
<p>下面的表格是 ipvs 模式下维护的 ipset 表集合：</p>
<table>
<thead>
<tr>
<th align="left">设置名称</th>
<th align="left">成员</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">KUBE-CLUSTER-IP</td>
<td align="left">所有服务 IP + 端口</td>
<td align="left">在 masquerade-all=true 或 clusterCIDR 指定的情况下对 Service Cluster IP 地址进行伪装，解决数据包欺骗问题</td>
</tr>
<tr>
<td align="left">KUBE-LOOP-BACK</td>
<td align="left">所有服务 IP + 端口 + IP</td>
<td align="left">解决数据包欺骗问题</td>
</tr>
<tr>
<td align="left">KUBE-EXTERNAL-IP</td>
<td align="left">服务外部 IP + 端口</td>
<td align="left">将数据包伪装成 Service 的外部 IP 地址</td>
</tr>
<tr>
<td align="left">KUBE-LOAD-BALANCER</td>
<td align="left">负载均衡器入口 IP + 端口</td>
<td align="left">将数据包伪装成 Load Balancer 类型的 Service</td>
</tr>
<tr>
<td align="left">KUBE-LOAD-BALANCER-LOCAL</td>
<td align="left">负载均衡器入口 IP + 端口 以及<code>externalTrafficPolicy=local</code></td>
<td align="left">接受数据包到 Load Balancer externalTrafficPolicy=local</td>
</tr>
<tr>
<td align="left">KUBE-LOAD-BALANCER-FW</td>
<td align="left">负载均衡器入口 IP + 端口 以及<code>loadBalancerSourceRanges</code></td>
<td align="left">使用指定的 loadBalancerSourceRanges 丢弃 Load Balancer 类型 Service 的数据包</td>
</tr>
<tr>
<td align="left">KUBE-LOAD-BALANCER-SOURCE-CIDR</td>
<td align="left">负载均衡器入口 IP + 端口 + 源 CIDR</td>
<td align="left">接受 Load Balancer 类型 Service 的数据包，并指定 loadBalancerSourceRanges</td>
</tr>
<tr>
<td align="left">KUBE-NODE-PORT-TCP</td>
<td align="left">NodePort 类型服务 TCP 端口</td>
<td align="left">将数据包伪装成 NodePort（TCP）</td>
</tr>
<tr>
<td align="left">KUBE-NODE-PORT-LOCAL-TCP</td>
<td align="left">NodePort 类型服务 TCP 端口，带有<code>externalTrafficPolicy=local</code></td>
<td align="left">接受数据包到 NodePort 服务，使用 externalTrafficPolicy=local</td>
</tr>
<tr>
<td align="left">KUBE-NODE-PORT-UDP</td>
<td align="left">NodePort 类型服务 UDP 端口</td>
<td align="left">将数据包伪装成 NodePort(UDP)</td>
</tr>
<tr>
<td align="left">KUBE-NODE-PORT-LOCAL-UDP</td>
<td align="left">NodePort 类型服务 UDP 端口，使用<code>externalTrafficPolicy=local</code></td>
<td align="left">接受数据包到 NodePort 服务，使用 externalTrafficPolicy=local</td>
</tr>
</tbody></table>
<h2 id="2-4-iptables与ipvs对比"><a href="#2-4-iptables与ipvs对比" class="headerlink" title="2.4 iptables与ipvs对比"></a>2.4 iptables与ipvs对比</h2><ul>
<li><p>iptables</p>
<ul>
<li>工作在内核空间</li>
<li>优点：灵活，功能强大（可以在数据包不同阶段对包进行操作）</li>
<li>缺点：表中规则过多时，响应变慢，即规则遍历匹配和更新，呈线性时延</li>
</ul>
</li>
<li><p>ipvs</p>
<ul>
<li>工作在内核空间</li>
<li>优点<ul>
<li>转发效率高</li>
<li>调度算法丰富：rr，wrr，lc，wlc，ip hash…</li>
</ul>
</li>
<li>缺点：内核支持不全,低版本内核不能使用，需要升级到4.0或5.0以上。</li>
</ul>
</li>
<li><p>使用iptables与ipvs时机</p>
<ul>
<li>1.10版本之前使用iptables(1.1版本之前使用UserSpace进行转发)</li>
<li>1.11版本之后同时支持iptables与ipvs，默认使用ipvs，如果ipvs模块没有加载时，会自动降级至iptables</li>
</ul>
</li>
</ul>
<h1 id="三、-service类型"><a href="#三、-service类型" class="headerlink" title="三、 service类型"></a>三、 service类型</h1><p>Service类型决定了访问Service的方法</p>
<h2 id="3-1-service类型"><a href="#3-1-service类型" class="headerlink" title="3.1 service类型"></a>3.1 service类型</h2><ul>
<li><p>ClusterIP</p>
<ul>
<li>默认，分配一个集群内部可以访问的虚拟IP</li>
</ul>
</li>
<li><p>NodePort</p>
<ul>
<li>在每个Node上分配一个端口作为外部访问入口</li>
<li>nodePort端口范围为:30000-32767</li>
</ul>
</li>
<li><p>LoadBalancer</p>
<ul>
<li>工作在特定的Cloud Provider上，例如Google Cloud，AWS，OpenStack</li>
</ul>
</li>
<li><p>ExternalName</p>
<ul>
<li>表示把集群外部的服务引入到集群内部中来，即实现了集群内部pod和集群外部的服务进行通信</li>
</ul>
</li>
</ul>
<h2 id="3-2-Service参数"><a href="#3-2-Service参数" class="headerlink" title="3.2 Service参数"></a>3.2 Service参数</h2><ul>
<li><p>port：访问service使用的端口</p>
</li>
<li><p>targetPort：Pod中容器端口</p>
</li>
<li><p>nodePort：通过Node实现外网用户访问k8s集群内service (30000-32767)</p>
</li>
</ul>
<h1 id="四、-Service创建"><a href="#四、-Service创建" class="headerlink" title="四、 Service创建"></a>四、 Service创建</h1><blockquote>
<p>Service的创建在工作中有两种方式，一是命令行创建，二是通过资源清单文件YAML文件创建。</p>
</blockquote>
<h2 id="4-1-ClusterIP类型"><a href="#4-1-ClusterIP类型" class="headerlink" title="4.1 ClusterIP类型"></a>4.1 ClusterIP类型</h2><p>ClusterIP根据是否生成ClusterIP又可分为普通Service和Headless Service</p>
<p>Service两类：</p>
<ul>
<li><p>普通Service：为Kubernetes的Service分配一个集群内部可访问的固定虚拟IP(Cluster IP), 实现集群内的访问。</p>
</li>
<li><p>Headless Service：该服务不会分配Cluster IP, 也不通过kube-proxy做反向代理和负载均衡。而是通过DNS提供稳定的网络ID来访问，DNS会将headless service的后端直接解析为pod IP列表。</p>
</li>
</ul>
<img src="/images/k8s-service/截图25.png" alt="截图25" style="zoom:67%;" />



<h3 id="4-1-1-普通ClusterIP-Service创建"><a href="#4-1-1-普通ClusterIP-Service创建" class="headerlink" title="4.1.1 普通ClusterIP Service创建"></a>4.1.1 普通ClusterIP Service创建</h3><h4 id="4-1-1-1-命令行创建Service"><a href="#4-1-1-1-命令行创建Service" class="headerlink" title="4.1.1.1 命令行创建Service"></a>4.1.1.1 命令行创建Service</h4><p>创建Deployment类型的应用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># cat 01_create_deployment_app_nginx.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-server1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">     metadata:</span><br><span class="line">       labels:</span><br><span class="line">         app: nginx</span><br><span class="line">     spec:</span><br><span class="line">       containers:</span><br><span class="line">       - name: c1</span><br><span class="line">         image: nginx:1.15-alpine</span><br><span class="line">         imagePullPolicy: IfNotPresent</span><br><span class="line">         ports:</span><br><span class="line">         - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>应用资源清单文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f 01_create_deployment_app_nginx.yaml</span></span><br></pre></td></tr></table></figure>

<p>验证Deployment类型的创建情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get deployment.apps</span></span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-server1   2/2     2            2           13s</span><br></pre></td></tr></table></figure>

<p>创建ClusterIP类型service与Deployment类型应用关联</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令创建service</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl expose deployment.apps nginx-server1 --type=ClusterIP --target-port=80 --port=80</span></span><br><span class="line">service/nginx-server1 exposed</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明<br>expose 创建service<br>deployment.apps 控制器类型<br>nginx-server1 应用名称，也是service名称<br>–type=ClusterIP 指定service类型<br>–target-port=80 指定Pod中容器端口<br>–port=80 指定service端口</p>
</blockquote>
<h4 id="4-1-1-2-通过资源清单文件创建Service"><a href="#4-1-1-2-通过资源清单文件创建Service" class="headerlink" title="4.1.1.2 通过资源清单文件创建Service"></a>4.1.1.2 通过资源清单文件创建Service</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># cat 02_create_deployment_app_nginx_with_service.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-server1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">     metadata:</span><br><span class="line">       labels:</span><br><span class="line">         app: nginx</span><br><span class="line">     spec:</span><br><span class="line">       containers:</span><br><span class="line">       - name: nginx-smart</span><br><span class="line">         image: nginx:1.15-alpine</span><br><span class="line">         imagePullPolicy: IfNotPresent</span><br><span class="line">         ports:</span><br><span class="line">         - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-svc</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>

<p>应用资源文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl  apply -f 02_create_deployment_app_nginx_with_service.yaml</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看service</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get service</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP    4d15h</span><br><span class="line">nginx-svc    ClusterIP   10.101.153.50   &lt;none&gt;        80/TCP    3s</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看endpoints</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get endpoints</span></span><br><span class="line">NAME         ENDPOINTS                            AGE</span><br><span class="line">kubernetes   192.168.122.30:6443                  4d15h</span><br><span class="line">nginx-svc    172.16.189.74:80,172.16.235.150:80   8s</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -l app=nginx</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-server1-77d4c485d8-gsrmq   1/1     Running   0          12s</span><br><span class="line">nginx-server1-77d4c485d8-mmc52   1/1     Running   0          12s</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-3-访问"><a href="#4-1-1-3-访问" class="headerlink" title="4.1.1.3 访问"></a>4.1.1.3 访问</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># curl http://10.101.153.50:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-4-两个pod里做成不同的主页方便测试负载均衡"><a href="#4-1-1-4-两个pod里做成不同的主页方便测试负载均衡" class="headerlink" title="4.1.1.4 两个pod里做成不同的主页方便测试负载均衡"></a>4.1.1.4 两个pod里做成不同的主页方便测试负载均衡</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl exec -it nginx-server1-77d4c485d8-gsrmq -- /bin/bash</span></span><br><span class="line">root@deployment-nginx-6fcfb67547-nv7dn:/<span class="comment"># cd /usr/share/nginx/html/</span></span><br><span class="line">root@deployment-nginx-6fcfb67547-nv7dn:/usr/share/nginx/html<span class="comment"># echo web1 &gt; index.html</span></span><br><span class="line">root@deployment-nginx-6fcfb67547-nv7dn:/usr/share/nginx/html<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">xxxxxxxxxx [root@master01 ~]<span class="comment"># kubectl exec -it nginx-server1-77d4c485d8-mmc52 -- /bin/bashroot@deployment-nginx-6fcfb67547-rqrcw:/# cd /usr/share/nginx/html/root@deployment-nginx-6fcfb67547-rqrcw:/usr/share/nginx/html# echo web2 &gt; index.htmlroot@deployment-nginx-6fcfb67547-rqrcw:/usr/share/nginx/html# exitexit</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-5-测试"><a href="#4-1-1-5-测试" class="headerlink" title="4.1.1.5 测试"></a>4.1.1.5 测试</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># curl 10.101.153.50</span></span><br><span class="line">或</span><br><span class="line">[root@master01 ~]<span class="comment"># while true;do curl 10.101.153.50;sleep 1; done</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-Headless-Service"><a href="#4-1-2-Headless-Service" class="headerlink" title="4.1.2 Headless Service"></a>4.1.2 Headless Service</h3><ul>
<li>普通的ClusterIP service是service name解析为cluster ip,然后cluster ip对应到后面的pod ip</li>
<li>Headless service是指service name 直接解析为后面的pod ip</li>
</ul>
<h4 id="4-1-2-1-编写用于创建Deployment控制器类型的资源清单文件"><a href="#4-1-2-1-编写用于创建Deployment控制器类型的资源清单文件" class="headerlink" title="4.1.2.1 编写用于创建Deployment控制器类型的资源清单文件"></a>4.1.2.1 编写用于创建Deployment控制器类型的资源清单文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># cat 03_create_deployment_app_nginx.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-server1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">     metadata:</span><br><span class="line">       labels:</span><br><span class="line">         app: nginx</span><br><span class="line">     spec:</span><br><span class="line">       containers:</span><br><span class="line">       - name: nginx-smart</span><br><span class="line">         image: nginx:1.15-alpine</span><br><span class="line">         imagePullPolicy: IfNotPresent</span><br><span class="line">         ports:</span><br><span class="line">         - containerPort: 80</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-2-通过资源清单文件创建headless-Service"><a href="#4-1-2-2-通过资源清单文件创建headless-Service" class="headerlink" title="4.1.2.2 通过资源清单文件创建headless Service"></a>4.1.2.2 通过资源清单文件创建headless Service</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编写YAML文件</span></span><br><span class="line">[root@master ~]<span class="comment"># vim 04_headless-service.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: headless-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP     <span class="comment"># ClusterIP类型,也是默认类型</span></span><br><span class="line">  clusterIP: None     <span class="comment"># None就代表是无头service</span></span><br><span class="line">  ports:                                <span class="comment"># 指定service 端口及容器端口</span></span><br><span class="line">  - port: 80                            <span class="comment"># service ip中的端口</span></span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80                      <span class="comment"># pod中的端口</span></span><br><span class="line">  selector:                             <span class="comment"># 指定后端pod标签</span></span><br><span class="line">     app: nginx                    <span class="comment"># 可通过kubectl get pod -l app=nginx查看哪些pod在使用此标签</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-3-应用资源清单文件创建headless-Service"><a href="#4-1-2-3-应用资源清单文件创建headless-Service" class="headerlink" title="4.1.2.3 应用资源清单文件创建headless Service"></a>4.1.2.3 应用资源清单文件创建headless Service</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl apply -f 04_headless_service.yml</span></span><br><span class="line">service/headless-service created</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-4-查看已创建的headless-Service"><a href="#4-1-2-4-查看已创建的headless-Service" class="headerlink" title="4.1.2.4 查看已创建的headless Service"></a>4.1.2.4 查看已创建的headless Service</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get svc</span></span><br><span class="line"></span><br><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">headless-service   ClusterIP   None             &lt;none&gt;        80/TCP           2m18s</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          5d9h</span><br><span class="line"><span class="comment">#可以看到headless-service没有CLUSTER-IP,用None表示</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-5-DNS"><a href="#4-1-2-5-DNS" class="headerlink" title="4.1.2.5 DNS"></a>4.1.2.5 DNS</h4><p>DNS服务监视Kubernetes API，为每一个Service创建DNS记录用于域名解析</p>
<p>headless service需要DNS来解决访问问题</p>
<p>DNS记录格式为：<code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local.</code></p>
<p>查看kube-dns服务的IP</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># kubectl get svc -n kube-system</span></span><br><span class="line"></span><br><span class="line">NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns         ClusterIP   10.96.0.2      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   5d9h</span><br><span class="line">metrics-server   ClusterIP   10.105.219.44   &lt;none&gt;        443/TCP                  45h</span><br><span class="line"><span class="comment">#查看到coreDNS的服务地址是10.96.0.2</span></span><br></pre></td></tr></table></figure>

<p>在集群主机通过DNS服务地址查找无头服务的dns解析</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># dig -t A headless-service.default.svc.cluster.local. @10.96.0.2</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-16.P2.el7_8.2 &lt;&lt;&gt;&gt; -t A headless-service.default.svc.cluster.local. @10.96.0.2</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; WARNING: .<span class="built_in">local</span> is reserved <span class="keyword">for</span> Multicast DNS</span><br><span class="line">;; You are currently testing what happens when an mDNS query is leaked to DNS</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 31371</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;headless-service.default.svc.cluster.local. IN A <span class="comment">#被解析域名</span></span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">headless-service.default.svc.cluster.local. 30 IN A 10.224.235.147 <span class="comment">#注意这里IP</span></span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 10.96.0.10<span class="comment">#53(10.96.0.2)</span></span><br><span class="line">;; WHEN: Sun May 17 10:58:50 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 129</span><br></pre></td></tr></table></figure>

<p>验证pod的IP</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get pod -o wide</span></span><br><span class="line"></span><br><span class="line">NAME                                READY   STATUS             RESTARTS   AGE   IP               NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deployment-56bf6c9c8c-jmk7r   1/1     Running            0          35m   10.224.235.147   worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>在集群中创建一个pod验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个镜像为busyboxplus:curl的pod，pod名称为bb2,用来解析域名</span></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl run bbp --image=busyboxplus:curl -it</span></span><br><span class="line">或</span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl run bbp --image=1.28 -it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">If you don<span class="string">'t see a command prompt, try pressing enter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#解析域名</span></span><br><span class="line"><span class="string">nslookup headless-service.default.svc.cluster.local.</span></span><br><span class="line"><span class="string">#访问命令</span></span><br><span class="line"><span class="string">[ root@bbp:/ ]$ curl http://headless-service.default.svc.cluster.local.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#输出</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">    body &#123;</span></span><br><span class="line"><span class="string">        width: 35em;</span></span><br><span class="line"><span class="string">        margin: 0 auto;</span></span><br><span class="line"><span class="string">        font-family: Tahoma, Verdana, Arial, sans-serif;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span></span><br><span class="line"><span class="string">working. Further configuration is required.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p&gt;For online documentation and support please refer to</span></span><br><span class="line"><span class="string">&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span></span><br><span class="line"><span class="string">Commercial support is available at</span></span><br><span class="line"><span class="string">&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">[ root@bbp:/ ]$ exit</span></span><br><span class="line"><span class="string">Session ended, resume using '</span>kubectl attach bbp -c bbp -i -t<span class="string">' command when the pod is running</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-NodePort类型"><a href="#4-2-NodePort类型" class="headerlink" title="4.2 NodePort类型"></a>4.2 NodePort类型</h2><p>在每个node上分配一个端口（30000-32767）作为外部访问入口</p>
<p>创建资源清单文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># cat 05_create_nodeport_service_app.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-app</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: c1</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-app</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-app</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    nodePort: 30001</span><br><span class="line">    port: 8060</span><br><span class="line">    targetPort: 80</span><br></pre></td></tr></table></figure>

<p>应用资源清单文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f 05_create_nodeport_service_app.yaml</span></span><br><span class="line">deployment.apps/nginx-app created</span><br><span class="line">service/nginx-app created</span><br></pre></td></tr></table></figure>

<p>验证service创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get deployment.apps</span></span><br><span class="line">NAME         READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-app    2/2     2            2           26s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          2d22h</span><br><span class="line">nginx-app    NodePort    10.104.157.20    &lt;none&gt;        8060:30001/TCP   36s</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get endpoints</span></span><br><span class="line">NAME         ENDPOINTS                       AGE</span><br><span class="line">kubernetes   192.168.122.10:6443             2d22h</span><br><span class="line">nginx-app    172.16.1.24:80,172.16.2.20:80   2m10s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># ss -anput | grep ":30001"</span></span><br><span class="line">tcp    LISTEN     0      128      :::30001                :::*                   users:((<span class="string">"kube-proxy"</span>,pid=5826,fd=9))</span><br><span class="line"></span><br><span class="line">[root@worker01 ~]<span class="comment"># ss -anput | grep ":30001"</span></span><br><span class="line">tcp    LISTEN     0      128      :::30001                :::*                   users:((<span class="string">"kube-proxy"</span>,pid=4937,fd=11))</span><br><span class="line"></span><br><span class="line">[root@worker02 ~]<span class="comment"># ss -anput | grep ":30001"</span></span><br><span class="line">tcp    LISTEN     0      128      :::30001                :::*                   users:((<span class="string">"kube-proxy"</span>,pid=5253,fd=11))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-app-ffd5ccc78-cnwbx    1/1     Running   0          8m59s</span><br><span class="line">nginx-app-ffd5ccc78-mz77g    1/1     Running   0          8m59s</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl exec -it nginx-app-ffd5ccc78-cnwbx -- bash</span></span><br><span class="line">root@nginx-app-ffd5ccc78-cnwbx:/<span class="comment"># echo "nginx-app-1" &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@nginx-app-ffd5ccc78-cnwbx:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl exec -it nginx-app-ffd5ccc78-mz77g -- bash</span></span><br><span class="line">root@nginx-app-ffd5ccc78-mz77g:/<span class="comment"># echo "nginx-app-2" &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@nginx-app-ffd5ccc78-mz77g:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>在与kubernetes 节点同一网络主机中访问k8s集群内service</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># curl http://192.168.10.12:30001</span></span><br><span class="line">nginx-app-2</span><br><span class="line">[root@bogon ~]<span class="comment"># curl http://192.168.10.13:30001</span></span><br><span class="line">nginx-app-1</span><br><span class="line">[root@bogon ~]<span class="comment"># curl http://192.168.10.14:30001</span></span><br><span class="line">nginx-app-1</span><br><span class="line">[root@bogon ~]<span class="comment"># curl http://192.168.10.15:30001</span></span><br><span class="line">nginx-app-2</span><br></pre></td></tr></table></figure>

<h2 id="4-3-LoadBalancer"><a href="#4-3-LoadBalancer" class="headerlink" title="4.3 LoadBalancer"></a>4.3 LoadBalancer</h2><h3 id="4-3-1-集群外访问过程"><a href="#4-3-1-集群外访问过程" class="headerlink" title="4.3.1 集群外访问过程"></a>4.3.1 集群外访问过程</h3><ul>
<li><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4></li>
<li><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4></li>
<li><h4 id="云服务提供商提供LB服务"><a href="#云服务提供商提供LB服务" class="headerlink" title="云服务提供商提供LB服务"></a>云服务提供商提供LB服务</h4></li>
<li><h4 id="NodeIP-Port-service-IP"><a href="#NodeIP-Port-service-IP" class="headerlink" title="NodeIP:Port(service IP)"></a>NodeIP:Port(service IP)</h4></li>
<li><h4 id="Pod-IP：端口"><a href="#Pod-IP：端口" class="headerlink" title="Pod IP：端口"></a>Pod IP：端口</h4></li>
</ul>
<img src="/images/k8s-service/截图26.png" alt="截图26" style="zoom:67%;" />



<h3 id="4-3-2-自建Kubernetes的LoadBalancer类型服务方案-MetalLB"><a href="#4-3-2-自建Kubernetes的LoadBalancer类型服务方案-MetalLB" class="headerlink" title="4.3.2  自建Kubernetes的LoadBalancer类型服务方案-MetalLB"></a>4.3.2  自建Kubernetes的LoadBalancer类型服务方案-MetalLB</h3><p>MetalLB可以为kubernetes集群中的Service提供网络负载均衡功能。</p>
<p>MetalLB两大功能为:</p>
<ul>
<li>地址分配，类似于DHCP</li>
<li>外部通告，一旦MetalLB为服务分配了外部IP地址，它就需要使群集之外的网络意识到该IP在群集中“存在”。MetalLB使用标准路由协议来实现此目的：ARP，NDP或BGP。</li>
</ul>
<p>参考网址： <a href="https://metallb.universe.tf/installation/" target="_blank" rel="noopener">https://metallb.universe.tf/installation/</a></p>
<p>应用资源清单文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">资源清单文件下载：</span><br><span class="line"><span class="comment"># kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/namespace.yaml</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/metallb.yaml</span></span><br></pre></td></tr></table></figure>

<p>准备metallb配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx metallb]<span class="comment"># cat metallb-conf.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  namespace: metallb-system</span><br><span class="line">  name: config</span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    address-pools:</span><br><span class="line">    - name: default</span><br><span class="line">      protocol: layer2</span><br><span class="line">      addresses:</span><br><span class="line">      - 192.168.10.90-192.168.10.100</span><br><span class="line"> </span><br><span class="line">192.168.10.90-192.168.10.100是集群节点服务器IP同一段。</span><br></pre></td></tr></table></figure>

<p>在master01节点应用资源清单文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f metallb-conf.yaml</span></span><br></pre></td></tr></table></figure>

<p>验证配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl describe configmap config -n metallb-system</span></span><br><span class="line">Name:         config</span><br><span class="line">Namespace:    metallb-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">config:</span><br><span class="line">----</span><br><span class="line">address-pools:</span><br><span class="line">- name: default</span><br><span class="line">  protocol: layer2</span><br><span class="line">  addresses:</span><br><span class="line">  - 192.168.10.90-192.168.10.100</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>发布Service类型为LoadBalancer的Deployment控制器类型应用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建Deployment控制器类型应用nginx-metallb及service，service类型为LoadBalancer</span></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># vim 02_nginx-metabllb.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-metallb</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-metallb1</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-metallb</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8090</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  <span class="built_in">type</span>: LoadBalancer</span><br><span class="line">  </span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f nginx.yaml</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   16d</span><br><span class="line">kube-node-lease        Active   16d</span><br><span class="line">kube-public            Active   16d</span><br><span class="line">kube-system            Active   16d</span><br><span class="line">kubernetes-dashboard   Active   13d</span><br><span class="line">metallb-system         Active   130m</span><br><span class="line">test1                  Active   12d</span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -n metallb-system</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">controller-64f8f944d-qdf8m   1/1     Running   0          110m</span><br><span class="line">speaker-cwzq7                1/1     Running   0          110m</span><br><span class="line">speaker-qk5fb                1/1     Running   0          110m</span><br><span class="line">speaker-wsllb                1/1     Running   0          110m</span><br><span class="line">speaker-x4bwt                1/1     Running   0          110m</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME            TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE</span><br><span class="line">kubernetes      ClusterIP      10.96.0.1       &lt;none&gt;           443/TCP          16d</span><br><span class="line">nginx-metallb   LoadBalancer   10.105.239.69   192.168.10.90   8090:31372/TCP   106m</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># ping 192.168.10.90</span></span><br><span class="line">PING 192.168.10.90 (192.168.10.90) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.10.90: icmp_seq=1 ttl=64 time=3.45 ms</span><br><span class="line">64 bytes from 192.168.10.90: icmp_seq=2 ttl=64 time=0.040 ms</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># curl http://192.168.122.90:8090</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：使用kubeadm部署kubernetes集群修改方法</strong></p>
<blockquote>
<p>如果在IPVS模式下使用kube-proxy，从Kubernetes v1.14.2开始，必须启用ARP模式。</p>
<p>可以通过在当前集群中编辑kube-proxy配置来实现：<br><code>kubectl edit configmap -n kube-system kube-proxy</code></p>
<p>并设置：<br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>kind: KubeProxyConfiguration<br>mode: “ipvs”<br>ipvs:<br>  strictARP: true</p>
</blockquote>
<h2 id="4-4-ExternalName"><a href="#4-4-ExternalName" class="headerlink" title="4.4 ExternalName"></a>4.4 ExternalName</h2><ul>
<li>把集群外部的服务引入到集群内部中来，实现了集群内部pod和集群外部的服务进行通信</li>
<li>ExternalName 类型的服务适用于外部服务使用域名的方式，缺点是不能指定端口</li>
<li>还有一点要注意: 集群内的Pod会继承Node上的DNS解析规则。所以只要Node可以访问的服务，Pod中也可以访问到, 这就实现了集群内服务访问集群外服务</li>
</ul>
<h3 id="将公网域名引入"><a href="#将公网域名引入" class="headerlink" title="将公网域名引入"></a>将公网域名引入</h3><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> [root@master01 ~]<span class="comment"># vim externelname.yml</span></span><br><span class="line"> </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-externalname</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ExternalName</span><br><span class="line">  externalName: www.baidu.com                  <span class="comment"># 对应的外部域名为www.baidu.com</span></span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f externelname.yml</span></span><br><span class="line">service/my-externalname created</span><br></pre></td></tr></table></figure>

<p>查看service</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get svc |grep exter</span></span><br><span class="line">my-externalname    ExternalName   &lt;none&gt;         www.baidu.com   &lt;none&gt;         69s</span><br></pre></td></tr></table></figure>

<p>查看my-service的dns解析</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># dig -t A my-externalname.default.svc.cluster.local. @10.96.0.2</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-72.el7 &lt;&lt;&gt;&gt; -t A my-externalname.default.svc.cluster.local. @10.2.0.2</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 31378</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;my-externalname.default.svc.cluster.local. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">my-externalname.default.svc.cluster.local. 5 IN CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          5       IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       5       IN      A       14.215.177.38           解析的是百度的IP</span><br><span class="line">www.a.shifen.com.       5       IN      A       14.215.177.39           解析的是百度的IP</span><br><span class="line"></span><br><span class="line">;; Query time: 32 msec</span><br><span class="line">;; SERVER: 10.2.0.2<span class="comment">#53(10.96.0.2)</span></span><br><span class="line">;; WHEN: Thu Nov 05 11:23:41 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 245</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> [root@master01 ~]<span class="comment"># kubectl exec -it deploy-nginx-6c9764bb69-86gwj -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># nslookup www.baidu.com</span></span><br><span class="line">......</span><br><span class="line">Name:      www.baidu.com</span><br><span class="line">Address 1: 14.215.177.39</span><br><span class="line">Address 2: 14.215.177.38</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># nslookup my-externalname.default.svc.cluster.local         </span></span><br><span class="line">......</span><br><span class="line">Name:      my-externalname.default.svc.cluster.local</span><br><span class="line">Address 1: 14.215.177.38</span><br><span class="line">Address 2: 14.215.177.39</span><br></pre></td></tr></table></figure>

<p>解析此<code>my-externalname.default.svc.cluster.local</code>域名和解析<code>www.baidu.com</code>是一样的结果</p>
<h3 id="不同命名空间访问"><a href="#不同命名空间访问" class="headerlink" title="不同命名空间访问"></a>不同命名空间访问</h3><p>创建ns1命名空间和相关deploy, pod,service</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> [root@master01 ~]<span class="comment"># vim ns1-nginx.yml</span></span><br><span class="line">apiVersion: v1                                                  </span><br><span class="line">kind: Namespace                                                 </span><br><span class="line">metadata:                                                             </span><br><span class="line">  name: ns1                                                     <span class="comment"># 创建ns1命名空间</span></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deploy-nginx                    </span><br><span class="line">  namespace: ns1                                                <span class="comment"># 属于ns1命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: 1                                  </span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx                                </span><br><span class="line">  template:                                        </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx                             </span><br><span class="line">    spec:</span><br><span class="line">      containers:                              </span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: svc1                                <span class="comment"># 服务名</span></span><br><span class="line">  namespace: ns1                            <span class="comment"># 属于ns1命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  clusterIP: None                           <span class="comment"># 无头service</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80                         </span><br><span class="line">    targetPort: 80                  </span><br><span class="line">---</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: external-svc1</span><br><span class="line">  namespace: ns1                            <span class="comment">#  属于ns1命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ExternalName</span><br><span class="line">  externalName: svc2.ns2.svc.cluster.local   <span class="comment"># 将ns2空间的svc2服务引入到ns1命名空间</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> [root@master1 ~]<span class="comment"># kubectl apply -f ns1-nginx.yml</span></span><br><span class="line"> namespace/ns1 created</span><br><span class="line"> deployment.apps/deploy-nginx created</span><br><span class="line"> service/svc1 created</span><br></pre></td></tr></table></figure>

<p>创建ns2命名空间和相关deploy, pod,service</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># vim ns1-nginx.yml</span></span><br><span class="line">apiVersion: v1                                                  </span><br><span class="line">kind: Namespace                                                 </span><br><span class="line">metadata:                                                             </span><br><span class="line">  name: ns2                                                     <span class="comment"># 创建ns2命名空间</span></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deploy-nginx                    </span><br><span class="line">  namespace: ns2                                                <span class="comment"># 属于ns2命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: 1                                  </span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx                                </span><br><span class="line">  template:                                        </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx                             </span><br><span class="line">    spec:</span><br><span class="line">      containers:                              </span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: svc2                                <span class="comment"># 服务名</span></span><br><span class="line">  namespace: ns2                            <span class="comment"># 属于ns2命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  clusterIP: None                           <span class="comment"># 无头service</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80                         </span><br><span class="line">    targetPort: 80                  </span><br><span class="line">---</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: external-svc1</span><br><span class="line">  namespace: ns2                            <span class="comment">#  属于ns2命名空间</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ExternalName</span><br><span class="line">  externalName: svc1.ns1.svc.cluster.local   <span class="comment"># 将ns1空间的svc1服务引入到ns2命名空间</span></span><br></pre></td></tr></table></figure>

<p>在ns1命名空间的pod里验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> [root@master01 ~]<span class="comment"># kubectl get pods -n ns1</span></span><br><span class="line"> NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line"> deploy-nginx-6c9764bb69-g5xl8   1/1     Running   0          8m10s</span><br><span class="line"> </span><br><span class="line">  [root@master01 ~]<span class="comment"># kubectl exec -it -n ns1 deploy-nginx-6c9764bb69-g5xl8 -- /bin/sh</span></span><br><span class="line"> / <span class="comment"># nslookup svc1</span></span><br><span class="line"> ......</span><br><span class="line"> Name:      svc1</span><br><span class="line"> Address 1: 10.3.166.140 deploy-nginx-6c9764bb69-g5xl8       IP与ns1里的podIP一致(见下面的查询结果)</span><br><span class="line"> </span><br><span class="line"> / <span class="comment"># nslookup svc2.ns2.svc.cluster.local</span></span><br><span class="line"> .....</span><br><span class="line"> Name:      svc2.ns2.svc.cluster.local</span><br><span class="line"> Address 1: 10.3.104.17 10-3-104-17.svc2.ns2.svc.cluster.local   IP与ns2里的podIP一致(见下面的查询结果)</span><br><span class="line"> </span><br><span class="line"> / <span class="comment"># exit</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -o wide -n ns1</span></span><br><span class="line"> NAME                            READY   STATUS    RESTARTS   AGE   IP             NODE             NOMINATED NODE   READINESS GATES</span><br><span class="line"> deploy-nginx-6c9764bb69-g5xl8   1/1     Running   0          70m   10.3.166.140   192.168.122.13   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -o wide -n ns2</span></span><br><span class="line"> NAME                            READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READI            NESS GATES</span><br><span class="line"> deploy-nginx-6c9764bb69-8psxl   1/1     Running   0          68m   10.3.104.17   192.168.122.14   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>反之，在ns2命名空间的pod里访问<code>svc1.ns1.svc.cluster.local</code>，解析的IP是ns1命名空间里的pod的IP</p>
<p>验证ns2中的pod的IP变化, ns1中的pod仍然可以使用<code>svc2.ns2.svc.cluster.local</code>访问</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get pod -n ns2</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">deploy-nginx-6c9764bb69-8psxl   1/1     Running   0          81m</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除pod，因为有replicas控制器，所以删除pod会自动拉一个起来</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl delete pod deploy-nginx-6c9764bb69-8psxl -n ns2</span></span><br><span class="line">pod <span class="string">"deploy-nginx-6c9764bb69-8psxl"</span> deleted                  </span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pod -o wide -n ns2</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE     IP             NODE             NOMINATED NODE   READINESS GATES</span><br><span class="line">deploy-nginx-6c9764bb69-8qbz2   1/1     Running   0          5m36s   10.3.166.141   192.168.122.13   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">pod名称变了,IP也变成了10.3.166.141</span><br></pre></td></tr></table></figure>

<p>回到ns1中的pod验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl exec -it -n ns1 deploy-nginx-6c9764bb69-g5xl8 -- /bin/sh</span></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># ping svc2.ns2.svc.cluster.local -c 2</span></span><br><span class="line">PING svc2.ns2.svc.cluster.local (10.3.166.141): 56 data bytes    <span class="comment">#解析的IP就是ns2中pod的新IP</span></span><br><span class="line">64 bytes from 10.3.166.141: seq=0 ttl=63 time=0.181 ms</span><br><span class="line">64 bytes from 10.3.166.141: seq=1 ttl=63 time=0.186 ms</span><br><span class="line"></span><br><span class="line">--- svc2.ns2.svc.cluster.local ping statistics ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.181/0.183/0.186 ms</span><br><span class="line">/ <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>

<h1 id="五、sessionAffinity"><a href="#五、sessionAffinity" class="headerlink" title="五、sessionAffinity"></a>五、sessionAffinity</h1><p>设置sessionAffinity（会话粘贴）为Clientip  (类似nginx的ip_hash算法,lvs的sh算法)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx ~]<span class="comment"># cat 02_create_deployment_app_nginx_with_service.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-server1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">     metadata:</span><br><span class="line">       labels:</span><br><span class="line">         app: nginx</span><br><span class="line">     spec:</span><br><span class="line">       containers:</span><br><span class="line">       - name: c1</span><br><span class="line">         image: nginx:1.15-alpine</span><br><span class="line">         imagePullPolicy: IfNotPresent</span><br><span class="line">         ports:</span><br><span class="line">         - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-svc</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></table></figure>

<p>应用资源清单</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl apply -f 02_create_deployment_app_nginx_with_service.yaml</span></span><br><span class="line">deployment.apps/nginx-server1 created</span><br><span class="line">service/nginx-svc created</span><br></pre></td></tr></table></figure>

<p>修改会话粘贴模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]# kubectl patch svc nginx-svc -p &#39;&#123;&quot;spec&quot;:&#123;&quot;sessionAffinity&quot;:&quot;ClientIP&quot;&#125;&#125;&#39;</span><br><span class="line">service&#x2F;nginx-svc patched</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# curl 10.100.53.31</span><br><span class="line">web1</span><br><span class="line">#多次访问,会话粘贴</span><br></pre></td></tr></table></figure>

<p>设置回sessionAffinity为None</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">设置回sessionAffinity为None</span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl patch svc nginx-svc -p '&#123;"spec":&#123;"sessionAffinity":"None"&#125;&#125;'</span></span><br><span class="line">service/my-service patched</span><br><span class="line"></span><br><span class="line"><span class="comment">#多次访问,回到负载均衡</span></span><br></pre></td></tr></table></figure>

<h1 id="六、修改为ipvs调度方式"><a href="#六、修改为ipvs调度方式" class="headerlink" title="六、修改为ipvs调度方式"></a>六、修改为ipvs调度方式</h1><blockquote>
<p>部署方式不同，修改方法不一样。</p>
<p>本次主要介绍使用kubeadm部署集群方式，二进制部署较为简单。</p>
<p>二进制部署修改：/etc/kubernetes/kube-proxy.yaml文件即可。</p>
<p>从kubernetes1.8版本开始，新增了kube-proxy对ipvs的支持，在kubernetes1.11版本中被纳入了GA.</p>
</blockquote>
<h2 id="6-1-修改为IPVS调度方式前升级内核"><a href="#6-1-修改为IPVS调度方式前升级内核" class="headerlink" title="6.1 修改为IPVS调度方式前升级内核"></a>6.1 修改为IPVS调度方式前升级内核</h2><p>现使用Centos7u6发布版本，默认内核版本为3.10.0，使用kubernetes为1.18.0时，可升级内核版本至4.18.0或5.6.0版本。</p>
<p>在所有节点中安装,需要重启操作系统更换内核。以下升级方法供参考。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum -y install perl</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># yum -y install https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># yum  --enablerepo="elrepo-kernel"  -y install kernel-ml.x86_64 </span></span><br><span class="line"><span class="comment">#此处升级为5.0以上版本。</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># grub2-set-default 0</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-修改kube-proxy的配置文件"><a href="#6-2-修改kube-proxy的配置文件" class="headerlink" title="6.2 修改kube-proxy的配置文件"></a>6.2 修改kube-proxy的配置文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl edit configmap kube-proxy -n kube-system</span></span><br><span class="line">    iptables:</span><br><span class="line">      masqueradeAll: <span class="literal">false</span></span><br><span class="line">      masqueradeBit: 14</span><br><span class="line">      minSyncPeriod: 0s</span><br><span class="line">      syncPeriod: 30s</span><br><span class="line">    ipvs:</span><br><span class="line">      excludeCIDRs: null</span><br><span class="line">      minSyncPeriod: 0s</span><br><span class="line">      scheduler: <span class="string">""</span>	  <span class="comment"># 可以在这里修改ipvs的算法,默认为rr轮循算法</span></span><br><span class="line">      strictARP: <span class="literal">false</span></span><br><span class="line">      syncPeriod: 30s</span><br><span class="line">    kind: KubeProxyConfiguration</span><br><span class="line">    metricsBindAddress: 127.0.0.1:10249</span><br><span class="line">    mode: <span class="string">"ipvs"</span>	  <span class="comment"># 默认""号里为空,加上ipvs</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-查看kube-system的namespace中kube-proxy有关的pod"><a href="#6-3-查看kube-system的namespace中kube-proxy有关的pod" class="headerlink" title="6.3  查看kube-system的namespace中kube-proxy有关的pod"></a>6.3  查看kube-system的namespace中kube-proxy有关的pod</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -n kube-system |grep kube-proxy</span></span><br><span class="line">kube-proxy-69mv6                           1/1     Running   6          2d18h</span><br><span class="line">kube-proxy-jpc6c                           1/1     Running   4          4d16h</span><br><span class="line">kube-proxy-kq65l                           1/1     Running   4          4d16h</span><br><span class="line">kube-proxy-lmphf                           1/1     Running   5          4d16h</span><br></pre></td></tr></table></figure>

<h2 id="6-4-验证kube-proxy-xxx的pod中的信息"><a href="#6-4-验证kube-proxy-xxx的pod中的信息" class="headerlink" title="6.4 验证kube-proxy-xxx的pod中的信息"></a>6.4 验证kube-proxy-xxx的pod中的信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># kubectl logs kube-proxy-jpc6c -n kube-system</span></span><br><span class="line">W0517 00:55:10.914754       1 server_others.go:559] Unknown proxy mode <span class="string">""</span>, assuming iptables proxy</span><br><span class="line">I0517 00:55:10.923228       1 node.go:136] Successfully retrieved node IP: 192.168.122.32</span><br><span class="line">I0517 00:55:10.923264       1 server_others.go:186] Using iptables Proxier.</span><br><span class="line">I0517 00:55:10.923567       1 server.go:583] Version: v1.18.2</span><br><span class="line">I0517 00:55:10.923965       1 conntrack.go:100] Set sysctl <span class="string">'net/netfilter/nf_conntrack_max'</span> to 131072</span><br><span class="line">I0517 00:55:10.924001       1 conntrack.go:52] Setting nf_conntrack_max to 131072</span><br><span class="line">I0517 00:55:10.924258       1 conntrack.go:83] Setting conntrack hashsize to 32768</span><br><span class="line">I0517 00:55:10.927041       1 conntrack.go:100] Set sysctl <span class="string">'net/netfilter/nf_conntrack_tcp_timeout_established'</span> to 86400</span><br><span class="line">I0517 00:55:10.927086       1 conntrack.go:100] Set sysctl <span class="string">'net/netfilter/nf_conntrack_tcp_timeout_close_wait'</span> to 3600</span><br><span class="line">I0517 00:55:10.927540       1 config.go:315] Starting service config controller</span><br><span class="line">I0517 00:55:10.927556       1 shared_informer.go:223] Waiting <span class="keyword">for</span> caches to sync <span class="keyword">for</span> service config</span><br><span class="line">I0517 00:55:10.927576       1 config.go:133] Starting endpoints config controller</span><br><span class="line">I0517 00:55:10.927594       1 shared_informer.go:223] Waiting <span class="keyword">for</span> caches to sync <span class="keyword">for</span> endpoints config</span><br><span class="line">I0517 00:55:11.027749       1 shared_informer.go:230] Caches are synced <span class="keyword">for</span> service config</span><br><span class="line">I0517 00:55:11.027858       1 shared_informer.go:230] Caches are synced <span class="keyword">for</span> endpoints config</span><br></pre></td></tr></table></figure>

<h2 id="6-5-重新启动kube-proxy"><a href="#6-5-重新启动kube-proxy" class="headerlink" title="6.5 重新启动kube-proxy"></a>6.5 重新启动kube-proxy</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除kube-proxy-xxx的所有pod，让它重新拉取新的kube-proxy-xxx的pod</span></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl delete pod kube-proxy-69mv6 -n kube-system</span></span><br><span class="line">pod <span class="string">"kube-proxy-69mv6"</span> deleted</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl delete pod kube-proxy-jpc6c -n kube-system</span></span><br><span class="line">pod <span class="string">"kube-proxy-jpc6c"</span> deleted</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl delete pod kube-proxy-kq65l -n kube-system</span></span><br><span class="line">pod <span class="string">"kube-proxy-kq65l"</span> deleted</span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl delete pod kube-proxy-lmphf -n kube-system</span></span><br><span class="line">pod <span class="string">"kube-proxy-lmphf"</span> deleted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master01 ~]<span class="comment"># kubectl get pods -n kube-system |grep kube-proxy</span></span><br><span class="line">kube-proxy-2mk2b                           1/1     Running   0          2m23s</span><br><span class="line">kube-proxy-5bj87                           1/1     Running   0          30s</span><br><span class="line">kube-proxy-7qq9l                           1/1     Running   0          52s</span><br><span class="line">kube-proxy-tjtqf                           1/1     Running   0          80s</span><br><span class="line"></span><br><span class="line"><span class="comment">#随意查看其中1个或3个kube-proxy-xxx的pod,验证是否为IPVS方式了</span></span><br><span class="line">[root@master1 ~]<span class="comment"># kubectl logs kube-proxy-tjtqf -n kube-system</span></span><br><span class="line">I0517 02:32:26.557696       1 node.go:136] Successfully retrieved node IP: 192.168.122.32</span><br><span class="line">I0517 02:32:26.557745       1 server_others.go:259] Using ipvs Proxier.</span><br><span class="line">W0517 02:32:26.557912       1 proxier.go:429] IPVS scheduler not specified, use rr by default</span><br><span class="line">I0517 02:32:26.560008       1 server.go:583] Version: v1.18.2</span><br><span class="line">I0517 02:32:26.560428       1 conntrack.go:52] Setting nf_conntrack_max to 131072</span><br><span class="line">I0517 02:32:26.561094       1 config.go:315] Starting service config controller</span><br><span class="line">I0517 02:32:26.562251       1 shared_informer.go:223] Waiting <span class="keyword">for</span> caches to sync <span class="keyword">for</span> service config</span><br><span class="line">I0517 02:32:26.561579       1 config.go:133] Starting endpoints config controller</span><br><span class="line">I0517 02:32:26.562271       1 shared_informer.go:223] Waiting <span class="keyword">for</span> caches to sync <span class="keyword">for</span> endpoints config</span><br><span class="line">I0517 02:32:26.662541       1 shared_informer.go:230] Caches are synced <span class="keyword">for</span> service config</span><br><span class="line">I0517 02:32:26.662566       1 shared_informer.go:230] Caches are synced <span class="keyword">for</span> endpoints config</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-controller</title>
    <url>/2022/11/15/k8s-controller/</url>
    <content><![CDATA[<h1 id="一、pod控制器controller"><a href="#一、pod控制器controller" class="headerlink" title="一、pod控制器controller"></a>一、pod控制器controller</h1><h2 id="1-1-Controller作用及分类"><a href="#1-1-Controller作用及分类" class="headerlink" title="1.1 Controller作用及分类"></a>1.1 Controller作用及分类</h2><p>controller用于控制pod</p>
<p>参考: <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/workloads/controllers/</a></p>
<p><img src="/images/k8s-controller/%E6%88%AA%E5%9B%BE18.png" alt="截图18"></p>
<a id="more"></a>

<p>控制器主要分为:</p>
<ul>
<li>Deployments   部署无状态应用，控制pod升级,回退</li>
<li>ReplicaSet       副本集,控制pod扩容,裁减</li>
<li>ReplicationController(相当于ReplicaSet的老版本,现在建议使用Deployments加ReplicaSet替代RC)</li>
<li>StatefulSets     部署有状态应用，结合Service、存储等实现对有状态应用部署</li>
<li>DaemonSet     守护进程集，运行在所有集群节点(包括master), 比如使用filebeat,node_exporter</li>
<li>Jobs                  一次性</li>
<li>Cronjob            周期性</li>
</ul>
<h2 id="1-2-Deployment"><a href="#1-2-Deployment" class="headerlink" title="1.2 Deployment"></a>1.2 Deployment</h2><h3 id="1-2-1-Replicaset控制器的功能"><a href="#1-2-1-Replicaset控制器的功能" class="headerlink" title="1.2.1 Replicaset控制器的功能"></a>1.2.1 Replicaset控制器的功能</h3><ul>
<li>支持新的基于集合的selector(以前的rc里没有这种功能)</li>
<li>通过改变Pod副本数量实现Pod的扩容和缩容</li>
</ul>
<h3 id="1-2-2-Deployment控制器的功能"><a href="#1-2-2-Deployment控制器的功能" class="headerlink" title="1.2.2 Deployment控制器的功能"></a>1.2.2 Deployment控制器的功能</h3><ul>
<li>Deployment集成了上线部署、滚动升级、创建副本、回滚等功能</li>
<li>Deployment里包含并使用了ReplicaSet</li>
</ul>
<h3 id="1-2-3-Deployment用于部署无状态应用"><a href="#1-2-3-Deployment用于部署无状态应用" class="headerlink" title="1.2.3 Deployment用于部署无状态应用"></a>1.2.3 Deployment用于部署无状态应用</h3><p>无状态应用的特点:</p>
<ul>
<li>所有pod无差别</li>
<li>所有pod中容器运行同一个image</li>
<li>所有pod可以运行在集群中任意node上</li>
<li>所有pod无启动顺序先后之分</li>
<li>随意pod数量扩容或缩容</li>
<li>例如简单运行一个静态web程序</li>
</ul>
<h3 id="1-2-4-创建deployment类型应用"><a href="#1-2-4-创建deployment类型应用" class="headerlink" title="1.2.4 创建deployment类型应用"></a>1.2.4 创建deployment类型应用</h3><p> 准备YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim deployment-nginx.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deploy-nginx			<span class="comment"># deployment名</span></span><br><span class="line">spec:				</span><br><span class="line">  replicas: 1					<span class="comment"># 副本集,deployment里使用了replicaset</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx				<span class="comment"># 匹配的pod标签,表示deployment和rs控制器控制带有此标签的pod</span></span><br><span class="line">  template:					    <span class="comment"># 代表pod的配置模板</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx				<span class="comment"># pod的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:				<span class="comment"># 以下为pod里的容器定义</span></span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建deployment</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f deployment-nginx.yml</span></span><br><span class="line">deployment.apps/deploy-nginx created</span><br></pre></td></tr></table></figure>

<p>查看验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get deployment				# deployment可简写成depoly</span></span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deploy-nginx   1/1     1            1           19s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">deploy-nginx-6c9764bb69-pbc2h   1/1     Running   0          75s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get replicasets				# replicasets可简写成rs</span></span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">deploy-nginx-6c9764bb69   1         1         1       2m6s</span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-访问deployment"><a href="#1-2-5-访问deployment" class="headerlink" title="1.2.5 访问deployment"></a>1.2.5 访问deployment</h3><p>查看pod的IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">deploy-nginx-6d9d558bb6-88nr8   1/1     Running   0          39s   10.244.159.155   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#pod在k8s-master1节点,pod的IP为10.244.159.155</span></span><br></pre></td></tr></table></figure>

<p>查看所有集群节点的网卡，可以看到所有集群节点的IP都为<code>10.244.0.0/16</code>这个大网段内的子网</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># ifconfig tunl0 |head -2</span></span><br><span class="line">tunl0: flags=193&lt;UP,RUNNING,NOARP&gt;  mtu 1480</span><br><span class="line">        inet 10.244.159.128  netmask 255.255.255.255</span><br><span class="line"></span><br><span class="line">[root@k8s-master3 ~]<span class="comment"># ifconfig tunl0 |head -2</span></span><br><span class="line">tunl0: flags=193&lt;UP,RUNNING,NOARP&gt;  mtu 1480</span><br><span class="line">        inet 10.244.135.192  netmask 255.255.255.255</span><br><span class="line"></span><br><span class="line">[root@k8s-worker1 ~]<span class="comment"># ifconfig tunl0 |head -2</span></span><br><span class="line">tunl0: flags=193&lt;UP,RUNNING,NOARP&gt;  mtu 1480</span><br><span class="line">        inet 10.244.194.64  netmask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>在任意集群节点上都可以访问此deploy里pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl 10.244.159.155</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果是任意集群节点都可以访问这个POD,但集群外部是不能访问的</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-删除deployment中的pod"><a href="#1-2-6-删除deployment中的pod" class="headerlink" title="1.2.6 删除deployment中的pod"></a>1.2.6 删除deployment中的pod</h3><p>删除pod（<strong>注意: 是删除deployment中的pod</strong>）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete pod deploy-nginx-6c9764bb69-pbc2h</span></span><br><span class="line">pod <span class="string">"deploy-nginx-6c9764bb69-pbc2h"</span> deleted</span><br></pre></td></tr></table></figure>

<p>再次查看,发现又重新启动了一个pod(<strong>节点由k8s-master1转为k8s-worker1 了,IP地址也变化了</strong>)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods  -o wide</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">deploy-nginx-6d9d558bb6-f2t6r   1/1     Running   0          28s   10.244.194.94   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>也就是说<strong>==pod的IP不是固定的==</strong>,比如把整个集群关闭再启动,pod也会自动启动,但是<strong>IP地址也会变化</strong></p>
<p><strong>既然IP地址不是固定的,所以需要一个固定的访问endpoint给用户,那么这种方式就是service.</strong></p>
<h3 id="1-2-7-pod版本升级"><a href="#1-2-7-pod版本升级" class="headerlink" title="1.2.7 pod版本升级"></a>1.2.7 pod版本升级</h3><p>查看帮助</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl set image -h</span></span><br></pre></td></tr></table></figure>

<p>升级前验证nginx版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pods deploy-nginx-6d9d558bb6-f2t6r | grep Image:</span></span><br><span class="line">    Image:          nginx:1.15-alpine</span><br><span class="line">    </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec deploy-nginx-6d9d558bb6-f2t6r -- nginx -v</span></span><br><span class="line">nginx version: nginx/1.15.12</span><br></pre></td></tr></table></figure>

<p>升级为1.16版</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl set image deployment deploy-nginx nginx=nginx:1.16-alpine --record</span></span><br><span class="line">deployment.apps/deploy-nginx image updated</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li><p><code>deployment deploy-nginx</code>代表名为deploy-nginx的deployment</p>
</li>
<li><p><code>nginx=nginx:1.16-alpine</code>前面的nginx为容器名</p>
</li>
<li><p>–record  表示会记录</p>
</li>
</ul>
<p><strong>容器名怎么查看?</strong></p>
<ul>
<li><code>kubectl describe pod pod名</code>查看</li>
<li><code>kubectl edit deployment deployment名</code>来查看容器名</li>
<li><code>kubectl get deployment deployment名 -o yaml</code>来查看容器名</li>
</ul>
<p>验证</p>
<p>如果升级的pod数量较多，则需要一定时间，可通过下面命令查看是否已经成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout status deployment deploy-nginx	</span></span><br><span class="line">deployment <span class="string">"deploy-nginx"</span> successfully rolled out</span><br></pre></td></tr></table></figure>

<p>验证 pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">deploy-nginx-5f4749c8c8-nskp9   1/1     Running   0          104s     <span class="comment">#更新后,NAME后面的id变了</span></span><br></pre></td></tr></table></figure>

<p>验证版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod deploy-nginx-5f4749c8c8-nskp9 |grep Image:</span></span><br><span class="line">    Image:          nginx:1.16-alpine							<span class="comment">#升级为1.16了</span></span><br><span class="line">    </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec deploy-nginx-5f4749c8c8-nskp9 -- nginx -v</span></span><br><span class="line">nginx version: nginx/1.16.1										<span class="comment">#升级为1.16了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再次升级</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record</span></span><br><span class="line">deployment.apps/deploy-nginx image updated</span><br></pre></td></tr></table></figure>

<h3 id="1-2-8-pod版本回退"><a href="#1-2-8-pod版本回退" class="headerlink" title="1.2.8 pod版本回退"></a>1.2.8 pod版本回退</h3><p>查看版本历史信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout history deployment deploy-nginx</span></span><br><span class="line">deployment.apps/deploy-nginx</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;												<span class="comment">#原1.15版</span></span><br><span class="line">2         kubectl <span class="built_in">set</span> image deployment deploy-nginx nginx=nginx:1.16-alpine --record=<span class="literal">true</span></span><br><span class="line">3         kubectl <span class="built_in">set</span> image deployment deploy-nginx nginx=nginx:1.17-alpine --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>定义要回退的版本（还需要执行才是真的回退版本)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout history deployment deploy-nginx --revision=1</span></span><br><span class="line">deployment.apps/deploy-nginx with revision <span class="comment">#1</span></span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:       app=nginx</span><br><span class="line">        pod-template-hash=6c9764bb69</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.15-alpine				<span class="comment">#可以看到这是要回退的1.15版本</span></span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Environment:        &lt;none&gt;</span><br><span class="line">    Mounts:     &lt;none&gt;</span><br><span class="line">  Volumes:      &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>执行回退</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout undo deployment deploy-nginx --to-revision=1</span></span><br><span class="line">deployment.apps/deploy-nginx rolled back</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout history deployment deploy-nginx</span></span><br><span class="line">deployment.apps/deploy-nginx</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">2         kubectl <span class="built_in">set</span> image deployment deploy-nginx nginx=nginx:1.16-alpine --record=<span class="literal">true</span></span><br><span class="line">3         kubectl <span class="built_in">set</span> image deployment deploy-nginx nginx=nginx:1.17-alpine --record=<span class="literal">true</span></span><br><span class="line">4         &lt;none&gt;						<span class="comment">#回到了1.15版,但revision的ID变了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">deploy-nginx-6c9764bb69-zgwpj   1/1     Running   0          54s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod deploy-nginx-6c9764bb69-zgwpj |grep Image:</span></span><br><span class="line">    Image:          nginx:1.15-alpine				回到了1.15版</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec deploy-nginx-6c9764bb69-zgwpj -- nginx -v</span></span><br><span class="line">nginx version: nginx/1.15.12						回到了1.15版</span><br></pre></td></tr></table></figure>

<h3 id="1-2-9-副本扩容"><a href="#1-2-9-副本扩容" class="headerlink" title="1.2.9 副本扩容"></a>1.2.9 副本扩容</h3><p>查看帮助</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl scale -h</span></span><br></pre></td></tr></table></figure>

<p>扩容为2个副本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl scale deployment deploy-nginx --replicas=2</span></span><br><span class="line">deployment.apps/deploy-nginx scaled</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">deploy-nginx-6d9d558bb6-4c64l   1/1     Running   0          27s   10.244.159.157   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">deploy-nginx-6d9d558bb6-hkq2b   1/1     Running   0          71s   10.244.194.95    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">在两个node节点上各1个pod</span><br></pre></td></tr></table></figure>

<p>继续扩容(我们这里只有2个node,但是可以大于node节点数据)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl scale deployment deploy-nginx --replicas=4</span></span><br><span class="line">deployment.extensions/nginx1 scaled</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">deploy-nginx-6d9d558bb6-4c64l   1/1     Running   0          87s     10.244.159.157   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">deploy-nginx-6d9d558bb6-586dr   1/1     Running   0          31s     10.244.135.197   k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">deploy-nginx-6d9d558bb6-hkq2b   1/1     Running   0          2m11s   10.244.194.95    k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">deploy-nginx-6d9d558bb6-kvgsc   1/1     Running   0          31s     10.244.224.13    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-10-副本裁减"><a href="#1-2-10-副本裁减" class="headerlink" title="1.2.10 副本裁减"></a>1.2.10 副本裁减</h3><p>指定副本数为1进行裁减</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl scale deployment deploy-nginx --replicas=1</span></span><br><span class="line">deployment.apps/deploy-nginx scaled</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">deploy-nginx-6d9d558bb6-hkq2b   1/1     Running   0          2m56s</span><br></pre></td></tr></table></figure>

<h3 id="1-2-11-多副本滚动更新"><a href="#1-2-11-多副本滚动更新" class="headerlink" title="1.2.11 多副本滚动更新"></a>1.2.11 多副本滚动更新</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl scale deployment deploy-nginx --replicas=16</span></span><br><span class="line">deployment.apps/deploy-nginx scaled</span><br><span class="line"></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx1-7d9b8757cf-2hd48   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-5m72n   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-5w2xr   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-5wmdh   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-6szjj   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-9dgsw   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-dc7qj   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-l52pr   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-m7rt4   1/1     Running   0          26m</span><br><span class="line">nginx1-7d9b8757cf-mdkj2   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-s79kp   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-shhvk   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-sv8gb   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-xbhf4   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-zgdgd   1/1     Running   0          61s</span><br><span class="line">nginx1-7d9b8757cf-zzljl   1/1     Running   0          61s</span><br><span class="line">nginx2-559567f789-8hstz   1/1     Running   1          114m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#滚动更新</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record</span></span><br><span class="line">deployment.apps/deploy-nginx image updated</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl rollout status deployment deploy-nginx</span></span><br><span class="line">......</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"deploy-nginx"</span> rollout to finish: 13 of 16 updated replicas are available...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"deploy-nginx"</span> rollout to finish: 14 of 16 updated replicas are available...</span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">"deploy-nginx"</span> rollout to finish: 15 of 16 updated replicas are available...</span><br><span class="line">deployment <span class="string">"deploy-nginx"</span> successfully rolled out</span><br></pre></td></tr></table></figure>

<h3 id="1-2-12-删除deployment"><a href="#1-2-12-删除deployment" class="headerlink" title="1.2.12 删除deployment"></a>1.2.12 删除deployment</h3><p>如果使用 <code>kubectl delete deployment deploy-nginx</code>命令删除deployment,那么里面的pod也会被自动删除</p>
<h2 id="1-3-Replicaset"><a href="#1-3-Replicaset" class="headerlink" title="1.3 Replicaset"></a>1.3 Replicaset</h2><p>提供复制集能力，控制pod扩缩容</p>
<p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim rs-nginx.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: rs-nginx</span><br><span class="line">  namespace: default</span><br><span class="line">spec:                    <span class="comment"># replicaset的spec</span></span><br><span class="line">  replicas: 2            <span class="comment"># 副本数</span></span><br><span class="line">  selector:              <span class="comment"># 标签选择器,对应pod的标签</span></span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx         <span class="comment"># 匹配的label</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx		<span class="comment"># pod名</span></span><br><span class="line">      labels:           <span class="comment"># 对应上面定义的标签选择器selector里面的内容</span></span><br><span class="line">        app: nginx</span><br><span class="line">    spec:               <span class="comment"># pod的spec</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br></pre></td></tr></table></figure>

<p>应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f rs-nginx.yml</span></span><br><span class="line">replicaset.apps/rs-nginx created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get rs</span></span><br><span class="line">NAME       DESIRED   CURRENT   READY   AGE</span><br><span class="line">rs-nginx   2         2         2       26s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">rs-nginx-7j9hz   1/1     Running   0          44s</span><br><span class="line">rs-nginx-pncsk   1/1     Running   0          43s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get deployment</span></span><br><span class="line">No resources found.</span><br><span class="line"></span><br><span class="line"><span class="comment">#找不到deployment,说明创建rs并没有创建deployment</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-StatefulSet控制器作用"><a href="#1-4-StatefulSet控制器作用" class="headerlink" title="1.4 StatefulSet控制器作用"></a>1.4 StatefulSet控制器作用</h2><ul>
<li>StatefulSet 是用来管理有状态应用的控制器。</li>
<li>StatefulSet 用来管理某Pod集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</li>
<li>参考: <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/</a></li>
</ul>
<h3 id="1-4-1-无状态应用与有状态应用"><a href="#1-4-1-无状态应用与有状态应用" class="headerlink" title="1.4.1 无状态应用与有状态应用"></a>1.4.1 无状态应用与有状态应用</h3><h4 id="1-4-1-1-无状态应用"><a href="#1-4-1-1-无状态应用" class="headerlink" title="1.4.1.1 无状态应用"></a>1.4.1.1 无状态应用</h4><ul>
<li>如nginx</li>
<li>请求本身包含了响应端为响应这一请求所需的全部信息。每一个请求都像首次执行一样，不会依赖之前的数据进行响应。</li>
</ul>
<ul>
<li>不需要持久化的数据</li>
<li>无状态应用的多个实例之间互不依赖，可以无序的部署、删除或伸缩</li>
</ul>
<h4 id="1-4-1-1-有状态应用"><a href="#1-4-1-1-有状态应用" class="headerlink" title="1.4.1.1 有状态应用"></a>1.4.1.1 有状态应用</h4><ul>
<li>如mysql</li>
<li>前后请求有关联与依赖</li>
</ul>
<ul>
<li>需要持久化的数据</li>
<li>有状态应用的多个实例之间有依赖，不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</li>
</ul>
<h3 id="1-4-2-StatefulSet的特点"><a href="#1-4-2-StatefulSet的特点" class="headerlink" title="1.4.2 StatefulSet的特点"></a>1.4.2 StatefulSet的特点</h3><ul>
<li>稳定的、唯一的网络标识符。        (通过headless服务实现)</li>
<li>稳定的、持久的存储。                   (通过PV，PVC，storageclass实现)</li>
<li>有序的、优雅的部署和缩放。       </li>
<li>有序的、自动的滚动更新。        </li>
</ul>
<h3 id="1-4-3-StatefulSet的YAML组成"><a href="#1-4-3-StatefulSet的YAML组成" class="headerlink" title="1.4.3 StatefulSet的YAML组成"></a>1.4.3 StatefulSet的YAML组成</h3><p>需要三个组成部分:</p>
<ol>
<li>headless service:                 实现稳定，唯一的网络标识</li>
<li>statefulset类型资源:            写法和deployment几乎一致，就是类型不一样</li>
<li>volumeClaimTemplate :     指定存储卷</li>
</ol>
<h3 id="1-4-4-创建StatefulSet应用"><a href="#1-4-4-创建StatefulSet应用" class="headerlink" title="1.4.4 创建StatefulSet应用"></a>1.4.4 创建StatefulSet应用</h3><p>参考: <a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/</a></p>
<h4 id="1-4-4-1-编辑YAML资源清单文件"><a href="#1-4-4-1-编辑YAML资源清单文件" class="headerlink" title="1.4.4.1  编辑YAML资源清单文件"></a>1.4.4.1  编辑YAML资源清单文件</h4><p>创建statelfulset应用来调用名为nfs-client的storageclass,以实现动态供给</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim nginx-storageclass-nfs.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None		<span class="comment"># 无头服务</span></span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web				<span class="comment"># statefulset的名称</span></span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">"nginx"</span></span><br><span class="line">  replicas: 3			<span class="comment"># 3个副本</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      storageClassName: <span class="string">"nfs-client"</span>		<span class="comment"># 与前面定义的storageclass名称对应</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br><span class="line">          </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f nginx-storageclass-nfs.yml</span></span><br><span class="line">service/nginx created</span><br><span class="line">statefulset.apps/web created</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-2-应用部署后验证"><a href="#1-4-4-2-应用部署后验证" class="headerlink" title="1.4.4.2 应用部署后验证"></a>1.4.4.2 应用部署后验证</h4><p>验证pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |grep web</span></span><br><span class="line">web-0                                     1/1     Running   0          1m15s</span><br><span class="line">web-1                                     1/1     Running   0          1m7s</span><br><span class="line">web-2                                     1/1     Running   0          57s</span><br></pre></td></tr></table></figure>

<p>验证pv</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~] <span class="comment"># kubectl get pv</span></span><br><span class="line">pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6  1Gi  RWO   Delete  Bound  default/www-web-0   nfs-client       3m</span><br><span class="line">pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc  1Gi  RWO   Delete  Bound  default/www-web-1   nfs-client       2m</span><br><span class="line">pvc-43afb71d-1d02-4699-b00c-71679fd75fc3  1Gi  RWO   Delete  ound   default/www-web-2   nfs-client       2m</span><br></pre></td></tr></table></figure>

<p>验证pvc</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pvc |grep web</span></span><br><span class="line">www-web-0  Bound   pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6   1Gi   RWO  nfs-client  3m</span><br><span class="line">www-web-1  Bound   pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc   1Gi   RWO  nfs-client  2m</span><br><span class="line">www-web-2  Bound   pvc-43afb71d-1d02-4699-b00c-71679fd75fc3   1Gi   RWO  nfs-client  2m</span><br></pre></td></tr></table></figure>

<p>验证nfs服务目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在nfs服务器（这里为hostos)的共享目录中发现自动产生了3个子目录</span></span><br><span class="line">[root@nfsserver ~]<span class="comment"># ls /data/nfs/</span></span><br><span class="line">default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6  </span><br><span class="line">default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3</span><br><span class="line">default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc  </span><br><span class="line"></span><br><span class="line"><span class="comment">#3个子目录默认都为空目录</span></span><br><span class="line">[root@nfsserver ~]<span class="comment"># tree /data/nfs/</span></span><br><span class="line">/data/nfs/</span><br><span class="line">├── default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6</span><br><span class="line">├── default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc</span><br><span class="line">└── default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3</span><br></pre></td></tr></table></figure>

<p>验证存储持久性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在3个pod中其中一个创建一个主页文件</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it web-0 -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># echo "haha" &gt;  /usr/share/nginx/html/index.html</span></span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在nfs服务器上发现文件被创建到了对应的目录中</span></span><br><span class="line">[root@nfsserver ~]<span class="comment"># tree /data/nfs/</span></span><br><span class="line">/data/nfs/</span><br><span class="line">├── default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6</span><br><span class="line">│   └── index.html								<span class="comment"># 此目录里多了index.html文件，对应刚才在web-0的pod中的创建</span></span><br><span class="line">├── default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc</span><br><span class="line">└── default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@nfsserver ~]<span class="comment"># cat /data/nfs/default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6/index.html</span></span><br><span class="line">haha											<span class="comment"># 文件内的内容也与web-0的pod中创建的一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除web-0这个pod,再验证</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl delete pod web-0</span></span><br><span class="line">pod <span class="string">"web-0"</span> deleted</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |grep web			# 因为控制器的原因，会迅速再拉起web-0这个pod</span></span><br><span class="line">web-0                                     1/1     Running   0          9s	  <span class="comment"># 时间上看到是新拉起的pod</span></span><br><span class="line">web-1                                     1/1     Running   0          37m</span><br><span class="line">web-2                                     1/1     Running   0          37m</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it web-0 -- cat /usr/share/nginx/html/index.html</span></span><br><span class="line">haha													<span class="comment"># 新拉起的pod仍然是相同的存储数据</span></span><br><span class="line"></span><br><span class="line">[root@nfsserver ~]<span class="comment"># cat /data/nfs/default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6/index.html</span></span><br><span class="line">haha													<span class="comment"># nfs服务器上的数据还在</span></span><br></pre></td></tr></table></figure>

<p><strong>结论: 说明数据可持久化</strong></p>
<p>访问验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">验证Coredns是否可用</span><br><span class="line"><span class="comment"># kubectl get svc -n kube-system</span></span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   6d23h</span><br><span class="line"></span><br><span class="line"><span class="comment"># dig -t a www.baidu.com @10.96.0.10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dig -t a nginx.default.svc.cluster.local. @10.96.0.10</span></span><br><span class="line">....</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">nginx.default.svc.cluster.local. 30 IN  A       10.224.194.75</span><br><span class="line">nginx.default.svc.cluster.local. 30 IN  A       10.224.159.141</span><br><span class="line">nginx.default.svc.cluster.local. 30 IN  A       10.224.126.6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dig -t a web-0.nginx.default.svc.cluster.local. @10.96.0.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在kubernetes集群内创建pod访问</span></span><br><span class="line"><span class="comment"># kubectl run -it busybox --image=radial/busyboxplus</span></span><br><span class="line">/ <span class="comment"># curl nginx.default.svc.cluster.local.</span></span><br><span class="line">web-0</span><br><span class="line">/ <span class="comment"># curl web-0.nginx.default.svc.cluster.local.</span></span><br><span class="line">web-0</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-已部署应用滚动更新-含金丝雀发布"><a href="#1-4-5-已部署应用滚动更新-含金丝雀发布" class="headerlink" title="1.4.5 已部署应用滚动更新(含金丝雀发布)"></a>1.4.5 已部署应用滚动更新(含金丝雀发布)</h3><p>它将按照与 Pod 终止相同的顺序（从最大序号到最小序号）进行，每次更新一个 Pod。</p>
<p>StatefulSet可以使用partition参数来实现金丝雀更新，partition参数可以控制StatefulSet控制器更新的Pod。下面，我们就进行StatefulSet控制器的金丝雀更新实战。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl patch sts web -p <span class="string">'&#123;"spec":&#123;"updateStrategy":&#123;"rollingUpdate":&#123;"partition":2&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用patch参数来指定了StatefulSet控制器的partition参数为2，表示当更新时，只有Pod的编号大于等于2的才更新。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl exec -it web-0 -- nginx -v</span></span><br><span class="line">nginx version: nginx/1.15.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl set image sts/web nginx=nginx:latest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get pods -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl exec -it web-2 -- nginx -v</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image</span></span><br><span class="line">Name                                     Image</span><br><span class="line">web-0                                    nginx:1.15-alpine</span><br><span class="line">web-1                                    nginx:1.15-alpine</span><br><span class="line">web-2                                    nginx:latest</span><br></pre></td></tr></table></figure>

<p><strong>如何实现全部更新呢？</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl patch sts web -p <span class="string">'&#123;"spec":&#123;"updateStrategy":&#123;"rollingUpdate":&#123;"partition":0&#125;&#125;&#125;&#125;'</span></span><br><span class="line">kubectl <span class="built_in">set</span> image sts/web nginx=nginx:latest</span><br><span class="line"></span><br><span class="line">kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image</span><br></pre></td></tr></table></figure>

<h3 id="1-4-6-已部署应用扩容与缩容"><a href="#1-4-6-已部署应用扩容与缩容" class="headerlink" title="1.4.6 已部署应用扩容与缩容"></a>1.4.6 已部署应用扩容与缩容</h3><p>在StatefulSet扩容时，会创建一个新的Pod，该Pod与之前的所有Pod都是有顺序的，并且新Pod的序号最大。在缩容时，StatefulSet控制器删除的也是序号最大的Pod。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl scale sts web --replicas=4</span><br><span class="line">kubectl get pods -w</span><br></pre></td></tr></table></figure>



<h1 id="二、pod控制器Controller进阶"><a href="#二、pod控制器Controller进阶" class="headerlink" title="二、pod控制器Controller进阶"></a>二、pod控制器Controller进阶</h1><h2 id="2-1-DaemonSet"><a href="#2-1-DaemonSet" class="headerlink" title="2.1 DaemonSet"></a>2.1 DaemonSet</h2><h3 id="2-1-1-DaemonSet介绍"><a href="#2-1-1-DaemonSet介绍" class="headerlink" title="2.1.1 DaemonSet介绍"></a>2.1.1 DaemonSet介绍</h3><ul>
<li>DaemonSet能够让所有（或者特定）的节点运行同一个pod。</li>
<li>当节点加入到K8S集群中，pod会被（DaemonSet）调度到该节点上运行，当节点从K8S集群中被移除，被DaemonSet调度的pod会被移除</li>
<li>如果删除DaemonSet，所有跟这个DaemonSet相关的pods都会被删除。</li>
<li>如果一个DaemonSet的Pod被杀死、停止、或者崩溃，那么DaemonSet将会重新创建一个新的副本在这台计算节点上。</li>
<li>DaemonSet一般应用于日志收集、监控采集、分布式存储守护进程等</li>
</ul>
<h3 id="2-1-2-DaemonSet应用案例"><a href="#2-1-2-DaemonSet应用案例" class="headerlink" title="2.1.2 DaemonSet应用案例"></a>2.1.2 DaemonSet应用案例</h3><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim daemonset-nginx.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: daemonset-nginx			</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: nginx-ds</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: nginx-ds</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:						<span class="comment"># tolerations代表容忍</span></span><br><span class="line">      - key: node-role.kubernetes.io/master  <span class="comment"># 能容忍的污点key</span></span><br><span class="line">        effect: NoSchedule   <span class="comment"># kubectl explain pod.spec.tolerations查看(能容忍的污点effect)</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        resources:    <span class="comment"># resources资源限制是为了防止master节点的资源被占太多(根据实际情况配置)</span></span><br><span class="line">          limits:</span><br><span class="line">            memory: 100Mi</span><br><span class="line">          requests:</span><br><span class="line">            memory: 100Mi</span><br></pre></td></tr></table></figure>

<p>apply应用YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f daemonset-nginx.yml</span></span><br><span class="line">daemonset.apps/daemonset-nginx created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get daemonset				# daemonset可简写为ds</span></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get ds</span></span><br><span class="line">NAME              DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">daemonset-nginx   4         4         4       4            4           &lt;none&gt;          114s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">daemonset-nginx-94z6d   1/1     Running   0          6s    10.244.194.104   k8s-worker1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">daemonset-nginx-hs9mk   1/1     Running   0          6s    10.244.135.206   k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">daemonset-nginx-jrcf5   1/1     Running   0          6s    10.244.159.167   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">daemonset-nginx-sslpl   1/1     Running   0          6s    10.244.224.22    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#k8s集群中每个节点都会运行一个pod</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Job"><a href="#2-2-Job" class="headerlink" title="2.2 Job"></a>2.2 Job</h2><h3 id="2-2-1-Job介绍"><a href="#2-2-1-Job介绍" class="headerlink" title="2.2.1 Job介绍"></a>2.2.1 Job介绍</h3><ul>
<li>对于ReplicaSet而言，它希望pod保持预期数目、持久运行下去，除非用户明确删除，否则这些对象一直存在，它们针对的是耐久性任务，如web服务等。</li>
<li>对于非耐久性任务，比如压缩文件，任务完成后，pod需要结束运行，不需要pod继续保持在系统中，这个时候就要用到Job。</li>
<li>Job负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。</li>
</ul>
<h3 id="2-2-2-Job应用案例"><a href="#2-2-2-Job应用案例" class="headerlink" title="2.2.2 Job应用案例"></a>2.2.2 Job应用案例</h3><h4 id="2-2-2-1-计算圆周率2000位"><a href="#2-2-2-1-计算圆周率2000位" class="headerlink" title="2.2.2.1 计算圆周率2000位"></a>2.2.2.1 计算圆周率2000位</h4><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim job1.yml</span></span><br><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi			<span class="comment"># job名</span></span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: pi		<span class="comment"># pod名</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi	   <span class="comment"># 容器名</span></span><br><span class="line">        image: perl	   <span class="comment"># 此镜像有800多M,可提前导入到所有节点,也可能指定导入到某一节点然后指定调度到此节点</span></span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">"perl"</span>,  <span class="string">"-Mbignum=bpi"</span>, <span class="string">"-wle"</span>, <span class="string">"print bpi(2000)"</span>]</span><br><span class="line">      restartPolicy: Never   <span class="comment"># 执行完后不再重启</span></span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建job</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl apply -f job1.yml</span></span><br><span class="line">job.batch/pi created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get jobs</span></span><br><span class="line">NAME   COMPLETIONS   DURATION   AGE</span><br><span class="line">pi     1/1           11s        18s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">pi-tjq9b                     0/1     Completed          0         27s</span><br><span class="line"></span><br><span class="line"><span class="comment">#Completed状态,也不再是ready状态</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl logs pi-tjq9b</span></span><br><span class="line">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-2-创建固定次数job"><a href="#2-2-2-2-创建固定次数job" class="headerlink" title="2.2.2.2  创建固定次数job"></a>2.2.2.2  创建固定次数job</h4><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim job2.yml</span></span><br><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: busybox-job</span><br><span class="line">spec:</span><br><span class="line">  completions: 10                                               <span class="comment"># 执行job的次数</span></span><br><span class="line">  parallelism: 1                                                <span class="comment"># 执行job的并发数</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: busybox-job-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: busybox</span><br><span class="line">        image: busybox</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">"echo"</span>, <span class="string">"hello"</span>]</span><br><span class="line">      restartPolicy: Never</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建job</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f job2.yml</span></span><br><span class="line">job.batch/busybox-job created</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get job</span></span><br><span class="line">NAME          COMPLETIONS   DURATION   AGE</span><br><span class="line">busybox-job   2/10          9s         9s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get job</span></span><br><span class="line">NAME          COMPLETIONS   DURATION   AGE</span><br><span class="line">busybox-job   3/10          12s        12s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get job</span></span><br><span class="line">NAME          COMPLETIONS   DURATION   AGE</span><br><span class="line">busybox-job   4/10          15s        15s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get job</span></span><br><span class="line">NAME          COMPLETIONS   DURATION   AGE</span><br><span class="line">busybox-job   10/10         34s        48s</span><br><span class="line"></span><br><span class="line"><span class="comment">#34秒左右结束</span></span><br><span class="line"></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">busybox-job-5zn6l            0/1     Completed          0          34s</span><br><span class="line">busybox-job-cm9kw            0/1     Completed          0          29s</span><br><span class="line">busybox-job-fmpgt            0/1     Completed          0          38s</span><br><span class="line">busybox-job-gjjvh            0/1     Completed          0          45s</span><br><span class="line">busybox-job-krxpd            0/1     Completed          0          25s</span><br><span class="line">busybox-job-m2vcq            0/1     Completed          0          41s</span><br><span class="line">busybox-job-ncg78            0/1     Completed          0          47s</span><br><span class="line">busybox-job-tbzz8            0/1     Completed          0          51s</span><br><span class="line">busybox-job-vb99r            0/1     Completed          0          21s</span><br><span class="line">busybox-job-wnch7            0/1     Completed          0          32s</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-3-一次性备份MySQL数据库"><a href="#2-2-2-3-一次性备份MySQL数据库" class="headerlink" title="2.2.2.3 一次性备份MySQL数据库"></a>2.2.2.3 一次性备份MySQL数据库</h4><blockquote>
<p> 通过Job控制器创建应用备份MySQL数据库</p>
</blockquote>
<h5 id="2-2-2-3-1-MySQL数据库准备"><a href="#2-2-2-3-1-MySQL数据库准备" class="headerlink" title="2.2.2.3.1  MySQL数据库准备"></a>2.2.2.3.1  MySQL数据库准备</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx jobcontroller]<span class="comment"># cat 00_mysql.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-test</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 3306</span><br><span class="line">    name: mysql</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: mysql-dump</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: db</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql-dump</span><br><span class="line">  serviceName: <span class="string">"mysql-test"</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql-dump</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: k8s-master3</span><br><span class="line">      containers:</span><br><span class="line">      - name: mysql</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        env:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: <span class="string">"abc123"</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">"/var/lib/mysql"</span></span><br><span class="line">          name: mysql-data</span><br><span class="line">      volumes:</span><br><span class="line">      - name: mysql-data</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /opt/mysqldata</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-3-2-创建用于实现任务的资源清单文件"><a href="#2-2-2-3-2-创建用于实现任务的资源清单文件" class="headerlink" title="2.2.2.3.2  创建用于实现任务的资源清单文件"></a>2.2.2.3.2  创建用于实现任务的资源清单文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx jobcontroller]<span class="comment"># cat 03_job.yaml</span></span><br><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-dump</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: mysql-dump</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: k8s-master2</span><br><span class="line">      containers:</span><br><span class="line">      - name: mysql-dump</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"mysqldump --host=mysql-test -uroot -pabc123 --databases mysql &gt; /root/mysql2022.sql"</span>]</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">"/root"</span></span><br><span class="line">          name: mysql-data</span><br><span class="line">      restartPolicy: Never</span><br><span class="line">      volumes:</span><br><span class="line">      - name: mysql-data</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /opt/mysqldump</span><br></pre></td></tr></table></figure>



<h2 id="2-3-CronJob"><a href="#2-3-CronJob" class="headerlink" title="2.3 CronJob"></a>2.3 CronJob</h2><p>执行周期性任务</p>
<h3 id="2-3-1-CronJob介绍"><a href="#2-3-1-CronJob介绍" class="headerlink" title="2.3.1 CronJob介绍"></a>2.3.1 CronJob介绍</h3><ul>
<li>类似于Linux系统的crontab，在指定的时间周期运行相关的任务</li>
<li>时间格式：分时日月周</li>
</ul>
<h3 id="2-3-2-CronJob应用案例"><a href="#2-3-2-CronJob应用案例" class="headerlink" title="2.3.2 CronJob应用案例"></a>2.3.2 CronJob应用案例</h3><h4 id="2-3-2-1-周期性输出字符"><a href="#2-3-2-1-周期性输出字符" class="headerlink" title="2.3.2.1 周期性输出字符"></a>2.3.2.1 周期性输出字符</h4><p>编写YAML文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim cronjob.yml</span></span><br><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: cronjob1</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">"* * * * *"</span>                 <span class="comment"># 分时日月周</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - date; <span class="built_in">echo</span> hello kubernetes</span><br><span class="line">            imagePullPolicy: IfNotPresent</span><br><span class="line">          restartPolicy: OnFailure</span><br></pre></td></tr></table></figure>

<p>应用YAML文件创建cronjob</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f cronjob.yml</span></span><br><span class="line">cronjob.batch/cronjob1 created</span><br></pre></td></tr></table></figure>

<p>查看验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get cronjob</span></span><br><span class="line">NAME       SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">cronjob1   * * * * *   False     0        &lt;none&gt;          21s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                         READY   STATUS             RESTARTS   AGE</span><br><span class="line">cronjob-1564993080-qlbgv     0/1     Completed          0          2m10s</span><br><span class="line">cronjob-1564993140-zbv7f     0/1     Completed          0          70s</span><br><span class="line">cronjob-1564993200-gx5xz     0/1     Completed          0          10s</span><br><span class="line"></span><br><span class="line"><span class="comment">#看AGE时间,每分钟整点执行一次</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-2-周期性备份MySQL数据库"><a href="#2-3-2-2-周期性备份MySQL数据库" class="headerlink" title="2.3.2.2 周期性备份MySQL数据库"></a>2.3.2.2 周期性备份MySQL数据库</h4><h5 id="2-3-2-2-1-MySQL数据库准备"><a href="#2-3-2-2-1-MySQL数据库准备" class="headerlink" title="2.3.2.2.1 MySQL数据库准备"></a>2.3.2.2.1 MySQL数据库准备</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx jobcontroller]<span class="comment"># cat 00_mysql.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-test</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 3306</span><br><span class="line">    name: mysql</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: mysql-dump</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: db</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql-dump</span><br><span class="line">  serviceName: <span class="string">"mysql-test"</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql-dump</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: worker03</span><br><span class="line">      containers:</span><br><span class="line">      - name: mysql</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        env:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: <span class="string">"abc123"</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">"/var/lib/mysql"</span></span><br><span class="line">          name: mysql-data</span><br><span class="line">      volumes:</span><br><span class="line">      - name: mysql-data</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /opt/mysqldata</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-2-2-Cronjob控制器类型应用资源清单文件"><a href="#2-3-2-2-2-Cronjob控制器类型应用资源清单文件" class="headerlink" title="2.3.2.2.2 Cronjob控制器类型应用资源清单文件"></a>2.3.2.2.2 Cronjob控制器类型应用资源清单文件</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nginx jobcontroller]<span class="comment"># cat 05_cronjob.yaml</span></span><br><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-dump</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">"*/1 * * * *"</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          nodeName: worker02</span><br><span class="line">          containers:</span><br><span class="line">          - name: c1</span><br><span class="line">            image: mysql:5.7</span><br><span class="line">            <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"mysqldump --host=mysql-test -uroot -pabc123 --databases mysql &gt; /root/mysql`date +%Y%m%d%H%M`.sql"</span>]</span><br><span class="line">            volumeMounts:</span><br><span class="line">              - name: mysql-data</span><br><span class="line">                mountPath: <span class="string">"/root"</span></span><br><span class="line">          restartPolicy: Never</span><br><span class="line">          volumes:</span><br><span class="line">            - name: mysql-data</span><br><span class="line">              hostPath:</span><br><span class="line">                path: /opt/mysqldump</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-存储卷</title>
    <url>/2022/11/16/k8s-%E5%AD%98%E5%82%A8%E5%8D%B7/</url>
    <content><![CDATA[<h1 id="存储卷介绍"><a href="#存储卷介绍" class="headerlink" title="存储卷介绍"></a>存储卷介绍</h1><p>pod有生命周期，生命周期结束后pod里的数据会消失(如配置文件,业务数据等)。</p>
<blockquote>
<p>需要将数据与pod分离,将数据放在专门的存储卷上</p>
</blockquote>
<p>pod在k8s集群的节点中是可以调度的, 如果pod挂了被调度到另一个节点,那么数据和pod的联系会中断。</p>
<blockquote>
<p>需要与集群节点分离的存储系统才能实现数据持久化</p>
</blockquote>
<p>简单来说: <strong>volume提供了在容器上挂载外部存储的能力</strong></p>
<a id="more"></a>

<h1 id="存储卷的分类"><a href="#存储卷的分类" class="headerlink" title="存储卷的分类"></a>存储卷的分类</h1><p><code>kubectl explain pod.spec.volumes</code>或者参考: <a href="https://kubernetes.io/docs/concepts/storage/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/</a></p>
<ul>
<li>本地存储卷 <ul>
<li>emptyDir    pod删除,数据也会被清除, 用于数据的临时存储</li>
<li>hostPath     宿主机目录映射(本地存储卷)</li>
</ul>
</li>
<li>网络存储卷<ul>
<li>NAS类           nfs等</li>
<li>SAN类           iscsi,FC等</li>
<li>分布式存储   glusterfs,cephfs,rbd,cinder等</li>
<li>云存储           aws,azurefile等</li>
</ul>
</li>
</ul>
<h1 id="存储卷的选择"><a href="#存储卷的选择" class="headerlink" title="存储卷的选择"></a>存储卷的选择</h1><p>按应用角度主要分为三类:</p>
<ul>
<li>文件存储  如:nfs,glusterfs,cephfs等<ul>
<li>优点: 数据共享(多pod挂载可以同读同写)</li>
<li>缺点: 性能较差</li>
</ul>
</li>
<li>块存储  如: iscsi,rbd等<ul>
<li>优点: 性能相对于文件存储好</li>
<li>缺点: 不能实现数据共享（部分）</li>
</ul>
</li>
<li>对象存储 如: ceph对象存储<ul>
<li>优点: 性能好, 数据共享</li>
<li>缺点: 使用方式特殊,支持较少</li>
</ul>
</li>
</ul>
<h1 id="本地存储卷–emptyDir"><a href="#本地存储卷–emptyDir" class="headerlink" title="本地存储卷–emptyDir"></a>本地存储卷–emptyDir</h1><ul>
<li><p>应用场景</p>
<p>实现pod内容器之间数据共享</p>
</li>
<li><p>特点</p>
<p>随着pod被删除，该卷也会被删除</p>
</li>
</ul>
<h2 id="创建yaml文件"><a href="#创建yaml文件" class="headerlink" title="创建yaml文件"></a>创建yaml文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim volume-emptydir.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-emptydir</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: write</span><br><span class="line">    image: centos</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"bash"</span>,<span class="string">"-c"</span>,<span class="string">"echo haha &gt; /data/1.txt ; sleep 6000"</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  - name: <span class="built_in">read</span></span><br><span class="line">    image: centos</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"bash"</span>,<span class="string">"-c"</span>,<span class="string">"cat /data/1.txt; sleep 6000"</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">      </span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于yaml文件创建pod"><a href="#基于yaml文件创建pod" class="headerlink" title="基于yaml文件创建pod"></a>基于yaml文件创建pod</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f volume-emptydir.yml</span></span><br><span class="line">pod/volume-emptydir created</span><br></pre></td></tr></table></figure>

<h2 id="查看pod启动情况"><a href="#查看pod启动情况" class="headerlink" title="查看pod启动情况"></a>查看pod启动情况</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |grep volume-emptydir</span></span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">volume-emptydir                    2/2     Running   0          15s</span><br></pre></td></tr></table></figure>

<h2 id="查看pod描述信息"><a href="#查看pod描述信息" class="headerlink" title="查看pod描述信息"></a>查看pod描述信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl describe pod volume-emptydir | tail -10</span></span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  50s   default-scheduler  Successfully assigned default/volume-emptydir to k8s-worker1</span><br><span class="line">  Normal  Pulling    50s   kubelet            Pulling image <span class="string">"centos:centos7"</span></span><br><span class="line">  Normal  Pulled     28s   kubelet            Successfully pulled image <span class="string">"centos:centos7"</span> <span class="keyword">in</span> 21.544912361s</span><br><span class="line">  Normal  Created    28s   kubelet            Created container write</span><br><span class="line">  Normal  Started    28s   kubelet            Started container write</span><br><span class="line">  Normal  Pulled     28s   kubelet            Container image <span class="string">"centos:centos7"</span> already present on machine</span><br><span class="line">  Normal  Created    28s   kubelet            Created container <span class="built_in">read</span></span><br><span class="line">  Normal  Started    28s   kubelet            Started container <span class="built_in">read</span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl logs volume-emptydir -c write</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl logs volume-emptydir -c read</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h1 id="本地存储卷–hostPath"><a href="#本地存储卷–hostPath" class="headerlink" title="本地存储卷–hostPath"></a>本地存储卷–hostPath</h1><ul>
<li><p>应用场景</p>
<p>pod内与集群节点目录映射（pod中容器想访问节点上数据，例如监控，只有监控访问到节点主机文件才能知道集群节点主机状态）</p>
</li>
<li><p>缺点</p>
<p>如果集群节点挂掉，控制器在另一个集群节点拉起容器，数据就会变成另一台集群节点主机的了（无法实现数据共享)</p>
</li>
</ul>
<h2 id="创建yaml文件-1"><a href="#创建yaml文件-1" class="headerlink" title="创建yaml文件"></a>创建yaml文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim volume-hostpath.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-hostpath</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"echo haha &gt; /data/1.txt ; sleep 600"</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">      </span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /opt</span><br><span class="line">      <span class="built_in">type</span>: Directory</span><br></pre></td></tr></table></figure>

<h2 id="基于yaml文件创建pod-1"><a href="#基于yaml文件创建pod-1" class="headerlink" title="基于yaml文件创建pod"></a>基于yaml文件创建pod</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply  -f volume-hostpath.yml</span></span><br><span class="line">pod/volume-hostpath created</span><br></pre></td></tr></table></figure>

<h2 id="查看pod状态"><a href="#查看pod状态" class="headerlink" title="查看pod状态"></a>查看pod状态</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods -o wide |grep volume-hostpath</span></span><br><span class="line">volume-hostpath     1/1   Running   0    29s     10.224.194.120   k8s-worker1   &lt;none&gt;     &lt;none&gt;</span><br><span class="line"><span class="comment">#可以看到pod是在k8s-worker1节点上</span></span><br></pre></td></tr></table></figure>

<h2 id="验证pod所在机器上的挂载文件"><a href="#验证pod所在机器上的挂载文件" class="headerlink" title="验证pod所在机器上的挂载文件"></a>验证pod所在机器上的挂载文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-worker1 ~]<span class="comment"># cat /opt/1.txt</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h1 id="网络存储卷–nfs"><a href="#网络存储卷–nfs" class="headerlink" title="网络存储卷–nfs"></a>网络存储卷–nfs</h1><h2 id="搭建nfs服务器"><a href="#搭建nfs服务器" class="headerlink" title="搭建nfs服务器"></a>搭建nfs服务器</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nfsserver ~]<span class="comment"># mkdir -p /data/nfs</span></span><br><span class="line">[root@nfsserver ~]<span class="comment"># vim /etc/exports</span></span><br><span class="line">/data/nfs       *(rw,no_root_squash,sync)</span><br><span class="line">[root@nfsserver ~]<span class="comment"># systemctl restart nfs-server</span></span><br><span class="line">[root@nfsserver ~]<span class="comment"># systemctl enable nfs-server</span></span><br></pre></td></tr></table></figure>

<h2 id="所有node节点安装nfs客户端相关软件包"><a href="#所有node节点安装nfs客户端相关软件包" class="headerlink" title="所有node节点安装nfs客户端相关软件包"></a>所有node节点安装nfs客户端相关软件包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-worker1 ~]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line">[root@k8s-worker2 ~]<span class="comment"># yum install nfs-utils -y</span></span><br></pre></td></tr></table></figure>

<h2 id="验证nfs可用性"><a href="#验证nfs可用性" class="headerlink" title="验证nfs可用性"></a>验证nfs可用性</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># showmount -e 192.168.10.129</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.10.129:</span><br><span class="line">/data/nfs *</span><br><span class="line"></span><br><span class="line">[root@node2 ~]<span class="comment"># showmount -e 192.168.10.129</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.10.129:</span><br><span class="line">/data/nfs *</span><br></pre></td></tr></table></figure>

<h2 id="master节点上创建yaml文件"><a href="#master节点上创建yaml文件" class="headerlink" title="master节点上创建yaml文件"></a>master节点上创建yaml文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim volume-nfs.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-nfs</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: documentroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">      volumes:</span><br><span class="line">      - name: documentroot</span><br><span class="line">        nfs:</span><br><span class="line">          server: 192.168.10.129</span><br><span class="line">          path: /data/nfs</span><br></pre></td></tr></table></figure>

<h2 id="应用yaml创建"><a href="#应用yaml创建" class="headerlink" title="应用yaml创建"></a>应用yaml创建</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment">#  kubectl apply -f volume-nfs.yml</span></span><br><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>

<h2 id="在nfs服务器共享目录中创建验证文件"><a href="#在nfs服务器共享目录中创建验证文件" class="headerlink" title="在nfs服务器共享目录中创建验证文件"></a>在nfs服务器共享目录中创建验证文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@nfsserver ~]<span class="comment"># echo "volume-nfs" &gt; /data/nfs/index.html</span></span><br></pre></td></tr></table></figure>

<h2 id="验证pod"><a href="#验证pod" class="headerlink" title="验证pod"></a>验证pod</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod |grep volume-nfs</span></span><br><span class="line">volume-nfs-649d848b57-qg4bz   1/1     Running   0          10s</span><br><span class="line">volume-nfs-649d848b57-wrnpn   1/1     Running   0          10s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it volume-nfs-649d848b57-qg4bz -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /usr/share/nginx/html/</span></span><br><span class="line">index.html</span><br><span class="line">/ <span class="comment"># cat /usr/share/nginx/html/index.html</span></span><br><span class="line">volume-nfs										<span class="comment"># 文件内容与nfs服务器上创建的一致</span></span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it volume-nfs-649d848b57-wrnpn -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /usr/share/nginx/html/</span></span><br><span class="line">index.html</span><br><span class="line">/ <span class="comment"># cat /usr/share/nginx/html/index.html</span></span><br><span class="line">volume-nfs										<span class="comment"># 文件内容与nfs服务器上创建的一致</span></span><br><span class="line">/ <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>

<h1 id="PV-持久存储卷-与PVC-持久存储卷声明"><a href="#PV-持久存储卷-与PVC-持久存储卷声明" class="headerlink" title="PV(持久存储卷)与PVC(持久存储卷声明)"></a>PV(持久存储卷)与PVC(持久存储卷声明)</h1><h2 id="persistenvolume-PV"><a href="#persistenvolume-PV" class="headerlink" title="persistenvolume(PV)"></a>persistenvolume(<strong>PV</strong>)</h2><ul>
<li><p>PV是配置好的一段存储(可以是任意类型的存储卷)</p>
</li>
<li><p>也就是说将网络存储共享出来,配置定义成PV。</p>
</li>
</ul>
<h2 id="PersistentVolumeClaim-PVC"><a href="#PersistentVolumeClaim-PVC" class="headerlink" title="PersistentVolumeClaim(PVC)"></a>PersistentVolumeClaim(<strong>PVC</strong>)</h2><ul>
<li><p>PVC是用户pod使用PV的申请请求。</p>
</li>
<li><p>用户不需要关心具体的volume实现细节,只需要关心使用需求。</p>
</li>
</ul>
<h2 id="pv与pvc之间的关系"><a href="#pv与pvc之间的关系" class="headerlink" title="pv与pvc之间的关系"></a>pv与pvc之间的关系</h2><ul>
<li>pv提供存储资源(生产者)</li>
<li>pvc使用存储资源(消费者)</li>
<li>使用pvc绑定pv</li>
</ul>
<img src="/images/k8s-存储卷/截图27.png" alt="截图27" style="zoom:67%;" />

<h2 id="实现nfs类型pv与pvc"><a href="#实现nfs类型pv与pvc" class="headerlink" title="实现nfs类型pv与pvc"></a>实现nfs类型pv与pvc</h2><h3 id="编写创建pv的YAML文件"><a href="#编写创建pv的YAML文件" class="headerlink" title="编写创建pv的YAML文件"></a>编写创建pv的YAML文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pv-nfs.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume						<span class="comment"># 类型为PersistentVolume(pv)</span></span><br><span class="line">metadata:		</span><br><span class="line">  name: pv-nfs								<span class="comment"># 名称</span></span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi							<span class="comment"># 大小</span></span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany							<span class="comment"># 访问模式</span></span><br><span class="line">  nfs:</span><br><span class="line">    path: /data/nfs							<span class="comment"># nfs共享目录</span></span><br><span class="line">    server: 192.168.10.129					<span class="comment"># nfs服务器IP</span></span><br></pre></td></tr></table></figure>

<p>访问模式有3种       参考: <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes</a></p>
<ul>
<li>ReadWriteOnce 单节点读写挂载</li>
<li>ReadOnlyMany  多节点只读挂载</li>
<li>ReadWriteMany  多节点读写挂载</li>
</ul>
<h3 id="创建pv并验证"><a href="#创建pv并验证" class="headerlink" title="创建pv并验证"></a>创建pv并验证</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pv-nfs.yml</span></span><br><span class="line">persistentvolume/pv-nfs created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pv</span></span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">pv-nfs   1Gi        RWX            Retain           Available                                   81s</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>RWX为ReadWriteMany的简写</li>
<li>Retain是回收策略  <ul>
<li>Retain表示需要不使用了需要手动回收</li>
<li>参考: <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reclaim-policy" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reclaim-policy</a></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="编写创建pvc的YAML文件"><a href="#编写创建pvc的YAML文件" class="headerlink" title="编写创建pvc的YAML文件"></a>编写创建pvc的YAML文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim pvc-nfs.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim				<span class="comment"># 类型为PersistentVolumeClaim(pvc)</span></span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-nfs							<span class="comment"># pvc的名称</span></span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany						<span class="comment"># 访问模式</span></span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi						<span class="comment"># 大小要与pv的大小保持一致</span></span><br></pre></td></tr></table></figure>

<h3 id="创建pvc并验证"><a href="#创建pvc并验证" class="headerlink" title="创建pvc并验证"></a>创建pvc并验证</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f pvc-nfs.yml</span></span><br><span class="line">persistentvolumeclaim/pvc-nfs created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME      STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc-nfs   Bound    pv-nfs   1Gi        RWX                           38s</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> STATUS必须为Bound状态(Bound状态表示pvc与pv绑定OK)</p>
</blockquote>
<h3 id="编写deployment的YMAL"><a href="#编写deployment的YMAL" class="headerlink" title="编写deployment的YMAL"></a>编写deployment的YMAL</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim deploy-nginx-nfs.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: deploy-nginx-nfs</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15-alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">      volumes:</span><br><span class="line">      - name: www</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: pvc-nfs</span><br></pre></td></tr></table></figure>

<h3 id="应用YAML创建deploment"><a href="#应用YAML创建deploment" class="headerlink" title="应用YAML创建deploment"></a>应用YAML创建deploment</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f deploy-nginx-nfs.yml</span></span><br><span class="line">deployment.apps/deploy-nginx-nfs created</span><br></pre></td></tr></table></figure>

<h3 id="验证pod-1"><a href="#验证pod-1" class="headerlink" title="验证pod"></a>验证pod</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pod |grep deploy-nginx-nfs</span></span><br><span class="line">deploy-nginx-nfs-6f9bc4546c-gbzcl   1/1     Running   0          1m46s</span><br><span class="line">deploy-nginx-nfs-6f9bc4546c-hp4cv   1/1     Running   0          1m46s</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it deploy-nginx-nfs-6f9bc4546c-gbzcl -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /usr/share/nginx/html/</span></span><br><span class="line">index.html</span><br><span class="line">/ <span class="comment"># cat /usr/share/nginx/html/index.html</span></span><br><span class="line">volume-nfs</span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl exec -it deploy-nginx-nfs-6f9bc4546c-hp4cv -- /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /usr/share/nginx/html/</span></span><br><span class="line">index.html</span><br><span class="line">/ <span class="comment"># cat /usr/share/nginx/html/index.html</span></span><br><span class="line">volume-nfs</span><br><span class="line">/ <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>

<h1 id="存储的动态供给"><a href="#存储的动态供给" class="headerlink" title="存储的动态供给"></a>存储的动态供给</h1><p>每次使用存储要先创建pv, 再创建pvc，真累!   所以我们可以实现使用存储的动态供给特性。</p>
<ul>
<li>静态存储需要用户申请PVC时保证容量和读写类型与预置PV的容量及读写类型完全匹配, 而动态存储则无需如此.</li>
<li>管理员无需预先创建大量的PV作为存储资源</li>
</ul>
<p>Kubernetes从1.4版起引入了一个新的资源对象StorageClass，可用于将存储资源定义为具有显著特性的类（Class）而不是具体</p>
<p>的PV。用户通过PVC直接向意向的类别发出申请，匹配由管理员事先创建的PV，或者由其按需为用户动态创建PV，这样就免去</p>
<p>了需要先创建PV的过程。</p>
<h2 id="使用NFS文件系统创建存储动态供给"><a href="#使用NFS文件系统创建存储动态供给" class="headerlink" title="使用NFS文件系统创建存储动态供给"></a>使用NFS文件系统创建存储动态供给</h2><p>PV对存储系统的支持可通过其插件来实现，目前，Kubernetes支持如下类型的插件。</p>
<p>官方地址：<a href="https://kubernetes.io/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/storage-classes/</a></p>
<p>官方插件是不支持NFS动态供给的，但是我们可以用第三方的插件来实现</p>
<p>第三方插件地址: <a href="https://github.com/kubernetes-retired/external-storage" target="_blank" rel="noopener">https://github.com/kubernetes-retired/external-storage</a></p>
<h3 id="下载并创建storageclass"><a href="#下载并创建storageclass" class="headerlink" title="下载并创建storageclass"></a>下载并创建storageclass</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes-sigs/nfs-subdir-external-provisioner/master/deploy/class.yaml</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># mv class.yaml storageclass-nfs.yml</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># cat storageclass-nfs.yml</span></span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass				<span class="comment"># 类型</span></span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client		<span class="comment"># 名称,要使用就需要调用此名称</span></span><br><span class="line">provisioner: k8s-sigs.io/nfs-subdir-external-provisioner 	<span class="comment"># 动态供给插件</span></span><br><span class="line">parameters:</span><br><span class="line">  archiveOnDelete: <span class="string">"false"</span>		<span class="comment"># 删除数据时是否存档，false表示不存档，true表示存档</span></span><br><span class="line">  </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f storageclass-nfs.yml</span></span><br><span class="line">storageclass.storage.k8s.io/managed-nfs-storage created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get storageclass</span></span><br><span class="line">NAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">nfs-client   k8s-sigs.io/nfs-subdir-external-provisioner   Delete          Immediate           <span class="literal">false</span>                  10s</span><br><span class="line"></span><br><span class="line"><span class="comment"># RECLAIMPOLICY pv回收策略，pod或pvc被删除后，pv是否删除还是保留。</span></span><br><span class="line"><span class="comment"># VOLUMEBINDINGMODE Immediate 模式下PVC与PV立即绑定，主要是不等待相关Pod调度完成，不关心其运行节点，直接完成绑定。相反的 WaitForFirstConsumer模式下需要等待Pod调度完成后进行PV绑定。</span></span><br><span class="line"><span class="comment"># ALLOWVOLUMEEXPANSION pvc扩容</span></span><br></pre></td></tr></table></figure>

<h3 id="下载并创建rbac"><a href="#下载并创建rbac" class="headerlink" title="下载并创建rbac"></a>下载并创建rbac</h3><p>因为storage自动创建pv需要经过kube-apiserver，所以需要授权。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes-sigs/nfs-subdir-external-provisioner/master/deploy/rbac.yaml</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># mv rbac.yaml storageclass-nfs-rbac.yaml</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># cat storageclass-nfs-rbac.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [<span class="string">""</span>]</span><br><span class="line">    resources: [<span class="string">"persistentvolumes"</span>]</span><br><span class="line">    verbs: [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>, <span class="string">"create"</span>, <span class="string">"delete"</span>]</span><br><span class="line">  - apiGroups: [<span class="string">""</span>]</span><br><span class="line">    resources: [<span class="string">"persistentvolumeclaims"</span>]</span><br><span class="line">    verbs: [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>, <span class="string">"update"</span>]</span><br><span class="line">  - apiGroups: [<span class="string">"storage.k8s.io"</span>]</span><br><span class="line">    resources: [<span class="string">"storageclasses"</span>]</span><br><span class="line">    verbs: [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>]</span><br><span class="line">  - apiGroups: [<span class="string">""</span>]</span><br><span class="line">    resources: [<span class="string">"events"</span>]</span><br><span class="line">    verbs: [<span class="string">"create"</span>, <span class="string">"update"</span>, <span class="string">"patch"</span>]</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: run-nfs-client-provisioner</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">---</span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  namespace: default</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [<span class="string">""</span>]</span><br><span class="line">    resources: [<span class="string">"endpoints"</span>]</span><br><span class="line">    verbs: [<span class="string">"get"</span>, <span class="string">"list"</span>, <span class="string">"watch"</span>, <span class="string">"create"</span>, <span class="string">"update"</span>, <span class="string">"patch"</span>]</span><br><span class="line">---</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f rbac.yaml</span></span><br><span class="line">serviceaccount/nfs-client-provisioner created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/nfs-client-provisioner-runner created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/run-nfs-client-provisioner created</span><br><span class="line">role.rbac.authorization.k8s.io/leader-locking-nfs-client-provisioner created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/leader-locking-nfs-client-provisioner created</span><br></pre></td></tr></table></figure>

<h3 id="创建动态供给的deployment"><a href="#创建动态供给的deployment" class="headerlink" title="创建动态供给的deployment"></a>创建动态供给的deployment</h3><p>需要一个deployment来专门实现pv与pvc的自动创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s-master1 ~]<span class="comment"># vim deploy-nfs-client-provisioner.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-client-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-client-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccount: nfs-client-provisioner</span><br><span class="line">      containers:</span><br><span class="line">        - name: nfs-client-provisioner</span><br><span class="line">          image: registry.cn-beijing.aliyuncs.com/pylixm/nfs-subdir-external-provisioner:v4.0.0</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: nfs-client-root</span><br><span class="line">              mountPath: /persistentvolumes</span><br><span class="line">          env:</span><br><span class="line">            - name: PROVISIONER_NAME</span><br><span class="line">              value: k8s-sigs.io/nfs-subdir-external-provisioner</span><br><span class="line">            - name: NFS_SERVER</span><br><span class="line">              value: 192.168.10.129</span><br><span class="line">            - name: NFS_PATH</span><br><span class="line">              value: /data/nfs</span><br><span class="line">      volumes:</span><br><span class="line">        - name: nfs-client-root</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.10.129</span><br><span class="line">            path: /data/nfs</span><br><span class="line">           </span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl apply -f deploy-nfs-client-provisioner.yml</span></span><br><span class="line">deployment.apps/nfs-client-provisioner created</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]<span class="comment"># kubectl get pods |grep nfs-client-provisioner</span></span><br><span class="line">nfs-client-provisioner-5b5ddcd6c8-b6zbq   1/1     Running   0          34s</span><br></pre></td></tr></table></figure>

<p>测试存储动态供给是否可用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim nginx-sc.yaml</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    name: web</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  serviceName: <span class="string">"nginx"</span></span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: huoban-harbor</span><br><span class="line">      terminationGracePeriodSeconds: 10</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      storageClassName: <span class="string">"nfs-client"</span></span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br><span class="line">          </span><br><span class="line">[root@k8s-master1 nfs]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nfs-client-provisioner-9c988bc46-pr55n   1/1     Running   0          95s</span><br><span class="line">web-0                                    1/1     Running   0          95s</span><br><span class="line">web-1                                    1/1     Running   0          61s</span><br><span class="line"></span><br><span class="line">[root@nfsserver ~]<span class="comment"># ls /data/nfs/</span></span><br><span class="line">default-www-web-0-pvc-c4f7aeb0-6ee9-447f-a893-821774b8d11f  default-www-web-1-pvc-8b8a4d3d-f75f-43af-8387-b7073d07ec01</span><br></pre></td></tr></table></figure>

<blockquote>
<p>批量下载文件：<br>for file in class.yaml deployment.yaml rbac.yaml  ; do wget <a href="https://raw.githubusercontent.com/kubernetes-incubator/external-storage/master/nfs-client/deploy/$file" target="_blank" rel="noopener">https://raw.githubusercontent.com/kubernetes-incubator/external-storage/master/nfs-client/deploy/$file</a> ; done</p>
</blockquote>
]]></content>
      <categories>
        <category>devops</category>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps-CICD</title>
    <url>/2022/11/16/DevOps/</url>
    <content><![CDATA[<h1 id="一、DevOps介绍"><a href="#一、DevOps介绍" class="headerlink" title="一、DevOps介绍"></a>一、DevOps介绍</h1><p><strong>DevOps</strong>，字面意思是<strong>Development &amp;Operations</strong>的缩写，也就是开发&amp;运维。</p>
<p>虽然字面意思只涉及到了开发团队和运维团队，其实QA测试团队也是参与其中的。</p>
<p>强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</p>
<img src="/images/DevOps/devops工具.png"  style="zoom:80%;" />

<a id="more"></a>

<p>如图所示，<strong>DevOps</strong>符号类似于一个无穷大的符号，代表一个不断提高效率并且持续不断工作的过程。</p>
<p><strong>DevOps</strong>的方式可以让公司能够更快地应对更新和市场发展变化，开发可以快速交付，部署也更加稳定。</p>
<p>核心就在于简化Dev和Ops团队之间的流程，使整体软件开发过程更快速。</p>
<p>整体的软件开发流程包括：</p>
<ul>
<li>PLAN：开发团队根据客户的目标制定开发计划</li>
<li>CODE：根据PLAN开始编码过程，需要将不同版本的代码存储在一个库中。</li>
<li>BUILD：编码完成后，需要将代码构建并且运行。</li>
<li>TEST：成功构建项目后，需要测试代码是否存在BUG或错误。</li>
<li>DEPLOY：代码经过手动测试和自动化测试后，认定代码已经准备好部署并且交给运维团队。</li>
<li>OPERATE：运维团队将代码部署到生产环境中。</li>
<li>MONITOR：项目部署上线后，需要持续的监控产品。</li>
<li>INTEGRATE：然后将监控阶段收到的反馈发送回PLAN阶段，整体反复的流程就是<strong>DevOps</strong>的核心，即持续集成、持续部署。</li>
</ul>
<p>为了保证整体流程可以高效的完成，各个阶段都有比较常见的工具，如下图：</p>
<h1 id="二、Code阶段工具"><a href="#二、Code阶段工具" class="headerlink" title="二、Code阶段工具"></a>二、Code阶段工具</h1><p>在code阶段，我们需要将不同版本的代码存储到一个仓库中，常见的版本控制工具就是SVN或者Git，这里我们采用Git作为版本控制工具，GitLab作为远程仓库。</p>
<h2 id="2-1-Git安装"><a href="#2-1-Git安装" class="headerlink" title="2.1 Git安装"></a>2.1 Git安装</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h2 id="2-2-GitLab安装"><a href="#2-2-GitLab安装" class="headerlink" title="2.2 GitLab安装"></a>2.2 GitLab安装</h2><p>单独准备服务器，采用Docker安装</p>
<ul>
<li><p>查看GitLab镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取GitLab镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备docker-compose.yml文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'3.1'</span></span><br><span class="line">services:</span><br><span class="line">  gitlab:</span><br><span class="line">    image: <span class="string">'gitlab/gitlab-ce:latest'</span></span><br><span class="line">    container_name: gitlab</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url <span class="string">'http://192.168.11.11:8929'</span></span><br><span class="line">        gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = 2224</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">'8929:8929'</span></span><br><span class="line">      - <span class="string">'2224:2224'</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">'./config:/etc/gitlab'</span></span><br><span class="line">      - <span class="string">'./logs:/var/log/gitlab'</span></span><br><span class="line">      - <span class="string">'./data:/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问GitLab首页</p>
<img src="/images/DevOps/GitLab.png"  style="zoom:67%;" />
</li>
<li><p>查看root用户初始密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab cat /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure>

<img src="/images/DevOps/初始密码.png"  style="zoom:50%;" />
</li>
<li><p>登录root用户</p>
</li>
</ul>
<img src="/images/DevOps/登录成功后跳转页面.png"  style="zoom:50%;" />

<ul>
<li><p>修改密码</p>
<img src="/images/DevOps/修改密码.png"  style="zoom:50%;" />

</li>
</ul>
<h1 id="三、Build阶段工具"><a href="#三、Build阶段工具" class="headerlink" title="三、Build阶段工具"></a>三、Build阶段工具</h1><p>构建Java项目的工具一般有两种选择，一个是Maven，一个是Gradle。</p>
<p>这里我们选择Maven作为项目的编译工具。</p>
<p>具体安装Maven流程不做阐述，但是需要确保配置好Maven仓库私服以及JDK编译版本。</p>
<h1 id="四、Operate阶段工具"><a href="#四、Operate阶段工具" class="headerlink" title="四、Operate阶段工具"></a>四、Operate阶段工具</h1><p>部署过程，会采用Docker进行部署，暂时只安装Docker即可，后续还需安装Kubenetes</p>
<h2 id="4-1-Docker安装"><a href="#4-1-Docker安装" class="headerlink" title="4.1 Docker安装"></a>4.1 Docker安装</h2><ul>
<li><p>准备测试环境&amp;生产环境</p>
</li>
<li><p>下载Docker依赖组件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置下载Docker的镜像源为阿里云</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Docker服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功后，启动Docker并设置开机自启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-2-Docker-Compose安装"><a href="#4-2-Docker-Compose安装" class="headerlink" title="4.2 Docker-Compose安装"></a>4.2 Docker-Compose安装</h2><ul>
<li><p>下载Docker/Compose：<a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p>
</li>
<li><p>将下载好的<a href="">docker-compose-Linux-x86_64</a>文件移动到Linux操作系统：……</p>
</li>
<li><p>设置<a href="">docker-compose-Linux-x86_64</a>文件权限，并移动到$PATH目录中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置文件权限</span></span><br><span class="line">chmod a+x docker-compose-Linux-x86_64</span><br><span class="line"><span class="comment"># 移动到/usr/bin目录下，并重命名为docker-compose</span></span><br><span class="line">mv docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="五、Integrate工具"><a href="#五、Integrate工具" class="headerlink" title="五、Integrate工具"></a>五、Integrate工具</h1><p>持续集成、持续部署的工具很多，其中Jenkins是一个开源的持续集成平台。</p>
<p>Jenkins涉及到将编写完毕的代码发布到测试环境和生产环境的任务，并且还涉及到了构建项目等任务。</p>
<p>Jenkins需要大量的插件保证工作，安装成本较高，下面会基于Docker搭建Jenkins。</p>
<h2 id="5-1-Jenkins介绍"><a href="#5-1-Jenkins介绍" class="headerlink" title="5.1 Jenkins介绍"></a>5.1 Jenkins介绍</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具</p>
<p>Jenkins应用广泛，大多数互联网公司都采用Jenkins配合GitLab、Docker、K8s作为实现<strong>DevOps</strong>的核心工具。</p>
<p>Jenkins最强大的就在于插件，Jenkins官方提供了大量的插件库，来自动化CI/CD过程中的各种琐碎功能。</p>
<p>Jenkins最主要的工作就是将GitLab上可以构建的工程代码拉取并且进行构建，再根据流程可以选择发布到测试环境或是生产环境。</p>
<p>一般是GitLab上的代码经过大量的测试后，确定发行版本，再发布到生产环境。</p>
<p>CI/CD可以理解为：</p>
<ul>
<li>CI过程即是通过Jenkins将代码拉取、构建、制作镜像交给测试人员测试。<ul>
<li>持续集成：让软件代码可以持续的集成到主干上，并自动构建和测试。</li>
</ul>
</li>
<li>CD过程即是通过Jenkins将打好标签的发行版本代码拉取、构建、制作镜像交给运维人员部署。<ul>
<li>持续交付：让经过持续集成的代码可以进行手动部署。</li>
<li>持续部署：让可以持续交付的代码随时随地的自动化部署。</li>
</ul>
</li>
</ul>
<p><img src="/images/DevOps/CI%E3%80%81CD.png" alt=""></p>
<h2 id="5-2-Jenkins安装"><a href="#5-2-Jenkins安装" class="headerlink" title="5.2 Jenkins安装"></a>5.2 Jenkins安装</h2><ul>
<li><p>拉取Jenkins镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写docker-compose.yml</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">version: <span class="string">"3.1"</span></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 50000:50000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/:/var/jenkins_home/</span><br></pre></td></tr></table></figure>
</li>
<li><p>首次启动会因为数据卷data目录没有权限导致启动失败，设置data目录写权限</p>
<p><code>chmod -R a+w data/</code></p>
</li>
<li><p>由于默认下载地址下载速度较慢，需要设置下载地址为国内镜像站</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改数据卷中的hudson.model.UpdateCenter.xml文件</span></span><br><span class="line">&lt;?xml version=<span class="string">'1.1'</span> encoding=<span class="string">'UTF-8'</span>?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"><span class="comment"># 将下载地址替换为http://mirror.esuni.jp/jenkins/updates/update-center.json</span></span><br><span class="line">&lt;?xml version=<span class="string">'1.1'</span> encoding=<span class="string">'UTF-8'</span>?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;http://mirror.esuni.jp/jenkins/updates/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"><span class="comment"># 清华大学的插件源也可以https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次重启Jenkins容器，访问Jenkins</p>
<img src="/images/DevOps/Jenkins首页.png"  style="zoom:67%;" />
</li>
<li><p>查看密码登录Jenkins，并登录下载插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<img src="/images/DevOps/登录并下载插件.png"  style="zoom:67%;" />

</li>
</ul>
<img src="/images/DevOps/登录并下载插件2.png"  style="zoom:67%;" />

<ul>
<li>选择需要安装的插件</li>
</ul>
<p><img src="/images/DevOps/%E6%8F%92%E4%BB%B61.png" alt=""></p>
<p><img src="/images/DevOps/%E6%8F%92%E4%BB%B62.png" alt=""></p>
<p><img src="/images/DevOps/%E6%8F%92%E4%BB%B63.png" alt=""></p>
<ul>
<li>下载完毕设置信息进入首页（可能会出现下载失败的插件）</li>
</ul>
<p><img src="/images/DevOps/%E6%88%AA%E5%9B%BE28.png" alt=""></p>
<p><img src="/images/DevOps/%E6%88%AA%E5%9B%BE29.png" alt=""></p>
<p><img src="/images/DevOps/%E6%88%AA%E5%9B%BE30.png" alt=""></p>
<h2 id="5-3-Jenkins入门配置"><a href="#5-3-Jenkins入门配置" class="headerlink" title="5.3 Jenkins入门配置"></a>5.3 Jenkins入门配置</h2><p>由于Jenkins需要从Git拉取代码、需要本地构建、甚至需要直接发布自定义镜像到Docker仓库，所以Jenkins需要配置大量内容。</p>
<h3 id="5-3-1-构建任务"><a href="#5-3-1-构建任务" class="headerlink" title="5.3.1 构建任务"></a>5.3.1 构建任务</h3><p>准备好GitLab仓库中的项目，并且通过Jenkins配置项目的实现当前项目的DevOps基本流程。</p>
<ul>
<li><p>构建Maven工程发布到GitLab（Gitee、Github均可）</p>
<p><img src="/images/DevOps/GitLab%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE.png" alt=""></p>
</li>
<li><p>Jenkins点击左侧导航新建任务</p>
<p><img src="/images/DevOps/%E6%96%B0%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" alt=""></p>
</li>
<li><p>选择自由风格构建任务</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1-1668584979544.png" alt=""></p>
</li>
</ul>
<h3 id="5-3-2-配置源码拉取地址"><a href="#5-3-2-配置源码拉取地址" class="headerlink" title="5.3.2 配置源码拉取地址"></a>5.3.2 配置源码拉取地址</h3><p>Jenkins需要将Git上存放的源码存储到Jenkins服务所在磁盘的本地</p>
<ul>
<li><p>配置任务源码拉取的地址</p>
<p><img src="/images/DevOps/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86.png" alt=""></p>
</li>
<li><p>Jenkins立即构建</p>
<p><img src="/images/DevOps/%E7%82%B9%E5%87%BB%E4%BB%BB%E5%8A%A1test%E4%B8%AD%E7%9A%84%E7%AB%8B%E5%8D%B3%E6%9E%84%E5%BB%BA.png" alt=""></p>
</li>
<li><p>查看构建工程的日志，点击上述③的任务条即可</p>
<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8B%E4%BB%BB%E5%8A%A1%E6%8B%89%E5%8F%96Git%E6%BA%90%E7%A0%81%E6%97%A5%E5%BF%97.png" alt=""></p>
<p>可以看到源码已经拉取带Jenkins本地，可以根据第三行日志信息，查看Jenkins本地拉取到的源码。</p>
</li>
<li><p>查看Jenkins容器中<a href="">/var/jenkins_home/workspace/test</a>的源码</p>
<p><img src="/images/DevOps/%E6%BA%90%E7%A0%81%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE-1668585165864.png" alt=""></p>
</li>
</ul>
<h3 id="5-3-3-配置Maven构建代码"><a href="#5-3-3-配置Maven构建代码" class="headerlink" title="5.3.3 配置Maven构建代码"></a>5.3.3 配置Maven构建代码</h3><p>代码拉取到Jenkins本地后，需要在Jenkins中对代码进行构建，这里需要Maven的环境，而Maven需要Java的环境，接下来需要在Jenkins中安装JDK和Maven，并且配置到Jenkins服务。</p>
<ul>
<li><p>准备JDK、Maven压缩包通过数据卷映射到Jenkins容器内部</p>
<p><img src="/images/DevOps/%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt=""></p>
</li>
<li><p>解压压缩包，并配置Maven的settings.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云镜像地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JDK1.8编译插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Jenkins配置JDK&amp;Maven并保存</p>
<p><img src="/images/DevOps/jdk.png" alt=""></p>
</li>
</ul>
<p><img src="/images/DevOps/maven.png" alt=""></p>
<ul>
<li><p>配置Jenkins任务构建代码</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEMaven%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81.png" alt=""></p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEMaven%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%812-1668585555375.png" alt=""></p>
</li>
<li><p>立即构建测试，查看target下的jar包</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E6%BA%90%E7%A0%81.png" alt=""></p>
</li>
</ul>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E6%BA%90%E7%A0%812.png" alt=""></p>
<h3 id="5-3-4-配置Publish发布-amp-远程操作"><a href="#5-3-4-配置Publish发布-amp-远程操作" class="headerlink" title="5.3.4 配置Publish发布&amp;远程操作"></a>5.3.4 配置Publish发布&amp;远程操作</h3><p>jar包构建好之后，就可以根据情况发布到测试或生产环境，这里需要用到之前下载好的插件Publish Over SSH。</p>
<ul>
<li><p>配置Publish Over SSH连接测试、生产环境</p>
<p><img src="/images/DevOps/Publish-Over-SSH%E9%85%8D%E7%BD%AE.png" alt=""></p>
</li>
<li><p>配置任务的构建后操作，发布jar包到目标服务</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%90%8E%E6%93%8D%E4%BD%9C.png" alt="">)<img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%90%8E%E6%93%8D%E4%BD%9C2.png" alt=""></p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%90%8E%E6%93%8D%E4%BD%9C3.png" alt=""></p>
</li>
<li><p>立即构建任务，并去目标服务查看</p>
<img src="/images/DevOps/立即构建.png"  style="zoom:67%;" />

<img src="/images/DevOps/立即构建2-1668585831545.png"  style="zoom:67%;" />

</li>
</ul>
<h1 id="六、CI、CD入门操作"><a href="#六、CI、CD入门操作" class="headerlink" title="六、CI、CD入门操作"></a>六、CI、CD入门操作</h1><p>基于Jenkins拉取GitLab的SpringBoot代码进行构建发布到测试环境实现持续集成</p>
<p>基于Jenkins拉取GitLab指定发行版本的SpringBoot代码进行构建发布到生产环境实现CD实现持续部署</p>
<h2 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h2><p>为了让程序代码可以自动推送到测试环境基于Docker服务运行，需要添加Docker配置和脚本文件让程序可以在集成到主干的同时运行起来。</p>
<ul>
<li><p>添加Dockerfile文件</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F.png" alt=""></p>
</li>
<li><p>添加docker-compose.yml文件</p>
<p><img src="/images/DevOps/%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.png" alt=""></p>
</li>
<li><p>追加Jenkins构建后操作脚本命令</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%91%E5%B8%83%E5%B9%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4.png" alt=""></p>
</li>
<li><p>发布到GitLab后由Jenkins立即构建并托送到目标服务器</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97.png" alt=""></p>
</li>
<li><p>测试部署到目标服务器程序</p>
<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3.png" alt=""></p>
<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A32.png" alt=""></p>
</li>
</ul>
<h2 id="6-2-持续交付、部署"><a href="#6-2-持续交付、部署" class="headerlink" title="6.2 持续交付、部署"></a>6.2 持续交付、部署</h2><p>程序代码在经过多次集成操作到达最终可以交付，持续交付整体流程和持续集成类似，不过需要选取指定的发行版本</p>
<ul>
<li><p>下载Git Parameter插件</p>
<p><img src="/images/DevOps/%E4%B8%8B%E8%BD%BDGitParameter.png" alt=""></p>
</li>
<li><p>设置项目参数化构建</p>
<p><img src="/images/DevOps/%E5%9F%BA%E4%BA%8EGit%E6%A0%87%E7%AD%BE%E6%9E%84%E5%BB%BA.png" alt=""></p>
<p><img src="/images/DevOps/%E5%9F%BA%E4%BA%8EGit%E6%A0%87%E7%AD%BE%E6%9E%84%E5%BB%BA2.png" alt=""></p>
</li>
<li><p>给项目添加tag版本</p>
<p><img src="/images/DevOps/%E6%B7%BB%E5%8A%A0tag%E7%89%88%E6%9C%AC.png" alt=""></p>
</li>
<li><p>任务构建时，采用Shell方式构建，拉取指定tag版本代码</p>
<p><img src="/images/DevOps/%E5%88%87%E6%8D%A2%E6%8C%87%E5%AE%9A%E6%A0%87%E7%AD%BE%E5%B9%B6%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt=""></p>
</li>
</ul>
<h1 id="七、集成Sonar-Qube"><a href="#七、集成Sonar-Qube" class="headerlink" title="七、集成Sonar Qube"></a>七、集成Sonar Qube</h1><h2 id="7-1-Sonar-Qube介绍"><a href="#7-1-Sonar-Qube介绍" class="headerlink" title="7.1 Sonar Qube介绍"></a>7.1 Sonar Qube介绍</h2><p>Sonar Qube是一个开源的代码分析平台，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，可以检测出重复代码、代码漏洞、代码规范和安全性漏洞的问题。</p>
<p>Sonar Qube可以与多种软件整合进行代码扫描，比如Maven，Gradle，Git，Jenkins等，并且会将代码检测结果推送回Sonar Qube并且在系统提供的UI界面上显示出来</p>
<p><img src="/images/DevOps/SonarQube%E7%9A%84UI%E7%95%8C%E9%9D%A2.png" alt=""></p>
<h2 id="7-2-Sonar-Qube环境搭建"><a href="#7-2-Sonar-Qube环境搭建" class="headerlink" title="7.2 Sonar Qube环境搭建"></a>7.2 Sonar Qube环境搭建</h2><h3 id="7-2-1-Sonar-Qube安装"><a href="#7-2-1-Sonar-Qube安装" class="headerlink" title="7.2.1 Sonar Qube安装"></a>7.2.1 Sonar Qube安装</h3><p>Sonar Qube在7.9版本中已经放弃了对MySQL的支持，并且建议在商业环境中采用PostgreSQL，那么安装Sonar Qube时需要依赖PostgreSQL。</p>
<p>并且这里会安装Sonar Qube的长期支持版本8.9</p>
<ul>
<li><p>拉取镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull postgres</span><br><span class="line">docker pull sonarqube:8.9.3-community</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写docker-compoe.yml</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">version: <span class="string">"3.1"</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    container_name: db</span><br><span class="line">    ports:</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - sonarnet</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_USER: sonar</span><br><span class="line">      POSTGRES_PASSWORD: sonar</span><br><span class="line">  sonarqube:</span><br><span class="line">    image: sonarqube:8.9.3-community</span><br><span class="line">    container_name: sonarqube</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"9000:9000"</span></span><br><span class="line">    networks:</span><br><span class="line">      - sonarnet</span><br><span class="line">    environment:</span><br><span class="line">      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar</span><br><span class="line">      SONAR_JDBC_USERNAME: sonar</span><br><span class="line">      SONAR_JDBC_PASSWORD: sonar</span><br><span class="line">networks:</span><br><span class="line">  sonarnet:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动失败，需要设置sysctl.conf文件信息</p>
<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AEvm.max_map_count.png" alt=""></p>
<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AEvm.max_map_count2.png" alt=""></p>
<p>并执行命令刷新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功</p>
<p><img src="/images/DevOps/%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97.png" alt=""></p>
</li>
<li><p>访问Sonar Qube首页</p>
<p><img src="/images/DevOps/%E7%99%BB%E5%BD%95.png" alt=""></p>
</li>
<li><p>还需要重新设置一次密码</p>
<p><img src="/images/DevOps/%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.png" alt=""></p>
</li>
<li><p>Sonar Qube首页</p>
<p><img src="/images/DevOps/SonarQube%E9%A6%96%E9%A1%B5.png" alt=""></p>
</li>
</ul>
<h3 id="7-2-2-安装中文插件"><a href="#7-2-2-安装中文插件" class="headerlink" title="7.2.2 安装中文插件"></a>7.2.2 安装中文插件</h3><p>​    <img src="/images/DevOps/%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E6%8F%92%E4%BB%B6.png" alt=""></p>
<p>安装成功后需要重启，安装失败重新点击install重装即可。</p>
<p>安装成功后，会查看到重启按钮，点击即可</p>
<p><img src="/images/DevOps/%E9%87%8D%E5%90%AF%E6%8C%89%E9%92%AE.png" alt=""></p>
<p>重启后查看效果</p>
<p><img src="/images/DevOps/%E9%A6%96%E9%A1%B5%E6%95%88%E6%9E%9C.png" alt=""></p>
<h2 id="7-3-Sonar-Qube基本使用"><a href="#7-3-Sonar-Qube基本使用" class="headerlink" title="7.3 Sonar Qube基本使用"></a>7.3 Sonar Qube基本使用</h2><p>Sonar Qube的使用方式很多，Maven可以整合，也可以采用sonar-scanner的方式，再查看Sonar Qube的检测效果</p>
<h3 id="7-3-1-Maven实现代码检测"><a href="#7-3-1-Maven实现代码检测" class="headerlink" title="7.3.1 Maven实现代码检测"></a>7.3.1 Maven实现代码检测</h3><ul>
<li><p>修改Maven的settings.xml文件配置Sonar Qube信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sonar.login</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">sonar.login</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sonar.password</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">sonar.password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span>http://192.168.11.11:9000<span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码位置执行命令：mvn sonar:sonar</p>
<p><img src="/images/DevOps/%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B.png" alt=""></p>
</li>
<li><p>查看Sonar Qube界面检测结果</p>
<p><img src="/images/DevOps/SonarQube%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<h3 id="7-3-2-Sonar-scanner实现代码检测"><a href="#7-3-2-Sonar-scanner实现代码检测" class="headerlink" title="7.3.2 Sonar-scanner实现代码检测"></a>7.3.2 Sonar-scanner实现代码检测</h3><ul>
<li><p>下载Sonar-scanner：<a href="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/" target="_blank" rel="noopener">https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/</a></p>
<p>下载4.6.x版本即可，要求Linux版本</p>
</li>
<li><p>解压并配置sonar服务端信息</p>
<ul>
<li><p>由于是zip压缩包，需要安装unzip解压插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install unzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压压缩包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置sonarQube服务端地址，修改conf下的sonar-scanner.properties</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BF%A1%E6%81%AF.png" alt=""></p>
</li>
</ul>
</li>
<li><p>执行命令检测代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在项目所在目录执行以下命令</span></span><br><span class="line">~/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=demo -Dsonar.projectKey=java -Dsonar.java.binaries=target/</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF.png" alt=""></p>
</li>
<li><p>查看SonarQube界面检测结果</p>
<p><img src="/images/DevOps/%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<h2 id="7-4-Jenkins集成Sonar-Qube"><a href="#7-4-Jenkins集成Sonar-Qube" class="headerlink" title="7.4 Jenkins集成Sonar Qube"></a>7.4 Jenkins集成Sonar Qube</h2><p>Jenkins继承Sonar Qube实现代码扫描需要先下载整合插件</p>
<h3 id="7-4-1-Jenkins安装插件"><a href="#7-4-1-Jenkins安装插件" class="headerlink" title="7.4.1 Jenkins安装插件"></a>7.4.1 Jenkins安装插件</h3><p><img src="/images/DevOps/%E4%B8%8B%E8%BD%BDSonarQube%E6%8F%92%E4%BB%B6.png" alt=""></p>
<p><img src="/images/DevOps/%E4%B8%8B%E8%BD%BDSonarQube%E6%8F%92%E4%BB%B62.png" alt=""></p>
<p><img src="/images/DevOps/%E4%B8%8B%E8%BD%BDSonarQube%E6%8F%92%E4%BB%B63.png" alt=""></p>
<h3 id="7-4-2-Jenkins配置Sonar-Qube"><a href="#7-4-2-Jenkins配置Sonar-Qube" class="headerlink" title="7.4.2 Jenkins配置Sonar Qube"></a>7.4.2 Jenkins配置Sonar Qube</h3><ul>
<li><p>开启Sonar Qube权限验证</p>
<p><img src="/images/DevOps/%E5%BC%80%E5%90%AFSonarQube%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C.png" alt=""></p>
</li>
<li><p>获取Sonar Qube的令牌</p>
<p><img src="/images/DevOps/%E8%8E%B7%E5%8F%96%E4%BB%A4%E7%89%8C.png" alt=""></p>
</li>
<li><p>配置Jenkins的Sonar Qube信息</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEJenkins%E7%9A%84SonarQube%E4%BF%A1%E6%81%AF1.png" alt=""></p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEJenkins%E7%9A%84SonarQube%E4%BF%A1%E6%81%AF2.png" alt=""></p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEJenkins%E7%9A%84SonarQube%E4%BF%A1%E6%81%AF3.png" alt=""></p>
</li>
</ul>
<h3 id="7-4-3-配置Sonar-scanner"><a href="#7-4-3-配置Sonar-scanner" class="headerlink" title="7.4.3 配置Sonar-scanner"></a>7.4.3 配置Sonar-scanner</h3><ul>
<li><p>将Sonar-scaner添加到Jenkins数据卷中并配置全局配置</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AESonar-scanner.png" alt=""></p>
</li>
<li><p>配置任务的Sonar-scanner</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84Sonar-scanner.png" alt=""></p>
</li>
</ul>
<h3 id="7-4-4-构建任务"><a href="#7-4-4-构建任务" class="headerlink" title="7.4.4 构建任务"></a>7.4.4 构建任务</h3><p>​    <img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1-1668587838774.png" alt=""></p>
<p>​    <img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A12.png" alt=""></p>
<h1 id="八、集成Harbor"><a href="#八、集成Harbor" class="headerlink" title="八、集成Harbor"></a>八、集成Harbor</h1><h2 id="8-1-Harbor介绍"><a href="#8-1-Harbor介绍" class="headerlink" title="8.1 Harbor介绍"></a>8.1 Harbor介绍</h2><p>前面在部署项目时，我们主要采用Jenkins推送jar包到指定服务器，再通过脚本命令让目标服务器对当前jar进行部署，这种方式在项目较多时，每个目标服务器都需要将jar包制作成自定义镜像再通过docker进行启动，重复操作比较多，会降低项目部署时间。</p>
<p>我们可以通过Harbor作为私有的Docker镜像仓库。让Jenkins统一将项目打包并制作成Docker镜像发布到Harbor仓库中，只需要通知目标服务，让目标服务统一去Harbor仓库上拉取镜像并在本地部署即可。</p>
<p>Docker官方提供了Registry镜像仓库，但是Registry的功能相对简陋。Harbor是VMware公司提供的一款镜像仓库，提供了权限控制、分布式发布、强大的安全扫描与审查机制等功能</p>
<h2 id="8-2-Harbor安装"><a href="#8-2-Harbor安装" class="headerlink" title="8.2 Harbor安装"></a>8.2 Harbor安装</h2><p>这里采用原生的方式安装Harbor。</p>
<ul>
<li><p>下载Harbor安装包：<a href="https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz" target="_blank" rel="noopener">https://github.com/goharbor/harbor/releases/download/v2.3.4/harbor-offline-installer-v2.3.4.tgz</a></p>
</li>
<li><p>拖拽到Linux并解压：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.3.4.tgz -C /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Harbor配置文件：</p>
<ul>
<li><p>首先复制一份harbor.yml配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑harbor.yml配置文件</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEHarbor%E6%96%87%E4%BB%B6.png" alt=""></p>
</li>
</ul>
</li>
<li><p>启动Harbor</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/harbor%E6%97%A5%E5%BF%97.png" alt=""></p>
</li>
<li><p>登录Harbor</p>
<p><img src="/images/DevOps/%E7%99%BB%E5%BD%95Harbor.png" alt=""></p>
</li>
<li><p>首页信息</p>
<p><img src="/images/DevOps/harbor%E9%A6%96%E9%A1%B5%E4%BF%A1%E6%81%AF.png" alt=""></p>
</li>
</ul>
<h2 id="8-3-Harbor使用方式"><a href="#8-3-Harbor使用方式" class="headerlink" title="8.3 Harbor使用方式"></a>8.3 Harbor使用方式</h2><p>Harbor作为镜像仓库，主要的交互方式就是将镜像上传到Harbor上，以及从Harbor上下载指定镜像</p>
<p>在传输镜像前，可以先使用Harbor提供的权限管理，将项目设置为私有项目，并对不同用户设置不同角色，从而更方便管理镜像。</p>
<h3 id="8-3-1-添加用户构建项目"><a href="#8-3-1-添加用户构建项目" class="headerlink" title="8.3.1 添加用户构建项目"></a>8.3.1 添加用户构建项目</h3><ul>
<li><p>创建用户</p>
<p><img src="/images/DevOps/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png" alt=""></p>
</li>
<li><p>构建项目（设置为私有）</p>
<p><img src="/images/DevOps/harbor%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt=""></p>
</li>
<li><p>给项目追加用户</p>
<p><img src="/images/DevOps/%E8%BF%BD%E5%8A%A0%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86.png" alt=""></p>
</li>
<li><p>切换测试用户</p>
<p><img src="/images/DevOps/%E5%88%87%E6%8D%A2%E6%B5%8B%E8%AF%95%E7%94%A8%E6%88%B7.png" alt=""></p>
</li>
</ul>
<h3 id="8-3-2-发布镜像到Harbor"><a href="#8-3-2-发布镜像到Harbor" class="headerlink" title="8.3.2 发布镜像到Harbor"></a>8.3.2 发布镜像到Harbor</h3><ul>
<li><p>修改镜像名称</p>
<p>名称要求：<code>harbor地址/项目名/镜像名:版本</code></p>
<p><img src="/images/DevOps/%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%90%8D%E7%A7%B0.png" alt=""></p>
</li>
<li><p>修改daemon.json，支持Docker仓库，并重启Docker</p>
<p><img src="/images/DevOps/%E4%BF%AE%E6%94%B9daemon.json%EF%BC%8C%E6%94%AF%E6%8C%81Docker%E4%BB%93%E5%BA%93.png" alt="修改daemon.json，支持Docker仓库"></p>
</li>
<li><p>设置登录仓库信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码 Harbor地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送镜像到Harbor</p>
<p><img src="/images/DevOps/%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F%E5%88%B0Harbor.png" alt=""></p>
<p><img src="/images/DevOps/%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F%E5%88%B0Harbor2.png" alt=""></p>
</li>
</ul>
<h3 id="8-3-3-从Harbor拉取镜像"><a href="#8-3-3-从Harbor拉取镜像" class="headerlink" title="8.3.3 从Harbor拉取镜像"></a>8.3.3 从Harbor拉取镜像</h3><p>跟传统方式一样，不过需要先配置<a href="">/etc/docker/daemon.json</a>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://pee6w651.mirror.aliyuncs.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>: [<span class="string">"192.168.11.11:80"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/harbor%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F.png" alt=""></p>
<h3 id="8-3-4-Jenkins容器使用宿主机Docker"><a href="#8-3-4-Jenkins容器使用宿主机Docker" class="headerlink" title="8.3.4 Jenkins容器使用宿主机Docker"></a>8.3.4 Jenkins容器使用宿主机Docker</h3><p>构建镜像和发布镜像到harbor都需要使用到docker命令。而在Jenkins容器内部安装Docker官方推荐直接采用宿主机带的Docker即可。</p>
<p>设置Jenkins容器使用宿主机Docker</p>
<ul>
<li><p>设置宿主机docker.sock权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo chown root:root /var/run/docker.sock</span><br><span class="line">sudo chmod o+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">version: <span class="string">"3.1"</span></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 50000:50000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/:/var/jenkins_home/</span><br><span class="line">      - /usr/bin/docker:/usr/bin/docker</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">      - /etc/docker/daemon.json:/etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-3-5-添加构建操作"><a href="#8-3-5-添加构建操作" class="headerlink" title="8.3.5 添加构建操作"></a>8.3.5 添加构建操作</h3><p><img src="/images/DevOps/harbor%E5%88%B6%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F.png" alt="harbor制作自定义镜像"></p>
<h3 id="8-3-6-编写部署脚本"><a href="#8-3-6-编写部署脚本" class="headerlink" title="8.3.6 编写部署脚本"></a>8.3.6 编写部署脚本</h3><p>部署项目需要通过Publish Over SSH插件，让目标服务器执行命令。为了方便一次性实现拉取镜像和启动的命令，推荐采用脚本文件的方式。</p>
<p>添加脚本文件到目标服务器，再通过Publish Over SSH插件让目标服务器执行脚本即可。</p>
<ul>
<li><p>编写脚本文件，添加到目标服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">harbor_url=<span class="variable">$1</span></span><br><span class="line">harbor_project_name=<span class="variable">$2</span></span><br><span class="line">project_name=<span class="variable">$3</span></span><br><span class="line">tag=<span class="variable">$4</span></span><br><span class="line">port=<span class="variable">$5</span></span><br><span class="line"></span><br><span class="line">imageName=<span class="variable">$harbor_url</span>/<span class="variable">$harbor_project_name</span>/<span class="variable">$project_name</span>:<span class="variable">$tag</span></span><br><span class="line"></span><br><span class="line">containerId=`docker ps -a | grep <span class="variable">$&#123;project_name&#125;</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$containerId</span>"</span> != <span class="string">""</span> ] ; <span class="keyword">then</span></span><br><span class="line">    docker stop <span class="variable">$containerId</span></span><br><span class="line">    docker rm <span class="variable">$containerId</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Delete Container Success"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">imageId=`docker /images | grep <span class="variable">$&#123;project_name&#125;</span> | awk <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$imageId</span>"</span> != <span class="string">""</span> ] ; <span class="keyword">then</span></span><br><span class="line">    docker rmi -f <span class="variable">$imageId</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Delete Image Success"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker login -u DevOps -p P@ssw0rd <span class="variable">$harbor_url</span></span><br><span class="line"></span><br><span class="line">docker pull <span class="variable">$imageName</span></span><br><span class="line"></span><br><span class="line">docker run -d -p <span class="variable">$port</span>:<span class="variable">$port</span> --name <span class="variable">$project_name</span> <span class="variable">$imageName</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Start Container Success"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$project_name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>if [ “$imageId” != “” ] ; then</p>
<p>docker rmi -f $imageId<br>echo “Delete Image Success”<br>fi</p>
<p>可以修改为</p>
<p>if [ [ “$tag” =~ “$imageId” ]] ; then<br>docker rmi -f $imageId<br>echo “Delete Image Success”<br>fi</p>
<p>因为$imageId可以能有多个，$tag包含在$imageId中就进入</p>
</blockquote>
</li>
</ul>
<p>并设置权限为可执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod a+x deploy.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C.png" alt=""></p>
<h3 id="8-3-7-配置构建后操作"><a href="#8-3-7-配置构建后操作" class="headerlink" title="8.3.7 配置构建后操作"></a>8.3.7 配置构建后操作</h3><p><img src="/images/DevOps/%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png" alt=""></p>
<h1 id="九、Jenkins流水线"><a href="#九、Jenkins流水线" class="headerlink" title="九、Jenkins流水线"></a>九、Jenkins流水线</h1><h2 id="9-1-Jenkins流水线任务介绍"><a href="#9-1-Jenkins流水线任务介绍" class="headerlink" title="9.1 Jenkins流水线任务介绍"></a>9.1 Jenkins流水线任务介绍</h2><p>之前采用Jenkins的自由风格构建的项目，每个步骤流程都要通过不同的方式设置，并且构建过程中整体流程是不可见的，无法确认每个流程花费的时间，并且问题不方便定位问题。</p>
<p>Jenkins的Pipeline可以让项目的发布整体流程可视化，明确执行的阶段，可以快速的定位问题。并且整个项目的生命周期可以通过一个Jenkinsfile文件管理，而且Jenkinsfile文件是可以放在项目中维护。</p>
<p>所以Pipeline相对自由风格或者其他的项目风格更容易操作。</p>
<h2 id="9-2-Jenkins流水线任务"><a href="#9-2-Jenkins流水线任务" class="headerlink" title="9.2 Jenkins流水线任务"></a>9.2 Jenkins流水线任务</h2><h3 id="9-2-1-构建Jenkins流水线任务"><a href="#9-2-1-构建Jenkins流水线任务" class="headerlink" title="9.2.1 构建Jenkins流水线任务"></a>9.2.1 构建Jenkins流水线任务</h3><ul>
<li><p>构建任务</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BAJenkins%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BB%BB%E5%8A%A1.png" alt=""></p>
</li>
<li><p>生成Groovy脚本</p>
<p><img src="/images/DevOps/HelloWorld%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90.png" alt=""></p>
</li>
<li><p>构建后查看视图</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E5%90%8E%E6%9F%A5%E7%9C%8B%E8%A7%86%E5%9B%BE.png" alt=""></p>
</li>
</ul>
<h3 id="9-2-2-Groovy脚本"><a href="#9-2-2-Groovy脚本" class="headerlink" title="9.2.2 Groovy脚本"></a>9.2.2 Groovy脚本</h3><ul>
<li><p>Groovy脚本基础语法</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有脚本命令包含在pipeline&#123;&#125;中</span></span><br><span class="line">pipeline &#123;  </span><br><span class="line">	<span class="comment">// 指定任务在哪个节点执行（Jenkins支持分布式）</span></span><br><span class="line">    agent any</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置全局环境，指定变量名=变量值信息</span></span><br><span class="line">    environment&#123;</span><br><span class="line">    	host = <span class="string">'192.168.11.11'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有任务的合集</span></span><br><span class="line">    stages &#123;</span><br><span class="line">    	<span class="comment">// 单个任务</span></span><br><span class="line">        stage(<span class="string">'任务1'</span>) &#123;</span><br><span class="line">        	<span class="comment">// 实现任务的具体流程</span></span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'do something'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 单个任务</span></span><br><span class="line">        stage(<span class="string">'任务2'</span>) &#123;</span><br><span class="line">        	<span class="comment">// 实现任务的具体流程</span></span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'do something'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写例子测试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    // 存放所有任务的合集</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'拉取Git代码'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'检测代码质量'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'检测代码质量'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'构建代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'构建代码'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'制作自定义镜像并发布Harbor'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'制作自定义镜像并发布Harbor'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'基于Harbor部署工程'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">'基于Harbor部署工程'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEGrovvy%E8%84%9A%E6%9C%AC.png" alt=""></p>
</li>
<li><p>查看效果</p>
<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<p>Ps：涉及到特定脚本，Jenkins给予了充足的提示，可以自动生成命令</p>
<p><img src="/images/DevOps/%E7%94%9F%E6%88%90%E5%91%BD%E4%BB%A4%E4%BD%8D%E7%BD%AE.png" alt=""></p>
<h3 id="9-2-3-Jenkinsfile实现"><a href="#9-2-3-Jenkinsfile实现" class="headerlink" title="9.2.3 Jenkinsfile实现"></a>9.2.3 Jenkinsfile实现</h3><p>Jenkinsfile方式需要将脚本内容编写到项目中的Jenkinsfile文件中，每次构建会自动拉取项目并且获取项目中Jenkinsfile文件对项目进行构建</p>
<ul>
<li><p>配置pipeline</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AEpipeline.png" alt=""></p>
</li>
<li><p>准备Jenkinsfile</p>
<p><img src="/images/DevOps/%E5%87%86%E5%A4%87Jenkinsfile%E6%96%87%E4%BB%B6.png" alt=""></p>
</li>
<li><p>测试效果</p>
<p><img src="/images/DevOps/%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<h2 id="9-3-Jenkins流水线任务实现"><a href="#9-3-Jenkins流水线任务实现" class="headerlink" title="9.3 Jenkins流水线任务实现"></a>9.3 Jenkins流水线任务实现</h2><h3 id="9-3-1-参数化构建"><a href="#9-3-1-参数化构建" class="headerlink" title="9.3.1 参数化构建"></a>9.3.1 参数化构建</h3><p>添加参数化构建，方便选择不的项目版本</p>
<p><img src="/images/DevOps/Git%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA.png" alt=""></p>
<h3 id="9-3-2-拉取Git代码"><a href="#9-3-2-拉取Git代码" class="headerlink" title="9.3.2 拉取Git代码"></a>9.3.2 拉取Git代码</h3><p>通过流水线语法生成Checkout代码的脚本</p>
<p><img src="/images/DevOps/%E8%AF%AD%E6%B3%95%E7%94%9F%E6%88%90.png" alt=""></p>
<p><img src="/images/DevOps/%E8%AF%AD%E6%B3%95%E7%94%9F%E6%88%902.png" alt=""></p>
<p>将*/master更改为标签${tag}</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$&#123;tag&#125;'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/test.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-3-构建代码"><a href="#9-3-3-构建代码" class="headerlink" title="9.3.3 构建代码"></a>9.3.3 构建代码</h3><p>通过脚本执行mvn的构建命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$&#123;tag&#125;'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/test.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'构建代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-4-代码质量检测"><a href="#9-3-4-代码质量检测" class="headerlink" title="9.3.4 代码质量检测"></a>9.3.4 代码质量检测</h3><p>通过脚本执行sonar-scanner命令即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$&#123;tag&#125;'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/test.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'构建代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'检测代码质量'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa'</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-5-制作自定义镜像并发布"><a href="#9-3-5-制作自定义镜像并发布" class="headerlink" title="9.3.5 制作自定义镜像并发布"></a>9.3.5 制作自定义镜像并发布</h3><ul>
<li><p>生成自定义镜像脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment&#123;</span><br><span class="line">        harborHost = <span class="string">'192.168.11.11:80'</span></span><br><span class="line">        harborRepo = <span class="string">'repository'</span></span><br><span class="line">        harborUser = <span class="string">'DevOps'</span></span><br><span class="line">        harborPasswd = <span class="string">'P@ssw0rd'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存放所有任务的合集</span><br><span class="line">    stages &#123;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$&#123;tag&#125;'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/test.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'构建代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'检测代码质量'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=31388be45653876c1f51ec02f0d478e2d9d0e1fa'</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'制作自定义镜像并发布Harbor'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'cp ./target/*.jar ./docker/</span></span><br><span class="line"><span class="string">                cd ./docker</span></span><br><span class="line"><span class="string">                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">                sh <span class="string">''</span><span class="string">'docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;</span></span><br><span class="line"><span class="string">                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;</span></span><br><span class="line"><span class="string">                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;'</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成Publish Over SSH脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment&#123;</span><br><span class="line">        harborHost = <span class="string">'192.168.11.11:80'</span></span><br><span class="line">        harborRepo = <span class="string">'repository'</span></span><br><span class="line">        harborUser = <span class="string">'DevOps'</span></span><br><span class="line">        harborPasswd = <span class="string">'P@ssw0rd'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存放所有任务的合集</span><br><span class="line">    stages &#123;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$&#123;tag&#125;'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/test.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'构建代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;docker</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'检测代码质量'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=7d66af4b39cfe4f52ac0a915d4c9d5c513207098'</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'制作自定义镜像并发布Harbor'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'cp ./target/*.jar ./docker/</span></span><br><span class="line"><span class="string">                cd ./docker</span></span><br><span class="line"><span class="string">                docker build -t $&#123;JOB_NAME&#125;:$&#123;tag&#125; ./'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">                sh <span class="string">''</span><span class="string">'docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborHost&#125;</span></span><br><span class="line"><span class="string">                docker tag $&#123;JOB_NAME&#125;:$&#123;tag&#125; $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;</span></span><br><span class="line"><span class="string">                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$&#123;tag&#125;'</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(<span class="string">'目标服务器拉取镜像并运行'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sshPublisher(publishers: [sshPublisherDesc(configName: <span class="string">'testEnvironment'</span>, transfers: [sshTransfer(cleanRemote: <span class="literal">false</span>, excludes: <span class="string">''</span>, execCommand: <span class="string">"/usr/bin/deploy.sh <span class="variable">$harborHost</span> <span class="variable">$harborRepo</span> <span class="variable">$JOB_NAME</span> <span class="variable">$tag</span> <span class="variable">$port</span> "</span>, execTimeout: 120000, flatten: <span class="literal">false</span>, makeEmptyDirs: <span class="literal">false</span>, noDefaultExcludes: <span class="literal">false</span>, patternSeparator: <span class="string">'[, ]+'</span>, remoteDirectory: <span class="string">''</span>, remoteDirectorySDF: <span class="literal">false</span>, removePrefix: <span class="string">''</span>, sourceFiles: <span class="string">''</span>)], usePromotionTimestamp: <span class="literal">false</span>, useWorkspaceInPromotion: <span class="literal">false</span>, verbose: <span class="literal">false</span>)])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于采用变量，记得使用双引号</p>
</blockquote>
</li>
</ul>
<h2 id="9-4-Jenkins流水线整合钉钉"><a href="#9-4-Jenkins流水线整合钉钉" class="headerlink" title="9.4 Jenkins流水线整合钉钉"></a>9.4 Jenkins流水线整合钉钉</h2><p>在程序部署成功后，可以通过钉钉的机器人及时向群众发送部署的最终结果通知</p>
<ul>
<li><p>安装插件</p>
<p><img src="/images/DevOps/%E9%92%89%E9%92%89%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png" alt=""></p>
</li>
<li><p>钉钉内部创建群组并构建机器人</p>
<p><img src="/images/DevOps/%E9%92%89%E9%92%89%E5%86%85%E9%83%A8%E5%88%9B%E5%BB%BA%E7%BE%A4%E7%BB%84%E5%B9%B6%E6%9E%84%E5%BB%BA%E6%9C%BA%E5%99%A8%E4%BA%BA.png" alt=""></p>
</li>
</ul>
<p>最终或获取到Webhook信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<ul>
<li><p>系统配置添加钉钉通知</p>
<p><img src="/images/DevOps/%E9%85%8D%E7%BD%AE%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5.png" alt=""></p>
</li>
<li><p>任务中追加流水线配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        sonarLogin = <span class="string">'2bab7bf7d5af25e2c2ca2f178af2c3c55c64d5d8'</span></span><br><span class="line">        harborUser = <span class="string">'admin'</span></span><br><span class="line">        harborPassword = <span class="string">'Harbor12345'</span></span><br><span class="line">        harborHost = <span class="string">'192.168.11.12:8888'</span></span><br><span class="line">        harborRepo = <span class="string">'repository'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'拉取Git代码'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'$tag'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://49.233.115.171:8929/root/lsx.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Maven构建代码'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'SonarQube检测代码'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=target/ -Dsonar.login=$&#123;sonarLogin&#125;'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'制作自定义镜像'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'cd docker</span></span><br><span class="line"><span class="string">                mv ../target/*.jar ./</span></span><br><span class="line"><span class="string">                docker build -t $&#123;JOB_NAME&#125;:$tag .</span></span><br><span class="line"><span class="string">                '</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'推送自定义镜像'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'docker login -u $&#123;harborUser&#125; -p $&#123;harborPassword&#125; $&#123;harborHost&#125;</span></span><br><span class="line"><span class="string">                docker tag $&#123;JOB_NAME&#125;:$tag $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag</span></span><br><span class="line"><span class="string">                docker push $&#123;harborHost&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:$tag'</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">'通知目标服务器'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sshPublisher(publishers: [sshPublisherDesc(configName: <span class="string">'centos-docker'</span>, transfers: [sshTransfer(cleanRemote: <span class="literal">false</span>, excludes: <span class="string">''</span>, execCommand: <span class="string">"/usr/bin/deploy.sh <span class="variable">$harborHost</span> <span class="variable">$harborRepo</span> <span class="variable">$JOB_NAME</span> <span class="variable">$tag</span> <span class="variable">$port</span>"</span>, execTimeout: 120000, flatten: <span class="literal">false</span>, makeEmptyDirs: <span class="literal">false</span>, noDefaultExcludes: <span class="literal">false</span>, patternSeparator: <span class="string">'[, ]+'</span>, remoteDirectory: <span class="string">''</span>, remoteDirectorySDF: <span class="literal">false</span>, removePrefix: <span class="string">''</span>, sourceFiles: <span class="string">''</span>)], usePromotionTimestamp: <span class="literal">false</span>, useWorkspaceInPromotion: <span class="literal">false</span>, verbose: <span class="literal">false</span>)])</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            dingtalk (</span><br><span class="line">                robot: <span class="string">'Jenkins-DingDing'</span>,</span><br><span class="line">                <span class="built_in">type</span>:<span class="string">'MARKDOWN'</span>,</span><br><span class="line">                title: <span class="string">"success: <span class="variable">$&#123;JOB_NAME&#125;</span>"</span>,</span><br><span class="line">                text: [<span class="string">"- 成功构建:<span class="variable">$&#123;JOB_NAME&#125;</span>项目!\n- 版本:<span class="variable">$&#123;tag&#125;</span>\n- 持续时间:<span class="variable">$&#123;currentBuild.durationString&#125;</span>\n- 任务:#<span class="variable">$&#123;JOB_NAME&#125;</span>"</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            dingtalk (</span><br><span class="line">                robot: <span class="string">'Jenkins-DingDing'</span>,</span><br><span class="line">                <span class="built_in">type</span>:<span class="string">'MARKDOWN'</span>,</span><br><span class="line">                title: <span class="string">"fail: <span class="variable">$&#123;JOB_NAME&#125;</span>"</span>,</span><br><span class="line">                text: [<span class="string">"- 失败构建:<span class="variable">$&#123;JOB_NAME&#125;</span>项目!\n- 版本:<span class="variable">$&#123;tag&#125;</span>\n- 持续时间:<span class="variable">$&#123;currentBuild.durationString&#125;</span>\n- 任务:#<span class="variable">$&#123;JOB_NAME&#125;</span>"</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="十、Kubernetes编排工具"><a href="#十、Kubernetes编排工具" class="headerlink" title="十、Kubernetes编排工具"></a>十、Kubernetes编排工具</h1><h2 id="10-1-Kubernetes介绍"><a href="#10-1-Kubernetes介绍" class="headerlink" title="10.1 Kubernetes介绍"></a>10.1 Kubernetes介绍</h2><p>Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。</p>
<p>Kubernetes主要能帮助我们完成：</p>
<ul>
<li><p>服务发现和负载均衡</p>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p>存储编排</p>
<p>Kubernetes 允许你自动挂载你选择的存储系统，比如本地存储，类似Docker的数据卷。</p>
</li>
<li><p>自动部署和回滚</p>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。Kubernetes 会自动帮你根据情况部署创建新容器，并删除现有容器给新容器提供资源。</p>
</li>
<li><p>自动完成装箱计算</p>
<p>Kubernetes 允许你设置每个容器的资源，比如CPU和内存。</p>
</li>
<li><p>自我修复</p>
<p>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的容器，并运行状况检查的容器。</p>
</li>
<li><p>秘钥与配置管理</p>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>
</li>
</ul>
<h2 id="10-2-Kubernetes架构"><a href="#10-2-Kubernetes架构" class="headerlink" title="10.2 Kubernetes架构"></a>10.2 Kubernetes架构</h2><p>Kubernetes 搭建需要至少两个节点，一个Master负责管理，一个Slave搭建在工作服务器上负责分配。</p>
<p><img src="/images/DevOps/kubernetes%E6%9E%B6%E6%9E%84.png" alt=""></p>
<p>从图中可以看到各个组件的基本功能：</p>
<ul>
<li>API Server：作为K8s通讯的核心组件，K8s内部交互以及接收发送指令的组件。</li>
<li>controller-manager：作为K8s的核心组件，主要做资源调度，根据集群情况分配资源</li>
<li>etcd：一个key-value的数据库，存储存储集群的状态信息</li>
<li>scheduler：负责调度每个工作节点</li>
<li>cloud-controller-manager：负责调度其他云服务产品</li>
<li>kubelet：管理Pods上面的容器。</li>
<li>kube-proxy：负责处理其他Slave或客户端的请求。</li>
<li>Pod：可以理解为就是运行的容器</li>
</ul>
<h2 id="10-3-Kubernetes安装"><a href="#10-3-Kubernetes安装" class="headerlink" title="10.3 Kubernetes安装"></a>10.3 Kubernetes安装</h2><p>这里会采用<a href="https://kuboard.cn/提供的方式安装K8s，安装单Master节点" target="_blank" rel="noopener">https://kuboard.cn/提供的方式安装K8s，安装单Master节点</a></p>
<ul>
<li>要求使用Centos7.8版本：<a href="https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso" target="_blank" rel="noopener">https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso</a></li>
<li>至少2台 <strong>2核4G</strong> 的服务器</li>
</ul>
<p>安装流程</p>
<p><img src="/images/DevOps/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>准备好服务器后开始安装</p>
<ul>
<li><p>重新设置hostname，不允许为localhost</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 hostname，名字不允许使用下划线、小数点、大写字母，不能叫master</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname your-new-host-name</span><br><span class="line"><span class="comment"># 查看修改结果</span></span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 设置 hostname 解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"127.0.0.1   <span class="variable">$(hostname)</span>"</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>要求2台服务之间可以相互通讯</p>
</li>
<li><p>安装软件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阿里云 docker hub 镜像</span></span><br><span class="line"><span class="built_in">export</span> REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">curl -sSL https://kuboard.cn/install-script/v1.19.x/install_kubelet.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>首先初始化Master节点</p>
<blockquote>
<p>关于初始化时用到的环境变量</p>
<ul>
<li><strong>APISERVER_NAME</strong> 不能是 master 的 hostname</li>
<li><strong>APISERVER_NAME</strong> 必须全为小写字母、数字、小数点，不能包含减号</li>
<li><strong>POD_SUBNET</strong> 所使用的网段不能与 <strong><em>master节点/worker节点</em></strong> 所在的网段重叠。该字段的取值为一个 <a href="https://kuboard.cn/glossary/cidr.html" target="_blank" rel="noopener">CIDR</a> 值，如果您对 CIDR 这个概念还不熟悉，请仍然执行 export POD_SUBNET=10.100.0.0/16 命令，不做修改</li>
</ul>
</blockquote>
<ul>
<li><p>设置ip，域名，网段并执行初始化操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 master 节点执行</span></span><br><span class="line"><span class="comment"># 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）</span></span><br><span class="line"><span class="comment"># export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令</span></span><br><span class="line"><span class="built_in">export</span> MASTER_IP=192.168.11.32</span><br><span class="line"><span class="comment"># 替换 apiserver.demo 为 您想要的 dnsName</span></span><br><span class="line"><span class="built_in">export</span> APISERVER_NAME=apiserver.demo</span><br><span class="line"><span class="comment"># Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</span></span><br><span class="line"><span class="built_in">export</span> POD_SUBNET=10.100.0.1/16</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;MASTER_IP&#125;</span>    <span class="variable">$&#123;APISERVER_NAME&#125;</span>"</span> &gt;&gt; /etc/hosts</span><br><span class="line">curl -sSL https://kuboard.cn/install-script/v1.19.x/init_master.sh | sh -s 1.19.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查Master启动状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 master 节点执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态</span></span><br><span class="line">watch kubectl get pod -n kube-system -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 master 节点初始化结果</span></span><br><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure>

<p>如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64 </span><br><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"cbr0"</span>,<span class="string">"type"</span>:<span class="string">"flannel"</span>,<span class="string">"delegate"</span>: &#123;<span class="string">"isDefaultGateway"</span>: <span class="literal">true</span>&#125;&#125;</span><br><span class="line">EOF</span><br><span class="line">mkdir /usr/share/oci-umount/oci-umount.d -p</span><br><span class="line">mkdir /run/flannel/</span><br><span class="line">cat &lt;&lt;EOF&gt; /run/flannel/subnet.env</span><br><span class="line">FLANNEL_NETWORK=172.100.0.0/16</span><br><span class="line">FLANNEL_SUBNET=172.100.1.0/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=<span class="literal">true</span></span><br><span class="line">EOF</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>安装网络服务插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> POD_SUBNET=10.100.0.0/16</span><br><span class="line">kubectl apply -f https://kuboard.cn/install-script/v1.22.x/calico-operator.yaml</span><br><span class="line">wget https://kuboard.cn/install-script/v1.22.x/calico-custom-resources.yaml</span><br><span class="line">sed -i <span class="string">"s#192.168.0.0/16#<span class="variable">$&#123;POD_SUBNET&#125;</span>#"</span> calico-custom-resources.yaml</span><br><span class="line">kubectl apply -f calico-custom-resources.yaml</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>初始化worker节点</p>
<ul>
<li><p>获取Join命令参数，在Master节点执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 master 节点执行</span></span><br><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4.png" alt=""></p>
</li>
<li><p>在worker节点初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 worker 节点执行</span></span><br><span class="line"><span class="comment"># 替换 x.x.x.x 为 master 节点的内网 IP</span></span><br><span class="line"><span class="built_in">export</span> MASTER_IP=192.168.11.32</span><br><span class="line"><span class="comment"># 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAME</span></span><br><span class="line"><span class="built_in">export</span> APISERVER_NAME=apiserver.demo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;MASTER_IP&#125;</span>    <span class="variable">$&#123;APISERVER_NAME&#125;</span>"</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为 master 节点上 kubeadm token create 命令的输出</span></span><br><span class="line">kubeadm join apiserver.demo:6443 --token vwfilu.3nhndohc5gn1jv9k     --discovery-token-ca-cert-hash sha256:22ff15cabfe87ab48a7db39b3bbf986fee92ec92eb8efc7fe9b0abe2175ff0c2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>检查最终运行效果</p>
<ul>
<li><p>在 master 节点上执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 master 节点执行</span></span><br><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure>

<p>如果出现NotReady的情况执行（最新版本的BUG，1.19一般没有）</p>
<blockquote>
<p>docker pull quay.io/coreos/flannel:v0.10.0-amd64<br>mkdir -p /etc/cni/net.d/<br>cat &lt;<EOF> /etc/cni/net.d/10-flannel.conf<br>{“name”:”cbr0”,”type”:”flannel”,”delegate”: {“isDefaultGateway”: true}}<br>EOF<br>mkdir /usr/share/oci-umount/oci-umount.d -p<br>mkdir /run/flannel/<br>cat &lt;<EOF> /run/flannel/subnet.env<br>FLANNEL_NETWORK=172.100.0.0/16<br>FLANNEL_SUBNET=172.100.1.0/24<br>FLANNEL_MTU=1450<br>FLANNEL_IPMASQ=true<br>EOF<br>kubectl apply -f <a href="https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml" target="_blank" rel="noopener">https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</a></p>
</blockquote>
</li>
<li><p>输出结果如下所示：</p>
<p><img src="/images/DevOps/%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<p>安装Kuboard管理K8s集群</p>
<ul>
<li><p>安装Kuboard</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml</span><br><span class="line"><span class="comment"># 您也可以使用下面的指令，唯一的区别是，该指令使用华为云的镜像仓库替代 docker hub 分发 Kuboard 所需要的镜像</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看启动情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">watch kubectl get pods -n kuboard</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/kuboard%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
<li><p>在浏览器中打开链接 <a href="http://your-node-ip-address:30080" target="_blank" rel="noopener">http://your-node-ip-address:30080</a></p>
<p><img src="/images/DevOps/kuboard%E9%A6%96%E9%A1%B5.png" alt=""></p>
</li>
<li><p>输入初始用户名和密码，并登录</p>
<ul>
<li>用户名： <code>admin</code></li>
<li>密码： <code>Kuboard123</code></li>
</ul>
<p><img src="/images/DevOps/kuboard%E9%A6%96%E9%A1%B5%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
</ul>
<h2 id="10-4-Kubernetes操作"><a href="#10-4-Kubernetes操作" class="headerlink" title="10.4 Kubernetes操作"></a>10.4 Kubernetes操作</h2><p>首先我们要了解Kubernetes在运行我们的资源时，关联到了哪些内容</p>
<ul>
<li><p>资源的构建方式：</p>
<ul>
<li>采用kubectl的命令方式</li>
<li>yaml文件方式</li>
</ul>
</li>
</ul>
<h3 id="10-4-1-Namespace"><a href="#10-4-1-Namespace" class="headerlink" title="10.4.1 Namespace"></a>10.4.1 Namespace</h3><ul>
<li><p>命名空间：主要是为了对Kubernetes中运行的资源进行过隔离， 但是网络是互通的，类似Docker的容器，可以将多个资源配置到一个NameSpace中。而NameSpace可以对不同环境进行资源隔离，默认情况下Kubernetes提供了default命名空间，在构建资源时，如果不指定资源，默认采用default资源。<br>命令方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看现有的全部命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建命名空间</span></span><br><span class="line">kubectl create ns 命名空间名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除现有命名空间， 并且会删除空间下的全部资源</span></span><br><span class="line">kubectl delete ns 命名空间名称</span><br></pre></td></tr></table></figure>

<p>yaml文件方式：（构建资源时，设置命名空间）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-4-2-Pod"><a href="#10-4-2-Pod" class="headerlink" title="10.4.2 Pod"></a>10.4.2 Pod</h3><ul>
<li><p>Pod：Kubernetes运行的一组容器，Pod是Kubernetes的最小单位，但是对于Docker而然，Pod中会运行多个Docker容器</p>
<ul>
<li><p>命令方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有运行的pod</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定Namespace下的Pod</span></span><br><span class="line">kubectl get pod [-n 命名空间]  <span class="comment">#（默认default）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">kubectl run pod名称 --image=镜像名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详细信息</span></span><br><span class="line">kubectl describe pod pod名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除pod</span></span><br><span class="line">kubectl delete pod pod名称 [-n 命名空间]  <span class="comment">#（默认default）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod输出的日志</span></span><br><span class="line">kubectl logs -f pod名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进去pod容器内部</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod名称 -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看kubernetes给Pod分配的ip信息，并且通过ip和容器的端口，可以直接访问</span></span><br><span class="line">kubectl get pod -owide</span><br></pre></td></tr></table></figure>
</li>
<li><p>yaml方式（推荐）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: 运行的pod名称</span><br><span class="line">  name: pod名称</span><br><span class="line">  namespace: 命名空间</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: 镜像名称</span><br><span class="line">    name: 容器名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Pod：kubectl apply -f yaml文件名称</span></span><br><span class="line"><span class="comment"># 删除Pod：kubectl delete -f yaml文件名称</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Pod中运行多个容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: 运行的pod名称</span><br><span class="line">  name: pod名称</span><br><span class="line">  namespace: 命名空间</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: 镜像名称</span><br><span class="line">    name: 容器名称</span><br><span class="line">  - image: 镜像名称</span><br><span class="line">    name: 容器名称</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>

<p>启动后可以查看到</p>
<p><img src="/images/DevOps/Kuboard%E6%95%88%E6%9E%9C.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h3 id="10-4-3-Deployment"><a href="#10-4-3-Deployment" class="headerlink" title="10.4.3 Deployment"></a>10.4.3 Deployment</h3><p>部署时，可以通过Deployment管理和编排Pod</p>
<p>Deployment部署实现</p>
<ul>
<li><p>命令方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于Deployment启动容器</span></span><br><span class="line">kubectl create deployment deployment名称 --image=镜像名称</span><br><span class="line"><span class="comment"># 用deployment启动的容器会在被删除后自动再次创建，达到故障漂移的效果</span></span><br><span class="line"><span class="comment"># 需要使用deploy的方式删除deploy</span></span><br><span class="line"><span class="comment"># 查看现在的deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除deployment</span></span><br><span class="line">kubectl delete deployment deployment名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于Deployment启动容器并设置Pod集群数</span></span><br><span class="line">kubectl create deployment deployment名称 --image=镜像名称 --replicas 集群个数</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">配置文件方式</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">       image: nginx</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 80</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>弹性伸缩功能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于scale实现弹性伸缩</span></span><br><span class="line">kubectl scale deploy/Deployment名称 --replicas 集群个数</span><br><span class="line"><span class="comment"># 或者修改yaml文件</span></span><br><span class="line">kubectl edit deploy Deployment名称</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%A1%B5%E9%9D%A2%E4%BF%AE%E6%94%B9.png" alt=""></p>
</li>
</ul>
<p>灰度发布</p>
<p>Deploy可以在部署新版本数据时，成功启动一个pod，才会下线一个老版本的Pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployment/Deployment名称 容器名=镜像:版本</span><br></pre></td></tr></table></figure>

<h3 id="10-4-4-Service"><a href="#10-4-4-Service" class="headerlink" title="10.4.4 Service"></a>10.4.4 Service</h3><p>可以将多个Pod对外暴露一个Service，让客户端可以通过Service访问到这一组Pod，并且可以实现负载均衡</p>
<h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>ClusterIP是集群内部Pod之间的访问方式</p>
<ul>
<li><p>命令实现效果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器</span></span><br><span class="line">kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口</span><br></pre></td></tr></table></figure>

<p>之后通过<code>kubectl get service</code>查看Service提供的ip，即可访问</p>
<p>![](/images/DevOps/kubectl get service.png)</p>
</li>
</ul>
<p>也可以通过<code>Deployment名称.namespace名称.svc</code>作为域名访问</p>
<p><img src="/images/DevOps/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%86%85%E6%89%A7%E8%A1%8C.png" alt=""></p>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p>ClusterIP的方式只能在Pod内部实现访问，但是一般需要对外暴露网关，所以需要NodePort的方式Pod外暴露访问</p>
<ul>
<li><p>命令实现方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过生成service映射一个Deployment下的所有pod中的某一个端口的容器</span></span><br><span class="line">kubectl expose deployment Deployment名称 --port=Service端口号 --target-port=Pod内容器端口 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E6%9F%A5%E7%9C%8BService%E6%95%88%E6%9E%9C.png" alt=""></p>
<blockquote>
<p>通过宿主机IP+对外端口访问</p>
</blockquote>
</li>
<li><p>yaml文件实现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels</span><br><span class="line">    app: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">  spec:</span><br><span class="line">    selector:</span><br><span class="line">      app: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - port: 8888</span><br><span class="line">     protocol: TCP</span><br><span class="line">     targetPort: 80</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-deployment</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-deployment</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-deployment</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-service</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-deployment</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8888</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="10-4-5-Ingress"><a href="#10-4-5-Ingress" class="headerlink" title="10.4.5 Ingress"></a>10.4.5 Ingress</h2><p>Kubernetes推荐将Ingress作为所有Service的入口，提供统一的入口，避免多个服务之间需要记录大量的IP或者域名，毕竟IP可能改变，服务太多域名记录不方便。</p>
<p>Ingress底层其实就是一个Nginx， 可以在Kuboard上直接点击安装</p>
<p><img src="/images/DevOps/Ingress1.png" alt=""></p>
<p><img src="/images/DevOps/Ingress2.png" alt=""></p>
<p>因为副本数默认为1，但是k8s整体集群就2个节点，所以显示下面即为安装成功</p>
<p><img src="/images/DevOps/Ingress3.png" alt=""></p>
<p>可以将Ingress接收到的请求转发到不同的Service中。</p>
<p>推荐使用yaml文件方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: ingress</span><br><span class="line">  rules:</span><br><span class="line">  - host: nginx.xxx.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: nginx-service</span><br><span class="line">            port:</span><br><span class="line">              number: 8888</span><br></pre></td></tr></table></figure>

<p><img src="/images/DevOps/%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%AE%E9%A2%98.png" alt="启动时问题"></p>
<p>Kuboard安装的Ingress有admission的校验配置，需要先删除配置再启动</p>
<p>找到指定的ingress的校验信息，删除即可</p>
<p><img src="/images/DevOps/%E5%88%A0%E9%99%A4ingress%E7%9A%84%E6%A0%A1%E9%AA%8C%E4%BF%A1%E6%81%AF.png" alt=""></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看校验webhook的配置</span></span><br><span class="line">kubectl get -A ValidatingWebhookConfiguration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的校验</span></span><br><span class="line">kubectl delete ValidatingWebhookConfiguration ingress-nginx-admission-my-ingress-controller</span><br></pre></td></tr></table></figure>

<blockquote>
<p>host文件配置nginx.xxx.com映射到宿主机ip</p>
<p>nginx.xxx.com:30717，域名+pod分配的外部端口访问</p>
</blockquote>
<h2 id="10-5-Jenkins集成Kubernetes"><a href="#10-5-Jenkins集成Kubernetes" class="headerlink" title="10.5 Jenkins集成Kubernetes"></a>10.5 Jenkins集成Kubernetes</h2><h3 id="10-5-1-准备部署的yml文件"><a href="#10-5-1-准备部署的yml文件" class="headerlink" title="10.5.1 准备部署的yml文件"></a>10.5.1 准备部署的yml文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  name: pipeline</span><br><span class="line">  labels:</span><br><span class="line">    app: pipeline</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pipeline</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pipeline    </span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pipeline</span><br><span class="line">        image: 192.168.11.102:80/repo/pipeline:v4.0.0</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  labels:</span><br><span class="line">    app: pipeline</span><br><span class="line">  name: pipeline  </span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: pipeline</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8081</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  name: pipeline</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: ingress</span><br><span class="line">  rules:</span><br><span class="line">  - host: xxx.pipeline.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: pipeline</span><br><span class="line">            port:</span><br><span class="line">              number: 8081</span><br></pre></td></tr></table></figure>

<h3 id="10-5-2-Harbor私服配置"><a href="#10-5-2-Harbor私服配置" class="headerlink" title="10.5.2 Harbor私服配置"></a>10.5.2 Harbor私服配置</h3><p>在尝试用kubernetes的yml文件启动pipeline服务时，会出现Kubernetes无法拉取镜像的问题，这里需要在kubernetes所在的Linux中配置Harbor服务信息，并且保证Kubernetes可以拉取Harbor上的镜像</p>
<ul>
<li><p>设置Master和Worker的私服地址信息</p>
<p><img src="/images/DevOps/jenkins-%E8%AE%BE%E7%BD%AEHarbor%E7%A7%81%E6%9C%8D%E5%9C%B0%E5%9D%80.png" alt=""></p>
</li>
<li><p>在Kuboard上设置私服密文信息</p>
<p><img src="/images/DevOps/Kuboard%E4%B8%8A%E8%AE%BE%E7%BD%AE%E7%A7%81%E6%9C%8D%E5%AF%86%E6%96%87%E4%BF%A1%E6%81%AF.png" alt=""></p>
<p>按照复制指令的位置测试认证，效果如下</p>
<p><img src="/images/DevOps/%E5%A4%8D%E5%88%B6%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E8%AE%A4%E8%AF%81.png" alt=""></p>
</li>
</ul>
<h3 id="10-5-3-测试使用效果"><a href="#10-5-3-测试使用效果" class="headerlink" title="10.5.3 测试使用效果"></a>10.5.3 测试使用效果</h3><p>执行kubectl命令，基于yml启动服务，并且基于部署后服务的提示信息以及Ingress的设置，直接访问</p>
<h4 id="10-5-3-1-Jenkins远程调用"><a href="#10-5-3-1-Jenkins远程调用" class="headerlink" title="10.5.3.1 Jenkins远程调用"></a>10.5.3.1 Jenkins远程调用</h4><ul>
<li><p>将pipeline.yml配置到Gitlab中</p>
<p><img src="/images/DevOps/pipeline.yml%E9%85%8D%E7%BD%AE%E5%88%B0Gitlab.png" alt=""></p>
</li>
<li><p>配置Jenkins的目标服务器，可以将yml文件传输到K8s的Master上</p>
<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AE%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt=""></p>
</li>
<li><p>修改Jenkinsfile，重新设置流水线任务脚本，并测试效果</p>
<p><img src="/images/DevOps/%E4%BC%A0%E9%80%92yml%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC.png" alt=""></p>
<p><img src="/images/DevOps/%E4%BC%A0%E9%80%92yml%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC2.png" alt=""></p>
</li>
<li><p>设置Jenkins无密码登录k8s-master</p>
<p>将Jenkins中公钥信息复制到k8s-master的~/.ssh/authorized_keysz中，保证远程连接无密码</p>
<p><img src="/images/DevOps/%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%A0%E9%9C%80%E5%AF%86%E7%A0%81.png" alt=""></p>
</li>
<li><p>设置执行kubectl的脚本到Jenkinsfile</p>
<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AEJenkinsfile.png" alt=""></p>
</li>
<li><p>执行查看效果</p>
<p><img src="/images/DevOps/%E6%89%A7%E8%A1%8C%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt=""></p>
<p>可以查看到yml文件是有变化的， 这样k8s就会重新加载</p>
<p>这种方式更适应与CD操作，将项目将基于某个版本部署到指定的目标服务器</p>
</li>
</ul>
<h2 id="10-6-基于GitLab的WebHooks"><a href="#10-6-基于GitLab的WebHooks" class="headerlink" title="10.6 基于GitLab的WebHooks"></a>10.6 基于GitLab的WebHooks</h2><p>这里要实现自动化的一个CI操作，也就是开发人员Push代码到Git仓库后，Jenkins会自动的构建项目，将最新的提交点代码构建并进行打包部署，这里区别去上述的CD操作，CD操作需要基于某个版本进行部署，而这里每次都是将最新的提交点集成到主干上并测试。</p>
<h3 id="10-6-1-WebHooks通知"><a href="#10-6-1-WebHooks通知" class="headerlink" title="10.6.1 WebHooks通知"></a>10.6.1 WebHooks通知</h3><p>开启Jenkins的自动构建</p>
<p><img src="/images/DevOps/%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt=""></p>
<p>设置Gitlab的Webhooks</p>
<p><img src="/images/DevOps/%E8%AE%BE%E7%BD%AEGitlab%E7%9A%84Webhooks.png" alt=""></p>
<p>需要关闭Jenkins的Gitlab认证</p>
<p><img src="/images/DevOps/%E5%85%B3%E9%97%ADJenkins%E7%9A%84Gitlab%E8%AE%A4%E8%AF%81.png" alt=""></p>
<p>再次测试Gitlab</p>
<p><img src="/images/DevOps/%E5%86%8D%E6%AC%A1%E6%B5%8B%E8%AF%95Gitlab.png" alt=""></p>
<h3 id="10-6-2-修改配置"><a href="#10-6-2-修改配置" class="headerlink" title="10.6.2 修改配置"></a>10.6.2 修改配置</h3><p>修改Jenkinsfile实现基于最新提交点实现持续集成效果，将之前引用${tag}的全部去掉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 所有的脚本命令都放在pipeline中</span><br><span class="line">pipeline&#123;</span><br><span class="line">	// 指定任务再哪个集群节点中执行</span><br><span class="line">	agent any</span><br><span class="line"></span><br><span class="line">	// 声明全局变量，方便后面使用</span><br><span class="line">	environment &#123;</span><br><span class="line">		harborUser = <span class="string">'admin'</span></span><br><span class="line">        harborPasswd = <span class="string">'Harbor12345'</span></span><br><span class="line">        harborAddress = <span class="string">'192.168.11.102:80'</span></span><br><span class="line">        harborRepo = <span class="string">'repo'</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'拉取git仓库代码'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                checkout([<span class="variable">$class</span>: <span class="string">'GitSCM'</span>, branches: [[name: <span class="string">'*/master'</span>]], extensions: [], userRemoteConfigs: [[url: <span class="string">'http://192.168.11.101:8929/root/mytest.git'</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'通过maven构建项目'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/maven/bin/mvn clean package -DskipTests'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'通过SonarQube做代码质量检测'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.source=./ -Dsonar.projectname=$&#123;JOB_NAME&#125; -Dsonar.projectKey=$&#123;JOB_NAME&#125; -Dsonar.java.binaries=./target/ -Dsonar.login=40306ae8ea69a4792df2ceb4d9d25fe8a6ab1701'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'通过Docker制作自定义镜像'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'mv ./target/*.jar ./docker/</span></span><br><span class="line"><span class="string">                docker build -t $&#123;JOB_NAME&#125;:latest ./docker/'</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'将自定义镜像推送到Harbor'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">''</span><span class="string">'docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;</span></span><br><span class="line"><span class="string">                docker tag $&#123;JOB_NAME&#125;:latest  $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest</span></span><br><span class="line"><span class="string">                docker push $&#123;harborAddress&#125;/$&#123;harborRepo&#125;/$&#123;JOB_NAME&#125;:latest '</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'将yml文件传到k8s-master上'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sshPublisher(publishers: [sshPublisherDesc(configName: <span class="string">'k8s'</span>, transfers: [sshTransfer(cleanRemote: <span class="literal">false</span>, excludes: <span class="string">''</span>, execCommand: <span class="string">''</span>, execTimeout: 120000, flatten: <span class="literal">false</span>, makeEmptyDirs: <span class="literal">false</span>, noDefaultExcludes: <span class="literal">false</span>, patternSeparator: <span class="string">'[, ]+'</span>, remoteDirectory: <span class="string">''</span>, remoteDirectorySDF: <span class="literal">false</span>, removePrefix: <span class="string">''</span>, sourceFiles: <span class="string">'pipeline.yml'</span>)], usePromotionTimestamp: <span class="literal">false</span>, useWorkspaceInPromotion: <span class="literal">false</span>, verbose: <span class="literal">false</span>)])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'远程执行k8s-master的kubectl命令'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">               sh <span class="string">''</span><span class="string">'ssh root@192.168.11.201 kubectl apply -f /usr/local/k8s/pipeline.yml</span></span><br><span class="line"><span class="string">                ssh root@192.168.11.201 kubectl rollout restart deployment pipeline -n test'</span><span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            dingtalk(</span><br><span class="line">                robot: <span class="string">'Jenkins-DingDing'</span>,</span><br><span class="line">                <span class="built_in">type</span>: <span class="string">'MARKDOWN'</span>,</span><br><span class="line">                title: <span class="string">"success: <span class="variable">$&#123;JOB_NAME&#125;</span>"</span>,</span><br><span class="line">                text: [<span class="string">"- 成功构建：<span class="variable">$&#123;JOB_NAME&#125;</span>! \n- 版本：latest \n- 持续时间：<span class="variable">$&#123;currentBuild.durationString&#125;</span>"</span> ]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            dingtalk(</span><br><span class="line">                robot: <span class="string">'Jenkins-DingDing'</span>,</span><br><span class="line">                <span class="built_in">type</span>: <span class="string">'MARKDOWN'</span>,</span><br><span class="line">                title: <span class="string">"success: <span class="variable">$&#123;JOB_NAME&#125;</span>"</span>,</span><br><span class="line">                text: [<span class="string">"- 构建失败：<span class="variable">$&#123;JOB_NAME&#125;</span>! \n- 版本：latest \n- 持续时间：<span class="variable">$&#123;currentBuild.durationString&#125;</span>"</span> ]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改pipeline.yml，更改镜像版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  name: pipeline</span><br><span class="line">  labels:</span><br><span class="line">    app: pipeline</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pipeline</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pipeline    </span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pipeline</span><br><span class="line">        image: 192.168.11.102:80/repo/pipeline:latest   <span class="comment"># 这里</span></span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line"><span class="comment"># 省略其他内容…………</span></span><br></pre></td></tr></table></figure>

<h3 id="10-6-3-滚动更新"><a href="#10-6-3-滚动更新" class="headerlink" title="10.6.3 滚动更新"></a>10.6.3 滚动更新</h3><p>因为pipeline没有改变时，每次不会重新加载，这样会导致Pod中的容器不会动态更新，这里需要使用kubectl的rollout restart命令滚动更新</p>
<p><img src="/images/DevOps/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B01.png" alt=""></p>
<p><img src="/images/DevOps/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B02.png" alt=""></p>
]]></content>
      <categories>
        <category>devops</category>
        <category>cicd</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
        <tag>gitlab</tag>
        <tag>jenkins</tag>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j-与springboot整合</title>
    <url>/2022/11/19/neo4j%E4%B8%8Espringboot%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>基于spring-data-neo4j-6.2.9，neo4j-java-driver.version-4.4.9-不同版本存在差异</p>
<h3 id="Spring-Data-Neo4j注解"><a href="#Spring-Data-Neo4j注解" class="headerlink" title="Spring Data Neo4j注解"></a>Spring Data Neo4j注解</h3><ul>
<li><p><code>@Node</code>：将指定标签的对象和neo4j对应标签节点之间建立映射，具有一个属性labels，允许配置一个或多个标签</p>
</li>
<li><p><code>@Id</code>：将类的属性标记为对象的唯一标识符。</p>
</li>
<li><p><code>@GeneratedValue</code>：在字段级别应用，<code>@Id</code>以指定应如何生成唯一标识符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认InternalIdGenerator，什么都不做，交由数据库自己生成id</span></span><br><span class="line">GeneratedValue.InternalIdGenerator<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">//生成<span class="title">UUID</span></span></span><br><span class="line"><span class="class"><span class="title">GeneratedValue</span>.<span class="title">UUIDGenerator</span>.<span class="title">class</span>    </span></span><br><span class="line"><span class="class">//自定义，实现<span class="title">IdGenerator</span>&lt;<span class="title">String</span>&gt;接口，覆写<span class="title">generateId</span>方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Property</code>：应用于字段级别，作为 Neo4j 节点和关系的属性保留，需要使用<code>@Property</code>. <code>name</code>用于指定数据库中属性的名称。</p>
<a id="more"></a>
</li>
<li><p><code>@CompositeProperty</code>：在字段级别应用于应作为复合读回的 Map 类型的属性。请参阅<a href="https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#custom.conversions.composite-properties" target="_blank" rel="noopener">复合属性</a>。</p>
</li>
<li><p><code>@Relationship</code>：应用于字段级别，用以指定关系的详细信息。</p>
<ul>
<li>type：关系名称</li>
<li>Direction：关系方向<ul>
<li>Relationship.Direction.INCOMING：<code>关系的目标对象</code>是<code>开始节点</code>，<code>当前类对象</code>是<code>结束节点</code>，<code>关系的目标对象</code> –&gt; <code>当前类对象</code></li>
<li>Relationship.Direction.OUTGOING：关系的目标对象是结束节点，<code>当前类对象</code>是<code>开始节点</code>，<code>关系的目标对象</code> &lt;–  <code>当前类对象</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>@DynamicLabels</code>：应用于字段级别以指定动态标签的来源。</p>
</li>
<li><p><code>@RelationshipProperties</code>：应用于类级别，标识该类是关系类，搭配<code>@Relationship</code>、<code>@TargetNode</code>使用。</p>
</li>
<li><p><code>@TargetNode</code>: 应用在<code>@RelationshipProperties</code>注解类上的某个字段，从另一端的角度来标记该关系的目标。</p>
</li>
</ul>
<h3 id="Spring-Data-commons注解"><a href="#Spring-Data-commons注解" class="headerlink" title="Spring Data commons注解"></a>Spring Data commons注解</h3><ul>
<li><code>@org.springframework.data.annotation.Id</code>和SDN一样<code>@Id</code>，其实<code>@Id</code>是用Spring Data Common的Id-annotation来注解的。</li>
<li><code>@CreatedBy</code>：应用于字段级别，表示节点的创建者。</li>
<li><code>@CreatedDate</code>：应用于字段级别，表示节点的创建日期。</li>
<li><code>@LastModifiedBy</code>：应用于字段级别以指示对节点的最后更改的作者。</li>
<li><code>@LastModifiedDate</code>：应用于字段级别，表示节点的最后修改日期。</li>
<li><code>@PersistenceCreator</code>：应用于一个构造函数以在读取实体时将其标记为首选构造函数。</li>
<li><code>@Persistent</code>：应用于类级别以指示此类是映射到数据库的候选者。</li>
<li><code>@Version</code>：应用于字段级别，用于乐观锁定并检查保存操作的修改。初始值为零，每次更新时都会自动增加。</li>
<li><code>@ReadOnlyProperty</code>：应用于字段级别以将属性标记为只读。该属性将在数据库读取期间被水化，但不受写入的影响。当用于关系时，请注意，如果不相关，则该集合中的任何相关实体都不会被持久化。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">neo4j:</span></span><br><span class="line">    <span class="attr">authentication:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">neo4j</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">bolt://localhost:7687</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.13&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.yrl&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;test-neo4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;test-neo4j&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;test-neo4j&lt;&#x2F;description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;excludes&gt;</span><br><span class="line">                        &lt;exclude&gt;</span><br><span class="line">                            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">                            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">                        &lt;&#x2F;exclude&gt;</span><br><span class="line">                    &lt;&#x2F;excludes&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改neo4j版本</p>
<p><properties>  &lt;neo4j-java-driver.version&gt;4.4.2&lt;/neo4j-java-driver.version&gt; </properties></p>
</blockquote>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><h3 id="节点类"><a href="#节点类" class="headerlink" title="节点类"></a>节点类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.neo4j.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Node</span>(<span class="string">"Movie"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识主键属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键生成策略，默认使用InternalIdGenerator，不生成主键值，交由数据库自己维护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点属性，同名无需加 <span class="doctag">@Property</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Property</span>(<span class="string">"tagline"</span>)</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过关系类维护节点之间的关系，可以为关系增加属性</span></span><br><span class="line"><span class="comment">     * Relationship.Direction.INCOMING：关系的目标对象 是 开始节点，当前类对象 是 结束节点，关系的目标对象 -ACTED_IN-&gt; 当前类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Relationship</span>(type = <span class="string">"ACTED_IN"</span>, direction = Relationship.Direction.INCOMING)</span><br><span class="line">    <span class="keyword">private</span> List&lt;RolesRelationship&gt; actorsAndRoles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点与节点之间直接通过<span class="doctag">@Relationship</span>注解建立关系</span></span><br><span class="line"><span class="comment">     * Relationship.Direction.INCOMING：属性对象 是 开始节点，当前类对象 是 结束节点，属性对象 -DIRECTED-&gt; 当前类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Relationship</span>(type = <span class="string">"DIRECTED"</span>, direction = Relationship.Direction.INCOMING)</span><br><span class="line">    <span class="keyword">private</span> List&lt;PersonEntity&gt; directors;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.neo4j.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Node</span>(<span class="string">"Person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识主键属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键生成策略，默认使用InternalIdGenerator，不生成主键值，交由数据库自己维护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点属性，同名无需加 <span class="doctag">@Property</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点属性，同名无需加 <span class="doctag">@Property</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer born;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关系类"><a href="#关系类" class="headerlink" title="关系类"></a>关系类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.neo4j.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.RelationshipId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.RelationshipProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.schema.TargetNode;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@RelationshipProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RolesRelationship</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RelationshipId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关系的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前关系的目标节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TargetNode</span></span><br><span class="line">    <span class="keyword">private</span> PersonEntity person;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.neo4j.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yrl.neo4j.entity.MovieEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.Neo4jRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieEntityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">MovieEntity</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名查询：根据title查询movie</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;MovieEntity&gt; <span class="title">findMovieEntityByTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.neo4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yrl.neo4j.entity.MovieEntity;</span><br><span class="line"><span class="keyword">import</span> com.yrl.neo4j.entity.PersonEntity;</span><br><span class="line"><span class="keyword">import</span> com.yrl.neo4j.entity.RolesRelationship;</span><br><span class="line"><span class="keyword">import</span> com.yrl.neo4j.repository.MovieEntityRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.core.Neo4jTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNeo4jApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieEntityRepository movieEntityRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Neo4jTemplate neo4jTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演员1</span></span><br><span class="line">        List&lt;RolesRelationship&gt; actorsAndRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; roleNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        roleNameList.add(<span class="string">"角色名称1-1"</span>);</span><br><span class="line">        roleNameList.add(<span class="string">"角色名称1-2"</span>);</span><br><span class="line">        actorsAndRoles.add(</span><br><span class="line">                RolesRelationship.builder()</span><br><span class="line">                        .roles(roleNameList)</span><br><span class="line">                        .person(PersonEntity.builder().name(<span class="string">"演员名称1"</span>).build())</span><br><span class="line">                        .build());</span><br><span class="line">        <span class="comment">//演员2</span></span><br><span class="line">        List&lt;String&gt; roleNameList2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        roleNameList2.add(<span class="string">"角色名称2-1"</span>);</span><br><span class="line">        roleNameList2.add(<span class="string">"角色名称2-2"</span>);</span><br><span class="line">        actorsAndRoles.add(</span><br><span class="line">                RolesRelationship.builder()</span><br><span class="line">                        .roles(roleNameList2)</span><br><span class="line">                        .person(PersonEntity.builder().name(<span class="string">"演员名称2"</span>).build())</span><br><span class="line">                        .build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//导演</span></span><br><span class="line">        List&lt;PersonEntity&gt; directors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        directors.add(PersonEntity.builder().name(<span class="string">"导演"</span>).build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//电影</span></span><br><span class="line">        MovieEntity build = MovieEntity.builder()</span><br><span class="line">                .title(<span class="string">"电影"</span>)</span><br><span class="line">                .description(<span class="string">"描述"</span>)</span><br><span class="line">                .actorsAndRoles(actorsAndRoles)</span><br><span class="line">                .directors(directors)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MovieEntity save = movieEntityRepository.save(build);</span><br><span class="line"><span class="comment">//        MovieEntity save = neo4jTemplate.save(build);</span></span><br><span class="line">        System.out.println(save);</span><br><span class="line">        <span class="comment">//MovieEntity(id=23, title=电影, description=描述, actorsAndRoles=[RolesRelationship(id=29, roles=[角色名称1-1, 角色名称1-2], person=PersonEntity(id=40, name=演员名称1, born=null)), RolesRelationship(id=30, roles=[角色名称2-1, 角色名称2-2], person=PersonEntity(id=24, name=演员名称2, born=null))], directors=[PersonEntity(id=52, name=导演, born=null)])</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MovieEntity movie = MovieEntity.builder().description(<span class="string">"描述"</span>).build();</span><br><span class="line"><span class="comment">//        List&lt;MovieEntity&gt; movieEntityList = movieEntityRepository.findAll(Example.of(movie));</span></span><br><span class="line"><span class="comment">//        List&lt;MovieEntity&gt; movieEntityList = movieEntityRepository.findAll();</span></span><br><span class="line">        List&lt;MovieEntity&gt; movieEntityList = neo4jTemplate.findAll(MovieEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(movieEntityList);</span><br><span class="line">        <span class="comment">//[MovieEntity(id=23, title=电影, description=描述, actorsAndRoles=[RolesRelationship(id=30, roles=[角色名称2-1, 角色名称2-2], person=PersonEntity(id=24, name=演员名称2, born=null)), RolesRelationship(id=29, roles=[角色名称1-1, 角色名称1-2], person=PersonEntity(id=40, name=演员名称1, born=null))], directors=[PersonEntity(id=52, name=导演, born=null)])]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        List&lt;MovieEntity&gt; movieEntityList = movieEntityRepository.findMovieEntityByTitle("电影");</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        parameters.put(<span class="string">"param"</span>, <span class="string">"电影"</span>);</span><br><span class="line">        String cypherQuery = <span class="string">"match(m:Movie)-[r]-(p) where m.title = $param return m,r,p"</span>;</span><br><span class="line">        List&lt;MovieEntity&gt; movieEntityList = neo4jTemplate.findAll(cypherQuery, parameters, MovieEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(movieEntityList);</span><br><span class="line">        <span class="comment">//[MovieEntity(id=23, title=电影, description=描述, actorsAndRoles=[RolesRelationship(id=30, roles=[角色名称2-1, 角色名称2-2], person=PersonEntity(id=24, name=演员名称2, born=null)), RolesRelationship(id=29, roles=[角色名称1-1, 角色名称1-2], person=PersonEntity(id=40, name=演员名称1, born=null))], directors=[PersonEntity(id=52, name=导演, born=null)])]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E4%B8%8Espringboot%E6%95%B4%E5%90%88/image-20221119154645975.png" alt=""></p>
<p><img src="/images/neo4j%E4%B8%8Espringboot%E6%95%B4%E5%90%88/image-20221119154800556.png" alt=""></p>
<p><img src="/images/neo4j%E4%B8%8Espringboot%E6%95%B4%E5%90%88/image-20221119161916198.png" alt=""></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>neo4j</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>nosql</tag>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j-安装学习</title>
    <url>/2022/11/19/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://neo4j.com/download-center/#community" target="_blank" rel="noopener">安装</a></h1><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><ol>
<li><p>如果尚未安装，则使用OpenJDK 8或Oracle Java 8，推荐用于Neo4j 3.0.x Version 7推荐用于2.3.0之前的版本。</p>
</li>
<li><p>找到您刚刚下载的zip文件并右键单击，解压缩所有文件。</p>
</li>
<li><p>将解压缩的文件放在服务器上的永久主目录中，例如<code>D:\neo4j\</code>。顶级目录称为<code>NEO4J_HOME</code>。</p>
<ul>
<li><p>要将Neo4j作为控制台应用程序运行，请使用：<code>&lt;NEO4J_HOME&gt;\bin\neo4j console</code></p>
</li>
<li><p>要将Neo4j作为服务使用安装：<code>&lt;NEO4J_HOME&gt;\bin\neo4j install-service</code>.</p>
</li>
<li><p>有关其他命令和了解Zip文件中包含的Windows PowerShell模块，<a href="https://neo4j.com/docs/operations-manual/current/installation/windows/" target="_blank" rel="noopener">请参阅Windows安装文档。</a></p>
</li>
</ul>
</li>
</ol>
<img src="/images/neo4j安装学习/image-20221117170822985.png" style="zoom:67%;" />

<img src="/images/neo4j安装学习/image-20221117171029841.png" style="zoom:67%;" />

<a id="more"></a>

<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol>
<li><p>拉取镜像</p>
<p><code>docker pull neo4j:3.5.22-community</code></p>
</li>
<li><p>运行镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 7474:7474 -p 7687:7687 --name neo4j \</span><br><span class="line">-e <span class="string">"NEO4J_AUTH=neo4j/123456"</span> \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/soft/neo4j/data:/data \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/soft/neo4j/logs:/logs \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/soft/neo4j/conf:/var/lib/neo4j/conf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/soft/neo4j/import:/var/lib/neo4j/import \</span><br><span class="line">neo4j:3.5.22-community</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ol>
<li><code>tar -xf neo4j-community-3.5.35-unix.tar.gz</code></li>
<li>将解压缩的文件放在服务器上的永久主目录中。顶级目录称为<code>NEO4J_HOME</code>。<ul>
<li>要将Neo4j作为控制台应用程序运行，使用：<code>&lt;NEO4J_HOME&gt;/bin/neo4j console</code></li>
<li>要在后台进程中运行Neo4j，使用：<code>&lt;NEO4J_HOME&gt;/bin/neo4j start</code></li>
<li>有关其他命令，<a href="https://neo4j.com/docs/operations-manual/current/installation/linux/tarball/" target="_blank" rel="noopener">请参阅Unix tarball安装文档</a>。</li>
</ul>
</li>
</ol>
<h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><ol>
<li><p>在浏览器中访问：<a href="http://localhost:7474。">http://localhost:7474。</a></p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117174754450.png" alt=""></p>
</li>
<li><p>使用用户名’neo4j’和默认密码’neo4j’进行连接。然后系统会提示更改密码。</p>
</li>
</ol>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117175006410.png" alt=""></p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117175056445.png" alt=""></p>
<ul>
<li>Neo4j浏览器是开发人员探索Neo4j数据库、执行Cypher查询并以表格或图表形式查看结果的工具。你甚至可以使用浏览器来:<ul>
<li>导入数据</li>
<li>在Java中调用用户定义过程</li>
<li>配置文件查询，使用EXPLAIN和Profile查看执行计划。</li>
</ul>
</li>
</ul>
<h1 id="CQL语句"><a href="#CQL语句" class="headerlink" title="CQL语句"></a>CQL语句</h1><h2 id="CQL简介"><a href="#CQL简介" class="headerlink" title="CQL简介"></a>CQL简介</h2><p>  Neo4j的Cypher语言是为处理图形数据而构建的，CQL代表Cypher查询语言。像Oracle数据库具有查询 语言SQL，Neo4j具有CQL作为查询语言。</p>
<ul>
<li>它是Neo4j图形数据库的查询语言。</li>
<li>它是一种声明性模式匹配语言</li>
<li>它遵循SQL语法。</li>
<li>它的语法是非常简单且人性化、可读的格式。</li>
</ul>
<table>
<thead>
<tr>
<th>CQL命令</th>
<th>用户</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>创建节点、关系和属性</td>
</tr>
<tr>
<td>MATCH</td>
<td>检索有关节点、关系和属性</td>
</tr>
<tr>
<td>RETURN</td>
<td>返回查询结构</td>
</tr>
<tr>
<td>WHERE</td>
<td>提供条件过滤检索数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除节点和关系</td>
</tr>
<tr>
<td>REMOVE</td>
<td>删除节点和关系的属性</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>排序检索数据</td>
</tr>
<tr>
<td>SET</td>
<td>添加或更新标签</td>
</tr>
</tbody></table>
<h2 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h2><ul>
<li><p>创建节点</p>
<ul>
<li><p>创建没有属性的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用属性创建节点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (&lt;node-<span class="keyword">name</span>&gt;:&lt;label-<span class="keyword">name</span>&gt;&#123;&lt;propertyKey1&gt;:&lt;propertValue1&gt;,&lt;propertyKey2&gt;:&lt;propertValue2&gt;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建关系</p>
<ul>
<li><p>在没有属性的节点之间创建关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (node1-name:lable1) - [relationship-name:relationship-lable] -&gt; (node2-name:lable2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建node1、node2，同时创建node1指向node2的关系</p>
</blockquote>
</li>
<li><p>使用属性创建节点之间的关系</p>
</li>
</ul>
</li>
<li><p>创建标签</p>
<ul>
<li><p>为节点或关系创建单个或多个标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE(node-name:lable-name1:lable-name2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name&gt;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;node-name&gt;</code>：创建的节点名称</p>
<p><code>&lt;label-name&gt;</code>：创建的节点标签名称</p>
<p>不能使用<code>&lt;node-name&gt;</code>来访问节点详细信息，应该使用此标签名称来访问节点详细信息，应该使用<code>&lt;label-name&gt;</code>来访问节点详细信息。</p>
</blockquote>
<h3 id="创建无属性节点"><a href="#创建无属性节点" class="headerlink" title="创建无属性节点"></a>创建无属性节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(emp:Employee)</span><br><span class="line">create(dept:Department)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117212942547.png" alt="执行前"></p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117213802555.png" alt="执行后"></p>
<h3 id="创建带属性节点"><a href="#创建带属性节点" class="headerlink" title="创建带属性节点"></a>创建带属性节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(c:coustomer&#123;id:&quot;1&quot;,name:&quot;zhangsan&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117215225986.png" alt=""></p>
<h3 id="创建多标签节点"><a href="#创建多标签节点" class="headerlink" title="创建多标签节点"></a>创建多标签节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(n1:l1:l2:l3)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n1 节点名称</p>
<p>l1、l2、l3都是标签</p>
</blockquote>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117220603617.png" alt=""></p>
<h3 id="创建有关系节点"><a href="#创建有关系节点" class="headerlink" title="创建有关系节点"></a>创建有关系节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(z:zhangsan) - [l:love] -&gt; (w:wangwu)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117221746753.png" alt=""></p>
<h2 id="MATCH"><a href="#MATCH" class="headerlink" title="MATCH"></a>MATCH</h2><ul>
<li>从数据库获取有关节点和属性的数据</li>
<li>从数据库获取有关节点，关系和属性的数据</li>
</ul>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (&lt;node-name&gt;:&lt;label-name&gt;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MATCH无法单独使用需要配合RETURN命令一起使用</p>
</blockquote>
<h2 id="RETURN"><a href="#RETURN" class="headerlink" title="RETURN"></a>RETURN</h2><ul>
<li>检索节点的某些属性</li>
<li>检索节点的所有属性</li>
<li>检索节点和关联关系的某些属性</li>
<li>检索节点和关联关系的所有属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RETURN </span><br><span class="line">   &lt;node-name&gt;.&lt;property1-name&gt;,</span><br><span class="line">   ........</span><br><span class="line">   &lt;node-name&gt;.&lt;propertyn-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;node-name&gt;</code> 节点名称</p>
<p><code>&lt;propertyn-name&gt;</code> 属性是键值对形式，这里的<code>&lt;propertyn-name&gt;</code>指的是属性的key</p>
</blockquote>
<h2 id="MATCH和RETURN"><a href="#MATCH和RETURN" class="headerlink" title="MATCH和RETURN"></a>MATCH和RETURN</h2><p>CQL语句中MATCH 需要搭配RETURN命令 一起使用</p>
<ul>
<li>检索节点的某些属性</li>
<li>检索节点的所有属性</li>
<li>检索节点和关联关系的某些属性</li>
<li>检索节点和关联关系的所有属性</li>
</ul>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH Command</span><br><span class="line">RETURN Command</span><br></pre></td></tr></table></figure>

<h3 id="获取所有节点"><a href="#获取所有节点" class="headerlink" title="获取所有节点"></a>获取所有节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (n1) RETURN n1 LIMIT 25</span><br></pre></td></tr></table></figure>

<img src="/images/neo4j/image-20221118100030368.png" style="zoom:80%;" />

<h3 id="获取含关系节点"><a href="#获取含关系节点" class="headerlink" title="获取含关系节点"></a>获取含关系节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (n1)-[r]-&gt;(n2) RETURN r, n1, n2 LIMIT 25</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118095937407.png" alt=""></p>
<h3 id="基于标签检索节点"><a href="#基于标签检索节点" class="headerlink" title="基于标签检索节点"></a>基于标签检索节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (n:Employee) RETURN n LIMIT 25</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117214625204.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(n:coustomer) return n.name</span><br><span class="line">match(n:coustomer) return n.name,n.id</span><br><span class="line">MATCH (n:coustomer) RETURN n LIMIT 25</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117215448728.png" alt=""></p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117220020780.png" alt=""></p>
<h3 id="基于关系检索节点"><a href="#基于关系检索节点" class="headerlink" title="基于关系检索节点"></a>基于关系检索节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match (p:Person) - [r:&#96;刷卡&#96;] -&gt; (c:Card) return p,r,c</span><br><span class="line">MATCH p&#x3D;()-[r:&#96;刷卡&#96;]-&gt;() RETURN p,r LIMIT 25</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118093502191.png" alt=""></p>
<h2 id="MATCH和WHERE"><a href="#MATCH和WHERE" class="headerlink" title="MATCH和WHERE"></a>MATCH和WHERE</h2><p>像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。</p>
<p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHERE &lt;condition&gt;</span><br><span class="line">WHERE &lt;condition&gt; &lt;boolean-operator&gt; &lt;condition&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作符：AND、OR、NOT、XOR、=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;= 、in</p>
</blockquote>
<h3 id="单标签查询"><a href="#单标签查询" class="headerlink" title="单标签查询"></a>单标签查询</h3><p>创建三个标签为person的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(a:Person&#123;name:&quot;zhangsan&quot;,age:18&#125;),(b:Person&#123;name:&quot;lisi&quot;,age:20&#125;),(c:Person&#123;name:&quot;wangwu&quot;,age:25&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117223825852.png" alt=""></p>
<p>年龄大于19的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(p:Person) where p.age &gt; 19 return p</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117223712390.png" alt=""></p>
<h3 id="多标签查询"><a href="#多标签查询" class="headerlink" title="多标签查询"></a>多标签查询</h3><p>创建三个标签为card的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(d1:Card&#123;num:123,money:100.11&#125;),(d2:Card&#123;num:124,money:200.22&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117224425086.png" alt=""></p>
<p>多个节点关联查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(c:Card),(p:Person) where c.num &#x3D; 123 and p.age &#x3D; 20 return c,p</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意大小写、值类型</p>
</blockquote>
<img src="/images/neo4j/image-20221117224937030.png" style="zoom:80%;" />

<h3 id="创建关系"><a href="#创建关系" class="headerlink" title="创建关系"></a>创建关系</h3><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;) </span><br><span class="line">WHERE &lt;condition&gt;</span><br><span class="line">CREATE (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;</span><br><span class="line">       &#123;&lt;relationship-properties&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)</span><br></pre></td></tr></table></figure>

<p>通过where查出两个节点并为他们创建关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(c:Card),(p:Person) where c.num &#x3D; 123 and p.age &#x3D; 20 create(p) - [x:刷卡] -&gt; (c)</span><br></pre></td></tr></table></figure>

<ul>
<li>建立关系前</li>
</ul>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117225955885.png" alt=""></p>
<ul>
<li>建立关系</li>
</ul>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221117230021860.png" alt=""></p>
<h2 id="MATCH和DELETE"><a href="#MATCH和DELETE" class="headerlink" title="MATCH和DELETE"></a>MATCH和DELETE</h2><ul>
<li><p>删除节点。</p>
<blockquote>
<p>存在关系的节点无法直接删除，需要先删除关系</p>
</blockquote>
</li>
<li><p>删除节点及相关节点和关系。</p>
</li>
</ul>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &lt;node-name-list&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用逗号（，）运算符来分隔节点名</p>
</blockquote>
<h3 id="根据标签删除节点"><a href="#根据标签删除节点" class="headerlink" title="根据标签删除节点"></a>根据标签删除节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(n:Department) delete n</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该标签下所有节点都会被删除</p>
<p>含有关系的节点无法直接删除</p>
</blockquote>
<h3 id="删除关系"><a href="#删除关系" class="headerlink" title="删除关系"></a>删除关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match p&#x3D;()-[r:love]-&gt;() delete r</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118101137943.png" alt=""></p>
<h3 id="根据删除节点和关系"><a href="#根据删除节点和关系" class="headerlink" title="根据删除节点和关系"></a>根据删除节点和关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重新为两节点建立关系</span><br><span class="line">match(z:zhangsan),(w:wangwu) create (z)-[l:love]-&gt;(w)</span><br><span class="line">&#x2F;&#x2F;同时删除两节点和关系</span><br><span class="line">match (z:zhangsan)-[l:love]-&gt;(w:wangwu) delete z,l,w</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建节点和关系</span><br><span class="line">create (z:zhangsan)-[l:love]-&gt;(w:wangwu)</span><br><span class="line">&#x2F;&#x2F;删除z节点和关系，保留w节点</span><br><span class="line">match (z:zhangsan)-[l:love]-&gt;(w:wangwu) delete z,l</span><br></pre></td></tr></table></figure>

<h3 id="限定标签条件删除"><a href="#限定标签条件删除" class="headerlink" title="限定标签条件删除"></a>限定标签条件删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match (n:Person) where n.age &#x3D; 18 delete n</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除符合条件的标签节点</p>
</blockquote>
<h2 id="MATCH和REMOVE"><a href="#MATCH和REMOVE" class="headerlink" title="MATCH和REMOVE"></a>MATCH和REMOVE</h2><ul>
<li>删除节点或关系的标签</li>
<li>删除节点或关系的属性</li>
</ul>
<h3 id="移除属性"><a href="#移除属性" class="headerlink" title="移除属性"></a>移除属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建节点</span><br><span class="line">create(b:book&#123;title:&quot;java&quot;,price:123&#125;)</span><br><span class="line">&#x2F;&#x2F;移除属性</span><br><span class="line">match(b:book) remove b.price return b</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118105522886.png" alt=""></p>
<h3 id="移除标签"><a href="#移除标签" class="headerlink" title="移除标签"></a>移除标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(a:A1) remove a:A2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意标签操作使用冒号</p>
</blockquote>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118122807669.png" alt=""></p>
<h2 id="MATCH和SET"><a href="#MATCH和SET" class="headerlink" title="MATCH和SET"></a>MATCH和SET</h2><ul>
<li>向现有节点或关系添加新属性</li>
<li>添加或更新属性值</li>
</ul>
<h3 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(a:A1) set a:A3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>标签操作使用冒号</p>
</blockquote>
<h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match (a:A1) SET a.title &#x3D; &#39;属性值&#39;</span><br><span class="line">match(a:A1) set a.title &#x3D; &#39;属性值2&#39; return a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>标签操作使用.</p>
<p>不存在则新增，存在则修改</p>
</blockquote>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><p>Neo4j CQL在MATCH命令中提供了“ORDER BY”子句，对MATCH查询返回的结果进行排序。</p>
<p>我们可以按升序或降序对行进行排序。</p>
<p>默认情况下，它按升序对行进行排序。 如果我们要按降序对它们进行排序，我们需要使用DESC子句。</p>
<p>创建数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(e:Employee&#123;id:1001,name:&quot;zhangsan&quot;,age:18&#125;),(e2:Employee&#123;id:1002,name:&quot;lisi&quot;,age:15&#125;),(e3:Employee&#123;id:1003,name:&quot;wangwu&quot;,age:30&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认升序</span><br><span class="line">match(e:Employee) return e.id,e.name,e.age</span><br><span class="line">match(e:Employee) return e.id,e.name,e.age order by e.id desc</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118151640234.png" alt=""></p>
<h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>与SQL一样，Neo4j CQL有两个子句，将两个不同的结果合并成一组结果</p>
<ul>
<li>UNION：去重</li>
<li>UNION ALL：不去重</li>
</ul>
<p>创建User标签、Employee标签数据</p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118153831453.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;union all</span><br><span class="line">match(u:User)return u.id as id,u.name as name,u.age as age union all match(e:Employee) return e.id as id,e.name as name,e.age as age order by e.id desc</span><br><span class="line">&#x2F;&#x2F;union</span><br><span class="line">match(u:User)return u.id as id,u.name as name,u.age as age union match(e:Employee) return e.id as id,e.name as name,e.age as age order by e.id desc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意添加别名，保持字段名一致，否则执行报错</p>
</blockquote>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118154315712.png" alt=""></p>
<h2 id="LIMIT和SKIP子句"><a href="#LIMIT和SKIP子句" class="headerlink" title="LIMIT和SKIP子句"></a>LIMIT和SKIP子句</h2><p>通过limit限制输出获取数据</p>
<p>通skip跳过某些数据</p>
<p>两者结合可以实现翻页效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match (u:User) return u skip 1</span><br><span class="line">match(u:User) return u limit 1</span><br><span class="line">&#x2F;&#x2F;skip和limit结合使用达到翻页效果</span><br><span class="line">match(u:User) return u skip 1 limit 1</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118160342387.png" alt=""></p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>Neo4j使用CQL MERGE命令 -</p>
<ul>
<li>创建节点，关系和属性</li>
<li>为从数据库检索数据</li>
</ul>
<p>MERGE命令是CREATE命令和MATCH命令的组合。</p>
<p>使用CREATE命令创建节点，不管存不存在一样的节点都会创建，MERGE命令如果不存在一样的节点就新建，存在则不处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(t:Test1&#123;name:&quot;测试名称&quot;,age:12&#125;)</span><br><span class="line">merge(t:Test2&#123;name:&quot;测试名称2&quot;,age:18&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118161956431.png" alt=""></p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118162005412.png" alt=""></p>
<h2 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h2><p>当我们创建一个具有现有节点标签名称但未指定其属性值的节点时，它将创建一个具有NULL属性值的新节点。</p>
<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118163154155.png" alt=""></p>
<h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(n:User) where n.age in[25,40] return n</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118164316931.png" alt=""></p>
<h2 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h2><h3 id="查询所有标签"><a href="#查询所有标签" class="headerlink" title="查询所有标签"></a>查询所有标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL db.labels()</span><br></pre></td></tr></table></figure>

<h3 id="查询所有关系"><a href="#查询所有关系" class="headerlink" title="查询所有关系"></a>查询所有关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL db.relationshipTypes()</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>upper</td>
<td>转大写</td>
</tr>
<tr>
<td>lower</td>
<td>转小写</td>
</tr>
<tr>
<td>substring</td>
<td>截取字符串</td>
</tr>
<tr>
<td>replace</td>
<td>替换字符串</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match(n:Person) return n.name as name,lower(n.name) as lower,upper(n.name) as upper,substring(n.name,1,3) as substring,replace(n.name,&#39;wang&#39;,&#39;王&#39;) as replace</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118170303862.png" alt=""></p>
<h2 id="AGGEGATION聚合"><a href="#AGGEGATION聚合" class="headerlink" title="AGGEGATION聚合"></a>AGGEGATION聚合</h2><p>和SQL一样，Neo4j CQL提供了一些在RETURN子句中使用的聚合函数。 它类似于SQL中的GROUP BY子句。</p>
<p>我们可以使用MATCH命令中的RETURN +聚合函数来处理一组节点并返回一些聚合值。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>统计返回的行数</td>
</tr>
<tr>
<td>max</td>
<td>获取返回的最大值</td>
</tr>
<tr>
<td>min</td>
<td>获取返货的最小值</td>
</tr>
<tr>
<td>sum</td>
<td>所有返回数据累加求和</td>
</tr>
<tr>
<td>avg</td>
<td>所有返回数据求平均值</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数后面的p.name，相当于sql里面的group by p.name</span><br><span class="line">match(p:Person) return count(p.name),p.name</span><br><span class="line">match(p:Person) return count(p.name),max(p.age),min(p.age),avg(p.age),sum(p.age)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118171421675.png" alt=""></p>
<h2 id="关系函数"><a href="#关系函数" class="headerlink" title="关系函数"></a>关系函数</h2><p>Neo4j CQL提供了一组关系函数，以在获取开始节点，结束节点等细节时知道关系的细节。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>startnode</td>
<td>用于查找关系的开始节点</td>
</tr>
<tr>
<td>endnode</td>
<td>用于查找关系的结束节点</td>
</tr>
<tr>
<td>id</td>
<td>用于查找关系的id</td>
</tr>
<tr>
<td>type</td>
<td>用于查找关系的类型，即关系的名称</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match n&#x3D;()-[r:&#96;刷卡&#96;]-() return startnode(r),endnode(r),id(r),type(r)</span><br><span class="line">match (p:Person)-[r:&#96;刷卡&#96;]-(c:Card) return startnode(r),endnode(r),id(r),type(r)</span><br></pre></td></tr></table></figure>

<p><img src="/images/neo4j%E5%AE%89%E8%A3%85%E5%AD%A6%E4%B9%A0/image-20221118172911214.png" alt=""></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>neo4j</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程-WebFlux</title>
    <url>/2022/11/29/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-WebFlux/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Spring提供了两个并行的技术栈。</p>
<ul>
<li><p><strong>Servlet Stack</strong>：<code>Spring MVC</code>是建立在Servlet API之上，使用同步阻塞IO架构，实现一个请求一个线程处理的模型。</p>
</li>
<li><p><strong>Reactive Stack</strong>，<code>Spring WebFlux</code>是一个从头构建的非阻塞web框架，利用了多核，下一代处理器的优势，可以处理大量的并发连接。</p>
<img src="/images/响应式编程-WebFlux/image-20221129103957291.png" style="zoom:80%;" />

</li>
</ul>
<a id="more"></a>

<h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><p>在Spring MVC（一般的servlet程序），使用一个大的线程池应对请求处理期间潜在的阻塞。</p>
<p>在Spring WebFlux（一般的非阻塞程序），使用较小的固定线程池（事件循环组）来处理请求。</p>
<h1 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h1><p>Spring 框架的整个基础设施都是围绕Servlet API 构建的，它们之间紧密耦合。</p>
<p>响应式Web内核首先需要使用模拟接口和对请求进行处理的方法替换javax.servlet.Servlet.service 方法，更改相关的类和接口。</p>
<p>增强和定制 Servlet API 对客户端请求和服务器响应的交互方式</p>
<ul>
<li><p>ServerHttpRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.http.server.reactive;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 请求的封装。</span></span><br><span class="line"><span class="comment">* 获取请求报文体的类型是Flux，表示具备响应式能力。</span></span><br><span class="line"><span class="comment">* DataBuffer是针对字节缓冲区的抽象，便于对特定服务器实现数据交换。</span></span><br><span class="line"><span class="comment">* 除了请求报文体，还有消息头、请求路径、cookie、查询参数等信息，可以在该接口或子接口中提</span></span><br><span class="line"><span class="comment">供。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerHttpRequest</span> <span class="keyword">extends</span> <span class="title">HttpRequest</span>, <span class="title">ReactiveHttpInputMessage</span>  </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.http;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReactiveHttpInputMessage</span> <span class="keyword">extends</span> <span class="title">HttpMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the body of the message as a &#123;<span class="doctag">@link</span> Publisher&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the body content publisher</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function">Flux&lt;DataBuffer&gt; <span class="title">getBody</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServerHttpResponse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.http.server.reactive;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应的封装。</span></span><br><span class="line"><span class="comment"> * writeWith方法接收的参数是Publisher，提供了响应式，并与特定响应式库解耦。</span></span><br><span class="line"><span class="comment"> * 返回值是Mono&lt;Void&gt;，表示向网络发送数据是一个异步的过程。</span></span><br><span class="line"><span class="comment"> * 即，只有当订阅Mono时才会执行发送数据的过程。</span></span><br><span class="line"><span class="comment"> * 接收服务器可以根据传输协议的流控支持背压。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerHttpResponse</span> <span class="keyword">extends</span> <span class="title">ReactiveHttpOutputMessage</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.http;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReactiveHttpOutputMessage</span> <span class="keyword">extends</span> <span class="title">HttpMessage</span> </span>&#123;</span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Use the given &#123;<span class="doctag">@link</span> Publisher&#125; to write the body of the message to the</span></span><br><span class="line"><span class="comment">	 * underlying HTTP layer.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> body the body content publisher</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Mono&#125; that indicates completion or error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Mono&lt;Void&gt; <span class="title">writeWith</span><span class="params">(Publisher&lt;? extends DataBuffer&gt; body)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServerWebExchange</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP请求-响应的容器。</span></span><br><span class="line"><span class="comment"> * 这是高层接口，除了HTTP交互，还可以保存框架相关信息。</span></span><br><span class="line"><span class="comment"> * 如请求的已恢复的WebSession信息等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServerWebExchange</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">ServerHttpRequest <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ServerHttpResponse <span class="title">getResponse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Mono&lt;WebSession&gt; <span class="title">getSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>重用 WebMVC 的基础设施，用 Flux 、 Mono 和 Publisher 等响应式类型替换同步通信。</p>
<p>保留与 Spring Web MVC 相同的 HandlerMapping 和 HandlerAdapter 链，使用基于 Reactor 的响应式交互替换实时命令：</p>
<ul>
<li><p>HandlerMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HandlerExecutionChain getHandler(HttpServletRequest request)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Mono&lt;Object&gt; <span class="title">getHandler</span><span class="params">(ServerWebExchange exchange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应式 HandlerMapping 中，两个方法整体上类似，不同之处在于响应式返回Mono 类型支持响应式。</p>
</li>
<li><p>HandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Mono&lt;HandlerResult&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange, Object handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应式HandlerAdapter 接口中，由于 ServerWebExchange 类同时组合了请求和响应，因此handle 方法的响应式版本更简洁，该方法返回 HandlerResult 的 Mono 而不是 ModelAndView 。</p>
</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><img src="/images/响应式编程-WebFlux/image-20221129122026202.png" style="zoom:80%;" />

<p>Spring Boot的WebFlux-Starter模块默认使用Netty作为服务器，可以达到异步、非阻塞的效果。</p>
<p>Tomcat、Jetty可以与Spring MVC和WebFlux一起使用，但MVC依赖于Servlet阻塞IO；WebFlux依赖于Servlet的非阻塞IO，并结合适配器使用Servlet Api。</p>
<p>对于Undertow，WebFlux可以直接使用Undertow API，无需Servlet API。</p>
<h1 id="SpringBoot响应式服务器启动"><a href="#SpringBoot响应式服务器启动" class="headerlink" title="SpringBoot响应式服务器启动"></a>SpringBoot响应式服务器启动</h1><h2 id="寻找web服务器类型"><a href="#寻找web服务器类型" class="headerlink" title="寻找web服务器类型"></a>寻找web服务器类型</h2><blockquote>
<p>SpringApplication.run(WebFluxApplication.class)</p>
<p>​    = &gt; 进入run方法 </p>
<p>​        = &gt;  return new SpringApplication(primarySources).run(args); </p>
<p>​                =&gt; 进入SpringApplication构造</p>
<p>​                    =&gt; this.webApplicationType = WebApplicationType.deduceFromClasspath()</p>
<p>​                        =&gt; 进入<code>deduceFromClasspath</code>方法，寻找web服务器类型</p>
<p>​                            =&gt; 引入webFlux，存在DispatcherHandler，获取到响应式类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存在org.springframework.web.reactive.DispatcherHandler &amp;&amp; 不存在org.springframework.web.servlet.DispatcherServlet</span></span><br><span class="line">    <span class="comment">//&amp;&amp; 不存在org.glassfish.jersey.servlet.ServletContainer</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//返回响应式类型</span></span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//"javax.servlet.Servlet","org.springframework.web.context.ConfigurableWebApplicationContext"</span></span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="comment">//Servlet和ConfigurableWebApplicationContext都不存在，返回未知类型</span></span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回servlet类型</span></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建响应式服务上下文"><a href="#创建响应式服务上下文" class="headerlink" title="创建响应式服务上下文"></a>创建响应式服务上下文</h2><blockquote>
<p>SpringApplication.run(WebFluxApplication.class)</p>
<p>​    = &gt; 进入run方法 </p>
<p>​        = &gt;  return new SpringApplication(primarySources).run(args); </p>
<p>​            =&gt; 进入run方法</p>
<p>​                =&gt; context = reateApplicationContext()</p>
<p>​                    =&gt; this.applicationContextFactory.create(this.webApplicationType)，根据web服务类型创建服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContextFactory&#125; registered in &#123;<span class="doctag">@code</span> spring.factories&#125; to support</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnnotationConfigReactiveWebServerApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ApplicationContextFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">create</span><span class="params">(WebApplicationType webApplicationType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (webApplicationType != WebApplicationType.REACTIVE) ? <span class="keyword">null</span></span><br><span class="line">            : <span class="keyword">new</span> AnnotationConfigReactiveWebServerApplicationContext();<span class="comment">//创建注解配置的响应式web服务上下文</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h2><blockquote>
<p>refresh()</p>
<p>=&gt; onRefresh()，调用ReactiveWebServerApplicationContext实现</p>
<p>​    =&gt; createWebServer()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactiveWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericReactiveWebApplicationContext</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableWebServerApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       WebServerManager serverManager = <span class="keyword">this</span>.serverManager;</span><br><span class="line">       <span class="keyword">if</span> (serverManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//获取工厂bean的名称</span></span><br><span class="line">          String webServerFactoryBeanName = getWebServerFactoryBeanName();</span><br><span class="line">          <span class="comment">//从IOC容器获取工厂对象，默认NettyReactiveWebServerFactory</span></span><br><span class="line">          ReactiveWebServerFactory webServerFactory = getWebServerFactory(webServerFactoryBeanName);</span><br><span class="line">          <span class="comment">//获取容器是否懒加载初始化标识</span></span><br><span class="line">          <span class="keyword">boolean</span> lazyInit = getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit();</span><br><span class="line">          <span class="comment">//创建服务器管理器，用于管理 web服务器和HttpHandler</span></span><br><span class="line">          <span class="keyword">this</span>.serverManager = <span class="keyword">new</span> WebServerManager(<span class="keyword">this</span>, webServerFactory, <span class="comment">/*从IOC获取所有HttpHandler*/</span><span class="keyword">this</span>::getHttpHandler, lazyInit);</span><br><span class="line">          getBeanFactory().registerSingleton(<span class="string">"webServerGracefulShutdown"</span>,</span><br><span class="line">                <span class="keyword">new</span> WebServerGracefulShutdownLifecycle(<span class="keyword">this</span>.serverManager));</span><br><span class="line">          <span class="comment">//spring容器创建完毕，在refresh的finishRefresh()中会调用WebServerStartStopLifecycle的start()，执行this.weServerManager.start()，启动服务器</span></span><br><span class="line">          getBeanFactory().registerSingleton(<span class="string">"webServerStartStop"</span>,</span><br><span class="line">                <span class="keyword">new</span> WebServerStartStopLifecycle(<span class="keyword">this</span>.serverManager));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServerManager</span> </span>&#123;</span><br><span class="line">    WebServerManager(ReactiveWebServerApplicationContext applicationContext, ReactiveWebServerFactory factory,</span><br><span class="line">			Supplier&lt;HttpHandler&gt; handlerSupplier, <span class="keyword">boolean</span> lazyInit) &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">		Assert.notNull(factory, <span class="string">"Factory must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.handler = <span class="keyword">new</span> DelayedInitializationHttpHandler(handlerSupplier, lazyInit);</span><br><span class="line">        <span class="comment">//根据工厂创建web服务器，NettyReactiveWebServerFactory.getWebServer</span></span><br><span class="line">		<span class="keyword">this</span>.webServer = factory.getWebServer(<span class="keyword">this</span>.handler);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.handler.initializeHandler();</span><br><span class="line">		<span class="keyword">this</span>.webServer.start();</span><br><span class="line">		<span class="keyword">this</span>.applicationContext</span><br><span class="line">				.publishEvent(<span class="keyword">new</span> ReactiveWebServerInitializedEvent(<span class="keyword">this</span>.webServer, <span class="keyword">this</span>.applicationContext));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><blockquote>
<p>refresh()</p>
<p>​    =&gt; finishRefresh()</p>
<p>​        =&gt; getLifecycleProcessor().onRefresh();</p>
<p>​            =&gt; startBeans(true)，WebServerStartStopLifecycle在此处调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServerStartStopLifecycle</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动web服务器</span></span><br><span class="line">		<span class="keyword">this</span>.weServerManager.start();</span><br><span class="line">		<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><img src="/images/响应式编程-WebFlux/d1c866faeba84b4e92449da1c6d71ac5.png" style="zoom:80%;" />

<ul>
<li>传入请求，由底层服务器引擎处理。服务器引擎列表不限于基于ServletAPI 的服务器。每个服务器引擎都有自己的响应式适配器，将 HTTP 请求和 HTTP 响应的内部表示映射到ServerHttpRequest 和 ServerHttpResponse 。</li>
<li>HttpHandler 阶段，该阶段将给定的 ServerHttpRequest 、 ServerHttpResponse 、用户Session 和相关信息组合到 ServerWebExchage 实例中。</li>
<li>WebFilterChain 阶段，它将定义的 WebFilter 组合到链中。然后， WebFilterChain 会负责执行此链中每个 WebFilter 实例的 WebFilter#filter 方法，以过滤传入的ServerWebExchange 。</li>
<li>如果满足所有过滤条件， WebFilterChain 将调用 WebHandler 实例。</li>
<li>查找 HandlerMapping 实例并调用第一个合适的实例。可以是RouterFunctionMapping、也可以是RequestMappingHandlerMapping 。</li>
<li>handerAdapter阶段，与以前功能相同，使用响应式流来构建响应式流。</li>
</ul>
<h1 id="DispatcherHandler"><a href="#DispatcherHandler" class="headerlink" title="DispatcherHandler"></a>DispatcherHandler</h1><p>与Spring MVC类似，Spring WebFlux也是围绕前端控制器模式设计。DispatcherHandler为请求提供共享性算法实际工作委托给组件处理。</p>
<p>DispatcherHandler是WebHandler的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">implements</span> <span class="title">WebHandler</span>, <span class="title">PreFlightRequestHandler</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理器映射器</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">	<span class="comment">//处理器适配器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">	<span class="comment">//结果处理器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> createNotFoundError();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (CorsUtils.isPreFlightRequest(exchange.getRequest())) &#123;</span><br><span class="line">			<span class="keyword">return</span> handlePreFlight(exchange);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Flux.fromIterable(<span class="keyword">this</span>.handlerMappings)</span><br><span class="line">				.concatMap(mapping -&gt; mapping.getHandler(exchange))<span class="comment">//根据处理器映射器寻找handler</span></span><br><span class="line">				.next()<span class="comment">//获取找到的第一个hander</span></span><br><span class="line">				.switchIfEmpty(createNotFoundError())<span class="comment">//为空则返回"No matching handler"错误</span></span><br><span class="line">				.flatMap(handler -&gt; invokeHandler(exchange, handler))<span class="comment">//寻找支持该handler的handlerAdapter调用</span></span><br><span class="line">				.flatMap(result -&gt; handleResult(exchange, result));<span class="comment">//处理结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="集成Springboot"><a href="#集成Springboot" class="headerlink" title="集成Springboot"></a>集成Springboot</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordDTO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String raw;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String secured;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PasswordDTO</span><span class="params">(@JsonProperty(<span class="string">"raw"</span>)</span> String raw, @<span class="title">JsonProperty</span><span class="params">(<span class="string">"secured"</span>)</span> String secured) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.raw = raw;</span><br><span class="line">        <span class="keyword">this</span>.secured = secured;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yrl.bean.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Order&gt; orderMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">create</span><span class="params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverRequest.bodyToMono(Order<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">doOnNext</span>(<span class="title">order</span> -&gt; </span>&#123;</span><br><span class="line">                    orderMap.put(order.getId(), order);</span><br><span class="line">                &#125;)</span><br><span class="line">                .flatMap(order -&gt; ServerResponse.created(URI.create(<span class="string">"/order/"</span> + order.getId())).build());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">get</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        String id = request.pathVariable(<span class="string">"id"</span>);</span><br><span class="line">        Order order1 = orderMap.get(id);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(order1)</span><br><span class="line">                .flatMap(order -&gt; ServerResponse.ok().syncBody(order)).switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">list</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(orderMap.values().stream().collect(Collectors.toList()))</span><br><span class="line">                .flatMap(order -&gt; ServerResponse.ok().syncBody(order))</span><br><span class="line">                .switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><ul>
<li><code>RouterFunctions.nest(RequestPredicate predicate, RouterFunction&lt;T&gt; routerFunction)</code>：包含两个参数，参数一：测试条件是否通过、参数二：参数一通过，执行路由函数</li>
<li><code>RouterFunctions.route(RequestPredicate predicate, HandlerFunction&lt;T&gt; handlerFunction)</code>：参数一：测试条件是否通过、参数二：参数一通过，执行处理器函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">routes</span><span class="params">(OrderHandler orderHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RouterFunctions.nest(</span><br><span class="line">            <span class="comment">// 判断请求路径是否匹配指定的前缀</span></span><br><span class="line">            path(<span class="string">"/orders"</span>),</span><br><span class="line">            <span class="comment">//如果匹配成功，则路由到这个函数</span></span><br><span class="line">            RouterFunctions.nest(</span><br><span class="line">                            <span class="comment">//判断请求报文头字段accept是否匹配APPLICATION_JSON</span></span><br><span class="line">                            RequestPredicates.accept(MediaType.APPLICATION_JSON),</span><br><span class="line">                            <span class="comment">//如果匹配则路由到下面的路由函数 ，将/orders/&#123;id&#125; 路由到handler的get</span></span><br><span class="line">                            RouterFunctions.route(</span><br><span class="line">                                    RequestPredicates.GET(<span class="string">"/&#123;id&#125;"</span>),</span><br><span class="line">                                    orderHandler::get</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">                    <span class="comment">// 如果get请求 /orders ，则路由到orderhandler.list</span></span><br><span class="line">                    .andRoute(</span><br><span class="line">                            RequestPredicates.method(HttpMethod.GET),</span><br><span class="line">                            orderHandler::list)</span><br><span class="line">                    <span class="comment">// 如果contentType匹配，并路径匹配orders,则路由到这个函数</span></span><br><span class="line">                    .andNest(</span><br><span class="line">                            RequestPredicates.contentType(MediaType.APPLICATION_JSON),</span><br><span class="line">                            <span class="comment">//如果是POST请求/orders，则路由到handler的create方法</span></span><br><span class="line">                            RouterFunctions.route(</span><br><span class="line">                                    RequestPredicates.POST(<span class="string">"/"</span>),</span><br><span class="line">                                    orderHandler::create</span><br><span class="line">                            )</span><br><span class="line">                    )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><img src="/images/响应式编程-WebFlux/image-20221129214830015.png" style="zoom:50%;" />

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><img src="/images/响应式编程-WebFlux/image-20221129214843976.png" style="zoom:50%;" />

<h3 id="指定id查询"><a href="#指定id查询" class="headerlink" title="指定id查询"></a>指定id查询</h3><img src="/images/响应式编程-WebFlux/image-20221129214913005.png" style="zoom:50%;" />

<h1 id="单机启动"><a href="#单机启动" class="headerlink" title="单机启动"></a>单机启动</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yrl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yrl.bean.PasswordDTO;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.HttpHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RequestPredicates;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.netty.DisposableServer;</span><br><span class="line"><span class="keyword">import</span> reactor.netty.http.server.HttpServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(StandaloneApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用Routes方法，然后将RouteFunction转化为HttpHandler</span></span><br><span class="line">        HttpHandler handler = RouterFunctions.toHttpHandler(routes(</span><br><span class="line">                <span class="comment">// BCryt算法进行18次散列， 这里需要耗时几秒</span></span><br><span class="line">                <span class="keyword">new</span> BCryptPasswordEncoder(<span class="number">18</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 内置HttpHandler适配器</span></span><br><span class="line">        ReactorHttpHandlerAdapter reactorAdapter = <span class="keyword">new</span> ReactorHttpHandlerAdapter(handler);</span><br><span class="line">        <span class="comment">// 创建HTTPServer实例，它是ReatorNettyAPI一部分</span></span><br><span class="line">        DisposableServer server = HttpServer.create()</span><br><span class="line">                .host(<span class="string">"localhost"</span>)</span><br><span class="line">                .port(<span class="number">8080</span>) <span class="comment">// 配置端口</span></span><br><span class="line">                .handle(reactorAdapter)  <span class="comment">// 指定handler</span></span><br><span class="line">                .bindNow();<span class="comment">// 调用bindNow 启动服务</span></span><br><span class="line">        LOGGER.info(<span class="string">"started in"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="comment">// 为了使应用程序保持活动状态，阻塞Thread,并监听服务器处理事件</span></span><br><span class="line">        server.onDispose().block();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RouterFunction&lt;?&gt; routes(BCryptPasswordEncoder passwordEncoder) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                <span class="comment">//匹配请求POST 并且路径是password</span></span><br><span class="line">                RouterFunctions.route(RequestPredicates.POST(<span class="string">"password"</span>),</span><br><span class="line">                        reqeust -&gt; reqeust</span><br><span class="line">                                .bodyToMono(PasswordDTO<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                                .doOnNext(System.out::println)</span><br><span class="line">                                <span class="comment">// BCryptPasswordEncoder检查已加密的原始密码，加密密码</span></span><br><span class="line">                                .map(p -&gt; passwordEncoder.matches(p.getRaw(), p.getSecured()))</span><br><span class="line">                                <span class="comment">// 如果密码匹配成功过 则OK</span></span><br><span class="line">                                <span class="comment">// 否则EXPECTATION_FAILED</span></span><br><span class="line">                                .flatMap(isMatched -&gt; isMatched ? ServerResponse.ok().build() :</span><br><span class="line">                                        ServerResponse.status(HttpStatus.EXPECTATION_FAILED).build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-WebFlux/image-20221129215903410.png" alt=""></p>
<h1 id="WebClient非阻塞请求"><a href="#WebClient非阻塞请求" class="headerlink" title="WebClient非阻塞请求"></a>WebClient非阻塞请求</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebClient</span><br><span class="line">    	<span class="comment">//创建客户端，指定</span></span><br><span class="line">        .create(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">    	<span class="comment">//指定请求方法为get</span></span><br><span class="line">        .get() 		</span><br><span class="line">    	<span class="comment">//指定uri，传送变量</span></span><br><span class="line">        .uri(<span class="string">"/orders/&#123;id&#125;"</span>, <span class="number">123</span>)</span><br><span class="line">	    <span class="comment">//指定结果处理方式</span></span><br><span class="line">        .retrieve()			</span><br><span class="line">    	<span class="comment">//将响应结果反序列化</span></span><br><span class="line">        .bodyToMono(Order<span class="class">.<span class="keyword">class</span>)	</span></span><br><span class="line"><span class="class">    	//处理结果</span></span><br><span class="line">        .map(Order::getId)	</span><br><span class="line">    	<span class="comment">//订阅输出，只有通过 subscribe 方法， WebClient 才会建立连接并开始发送数据到远程服务器</span></span><br><span class="line">        .subscribe(item -&gt; System.out.println(<span class="string">"subscribe："</span> + item));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
        <category>webflux</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>webflux</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程-ProjectReactor</title>
    <url>/2022/11/29/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-ProjectReactor/</url>
    <content><![CDATA[<h1 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a><a href="https://projectreactor.io/docs/core/release/reference/index.html#about-doc" target="_blank" rel="noopener">Project Reactor</a></h1><h2 id="响应式概念"><a href="#响应式概念" class="headerlink" title="响应式概念"></a>响应式概念</h2><p>响应式编程通常以面向对象的语言呈现，作为观察者设计模式的扩展。</p>
<p>通过编写异步、非阻塞的代码寻求更高的处理效率。</p>
<p>Callback异步处理，通过Future获取结果可能会出现回调地狱，CompletableFuture可以将多个Future进行编排，但使用上并不是那么容易，且不支持惰性计算、多值和处理的灵活性。</p>
<p>响应式库（例如 Reactor）旨在解决 JVM 上“经典”异步方法的这些缺点：</p>
<ul>
<li>可组合性和可读性</li>
<li>数据作为使用丰富的运算符词汇操作的流</li>
<li>在订阅之前什么都不会发生</li>
<li>背压或消费者向生产者发出排放率过高信号的能力</li>
<li>与并发无关的高级但高价值的抽象</li>
</ul>
<a id="more"></a>

<h2 id="reactort-概念"><a href="#reactort-概念" class="headerlink" title="reactort 概念"></a>reactort 概念</h2><ul>
<li>对响应式流规范的一种实现</li>
<li>Spring WebFlux默认的响应式框架</li>
<li>完全异步非阻塞，对背压支持</li>
<li>提供两个异步序列API：Flux[N]、Mono[0|1]</li>
<li>提供对响应式流的操作</li>
</ul>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><ul>
<li><p>Publisher - 发布者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>发送<code>onNex</code>t信号次数不得超过订阅者请求的元素个数</li>
<li>如果进程失败，需要调用<code>onError</code>告知订阅者</li>
<li><code>Publisher.subscribe()</code>内部需调用<code>onSubscribe(Subscriber s)</code></li>
<li>允许同时存在多个订阅者</li>
</ul>
</li>
<li><p>Subscriber - 订阅者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要调用<code>Subscriptions.request(long n)</code>来向发布者请求数据，n指请求多少数据量</li>
<li><code>onComplete</code>或<code>onError</code>方法，终止方法</li>
<li>只能存在一个活跃的订阅</li>
<li>调用<code>Subscription.cancel()</code>之后仍有<code>onNext</code>信号发送</li>
</ul>
</li>
<li><p>Subscription - 订阅关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要在当前订阅者的上下文中被调用</li>
<li><code>Subscription.request(long n)</code>最多请求2^63-1个元素</li>
</ul>
</li>
<li><p>Processor -  处理器，reactor3.5后废弃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;,<span class="title">Publisher</span>&lt;<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h4><p>Mono最多可以指定一个元素</p>
<ul>
<li><p>just - 指定一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定元素，只能指定一个元素</span></span><br><span class="line">Mono&lt;String&gt; just = Mono.just(<span class="string">"hello"</span>);</span><br><span class="line">just.subscribe(System.out::println);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>justOrEmpty - 指定可能为空的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定可能为空的元素</span></span><br><span class="line">Mono&lt;Object&gt; objectMono = Mono.justOrEmpty(<span class="keyword">null</span>);</span><br><span class="line">objectMono.subscribe(System.out::println);<span class="comment">//无输出</span></span><br><span class="line"></span><br><span class="line">Mono&lt;Object&gt; objectMono = Mono.justOrEmpty(Optional.empty());</span><br><span class="line">objectMono.subscribe(System.out::println);<span class="comment">//无输出</span></span><br><span class="line"></span><br><span class="line">Mono&lt;Object&gt; objectMono = Mono.justOrEmpty(<span class="number">123</span>);</span><br><span class="line">objectMono.subscribe(System.out::println);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fromCallable - 异步调用创建，<strong>并未试出异步效果？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">request</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">        URLConnection urlConnection = url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(temp).append(<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//打印出来还是main线程？</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(request());</span></span><br><span class="line">        Mono.just(request()).subscribe(System.out::println);</span><br><span class="line">        Mono.fromCallable(() -&gt; request()).subscribe(System.out::println);</span><br><span class="line">        Mono.fromCallable(AsyncMonoTest::request).subscribe(System.out::println);</span><br><span class="line">        Mono.fromCallable(AsyncMonoTest::request)</span><br><span class="line">                .subscribe(</span><br><span class="line">                        data -&gt; &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName());</span><br><span class="line">                            System.out.println(data);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        ex -&gt; System.out.println(<span class="string">"出错："</span> + ex),</span><br><span class="line">                        () -&gt; System.out.println(<span class="string">"请求完成"</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><p>Flux可以指定多个元素创建响应式流</p>
<ul>
<li><p>just - 列举创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; just = Flux.just(<span class="string">"hello"</span>, <span class="string">"every body"</span>);</span><br><span class="line">just.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello<br>every body</p>
</blockquote>
</li>
<li><p>fromArray - 数组创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; stringFlux = Flux.fromArray(<span class="keyword">new</span> String[]&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;);</span><br><span class="line">stringFlux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello<br>every body</p>
</blockquote>
</li>
<li><p>fromIterable - iterable接口创建</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; iterableFlux = Flux.fromIterable(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">iterableFlux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>3<br>4</p>
</blockquote>
</li>
<li><p>range - 递增序列创建</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125212614521.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数（即1000）为递增序列的初始值；第二个参数为递增的总数据量，包含初始值</span></span><br><span class="line">Flux&lt;Integer&gt; rangeFlux = Flux.range(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line">rangeFlux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>1003<br>1004</p>
</blockquote>
</li>
<li><p>from - 基于publisher创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.from(<span class="keyword">new</span> Publisher&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 请求Publisher开始流数据</span></span><br><span class="line"><span class="comment">             * 这是一个“工厂方法”，可以多次调用，每次启动一个新的Subscription。</span></span><br><span class="line"><span class="comment">             * 每个订阅（Subscription）只适用于单个订阅服务器（Subscriber）。</span></span><br><span class="line"><span class="comment">             * 订阅服务器（Subscriber）只能向单个发布服务器（Publisher）订阅一次。</span></span><br><span class="line"><span class="comment">             * 如果发布者（Publisher）拒绝订阅（Subscriber）尝试或以其他方式失败，它将通过Subscriber.onError发出错误信号。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> subscriber</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            subscriber.onNext(<span class="string">"hello - "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(</span><br><span class="line">    data -&gt; System.out.println(data),</span><br><span class="line">    ex -&gt; System.out.println(<span class="string">"出错："</span> + ex),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"请求完成"</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda简化</span></span><br><span class="line">Flux.from((Publisher&lt;String&gt;) subscriber -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hello - "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    subscriber.onComplete();</span><br><span class="line">&#125;).subscribe(</span><br><span class="line">    data -&gt; System.out.println(data),</span><br><span class="line">    ex -&gt; System.out.println(<span class="string">"出错："</span> + ex),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"请求完成"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello - 0<br>hello - 1<br>hello - 2<br>hello - 3<br>hello - 4<br>请求完成</p>
</blockquote>
</li>
<li><p>interval - 间隔创建</p>
<p>指定时间间隔内，从0开始递增产生值</p>
<p><code>public static Flux&lt;Long&gt; interval(Duration delay, Duration period, Scheduler timer)</code></p>
<p>第一个参数：延迟开始时间、第二个参数：间隔时间周期、第三个参数：调度线程池</p>
<img src="/images/响应式编程-ProjectReactor/image-20221127212549430.png" style="zoom:80%;" />

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.interval(Duration.ZERO, Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="编程方式创建"><a href="#编程方式创建" class="headerlink" title="编程方式创建"></a>编程方式创建</h4><h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h5><p>逐一对信号进行加工输出创建Flux，通过BiFunction函数对状态加工输出，发送给下游订阅者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">    <span class="comment">//为每个订阅提供初始状态值</span></span><br><span class="line">    <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//处理状态值，为订阅者提供数据</span></span><br><span class="line">    <span class="comment">//state：状态值；sink</span></span><br><span class="line">    <span class="keyword">new</span> BiFunction&lt;Integer, SynchronousSink&lt;String&gt;, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer state, SynchronousSink&lt;String&gt; sink)</span> </span>&#123;</span><br><span class="line">            sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span> * state);<span class="comment">//将数据输出给订阅者</span></span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">//当前订阅的流已结束</span></span><br><span class="line">                sink.complete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//传递状态值，会继续调用apply方法</span></span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//当第二个参数终止或者下游调用取消时，这里接收最后一个状态值</span></span><br><span class="line">    <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"state:"</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">flux.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda简化</span></span><br><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">    () -&gt; <span class="number">0</span>,</span><br><span class="line">    (state, sink) -&gt; &#123;</span><br><span class="line">        sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span> * state);</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">10</span>) &#123;</span><br><span class="line">            sink.complete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    (state) -&gt; System.out.println(<span class="string">"state:"</span> + state));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 x 0 = 0<br>3 x 1 = 3<br>3 x 2 = 6<br>3 x 3 = 9<br>3 x 4 = 12<br>3 x 5 = 15<br>3 x 6 = 18<br>3 x 7 = 21<br>3 x 8 = 24<br>3 x 9 = 27<br>3 x 10 = 30<br>state:11</p>
</blockquote>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>适用于单线程生产者，默认背压策略：<code>OverflowStrategy.BUFFER</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">push</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> FluxSink&lt;T&gt;&gt; emitter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> push(emitter, OverflowStrategy.BUFFER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">push</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> FluxSink&lt;T&gt;&gt; emitter, OverflowStrategy backpressure)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> FluxCreate&lt;&gt;(emitter, backpressure, FluxCreate.CreateMode.PUSH_ONLY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/images/响应式编程-ProjectReactor/image-20221127153950559.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.push(<span class="keyword">new</span> Consumer&lt;FluxSink&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(FluxSink&lt;Integer&gt; fluxSink)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(item -&gt; fluxSink.next(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<h5 id="create"><a href="#create" class="headerlink" title="create"></a>create</h5><p>使用上与push类似，适用于多线程生产者，默认背压策略：<code>OverflowStrategy.BUFFER</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">create</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> FluxSink&lt;T&gt;&gt; emitter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> create(emitter, OverflowStrategy.BUFFER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">create</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> FluxSink&lt;T&gt;&gt; emitter, OverflowStrategy backpressure)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> FluxCreate&lt;&gt;(emitter, backpressure, FluxCreate.CreateMode.PUSH_PULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多线程使用上如何体现？</strong></p>
<img src="/images/响应式编程-ProjectReactor/image-20221127154013364.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.create(<span class="keyword">new</span> Consumer&lt;FluxSink&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(FluxSink&lt;Integer&gt; fluxSink)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(item -&gt; fluxSink.next(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> OverflowStrategy &#123;</span><br><span class="line">	<span class="comment">//完全忽略下游的背压请求。</span></span><br><span class="line">	IGNORE,</span><br><span class="line">	<span class="comment">//当消费不过来有新元素下发时，报错。</span></span><br><span class="line">	ERROR,</span><br><span class="line">	<span class="comment">//如果下游没有准备好接收信号，则丢弃传入信号。</span></span><br><span class="line">	DROP,</span><br><span class="line">	<span class="comment">//只会保留最新的元素。</span></span><br><span class="line">	LATEST,</span><br><span class="line">	<span class="comment">//下发元素时会在一个队列中进行缓存。</span></span><br><span class="line">	BUFFER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">Flux.range(<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">10</span>))</span><br><span class="line">        .onBackpressureError()</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .subscribe(</span><br><span class="line">                System.out::println,</span><br><span class="line">                ex -&gt;&#123;</span><br><span class="line">                    System.out.println(ex);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"处理完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">"main结束"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>3<br>reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue…)<br>main结束</p>
</blockquote>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>当订阅时，Subscriber会创建一个对象链，沿着链向上寻找第一个发布者。</p>
<h4 id="基于-Lambda-订阅"><a href="#基于-Lambda-订阅" class="headerlink" title="基于 Lambda 订阅"></a>基于 Lambda 订阅</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订阅并触发序列</span></span><br><span class="line">subscribe(); </span><br><span class="line"><span class="comment">//对每个产生的值做一些事情</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer); </span><br><span class="line"><span class="comment">//处理值但也对错误做出反应</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer); </span><br><span class="line"><span class="comment">//处理值和错误，但也在序列成功完成时运行一些代码</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer); </span><br><span class="line"><span class="comment">//处理值和错误并成功完成，但也对该调用Subscription产生的结果做一些事情</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Subscription&gt; subscriptionConsumer);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有这些subscribe()都有一个Disposable返回类型，可以通过调用其dispose()方法取消订阅。</p>
<p>对于<code>Flux</code>or <code>Mono</code>，取消是一个信号，表明源应该停止生成元素。但是，它不能保证是立即的：某些源可能会非常快地生成元素，以至于它们甚至可以在收到取消指令之前完成</p>
</blockquote>
<h4 id="基于BaseSubscriber订阅"><a href="#基于BaseSubscriber订阅" class="headerlink" title="基于BaseSubscriber订阅"></a>基于BaseSubscriber订阅</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">flux.subscribe(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Subscribed"</span>);</span><br><span class="line">        request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Subscribed<br>1<br>2<br>3<br>4</p>
</blockquote>
<h3 id="using-资源统一处理"><a href="#using-资源统一处理" class="headerlink" title="using - 资源统一处理"></a>using - 资源统一处理</h3><p><code>public static &lt;T, D&gt; Flux&lt;T&gt; using(Callable&lt;? extends D&gt; resourceSupplier, Function&lt;? super D, ? extends Publisher&lt;? extends T&gt;&gt; sourceSupplier, Consumer&lt;? super D&gt; resourceCleanup)</code></p>
<ul>
<li><p>resourceSupplier：在订阅时被调用，以生成资源的可调用对象</p>
</li>
<li><p>sourceSupplier：从resourceSupplier获取Publisher，数据源</p>
</li>
<li><p>resourceCleanup：在完成时，调用资源对象的清理回调</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Connection <span class="title">newConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建Connection对象"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Connection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (rnd.nextInt(<span class="number">10</span>) &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"通信异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(<span class="string">"数据1"</span>, <span class="string">"数据2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// close方法可以释放内部资源，并且应该始终被调用，即使在getData执行期间发生错误也是如此。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭Connection连接"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        try (Connection connection = Connection.newConnection()) &#123;</span></span><br><span class="line"><span class="comment">//            connection.getData().forEach(data -&gt; System.out.println("接收的数据：" +</span></span><br><span class="line"><span class="comment">//                    data));</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            System.err.println("错误信息：" + e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Flux.using(</span><br><span class="line">                Connection::newConnection,</span><br><span class="line">                connection -&gt; Flux.fromIterable(connection.getData()),</span><br><span class="line">                Connection::close</span><br><span class="line">        ).subscribe(</span><br><span class="line">                data -&gt; System.out.println(<span class="string">"onNext接收到数据："</span> + data),</span><br><span class="line">                ex -&gt; System.err.println(<span class="string">"onError接收到的异常信息："</span> + ex),</span><br><span class="line">                () -&gt; System.out.println(<span class="string">"处理完毕"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建Connection对象<br>关闭Connection连接<br>onError接收到的异常信息：java.lang.RuntimeException: 通信异常</p>
</blockquote>
<h3 id="Schedulers"><a href="#Schedulers" class="headerlink" title="Schedulers"></a>Schedulers</h3><h4 id="调度线程池"><a href="#调度线程池" class="headerlink" title="调度线程池"></a>调度线程池</h4><ul>
<li><strong>Schedulers.newSingle()</strong>：单个可重复使用的线程。</li>
<li><strong>Schedulers.elastic()</strong>： 无界弹性线程池，有隐藏背压问题并导致过多线程的倾向，3.5.0开始弃用。</li>
<li><strong>Schedulers.boundedElastic()</strong>：有界弹性线程池 ，会根据需要创建新的工作池并重用闲置的工作池；闲置时间过长（默认为 60 秒）的工作池也会被处理掉。与elastic()不同，它对其可以创建的支持线程数有上限（默认为 CPU 核心数 x 10）。达到上限后提交的最多 100 000 个任务将被排入队列，并在线程可用时重新安排（延迟调度时，延迟在线程可用时开始）。</li>
<li><strong>Schedulers.parallel()</strong> ：为并行工作调整的固定工作池，创建与CPU 内核一样多的worker。</li>
<li><strong>Schedulers.newParallel()</strong> ：指定线程数，线程工厂的自定义线程池。可以使用newXXX 方法自定义创建各种调度程序类型的新实例。</li>
</ul>
<h4 id="publishOn"><a href="#publishOn" class="headerlink" title="publishOn"></a>publishOn</h4><p>影响调用publishOn()之后方法的执行上下文，任务被提交给Schedulers 的线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">        .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());<span class="comment">//main</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">10</span> + i;</span><br><span class="line">                &#125;</span><br><span class="line">        )</span><br><span class="line">        .publishOn(s)<span class="comment">//此方法之后的链路切换为Scheduler线程</span></span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()); <span class="comment">//parallel-scheduler-1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"value"</span> + i;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">flux.subscribe(item -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + item));<span class="comment">//parallel-scheduler-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>main<br>main<br>parallel-scheduler-1<br>parallel-scheduler-1 value11<br>parallel-scheduler-1<br>parallel-scheduler-1 value12</p>
</blockquote>
<h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h4><p>从订阅开始整条链路的执行上下文都交给Schedulers 的线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//parallel-scheduler-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">        )</span><br><span class="line">    .subscribeOn(s) <span class="comment">//从订阅时间开始切换整个序列的上下文交给Scheduler的线程执行</span></span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">//parallel-scheduler-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"value"</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">flux.subscribe(item -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + item));<span class="comment">//parallel-scheduler-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>parallel-scheduler-1<br>parallel-scheduler-1<br>parallel-scheduler-1 value11<br>parallel-scheduler-1<br>parallel-scheduler-1<br>parallel-scheduler-1 value12</p>
</blockquote>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="doOnError：出错时触发"><a href="#doOnError：出错时触发" class="headerlink" title="doOnError：出错时触发"></a>doOnError：出错时触发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .concatWith(Flux.error(<span class="keyword">new</span> RuntimeException(<span class="string">"出错"</span>)))</span><br><span class="line">        .doOnError((ex) -&gt; System.out.println(ex));</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 出错<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 出错<br>Caused by: java.lang.RuntimeException: 出错<br>    at com.yrl.reactor.ReactorDemo1.main(ReactorDemo1.java:18)</p>
</blockquote>
<h4 id="retry：重试"><a href="#retry：重试" class="headerlink" title="retry：重试"></a>retry：重试</h4><p>不指定重试次数则无限重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .concatWith(Flux.error(<span class="keyword">new</span> RuntimeException(<span class="string">"出错"</span>)))</span><br><span class="line">        .doOnError((ex) -&gt; System.out.println(ex))</span><br><span class="line">        .retry(<span class="number">1</span>);</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 出错<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.RuntimeException: 出错<br>Caused by: java.lang.RuntimeException: 出错<br>    at com.yrl.reactor.ReactorDemo1.main(ReactorDemo1.java:18)</p>
<p>Process finished with exit code 0</p>
</blockquote>
<h4 id="onErrorResume：出错使用备用流"><a href="#onErrorResume：出错使用备用流" class="headerlink" title="onErrorResume：出错使用备用流"></a>onErrorResume：出错使用备用流</h4><p>根据错误返回对应的流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">    .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">    .concatWith(Flux.error(<span class="keyword">new</span> RuntimeException(<span class="string">"出错"</span>)))</span><br><span class="line">    .doOnError((ex) -&gt; System.out.println(ex))</span><br><span class="line">    .onErrorResume(ex -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"onErrorResume - ex:"</span> + ex);</span><br><span class="line">        <span class="keyword">return</span> Flux.just(<span class="number">11111</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>onErrorResume - ex:java.lang.RuntimeException: 出错<br>11111</p>
<p>Process finished with exit code 0</p>
</blockquote>
<h4 id="onErrorReturn-存在错误则返回指定值"><a href="#onErrorReturn-存在错误则返回指定值" class="headerlink" title="onErrorReturn - 存在错误则返回指定值"></a>onErrorReturn - 存在错误则返回指定值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .concatWith(Flux.error(<span class="keyword">new</span> RuntimeException(<span class="string">"出错"</span>)))</span><br><span class="line">        .doOnError((ex) -&gt; System.out.println(ex))</span><br><span class="line">        .onErrorReturn(<span class="number">11111</span>);</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>11111</p>
</blockquote>
<h4 id="onErrorMap-对错误进行转换"><a href="#onErrorMap-对错误进行转换" class="headerlink" title="onErrorMap - 对错误进行转换"></a>onErrorMap - 对错误进行转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .concatWith(Flux.error(<span class="keyword">new</span> RuntimeException(<span class="string">"出错"</span>)))</span><br><span class="line">        .doOnError((ex) -&gt; System.out.println(ex))</span><br><span class="line">        .onErrorMap(ex -&gt; <span class="keyword">new</span> Exception(ex.getMessage()));</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>java.lang.RuntimeException: 出错<br>[ERROR] (main) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 出错<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 出错<br>Caused by: java.lang.Exception: 出错<br>    at com.yrl.reactor.ReactorDemo1.lambda$main$1(ReactorDemo1.java:21)<br>    at reactor.core.publisher.Flux.lambda$onErrorMap$27(Flux.java:6544)<br>    at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94)<br>    at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:221)<br>    at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2023)<br>    at reactor.core.publisher.Operators.error(Operators.java:196)<br>    at reactor.core.publisher.FluxError.subscribe(FluxError.java:43)<br>    at reactor.core.publisher.Flux.subscribe(Flux.java:8095)<br>    at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:208)<br>    at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:80)<br>    at reactor.core.publisher.Flux.subscribe(Flux.java:8095)<br>    at reactor.core.publisher.Flux.subscribeWith(Flux.java:8268)<br>    at reactor.core.publisher.Flux.subscribe(Flux.java:8065)<br>    at reactor.core.publisher.Flux.subscribe(Flux.java:7989)<br>    at reactor.core.publisher.Flux.subscribe(Flux.java:7932)<br>    at com.yrl.reactor.ReactorDemo1.main(ReactorDemo1.java:22)</p>
</blockquote>
<h3 id="defaultIfEmpty-为空时使用默认值"><a href="#defaultIfEmpty-为空时使用默认值" class="headerlink" title="defaultIfEmpty - 为空时使用默认值"></a>defaultIfEmpty - 为空时使用默认值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.empty().defaultIfEmpty(<span class="string">"hello"</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello</p>
</blockquote>
<h3 id="defer-延迟执行"><a href="#defer-延迟执行" class="headerlink" title="defer - 延迟执行"></a>defer - 延迟执行</h3><p><code>public static &lt;T&gt; Mono&lt;T&gt; defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier)</code></p>
<p>延迟执行，有订阅者出现才会执行，且为每个订阅者生成所有数据</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125160433884.png"  style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String data = UUID.randomUUID().toString();</span><br><span class="line">    System.out.println(<span class="string">"生成数据:"</span> + data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mono&lt;String&gt; mono = Mono.just(data());</span><br><span class="line">    Flux&lt;String&gt; flux = Flux.just(data());</span><br><span class="line">    <span class="comment">//不订阅也会执行data()逻辑</span></span><br><span class="line">    <span class="comment">//生成数据:3915beeb-d8c3-4201-a296-9c8bfaa5d90d</span></span><br><span class="line">	<span class="comment">//生成数据:4d5fffff-1546-4b7b-accb-3fd501b78606</span></span><br><span class="line">	<span class="comment">//=========</span></span><br><span class="line">    </span><br><span class="line">    Mono&lt;String&gt; deferMono = Mono.defer(() -&gt; Mono.just(data()));</span><br><span class="line">    Flux&lt;String&gt; deferFlux = Flux.defer(() -&gt; Flux.just(data()));</span><br><span class="line">    System.out.println(<span class="string">"========="</span>);</span><br><span class="line">    deferMono.subscribe();<span class="comment">//订阅才会执行data()逻辑</span></span><br><span class="line">    deferFlux.subscribe();<span class="comment">//订阅才会执行data()逻辑</span></span><br><span class="line">    <span class="comment">//=========</span></span><br><span class="line">	<span class="comment">//生成数据:c7dbd697-bd1a-42af-b832-b39a48f8374e</span></span><br><span class="line">	<span class="comment">//生成数据:20c38ced-1476-4624-af23-6835c05ba32b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h3><p><code>public final Flux&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)</code></p>
<p>通过该方法可以对 Flux 或 Mono 上的每个元素执行一些操作，回调Subscriber.onNext</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125160254989.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">100</span>,<span class="number">3</span>)</span><br><span class="line">    .doOnNext(System.out::println)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>100<br>101<br>102</p>
</blockquote>
<h3 id="doOnComplete"><a href="#doOnComplete" class="headerlink" title="doOnComplete"></a>doOnComplete</h3><p>完成订阅处理后回调doOnComplete方法</p>
<p><code>public final Flux&lt;T&gt; doOnComplete(Runnable onComplete)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221128143928695.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .doOnComplete(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"完成"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000<br>1001<br>1002<br>完成</p>
</blockquote>
<h3 id="doOnTerminate"><a href="#doOnTerminate" class="headerlink" title="doOnTerminate"></a>doOnTerminate</h3><p>无论什么原因终止都会被调用</p>
<h3 id="log-日志跟踪"><a href="#log-日志跟踪" class="headerlink" title="log - 日志跟踪"></a>log - 日志跟踪</h3><p>观察所有活性流信号并使用Logger支持跟踪它们，默认使用info级别和java.util.logging（如果SLF4J可用则使用它）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; range = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">        .log();</span><br><span class="line">range.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[ INFO] (main) | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)<br>[ INFO] (main) | request(unbounded)<br>[ INFO] (main) | onNext(1000)<br>1000<br>[ INFO] (main) | onNext(1001)<br>1001<br>[ INFO] (main) | onNext(1002)<br>1002<br>[ INFO] (main) | onComplete()</p>
</blockquote>
<h3 id="map-转换数据"><a href="#map-转换数据" class="headerlink" title="map - 转换数据"></a>map - 转换数据</h3><p>使用Function函数转换入参数据，返回指定形式数据</p>
<p><code>public final &lt;V&gt; Flux&lt;V&gt; map(Function&lt;? super T, ? extends V&gt; mapper)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125160221699.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">100</span>,<span class="number">3</span>)</span><br><span class="line">    .map(num -&gt; <span class="string">"hello "</span> + num)<span class="comment">//传入Function类型的lambda表达式转换数据格式</span></span><br><span class="line">    .doOnNext(System.out::println)<span class="comment">//打印数据流上的数据</span></span><br><span class="line">    .subscribe();<span class="comment">//订阅数据</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello 100<br>hello 101<br>hello 102</p>
</blockquote>
<h3 id="扁平化数据"><a href="#扁平化数据" class="headerlink" title="扁平化数据"></a>扁平化数据</h3><h4 id="flatMap-立即订阅，交错处理"><a href="#flatMap-立即订阅，交错处理" class="headerlink" title="flatMap - 立即订阅，交错处理"></a>flatMap - 立即订阅，交错处理</h4><p>同时订阅数据，数据交错处理</p>
<img src="/images/响应式编程-ProjectReactor/image-20221127215730456.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.just(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>),Arrays.asList(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .flatMap(item -&gt; Flux.fromIterable(item)</span><br><span class="line">        .doOnSubscribe(subscription -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"已经订阅"</span>);</span><br><span class="line">        &#125;)<span class="comment">//增加一个延时，订阅后延时一段时间再发送</span></span><br><span class="line">        .delayElements(Duration.ofMillis(random.nextInt(<span class="number">100</span>) + <span class="number">100</span>))</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1, 2, 3]<br>已经订阅<br>[a, b, c, d]<br>已经订阅<br>[7, 8, 9]<br>已经订阅<br>1<br>a<br>7<br>2<br>b<br>3<br>c<br>8<br>d<br>9</p>
</blockquote>
<h4 id="concatMap-顺序订阅，顺序处理"><a href="#concatMap-顺序订阅，顺序处理" class="headerlink" title="concatMap- 顺序订阅，顺序处理"></a>concatMap- 顺序订阅，顺序处理</h4><img src="/images/响应式编程-ProjectReactor/image-20221127220112862.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.just(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>),Arrays.asList(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .concatMap(item -&gt; Flux.fromIterable(item)</span><br><span class="line">                .doOnSubscribe(subscription -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"已经订阅"</span>);</span><br><span class="line">                &#125;)<span class="comment">//增加一个延时，订阅后延时一段时间再发送</span></span><br><span class="line">                .delayElements(Duration.ofMillis(random.nextInt(<span class="number">100</span>) + <span class="number">100</span>))</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1, 2, 3]<br>已经订阅<br>[a, b, c, d]<br>[7, 8, 9]<br>1<br>2<br>3<br>已经订阅<br>a<br>b<br>c<br>d<br>已经订阅<br>7<br>8<br>9</p>
</blockquote>
<h4 id="flatMapSequential-立即订阅，顺序处理"><a href="#flatMapSequential-立即订阅，顺序处理" class="headerlink" title="flatMapSequential - 立即订阅，顺序处理"></a>flatMapSequential - 立即订阅，顺序处理</h4><img src="/images/响应式编程-ProjectReactor/image-20221127220940230.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.just(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>),Arrays.asList(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .flatMapSequential(item -&gt; Flux.fromIterable(item)</span><br><span class="line">                .doOnSubscribe(subscription -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"已经订阅"</span>);</span><br><span class="line">                &#125;)<span class="comment">// 我们增加一个延时，订阅后延时一段时间再发送</span></span><br><span class="line">                .delayElements(Duration.ofMillis(random.nextInt(<span class="number">100</span>) + <span class="number">100</span>))</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1, 2, 3]<br>已经订阅<br>[a, b, c, d]<br>已经订阅<br>[7, 8, 9]<br>已经订阅<br>1<br>2<br>3<br>a<br>b<br>c<br>d<br>7<br>8<br>9</p>
</blockquote>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter - 过滤"></a>filter - 过滤</h3><p><code>public final Flux&lt;T&gt; filter(Predicate&lt;? super T&gt; p)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">100</span>,<span class="number">3</span>)</span><br><span class="line">    .filter(num -&gt; num % <span class="number">3</span> == <span class="number">0</span>)<span class="comment">//过滤数据，只有102符合</span></span><br><span class="line">    .map(num -&gt; <span class="string">"hello "</span> + num)<span class="comment">//数据转换</span></span><br><span class="line">    .doOnNext(System.out::println)<span class="comment">//</span></span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello 102</p>
</blockquote>
<h3 id="index-增加索引值"><a href="#index-增加索引值" class="headerlink" title="index - 增加索引值"></a>index - 增加索引值</h3><p><code>public final Flux&lt;Tuple2&lt;Long, T&gt;&gt; index()</code></p>
<p>为数据增加索引，构建二元数据 Tuple2&lt;(index, value)&gt;</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125160122401.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">100</span>, <span class="number">3</span>)</span><br><span class="line">    .map(item -&gt; <span class="string">"hello-"</span> + item)</span><br><span class="line">    .index()</span><br><span class="line">    .doOnNext(item -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Tuple2："</span> + item);</span><br><span class="line">        <span class="comment">// 二元组第一个元素 ，编号0开始</span></span><br><span class="line">        Long t1 = item.getT1();</span><br><span class="line">        System.out.println(<span class="string">"索引："</span> + t1);</span><br><span class="line">        <span class="comment">// 二元组第二个元素，也就是具体值</span></span><br><span class="line">        String t2 = item.getT2();</span><br><span class="line">        System.out.println(<span class="string">"值："</span> + t2);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tuple2：[0,hello-100]<br>索引：0<br>值：hello-100</p>
<p>Tuple2：[1,hello-101]<br>索引：1<br>值：hello-101</p>
<p>Tuple2：[2,hello-102]<br>索引：2<br>值：hello-102</p>
</blockquote>
<h3 id="timestamp-增加时间戳"><a href="#timestamp-增加时间戳" class="headerlink" title="timestamp - 增加时间戳"></a>timestamp - 增加时间戳</h3><p><code>public final Flux&lt;Tuple2&lt;Long, T&gt;&gt; timestamp()</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125161829462.png" style="zoom:50%;" />

<p>为数据增加当前时间戳，构建二元数据 Tuple2&lt;(timestamp , value)&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">    .map(item -&gt; <span class="string">"hello-"</span> + item)</span><br><span class="line">    .timestamp()</span><br><span class="line">    .doOnNext(item -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Tuple2："</span> + item);</span><br><span class="line">        <span class="comment">// 二元组第一个元素 ，当前时间戳</span></span><br><span class="line">        Long t1 = item.getT1();</span><br><span class="line">        System.out.println(<span class="string">"时间戳："</span> + t1);</span><br><span class="line">        <span class="comment">// 二元组第二个元素，也就是具体值</span></span><br><span class="line">        String t2 = item.getT2();</span><br><span class="line">        System.out.println(<span class="string">"值："</span> + t2);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tuple2：[1669364259980,hello-100]<br>时间戳：1669364259980<br>值：hello-100</p>
<p>Tuple2：[1669364259980,hello-101]<br>时间戳：1669364259980<br>值：hello-101</p>
<p>Tuple2：[1669364259980,hello-102]<br>时间戳：1669364259980<br>值：hello-102</p>
</blockquote>
<h3 id="skip-跳过"><a href="#skip-跳过" class="headerlink" title="skip - 跳过"></a>skip - 跳过</h3><p>跳过指定数量的元素</p>
<p><code>public final Flux&lt;T&gt; skip(long skipped)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125211138683.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>102</p>
</blockquote>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>忽略来自该Flux的元素，并将其完成信号转换为所新提供Mono的发射和完成信号，订阅者只处理Mono数据</p>
<img src="/images/响应式编程-ProjectReactor/image-20221128102520007.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .doOnNext(item -&gt; System.out.println(<span class="string">"doOnNext:"</span> + item))</span><br><span class="line">        .then(Mono.just(<span class="number">7</span>))</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doOnNext:1<br>doOnNext:2<br>doOnNext:3<br>doOnNext:4<br>doOnNext:5<br>doOnNext:6<br>7</p>
</blockquote>
<h3 id="thenMany"><a href="#thenMany" class="headerlink" title="thenMany"></a>thenMany</h3><p>让这个Flux完成后使用新的Flux，订阅者只处理新Flux数据</p>
<img src="/images/响应式编程-ProjectReactor/image-20221128102707085.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        .doOnNext(item -&gt; System.out.println(<span class="string">"doOnNext:"</span> + item))</span><br><span class="line">        .thenMany(Flux.just(<span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doOnNext:1<br>doOnNext:2<br>doOnNext:3<br>doOnNext:4<br>doOnNext:5<br>doOnNext:6<br>8<br>9</p>
</blockquote>
<h3 id="next-只获取一个数据"><a href="#next-只获取一个数据" class="headerlink" title="next - 只获取一个数据"></a>next - 只获取一个数据</h3><p>只获取一个数据到一个新的Mono。如果为空，则发出一个空的Mono。</p>
<img src="/images/响应式编程-ProjectReactor/image-20221129101025401.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono&lt;Integer&gt; next = Flux</span><br><span class="line">        .range(<span class="number">1000</span>, <span class="number">5</span>)</span><br><span class="line">        .next();</span><br><span class="line">next.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000</p>
</blockquote>
<h3 id="take-获取前N个数据"><a href="#take-获取前N个数据" class="headerlink" title="take - 获取前N个数据"></a>take - 获取前N个数据</h3><p><code>public final Flux&lt;T&gt; take(long n)</code></p>
<p>获取前N个数据后取消订阅剩余数据</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125162702366.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">        .take(<span class="number">2</span>)<span class="comment">//只获取2条数据</span></span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>100<br>101</p>
</blockquote>
<h3 id="takeLast-获取后N个数据"><a href="#takeLast-获取后N个数据" class="headerlink" title="takeLast - 获取后N个数据"></a>takeLast - 获取后N个数据</h3><p><code>public final Flux&lt;T&gt; takeLast(int n)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125163614773.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">        .takeLast(<span class="number">2</span>)</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>101<br>102</p>
</blockquote>
<h3 id="takeUntil-传递值，直到条件满足则停止"><a href="#takeUntil-传递值，直到条件满足则停止" class="headerlink" title="takeUntil - 传递值，直到条件满足则停止"></a>takeUntil - 传递值，直到条件满足则停止</h3><p><code>public final Flux&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125164347476.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">        .takeUntil(num -&gt; num == <span class="number">101</span>)<span class="comment">//传递100、101，此时规则为true，停止传递数据</span></span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>100<br>101</p>
</blockquote>
<h3 id="elementAt-根据索引获取数据"><a href="#elementAt-根据索引获取数据" class="headerlink" title="elementAt - 根据索引获取数据"></a>elementAt - 根据索引获取数据</h3><p><code>public final Mono&lt;T&gt; elementAt(int index)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125164749737.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line">        .elementAt(<span class="number">2</span>)</span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>102</p>
</blockquote>
<h3 id="takeUntilOther-获取数据直到另一数据流数据到来，则停止该流处理"><a href="#takeUntilOther-获取数据直到另一数据流数据到来，则停止该流处理" class="headerlink" title="takeUntilOther - 获取数据直到另一数据流数据到来，则停止该流处理"></a>takeUntilOther - 获取数据直到另一数据流数据到来，则停止该流处理</h3><p><code>public final Flux&lt;T&gt; takeUntilOther(Publisher&lt;?&gt; other)</code></p>
<h3 id="skipUntilOther-Publisher-跳过数据直到另一数据流数据到来，才开始该流处理"><a href="#skipUntilOther-Publisher-跳过数据直到另一数据流数据到来，才开始该流处理" class="headerlink" title="skipUntilOther(Publisher) - 跳过数据直到另一数据流数据到来，才开始该流处理"></a>skipUntilOther(Publisher) - 跳过数据直到另一数据流数据到来，才开始该流处理</h3><p><code>public final Flux&lt;T&gt; skipUntilOther(Publisher&lt;?&gt; other)</code></p>
<p>takeUntilOther与skipUntilOther结合的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Flux，它发出从0开始增长，并在全局计时器上按指定的时间间隔递增。第一个元素在等于周期的初始延迟之后发出</span></span><br><span class="line">   Flux.interval(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">           .map(item -&gt; <span class="string">"item "</span> + item)</span><br><span class="line">           .doOnNext(System.out::println)</span><br><span class="line">           <span class="comment">//跳过前面的数据，当第三秒mono数据量加入时触发下面的subscribe打印"onNext: " + item</span></span><br><span class="line">           .skipUntilOther(Mono.just(<span class="string">"start"</span>).delayElement(Duration.ofSeconds(<span class="number">3</span>)))</span><br><span class="line">           <span class="comment">//处理数据，当第六秒时停止处理</span></span><br><span class="line">           .takeUntilOther(Mono.just(<span class="string">"end"</span>).delayElement(Duration.ofSeconds(<span class="number">6</span>)))</span><br><span class="line">           .subscribe(</span><br><span class="line">                   item -&gt; System.out.println(<span class="string">"onNext: "</span> + item),</span><br><span class="line">                   ex -&gt; System.err.println(<span class="string">"onError: "</span> + ex),</span><br><span class="line">                   () -&gt; System.out.println(<span class="string">"onCompleted"</span>)</span><br><span class="line">           );</span><br><span class="line">   Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>item 0<br>item 1<br>item 2<br>onNext: item 2<br>item 3<br>onNext: item 3<br>item 4<br>onNext: item 4<br>onCompleted</p>
</blockquote>
<h3 id="all-全部符合为rue"><a href="#all-全部符合为rue" class="headerlink" title="all - 全部符合为rue"></a>all - 全部符合为rue</h3><p><code>public final Mono&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125205639146.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">        .all(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>true</p>
</blockquote>
<h3 id="any-任一符合为rue"><a href="#any-任一符合为rue" class="headerlink" title="any - 任一符合为rue"></a>any - 任一符合为rue</h3><p><code>public final Mono&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125205906914.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .any(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>true</p>
</blockquote>
<blockquote>
</blockquote>
<h3 id="hasElement-是否含有指定元素"><a href="#hasElement-是否含有指定元素" class="headerlink" title="hasElement - 是否含有指定元素"></a>hasElement - 是否含有指定元素</h3><p>操作符检查流中是否包含某个所需的元素。短路逻辑，在元素与值匹配时立即返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .hasElement(<span class="number">5</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>true</p>
</blockquote>
<h3 id="repeat-重复操作"><a href="#repeat-重复操作" class="headerlink" title="repeat - 重复操作"></a>repeat - 重复操作</h3><p><code>public final Flux&lt;T&gt; repeat()</code>无限订阅</p>
<p><code>public final Flux&lt;T&gt; repeat(long numRepeat)</code>再原有基础上再订阅numRepeat次</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125213259115.png" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">100</span>)</span><br><span class="line">        .repeat(<span class="number">2</span>)<span class="comment">//再原有基础上再重复订阅2次</span></span><br><span class="line">        .doOnNext(System.out::println)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>100<br>100<br>100</p>
</blockquote>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><h4 id="distinctUntilChanged-局部去重"><a href="#distinctUntilChanged-局部去重" class="headerlink" title="distinctUntilChanged - 局部去重"></a>distinctUntilChanged - 局部去重</h4><p><code>public final Flux&lt;T&gt; distinctUntilChanged()</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125214421792.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        .distinctUntilChanged()<span class="comment">//局部范围去重</span></span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1</p>
<p>2</p>
<p>3</p>
<p>1</p>
<p>2</p>
</blockquote>
<h4 id="distinct-全局去重"><a href="#distinct-全局去重" class="headerlink" title="distinct - 全局去重"></a>distinct - 全局去重</h4><p><code>public final Flux&lt;T&gt; distinct()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        .distinct()<span class="comment">//全局去重</span></span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1</p>
<p>2</p>
<p>3</p>
</blockquote>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="reduce-前一步结果与当前元素组合"><a href="#reduce-前一步结果与当前元素组合" class="headerlink" title="reduce - 前一步结果与当前元素组合"></a>reduce - 前一步结果与当前元素组合</h4><p><code>public final &lt;A&gt; Mono&lt;A&gt; reduce(A initial, BiFunction&lt;A, ? super T, A&gt; accumulator)</code></p>
<p>使用BiFunction会将前一步的结果（首次为初始值）与当前的元素组合在一起</p>
<img src="/images/响应式编程-ProjectReactor/image-20221125220330299.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    	<span class="comment">//0位初始值</span></span><br><span class="line">        .reduce(<span class="number">0</span>,(item1,item2)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"item1:"</span> + item1);</span><br><span class="line">            System.out.println(<span class="string">"item2:"</span> + item2);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span> item1 + item2;</span><br><span class="line">        &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>item1:0<br>item2:1</p>
<p>item1:1<br>item2:2</p>
<p>item1:3<br>item2:3</p>
<p>item1:6<br>item2:4</p>
<p>item1:10<br>item2:5</p>
<p>15</p>
</blockquote>
<h4 id="scan-前一步结果与当前元素组合"><a href="#scan-前一步结果与当前元素组合" class="headerlink" title="scan  - 前一步结果与当前元素组合"></a>scan  - 前一步结果与当前元素组合</h4><p>与reduce类似，区别在于scan会将中间结果打印</p>
<p><code>public final &lt;A&gt; Flux&lt;A&gt; scan(A initial, BiFunction&lt;A, ? super T, A&gt; accumulator)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125220833268.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">        .scan(<span class="comment">/*初始值*/</span><span class="number">0</span>,(<span class="comment">/*前一步的结果（首次为初始值）*/</span>num1,<span class="comment">/*新一轮传递过来的值*/</span>num2) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"num1:"</span> + num1);</span><br><span class="line">            System.out.println(<span class="string">"num2:"</span> + num2);</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0<br>num1:0<br>num2:1<br>1<br>num1:1<br>num2:2<br>3<br>num1:3<br>num2:3<br>6<br>num1:6<br>num2:4<br>10<br>num1:10<br>num2:5<br>15</p>
</blockquote>
<h4 id="concat-组合多个流，流之间存在顺序"><a href="#concat-组合多个流，流之间存在顺序" class="headerlink" title="concat - 组合多个流，流之间存在顺序"></a>concat - 组合多个流，流之间存在顺序</h4><p>通过向下游转发接收的元素来连接所有数据源。当操作符连接两个流时，它首先消费并重新发送第一个流的所有元素，然后对第二个流执行相同的操作。</p>
<p><code>public static &lt;T&gt; Flux&lt;T&gt; concat(Publisher&lt;? extends T&gt;... sources)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126103524182.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.concat(</span><br><span class="line">        Flux.range(<span class="number">10</span>,<span class="number">5</span>).delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .doOnSubscribe(subscription -&gt; System.out.println(<span class="string">"订阅第一个流"</span>)),</span><br><span class="line">        Flux.range(<span class="number">100</span>,<span class="number">5</span>).delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .doOnSubscribe(subscription -&gt; System.out.println(<span class="string">"订阅第二流"</span>))</span><br><span class="line">).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>订阅第一个流<br>10<br>11<br>12<br>13<br>14<br>订阅第二流<br>100<br>101<br>102<br>103<br>104</p>
</blockquote>
<h4 id="merge-组合多个流，流之间无顺序"><a href="#merge-组合多个流，流之间无顺序" class="headerlink" title="merge  - 组合多个流，流之间无顺序"></a>merge  - 组合多个流，流之间无顺序</h4><p>将来自上游序列的数据合并到一个下游序列中。与 concat 操作符不同，上游数据源是立即（<strong>同时</strong>）被订阅的。</p>
<p><code>public static &lt;T&gt; Flux&lt;T&gt; merge(Publisher&lt;? extends T&gt;... sources)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126103808707.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.merge(</span><br><span class="line">        Flux.range(<span class="number">10</span>,<span class="number">5</span>).delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">                .doOnSubscribe(subscription -&gt; System.out.println(<span class="string">"订阅第一个流"</span>)),</span><br><span class="line">        Flux.range(<span class="number">100</span>,<span class="number">5</span>).delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">                .doOnSubscribe(subscription -&gt; System.out.println(<span class="string">"订阅第二流"</span>))</span><br><span class="line">).subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>订阅第一个流<br>订阅第二流<br>100<br>10<br>101<br>11<br>102<br>12<br>103<br>13<br>104<br>14</p>
</blockquote>
<h4 id="zip-压缩合并为二元数据"><a href="#zip-压缩合并为二元数据" class="headerlink" title="zip - 压缩合并为二元数据"></a>zip - 压缩合并为二元数据</h4><p>将两个源压缩到一起，也就是说，等待所有源发出一个元素，并将这些元素合并到Tuple2中。操作符将继续这样做，直到任何一个源完成。</p>
<p><code>public static &lt;T1, T2&gt; Flux&lt;Tuple2&lt;T1, T2&gt;&gt; zip(Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126104608798.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.zip(</span><br><span class="line">        Flux.range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">10</span>)),</span><br><span class="line">        Flux.range(<span class="number">100</span>,<span class="number">10</span>)</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">10</span>))</span><br><span class="line">        ).subscribe(System.out::println);</span><br><span class="line">        Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1,100]<br>[2,101]<br>[3,102]<br>[4,103]<br>[5,104]<br>[6,105]<br>[7,106]<br>[8,107]<br>[9,108]<br>[10,109]</p>
</blockquote>
<h4 id="combineLatest-压缩合并数据，以新值为准使用自定义函数"><a href="#combineLatest-压缩合并数据，以新值为准使用自定义函数" class="headerlink" title="combineLatest - 压缩合并数据，以新值为准使用自定义函数"></a>combineLatest - 压缩合并数据，以新值为准使用自定义函数</h4><p>都是压缩合并数据，与zip不同的是，combineLatest 数据是由来自两个Publisher源的最新发布值的组合生成的。</p>
<p><code>public static &lt;T1, T2, V&gt; Flux&lt;V&gt; combineLatest(Publisher&lt;? extends T1&gt; source1,Publisher&lt;? extends T2&gt; source2,BiFunction&lt;? super T1, ? super T2, ? extends V&gt; combinator)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126105655754.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.combineLatest(</span><br><span class="line">        Flux.range(<span class="number">1</span>,<span class="number">10</span>).delayElements(Duration.ofMillis(<span class="number">1000</span>)),</span><br><span class="line">        Flux.range(<span class="number">100</span>,<span class="number">10</span>).delayElements(Duration.ofMillis(<span class="number">2000</span>)),</span><br><span class="line">        ((integer1, integer2) -&gt; integer1 + <span class="string">"=="</span> +integer2)<span class="comment">//聚合函数，它将从每个上游接收最新的值并将该值返回给下游信号</span></span><br><span class="line">).subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1==100<br>2==100<br>3==100<br>4==100<br>4==101<br>5==101<br>5==102<br>6==102<br>7==102<br>7==103<br>8==103<br>9==103</p>
</blockquote>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><h4 id="buffer-达到缓冲区大小时，传递数据"><a href="#buffer-达到缓冲区大小时，传递数据" class="headerlink" title="buffer - 达到缓冲区大小时，传递数据"></a>buffer - 达到缓冲区大小时，传递数据</h4><p>将传入的值收集到多个List缓冲区中，这些缓冲区将在每次达到给定的最大大小或在此Flux完成时由返回的Flux发出。</p>
<p><code>public final Flux&lt;List&lt;T&gt;&gt; buffer(int maxSize)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126112534233.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">        .buffer(<span class="number">10</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]<br>[21, 22, 23, 24, 25, 26, 27, 28, 29, 30]<br>[31, 32, 33, 34, 35, 36, 37, 38, 39, 40]<br>[41, 42, 43, 44, 45, 46, 47, 48, 49, 50]<br>[51, 52, 53, 54, 55, 56, 57, 58, 59, 60]<br>[61, 62, 63, 64, 65, 66, 67, 68, 69, 70]<br>[71, 72, 73, 74, 75, 76, 77, 78, 79, 80]<br>[81, 82, 83, 84, 85, 86, 87, 88, 89, 90]<br>[91, 92, 93, 94, 95, 96, 97, 98, 99, 100]</p>
</blockquote>
<h4 id="windowUntil-满足窗口条件时传递数据"><a href="#windowUntil-满足窗口条件时传递数据" class="headerlink" title="windowUntil - 满足窗口条件时传递数据"></a>windowUntil - 满足窗口条件时传递数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">101</span>, <span class="number">20</span>)</span><br><span class="line">    	<span class="comment">//第一个参数：为true时创建新的窗口</span></span><br><span class="line">    	<span class="comment">//第二个参数：为true时加入新的窗口，false加入旧窗口</span></span><br><span class="line">        .windowUntil(<span class="comment">/**判断是否为质数*/</span>ReactorDemo::isPrime, <span class="keyword">true</span>)</span><br><span class="line">        .subscribe(</span><br><span class="line">                data -&gt; data.collectList()</span><br><span class="line">                        .subscribe(</span><br><span class="line">                                item -&gt; System.out.println(<span class="string">"window:"</span> + item)</span><br><span class="line">                        )</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二个参数为true时：<br>window:[]<br>window:[101, 102]<br>window:[103, 104, 105, 106]<br>window:[107, 108]<br>window:[109, 110, 111, 112]<br>window:[113, 114, 115, 116, 117, 118, 119, 120]</p>
<p>第二个参数为false时：<br>window:[101]<br>window:[102, 103]<br>window:[104, 105, 106, 107]<br>window:[108, 109]<br>window:[110, 111, 112, 113]<br>window:[114, 115, 116, 117, 118, 119, 120]</p>
</blockquote>
<h4 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">        .groupBy(item -&gt; item % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"偶数"</span> : <span class="string">"奇数"</span>)</span><br><span class="line">        .subscribe(groupFlux -&gt;</span><br><span class="line">                groupFlux.scan(</span><br><span class="line">                                <span class="comment">/*初始值*/</span><span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">                                (<span class="comment">/*前一步的结果（首次为初始值）*/</span>list, <span class="comment">/*新一轮传递过来的值*/</span>element) -&gt; &#123;</span><br><span class="line">                                    list.add(element);</span><br><span class="line">                                    <span class="keyword">return</span> list;</span><br><span class="line">                                &#125;).filter(list -&gt; !list.isEmpty()).</span><br><span class="line">                        subscribe(item -&gt; System.out.println(groupFlux.key() + <span class="string">"======"</span> + item))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>奇数======[1]<br>偶数======[2]<br>奇数======[1, 3]<br>偶数======[2, 4]<br>奇数======[1, 3, 5]<br>偶数======[2, 4, 6]<br>奇数======[1, 3, 5, 7]</p>
</blockquote>
<h3 id="thenMany-触发新流"><a href="#thenMany-触发新流" class="headerlink" title="thenMany - 触发新流"></a>thenMany - 触发新流</h3><img src="/images/响应式编程-ProjectReactor/image-20221125221720220.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .doOnNext(item -&gt; System.out.println(item))</span><br><span class="line">        .thenMany(Flux.just(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
</blockquote>
<h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="普通List"><a href="#普通List" class="headerlink" title="普通List"></a>普通List</h5><p>收集此Flux发出的所有元素到一个List中，该List在此序列完成时由结果Mono发出。</p>
<p><code>public final Mono&lt;List&lt;T&gt;&gt; collectList()</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221126112948110.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">36</span>,<span class="number">4</span>,<span class="number">25</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">.collectList()</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1, 2, 36, 4, 25, 6, 7]</p>
</blockquote>
<h5 id="排序List"><a href="#排序List" class="headerlink" title="排序List"></a>排序List</h5><p><code>public final Mono&lt;List&lt;T&gt;&gt; collectSortedList(@Nullable Comparator&lt;? super T&gt; comparator)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125172110724.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">36</span>,<span class="number">4</span>,<span class="number">25</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">      <span class="comment">//CollectionSoredList 默认是升序</span></span><br><span class="line">      .collectSortedList(Comparator.reverseOrder())</span><br><span class="line">      .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[36, 25, 7, 6, 4, 2, 1]<br>收集集合中的序列元素可能耗费资源，当序列具有许多元素时这种现象尤为突出。此外，尝试在无限流上收集数据可能消耗所有可用的内存。</p>
</blockquote>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="自定义key值"><a href="#自定义key值" class="headerlink" title="自定义key值"></a>自定义key值</h5><p><code>public final &lt;K&gt; Mono&lt;Map&lt;K, T&gt;&gt; collectMap(Function&lt;? super T, ? extends K&gt; keyExtractor)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125173941191.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">      .collectMap(item -&gt; <span class="string">"key"</span> + item)</span><br><span class="line">      .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>{key1=1, key2=2, key5=5, key6=6, key3=3, key4=4}</p>
</blockquote>
<h5 id="自定义key、value值"><a href="#自定义key、value值" class="headerlink" title="自定义key、value值"></a>自定义key、value值</h5><p><code>public final &lt;K, V&gt; Mono&lt;Map&lt;K, V&gt;&gt; collectMap(Function&lt;? super T, ? extends K&gt; keyExtractor,Function&lt;? super T, ? extends V&gt; valueExtractor)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125174159354.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .collectMap(</span><br><span class="line">  item -&gt; <span class="string">"key-"</span> + item,</span><br><span class="line">  item -&gt; <span class="string">"value-"</span> + item</span><br><span class="line">).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>{key-1=value-1, key-5=value-5, key-4=value-4, key-3=value-3, key-2=value-2, key-6=value-6}</p>
</blockquote>
<h5 id="自定义key、value值、map工厂"><a href="#自定义key、value值、map工厂" class="headerlink" title="自定义key、value值、map工厂"></a>自定义key、value值、map工厂</h5><p><code>public final &lt;K, V&gt; Mono&lt;Map&lt;K, V&gt;&gt; collectMap(final Function&lt;? super T, ? extends K&gt; keyExtractor,final Function&lt;? super T, ? extends V&gt; valueExtractor,Supplier&lt;Map&lt;K, V&gt;&gt; mapSupplier)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        .collectMap(</span><br><span class="line">                integer -&gt; <span class="string">"key-"</span> + integer,</span><br><span class="line">                integer -&gt; <span class="string">"value-"</span> + integer,</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">7</span> ;i &lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                        map.put(<span class="string">"key:"</span> + i ,<span class="string">"value:"</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>{key-1=value-1, key-5=value-5, key-4=value-4, key-3=value-3, key-2=value-2, key-6=value-6, key:9=value:9, key:8=value:8, key:7=value:7}</p>
</blockquote>
<h4 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h4><h5 id="多值map，自定义key、value"><a href="#多值map，自定义key、value" class="headerlink" title="多值map，自定义key、value"></a>多值map，自定义key、value</h5><p><code>public final &lt;K, V&gt; Mono&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; collectMultimap(Function&lt;? super T, ? extends K&gt; keyExtractor,Function&lt;? super T, ? extends V&gt; valueExtractor)</code></p>
<img src="/images/响应式编程-ProjectReactor/image-20221125181532025.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .collectMultimap(</span><br><span class="line">                item -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (item % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"key-2"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"key-1"</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                item -&gt; <span class="string">"value-"</span> + item</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>{</p>
<p>​    key-1=[value-1, value-3, value-5],</p>
<p>​    key-2=[value-2, value-4]</p>
<p>}</p>
</blockquote>
<h5 id="多值map，自定义key、value、map工厂"><a href="#多值map，自定义key、value、map工厂" class="headerlink" title="多值map，自定义key、value、map工厂"></a>多值map，自定义key、value、map工厂</h5><p><code>public final &lt;K, V&gt; Mono&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; collectMultimap(final Function&lt;? super T, ? extends K&gt; keyExtractor,final Function&lt;? super T, ? extends V&gt; valueExtractor,Supplier&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapSupplier</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .collectMultimap(</span><br><span class="line">                item -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (item % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"key-2"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"key-1"</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                item -&gt; <span class="string">"value-"</span> + item,</span><br><span class="line">                <span class="comment">// 扩充</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    Map map = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line">                    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                            list.add(<span class="string">"ele:"</span> + j);</span><br><span class="line">                        &#125;</span><br><span class="line">                        map.put(i + <span class="string">"-key"</span>, list);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> map;</span><br><span class="line">                &#125;</span><br><span class="line">        ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>{</p>
<p>​    key-1=[value-1, value-3, value-5], </p>
<p>​    2-key=[ele:0, ele:0, ele:1], </p>
<p>​    key-2=[value-2, value-4],</p>
<p>​    0-key=[ele:0, ele:0, ele:1], </p>
<p>​    1-key=[ele:0, ele:0, ele:1]</p>
<p>}</p>
</blockquote>
<h3 id="转换阻塞结构"><a href="#转换阻塞结构" class="headerlink" title="转换阻塞结构"></a>转换阻塞结构</h3><h4 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterable&lt;Integer&gt; integers = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .toIterable();</span><br><span class="line"><span class="keyword">for</span> (Integer num : integers) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>3<br>4</p>
</blockquote>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).toStream();</span><br><span class="line">integerStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>3</p>
</blockquote>
<h4 id="BlockFirst"><a href="#BlockFirst" class="headerlink" title="BlockFirst"></a>BlockFirst</h4><p>阻塞了当前线程，直到上游发出第一个值或完成流为止</p>
<img src="/images/响应式编程-ProjectReactor/image-20221128095838549.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .doOnNext(item -&gt; System.out.println(<span class="string">"onNext:"</span> + item))</span><br><span class="line">        .blockFirst();</span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onNext:1<br>1</p>
</blockquote>
<h4 id="blockLast"><a href="#blockLast" class="headerlink" title="blockLast"></a>blockLast</h4><p>阻塞当前线程，直到上游发出最后一个值或完成流为止。在 onError的情况下，它会在被阻塞的线程中抛出异常。</p>
<img src="/images/响应式编程-ProjectReactor/image-20221128101415871.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer2 = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .doOnNext(item -&gt; System.out.println(<span class="string">"onNext:"</span> + item))</span><br><span class="line">        .blockLast();</span><br><span class="line">System.out.println(integer2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onNext:1<br>onNext:2<br>onNext:3<br>3</p>
</blockquote>
<h3 id="物化和非物化信号"><a href="#物化和非物化信号" class="headerlink" title="物化和非物化信号"></a>物化和非物化信号</h3><p>将流中的元素封装为Signal对象进行处理。</p>
<h4 id="正常调用"><a href="#正常调用" class="headerlink" title="正常调用"></a>正常调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Flux.just(1, 2, 3)</span><br><span class="line">            .delayElements(Duration.ofMillis(1000))</span><br><span class="line">            .publishOn(Schedulers.parallel())</span><br><span class="line">            .concatWith(Flux.error(new Exception(&quot;手动异常&quot;)))</span><br><span class="line">            .doOnEach(item -&gt; System.out.println(&quot;是否完成：&quot; + item.isOnComplete()))</span><br><span class="line">            .subscribe(System.out::println);</span><br><span class="line">    Thread.sleep(10 * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否完成：false<br>1<br>是否完成：false<br>2<br>是否完成：false<br>3<br>是否完成：false<br>[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 手动异常<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 手动异常<br>Caused by: java.lang.Exception: 手动异常<br>    at com.yrl.reactor.ReactorDemo.main(ReactorDemo.java:12)</p>
</blockquote>
<h4 id="物化调用"><a href="#物化调用" class="headerlink" title="物化调用"></a>物化调用</h4><img src="/images/响应式编程-ProjectReactor/image-20221128145513167.png" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .delayElements(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">    .publishOn(Schedulers.parallel())</span><br><span class="line">    .concatWith(Flux.error(<span class="keyword">new</span> Exception(<span class="string">"手动异常"</span>)))</span><br><span class="line">    .materialize()</span><br><span class="line">    .doOnEach(item -&gt; System.out.println(<span class="string">"是否完成："</span> + item.isOnComplete()))</span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否完成：false<br>onNext(1)<br>是否完成：false<br>onNext(2)<br>是否完成：false<br>onNext(3)<br>是否完成：false<br>onError(java.lang.Exception: 手动异常)<br>是否完成：true</p>
</blockquote>
<h4 id="非物化调用"><a href="#非物化调用" class="headerlink" title="非物化调用"></a>非物化调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .delayElements(Duration.ofMillis(<span class="number">1000</span>))</span><br><span class="line">    .publishOn(Schedulers.parallel())</span><br><span class="line">    .concatWith(Flux.error(<span class="keyword">new</span> Exception(<span class="string">"手动异常"</span>)))</span><br><span class="line">    .materialize()</span><br><span class="line">    .doOnEach(item -&gt; System.out.println(<span class="string">"是否完成："</span> + item.isOnComplete()))</span><br><span class="line">    .dematerialize()<span class="comment">//需要搭配materialize一起使用</span></span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否完成：false<br>1<br>是否完成：false<br>2<br>是否完成：false<br>3<br>是否完成：false<br>[ERROR] (parallel-1) Operator called default onErrorDropped - reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 手动异常<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.Exception: 手动异常<br>Caused by: java.lang.Exception: 手动异常<br>    at com.yrl.reactor.ReactorDemo.main(ReactorDemo.java:12)</p>
</blockquote>
<h3 id="冷热数据"><a href="#冷热数据" class="headerlink" title="冷热数据"></a>冷热数据</h3><p>冷发布者：无论订阅者何时出现，都为该订阅者生成所有的序列数据，没有订阅者就不会生成数据。</p>
<p>热发布者：数据的生成不依赖于订阅者而存在，数据可能在第一个订阅者出现之间就开始产生了。</p>
<h4 id="冷发布"><a href="#冷发布" class="headerlink" title="冷发布"></a>冷发布</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; coldPublisher = Flux.defer(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"生成数据"</span>);</span><br><span class="line">    <span class="keyword">return</span> Flux.just(UUID.randomUUID().toString());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"尚未生成数据"</span>);</span><br><span class="line">coldPublisher.subscribe(e -&gt; System.out.println(<span class="string">"onNext:"</span> + e));</span><br><span class="line">coldPublisher.subscribe(e -&gt; System.out.println(<span class="string">"onNext:"</span> + e));</span><br><span class="line">System.out.println(<span class="string">"为两次订阅生成两次数据"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尚未生成数据<br>生成数据<br>onNext:1d496bec-d1be-4274-b24a-74ece485e51a<br>生成数据<br>onNext:19ab947e-bfd7-4600-9ffe-0e3a0b91c58c<br>为两次订阅生成两次数据</p>
</blockquote>
<h4 id="冷发布同时订阅通知"><a href="#冷发布同时订阅通知" class="headerlink" title="冷发布同时订阅通知"></a>冷发布同时订阅通知</h4><p>使用publish()返回的 ConnectableFlux 可以向几个订阅者多播事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; coldPublisher = Flux.defer(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"生成数据"</span>);</span><br><span class="line">    <span class="keyword">return</span> Flux.just(UUID.randomUUID().toString());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"尚未生成数据"</span>);</span><br><span class="line">ConnectableFlux&lt;String&gt; connectableFlux = coldPublisher.publish();</span><br><span class="line">connectableFlux.subscribe(e -&gt; System.out.println(<span class="string">"onNext:"</span> + e));</span><br><span class="line">connectableFlux.subscribe(e -&gt; System.out.println(<span class="string">"onNext:"</span> + e));</span><br><span class="line">System.out.println(<span class="string">"准备建立连接"</span>);</span><br><span class="line">connectableFlux.connect();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尚未生成数据<br>准备建立连接<br>生成数据<br>onNext:ad8292c5-3d65-488e-9659-cdc7a7a2a559<br>onNext:ad8292c5-3d65-488e-9659-cdc7a7a2a559</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; source = Flux.range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">        .doOnSubscribe(s -&gt; System.out.println(<span class="string">"对冷发布者的新订阅票据："</span> + s));</span><br><span class="line"><span class="comment">//准备一个ConnectableFlux，它共享此Flux序列，并以反压力感知的方式将值分发给订阅者</span></span><br><span class="line">ConnectableFlux&lt;Integer&gt; conn = source.publish();</span><br><span class="line">conn.subscribe(item -&gt; System.out.println(<span class="string">"[subscriber 1] onNext:"</span> + item));</span><br><span class="line">conn.subscribe(item -&gt; System.out.println(<span class="string">"[subscriber 2] onNext:"</span> + item));</span><br><span class="line">System.out.println(<span class="string">"准备建立连接"</span>);</span><br><span class="line">conn.connect();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>准备建立连接<br>对冷发布者的新订阅票据：reactor.core.publisher.FluxRange$RangeSubscription@22a71081<br>[subscriber 1] onNext:0<br>[subscriber 2] onNext:0<br>[subscriber 1] onNext:1<br>[subscriber 2] onNext:1<br>[subscriber 1] onNext:2<br>[subscriber 2] onNext:2</p>
</blockquote>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; source = Flux.range(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">        .doOnSubscribe(s -&gt; System.out.println(<span class="string">"冷发布者的新订阅数据"</span>));</span><br><span class="line">Flux&lt;Integer&gt; cacheSource = source.cache(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">cacheSource.subscribe(item -&gt; System.out.println(<span class="string">"[subscribe 1] on Next:"</span> +item));</span><br><span class="line">cacheSource.subscribe(item -&gt; System.out.println(<span class="string">"[subscribe 2] on Next:"</span> +item));</span><br><span class="line">Thread.sleep(<span class="number">1200</span>);<span class="comment">//缓存超时，重新订阅生成数据</span></span><br><span class="line">cacheSource.subscribe(item -&gt; System.out.println(<span class="string">"[subscribe 3] on Next:"</span> +item));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>冷发布者的新订阅数据<br>[subscribe 1] on Next:0<br>[subscribe 1] on Next:1<br>[subscribe 1] on Next:2<br>[subscribe 1] on Next:3<br>[subscribe 1] on Next:4<br>[subscribe 2] on Next:0<br>[subscribe 2] on Next:1<br>[subscribe 2] on Next:2<br>[subscribe 2] on Next:3<br>[subscribe 2] on Next:4<br>冷发布者的新订阅数据<br>[subscribe 3] on Next:0<br>[subscribe 3] on Next:1<br>[subscribe 3] on Next:2<br>[subscribe 3] on Next:3<br>[subscribe 3] on Next:4</p>
</blockquote>
<h4 id="共享-热发布"><a href="#共享-热发布" class="headerlink" title="共享-热发布"></a>共享-热发布</h4><p>使用publish()需要等待订阅者出现才能开始处理。</p>
<p>share可以将冷发布者转变为热发布者，会为每个新订阅者传播订阅者尚未错过的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;Integer&gt; source = Flux.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .doOnSubscribe(s -&gt; System.out.println(<span class="string">"冷发布者新的订阅票据"</span>));</span><br><span class="line">Flux&lt;Integer&gt; shareSource = source.share();</span><br><span class="line">shareSource.subscribe(item -&gt; System.out.println(<span class="string">"subscribe 1 onNext:"</span> + item));</span><br><span class="line">Thread.sleep(<span class="number">400</span>);</span><br><span class="line">shareSource.subscribe(item -&gt; System.out.println(<span class="string">"subscribe 2 onNext:"</span> + item));</span><br><span class="line">Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>冷发布者新的订阅票据<br>subscribe 1 onNext:0<br>subscribe 1 onNext:1<br>subscribe 1 onNext:2<br>subscribe 1 onNext:3<br>subscribe 2 onNext:3<br>subscribe 1 onNext:4<br>subscribe 2 onNext:4</p>
</blockquote>
]]></content>
      <categories>
        <category>spring</category>
        <category>webflux</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>webflux</tag>
      </tags>
  </entry>
</search>
