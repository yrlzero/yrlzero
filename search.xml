<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JackJson和FastJson常见操作</title>
    <url>/2020/11/29/JackJson%E5%92%8CFastJson%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="Jackjson"><a href="#Jackjson" class="headerlink" title="Jackjson"></a>Jackjson</h3><a id="more"></a>

<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//Include.ALWAYS  是序列化对像所有属性</span></span><br><span class="line"><span class="comment">//Include.NON_NULL 只有不为null的字段才被序列化</span></span><br><span class="line"><span class="comment">//Include.NON_EMPTY 如果为null或者 空字符串和空集合都不会被序列化</span></span><br><span class="line">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line"><span class="comment">//取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式</span></span><br><span class="line">objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//如果是空对象的时候,设置为false不抛异常,也就是对应的属性没有get方法,默认是true,即会抛异常</span></span><br><span class="line">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//反序列化的时候如果多了其他属性,不抛出异常  </span></span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">      <span class="comment"># 设置属性命名策略,对应jackson下PropertyNamingStrategy中的常量值，SNAKE_CASE-返回的json驼峰式转下划线，json body下划线传到后端自动转驼峰式</span></span><br><span class="line">      <span class="attr">property-naming-strategy:</span> <span class="string">SNAKE_CASE</span></span><br><span class="line">      <span class="comment"># 全局设置@JsonFormat的格式pattern</span></span><br><span class="line">      <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">      <span class="comment"># 当地时区</span></span><br><span class="line">      <span class="attr">locale:</span> <span class="string">zh</span></span><br><span class="line">      <span class="comment"># 设置全局时区</span></span><br><span class="line">      <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">      <span class="comment"># 常用，全局设置pojo或被@JsonInclude注解的属性的序列化方式</span></span><br><span class="line">      <span class="attr">default-property-inclusion:</span> <span class="string">NON_NULL</span> <span class="comment">#不为空的属性才会序列化,具体属性可看JsonInclude.Include</span></span><br><span class="line">      <span class="comment"># 常规默认,枚举类SerializationFeature中的枚举属性为key，值为boolean设置jackson序列化特性,具体key请看SerializationFeature源码</span></span><br><span class="line">      <span class="attr">serialization:</span></span><br><span class="line">        <span class="attr">WRITE_DATES_AS_TIMESTAMPS:</span> <span class="literal">true</span> <span class="comment"># 返回的java.util.date转换成timestamp</span></span><br><span class="line">        <span class="attr">FAIL_ON_EMPTY_BEANS:</span> <span class="literal">true</span> <span class="comment"># 对象为空时是否报错，默认true</span></span><br><span class="line">      <span class="comment"># 枚举类DeserializationFeature中的枚举属性为key，值为boolean设置jackson反序列化特性,具体key请看DeserializationFeature源码</span></span><br><span class="line">      <span class="attr">deserialization:</span></span><br><span class="line">        <span class="comment"># 常用,json中含pojo不存在属性时是否失败报错,默认true</span></span><br><span class="line">        <span class="attr">FAIL_ON_UNKNOWN_PROPERTIES:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 枚举类MapperFeature中的枚举属性为key，值为boolean设置jackson ObjectMapper特性</span></span><br><span class="line">      <span class="comment"># ObjectMapper在jackson中负责json的读写、json与pojo的互转、json tree的互转,具体特性请看MapperFeature,常规默认即可</span></span><br><span class="line">      <span class="attr">mapper:</span></span><br><span class="line">        <span class="comment"># 使用getter取代setter探测属性，如类中含getName()但不包含name属性与setName()，传输的vo json格式模板中依旧含name属性</span></span><br><span class="line">        <span class="attr">USE_GETTERS_AS_SETTERS:</span> <span class="literal">true</span> <span class="comment">#默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonParser.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonParser特性</span></span><br><span class="line">      <span class="comment"># JsonParser在jackson中负责json内容的读取,具体特性请看JsonParser.Feature，一般无需设置默认即可</span></span><br><span class="line">      <span class="attr">parser:</span></span><br><span class="line">        <span class="attr">ALLOW_SINGLE_QUOTES:</span> <span class="literal">true</span> <span class="comment"># 是否允许出现单引号,默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonGenerator特性，一般无需设置默认即可</span></span><br><span class="line">      <span class="comment"># JsonGenerator在jackson中负责编写json内容,具体特性请看JsonGenerator.Feature</span></span><br></pre></td></tr></table></figure>



<p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map转对象</span></span><br><span class="line">System.out.println(<span class="string">"====  map-&gt;对象 ====="</span>);</span><br><span class="line">User user = objectMapper.convertValue(map, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将对象写成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map);</span><br><span class="line">System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//json串转换成json节点对象</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;json节点对象  ====="</span>);</span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(jsonStr);</span><br><span class="line">System.out.println(jsonNode);</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"name"</span>).asText());</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"age"</span>).asInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Map param = objectMapper.readValue(jsonStr, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Person person = objectMapper.readValue(jsonStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(param);</span><br><span class="line">System.out.println(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line">String listStr = objectMapper.writeValueAsString(list);</span><br><span class="line"><span class="comment">//no.1</span></span><br><span class="line">JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List<span class="class">.<span class="keyword">class</span>, <span class="title">Person</span>.<span class="title">class</span>)</span>;</span><br><span class="line">List&lt;Person&gt; persons =  (List&lt;Person&gt;)objectMapper.readValue(listStr, javaType);</span><br><span class="line">System.out.println(persons);</span><br><span class="line"><span class="comment">//no.2</span></span><br><span class="line">List&lt;Person&gt; persons2 = objectMapper.readValue(listStr, <span class="keyword">new</span> TypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//xml转成对象</span></span><br><span class="line"><span class="comment">//对象需加上注解映射@JacksonXmlRootElement、@JacksonXmlProperty、@JacksonXmlElementWrapper、@JacksonXmlCData、@JacksonXmlText</span></span><br><span class="line">System.out.println(<span class="string">"==== xml串 --&gt; 对象 ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">User user = xmlMapper.readValue(xml, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//对象转成xml</span></span><br><span class="line">System.out.println(<span class="string">"==== 对象 --&gt; xml ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">String xmlStr = xmlMapper.writeValueAsString(user)</span><br></pre></td></tr></table></figure>

<h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将对象转换成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">24</span>);</span><br><span class="line">String jsonString = JSON.toJSONString(p);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Person person = JSON.parseObject(jsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Map map = JSON.parseObject(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonString);</span><br><span class="line">System.out.println(person);</span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(jsonObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(p);</span><br><span class="line">String listStr = JSON.toJSONString(list);</span><br><span class="line">List&lt;Person&gt; peoples = JSON.parseArray(listStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONArray jsonArray = JSON.parseArray(listStr);</span><br><span class="line">System.out.println(peoples);</span><br><span class="line">System.out.println(jsonArray);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConverterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">fastJsonHttpMessageConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.定义一个converters转换消息的对象</span></span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="comment">// 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据</span></span><br><span class="line">        FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</span><br><span class="line">        <span class="comment">// 3.在converter中添加配置信息</span></span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        <span class="comment">// 4.将converter赋值给HttpMessageConverter</span></span><br><span class="line">        HttpMessageConverter&lt;?&gt; converter = fastConverter;</span><br><span class="line">        <span class="comment">// 5.返回HttpMessageConverters对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jackson2HashMapper"><a href="#Jackson2HashMapper" class="headerlink" title="Jackson2HashMapper"></a>Jackson2HashMapper</h3><p>org.springframework.data.redis.hash</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jackson2HashMapper jackson2HashMapper = <span class="keyword">new</span> Jackson2HashMapper(objectMapper,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//对象转map</span></span><br><span class="line">Map&lt;String, Object&gt; map = jackson2HashMapper.toHash(user);</span><br><span class="line"><span class="comment">//map转对象</span></span><br><span class="line">Object o = jackson2HashMapper.fromHash(map);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>json</category>
      </categories>
  </entry>
  <entry>
    <title>JDK8新特性——时间类</title>
    <url>/2021/03/13/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<p><font size='6.5px'>JDK8新特性——时间类</font></p>
<h1 id="为什么需要使用新的时间类"><a href="#为什么需要使用新的时间类" class="headerlink" title="为什么需要使用新的时间类"></a>为什么需要使用新的时间类</h1><p>1、Date如果不格式化，打印出的日期可读性差【Tue Sep 10 09:34:04 CST 2019】；</p>
<p>2、使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的；</p>
<p>3、获取时间一些参数需要转换为calendar类获取……</p>
<a id="more"></a>

<h1 id="JDK8新特性提供的时间操作类"><a href="#JDK8新特性提供的时间操作类" class="headerlink" title="JDK8新特性提供的时间操作类"></a>JDK8新特性提供的时间操作类</h1><p>1、LocalDate    【日期】</p>
<p>2、LocalTime    【时间】</p>
<p>3、LocalDateTime    【日期时间】</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的年月日"><a href="#构造指定的年月日" class="headerlink" title="构造指定的年月日"></a>构造指定的年月日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时分秒"><a href="#构造指定的时分秒" class="headerlink" title="构造指定的时分秒"></a>构造指定的时分秒</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">12</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时日"><a href="#获取当前时日" class="headerlink" title="获取当前时日"></a>获取当前时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时日"><a href="#构造指定的时日" class="headerlink" title="构造指定的时日"></a>构造指定的时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2019</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取时间的某一个值"><a href="#获取时间的某一个值" class="headerlink" title="获取时间的某一个值"></a>获取时间的某一个值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDateTime1.getYear();   <span class="comment">//2020  年份</span></span><br><span class="line">Month month = localDateTime1.getMonth();   <span class="comment">//JUNE  月份</span></span><br><span class="line"><span class="keyword">int</span> monthValue = localDateTime1.getMonthValue();   <span class="comment">//6  月份数值</span></span><br><span class="line"><span class="keyword">int</span> day = localDateTime1.getDayOfMonth();   <span class="comment">//28  日期</span></span><br><span class="line">DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek();   <span class="comment">//SUNDAY  周</span></span><br><span class="line"><span class="keyword">int</span> dayOfYear = localDateTime1.getDayOfYear();   <span class="comment">//180  年的第几天</span></span><br><span class="line"><span class="keyword">int</span> hour = localDateTime1.getHour();   <span class="comment">//13 小时</span></span><br><span class="line"><span class="keyword">int</span> minute = localDateTime1.getMinute();   <span class="comment">//51  分钟</span></span><br><span class="line"><span class="keyword">int</span> second = localDateTime1.getSecond();   <span class="comment">//19  秒</span></span><br></pre></td></tr></table></figure>

<h2 id="LocalDateTime、LocalDate、LocalTime的转换"><a href="#LocalDateTime、LocalDate、LocalTime的转换" class="headerlink" title="LocalDateTime、LocalDate、LocalTime的转换"></a>LocalDateTime、LocalDate、LocalTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime = localTime.atDate(localDate);</span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<h2 id="将某个时间增加"><a href="#将某个时间增加" class="headerlink" title="将某个时间增加"></a>将某个时间增加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.plus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//增加2年</span></span><br><span class="line">localDateTime = localDateTime.plusYears(<span class="number">2</span>);  <span class="comment">//增加2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间减少"><a href="#将某个时间减少" class="headerlink" title="将某个时间减少"></a>将某个时间减少</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.minus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//减少2年</span></span><br><span class="line">localDateTime = localDateTime.minusYears(<span class="number">2</span>);  <span class="comment">//减少2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间参数指定"><a href="#将某个时间参数指定" class="headerlink" title="将某个时间参数指定"></a>将某个时间参数指定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime1 = localDateTime1.with(ChronoField.MONTH_OF_YEAR,<span class="number">1</span>);  <span class="comment">//指定月份为1月</span></span><br><span class="line">localDateTime1 = localDateTime1.withHour(<span class="number">2</span>);  <span class="comment">//指定小时为2时</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime.with(firstDayOfYear());  <span class="comment">//获取当年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfMonth());  <span class="comment">//获取当月的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextYear());  <span class="comment">//获取下年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextMonth());  <span class="comment">//获取下月的第一天</span></span><br><span class="line">localDateTime.with(firstInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月第一个星期一的时间</span></span><br><span class="line">localDateTime.with(lastDayOfYear());  <span class="comment">//获取上年的第一天</span></span><br><span class="line">localDateTime.with(lastDayOfMonth());  <span class="comment">//获取上月的第一天</span></span><br><span class="line">localDateTime.with(lastInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月最后一个星期一的时间</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认提供了几种格式时间的方式【一般不用】</span></span><br><span class="line">String s1 = localDateTime.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDateTime.format(DateTimeFormatter.ISO_DATE_TIME);</span><br><span class="line"><span class="comment">//自定义格式化时间的方式</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy/hh/mm/ss"</span>);</span><br><span class="line">String s3 = localDateTime.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="字符串解析时间"><a href="#字符串解析时间" class="headerlink" title="字符串解析时间"></a>字符串解析时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 &#x3D; LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 &#x3D; LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&#x2F;hh&#x2F;mm&#x2F;ss&quot;);</span><br><span class="line">LocalDate localDate3 &#x3D; LocalDate.parse(&quot;28&#x2F;06&#x2F;2020&#x2F;02&#x2F;28&#x2F;46&quot;, dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="Timestamp与LocalDateTime的转换"><a href="#Timestamp与LocalDateTime的转换" class="headerlink" title="Timestamp与LocalDateTime的转换"></a>Timestamp与LocalDateTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toLocalDateTime();</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime与Long（时间戳）的转换"><a href="#LocalDateTime与Long（时间戳）的转换" class="headerlink" title="LocalDateTime与Long（时间戳）的转换"></a>LocalDateTime与Long（时间戳）的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = (<span class="keyword">new</span> Timestamp(System.currentTimeMillis())).toLocalDateTime();</span><br><span class="line"><span class="keyword">long</span> time = localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br></pre></td></tr></table></figure>

<h2 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.isBefore(localDateTime4));</span><br><span class="line">System.out.println(localDateTime.isAfter(localDateTime4));</span><br></pre></td></tr></table></figure>

<h2 id="计算时间间隔（Duration类和Period类）"><a href="#计算时间间隔（Duration类和Period类）" class="headerlink" title="计算时间间隔（Duration类和Period类）"></a>计算时间间隔（Duration类和Period类）</h2><p>使用场景【计算年龄、合同时间等。。。】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">Duration duration = Duration.between(localDateTime,localDateTime4);</span><br><span class="line"><span class="comment">//间隔多少天</span></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();</span><br><span class="line"><span class="comment">//间隔多少小时</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line"><span class="comment">//间隔多少分钟</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">Period period2 = Period.between(localDateTime.toLocalDate(),localDateTime4.toLocalDate());</span><br><span class="line"><span class="comment">//间隔多少年</span></span><br><span class="line"><span class="keyword">int</span> years = period2.getYears();</span><br><span class="line"><span class="comment">//间隔多少月（只计算月份，不计年）</span></span><br><span class="line"><span class="keyword">int</span> months = period2.getMonths();</span><br><span class="line"><span class="comment">//间隔多少月（计算年）</span></span><br><span class="line"><span class="keyword">long</span> toTotalMonths = period2.toTotalMonths();</span><br></pre></td></tr></table></figure>

<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter YEAR_MONTH_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter LONG_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss SSS"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyMMddHHmmss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDateTime</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">       LocalDateTime localDateTime = LocalDateTime.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDateTime.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDate</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDate.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将字符串日期转换成date类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">dateStrConvertDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(dateStr, dateTimeFormatter);</span><br><span class="line">        <span class="comment">// 获得 Instant</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(parse.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将date类型转换成字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateConvertDateStr</span><span class="params">(Date date,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localdate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">dateConvertLocalDate</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">dateConvertLocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localdate转换成date(时分秒为零)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateConvertDate</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        Instant instant = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localDateTime转换成date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTimeConvertDate</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">getCurrentLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">getCurrentLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getCurrentLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM-dd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyMMdd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(SHORT_DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentMonthStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(YEAR_MONTH_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss SSS”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentLongDateTimeStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(LONG_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyMMddHHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(SHORT_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间字符串以“HHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now().format(TIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间日期字符串以指定的字符串格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String dateStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String dateTimeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">parseLocalTime</span><span class="params">(String timeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate date, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime datetime, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datetime.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalTime</span><span class="params">(LocalTime time, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">formatLocalDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">formatLocalDateTime</span><span class="params">(String dateTimeStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">formatLocalTime</span><span class="params">(String longDateTimeStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(longDateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodHours</span><span class="params">(LocalDateTime startDateTime,LocalDateTime endDateTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Duration.between(startDateTime, endDateTime).get(ChronoUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodDays</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔周数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodWeeks</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.WEEKS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔月数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodMonths</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.MONTHS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔年数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodYears</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.YEARS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCurrentLocalDate().equals(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取时间日期的毫秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">localDateTimeToEpochMilli</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间毫秒数获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">epochMilliToLocalDateTime</span><span class="params">(Long timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Timestamp(timeMillis)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取Timestamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">localDateTimeToTimestamp</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Timestamp(dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Timestamp获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">localDateTimeToTimestamp</span><span class="params">(Timestamp timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp.toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为闰年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate.isLeapYear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBefore</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isBefore(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAfter</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isAfter(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间（整数年）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByYear</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusYears(years).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间(非整数年)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByMonth</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> monthValues)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusMonths(monthValues).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间相应注解"><a href="#时间相应注解" class="headerlink" title="时间相应注解"></a>时间相应注解</h1><h2 id="将返回时间转为指定字符串格式"><a href="#将返回时间转为指定字符串格式" class="headerlink" title="将返回时间转为指定字符串格式"></a>将返回时间转为指定字符串格式</h2><p>@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”, timezone = “GMT+8”)</p>
<h2 id="时间入参格式化"><a href="#时间入参格式化" class="headerlink" title="时间入参格式化"></a>时间入参格式化</h2><p>@DateTimeFormat(pattern = “yyyy-MM-dd”)</p>
<p>@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)</p>
]]></content>
      <categories>
        <category>JDK8新特性</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-AQS</title>
    <url>/2020/12/05/AQS/</url>
    <content><![CDATA[<h2 id="AQS-AbstractQueuedSynchronizer-抽象的队列式同步器"><a href="#AQS-AbstractQueuedSynchronizer-抽象的队列式同步器" class="headerlink" title="AQS (AbstractQueuedSynchronizer)抽象的队列式同步器"></a>AQS (AbstractQueuedSynchronizer)抽象的队列式同步器</h2><p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E7%B1%BB%E4%B8%8Eaqs%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt=""></p>
<p>其中Sync及其子类NonfairSync、FairSync和node均为ReentrantLock的静态内部类</p>
<a id="more"></a>

<h3 id="AQS内部结构"><a href="#AQS内部结构" class="headerlink" title="AQS内部结构"></a>AQS内部结构</h3><h4 id="state："><a href="#state：" class="headerlink" title="state："></a>state：</h4><p>​        同步器状态，被volatile修饰，通过cas争抢状态</p>
<h4 id="exclusiveOwnerThread："><a href="#exclusiveOwnerThread：" class="headerlink" title="exclusiveOwnerThread："></a>exclusiveOwnerThread：</h4><p>​        互斥锁持有的线程（AbstractOwnableSynchronizer的属性，aqs的父类）</p>
<h4 id="head："><a href="#head：" class="headerlink" title="head："></a>head：</h4><p>​        同步等待队列的头部，被volatile修饰</p>
<h4 id="tail："><a href="#tail：" class="headerlink" title="tail："></a>tail：</h4><p>​        同步等待队列的尾部，被volatile修饰</p>
<h4 id="node："><a href="#node：" class="headerlink" title="node："></a>node：</h4><p>​        AQS的静态内部类，CLH的基础节点</p>
<h3 id="Node内部结构"><a href="#Node内部结构" class="headerlink" title="Node内部结构"></a>Node内部结构</h3><h4 id="prev："><a href="#prev：" class="headerlink" title="prev："></a>prev：</h4><p>​        指向前一个node节点，被volatile修饰</p>
<h4 id="next："><a href="#next：" class="headerlink" title="next："></a>next：</h4><p>​        指向后一个node节点，被volatile修饰</p>
<h4 id="waitStatus："><a href="#waitStatus：" class="headerlink" title="waitStatus："></a>waitStatus：</h4><p>​        信号状态，默认是0，被volatile修饰</p>
<h5 id="CANCELLED-1："><a href="#CANCELLED-1：" class="headerlink" title="CANCELLED = 1："></a>CANCELLED = 1：</h5><p>​                        取消状态，当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后，节点将不会再变化</p>
<h5 id="SIGNAL-1："><a href="#SIGNAL-1：" class="headerlink" title="SIGNAL = -1："></a>SIGNAL = -1：</h5><p>​                        等待触发状态，后继节点在等待当前节点唤醒。后继节点入队后，会将前继节点的状态更新为SGNAL</p>
<h5 id="CONDITION-2："><a href="#CONDITION-2：" class="headerlink" title="CONDITION = -2："></a>CONDITION = -2：</h5><p>​                        节点等待在confition上，当其他线程调用confition的signal()方法后，CONDITION状态的节点将从等待队列转移到同步队列中</p>
<h5 id="PROPAGATE-3："><a href="#PROPAGATE-3：" class="headerlink" title="PROPAGATE = -3："></a>PROPAGATE = -3：</h5><p>​                        共享模式下，前继节点不仅会唤醒后继节点，同时也可能会唤醒后继节点的后继节点</p>
<h4 id="thread：当前节点关联的客户线程，被volatile修饰"><a href="#thread：当前节点关联的客户线程，被volatile修饰" class="headerlink" title="thread：当前节点关联的客户线程，被volatile修饰"></a>thread：当前节点关联的客户线程，被volatile修饰</h4><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="http://yrlzero.gitee.io/images/多线程/AQS.png" style="zoom:200%;" />

<h4 id="lock-流程"><a href="#lock-流程" class="headerlink" title="lock()流程"></a>lock()流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sync的lock()</span><br><span class="line">	1 NonfairSync.lock() 非公平锁</span><br><span class="line">		2 调用父类aqs的compareAndSetState（第一次）cas争抢同步器状态，</span><br><span class="line">			1.1 成功，调用父类aos的setExclusiveOwnerThread(Thread.currentThread())，修改exclusiveOwnerThread为当前线程</span><br><span class="line">			1.2 失败，调用aqs的acquire()尝试争抢和排队  if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">				2.1 调用aqs的tryAcquire，进入子类reentrantLock的tryAcquire(arg)</span><br><span class="line">					2.1.1 调用NonfairSync的tryAcquire里面的nonfairTryAcquire(acquires)，尝试获取同步器状态</span><br><span class="line">						2.1.1.1 同步器状态为0，（第二次）cas争抢同步器状态</span><br><span class="line">							2.1.1.1.1 成功，设置AOS的exclusiveOwnerThread为当前线程，返回true，不进行排队</span><br><span class="line">							2.1.1.1.2 失败，返回false，进入排队</span><br><span class="line">						2.1.1.2 同步器状态不为0，AOS的exclusiveOwnerThread等于当前线程（一般为重入）</span><br><span class="line">							2.1.1.2.1 符合，同步器状态加1，返回true，不进行排队</span><br><span class="line">							2.1.1.2.2 不符合，返回false，进行排队</span><br><span class="line">				2.2 调用父类aqs的addWaiter(Node mode)，为当前线程创建排他的node节点</span><br><span class="line">					2.2.1 （旧）尾结点是否为空</span><br><span class="line">						2.2.1.1 （旧）尾结点不为空，当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">							2.2.1.1.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">								2.2.1.1.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点，等待加入队列</span><br><span class="line">								2.2.1.1.1.2 失败，往下执行，进入aqs的enq(node)</span><br><span class="line">						2.2.1.2 （旧）尾结点为空，往下执行，进入aqs的enq(node)</span><br><span class="line">					2.2.2 进入父类aqs的enq(node)，死循环</span><br><span class="line">						2.2.2.1 （旧）尾结点为空（说明该队列还没有初始化）</span><br><span class="line">							2.2.2.1.1 新创建node节点，cas设置为头结点</span><br><span class="line">								2.2.2.1.1 设置成功，尾结点等于头结点，相互指向，形成哨兵节点</span><br><span class="line">								2.2.2.1.2 设置失败，重新循环，进入2.2.2</span><br><span class="line">							2.2.2.1.2 （旧）尾结点不为空</span><br><span class="line">								2.2.2.1.2.1 当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">								2.2.2.1.2.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">									2.2.2.1.2.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点的上一节点（旧的尾结点），这里的返回只是为了退出2.2.2，等待加入队列</span><br><span class="line">									2.2.2.1.2.1.2 失败，重新循环，进入2.2.2</span><br><span class="line">									</span><br><span class="line">					2.2.3 返回当前线程节点，等待加入队列	</span><br><span class="line">				2.3 调用父类aqs的acquireQueued()，死循环</span><br><span class="line">					2.3.1 获取当前节点的前置节点</span><br><span class="line">					2.3.2 前置节点为头节点 &amp;&amp; 当前节点再次尝试获取同步器状态，tryAcquire(arg)参见2.1</span><br><span class="line">						2.3.2.1 成功，</span><br><span class="line">							2.3.2.1.1 调用父类aqs的setHead(node)当前节点设置为头节点，当前节点关联的线程赋值null，上一节点赋值null</span><br><span class="line">							2.3.2.1.2 前置节点的下一节点赋值null，辅助gc回收； 不执行finally &#123;if (failed)&#123;cancelAcquire(node);&#125;&#125;，返回false（也就是不中断），退出2.3</span><br><span class="line">					2.3.3 调用父类aqs的shouldParkAfterFailedAcquire(p, node)和parkAndCheckInterrupt()</span><br><span class="line">						2.3.3.1 shouldParkAfterFailedAcquire(p, node) 获取失败后park之前重置等待状态的方法</span><br><span class="line">							2.3.3.1.1 获取前置节点（当前节点的上一节点）的等待状态</span><br><span class="line">							2.3.3.1.2 等待状态等于-1时，返回true，前置节点还没有被触发，当前节点可以被park</span><br><span class="line">							2.3.3.1.3等待状态大于0时，前置节点处于取消状态，获取前置节点的上一节点作为当前节点的上一节点，再次判断状态，重复循环，等待状态不大于0是，此时的前置节点的下一节点为当前线程节点，返回false，继续2.3</span><br><span class="line">							2.3.3.1.4 等待状态不为以上两种时，cas将状态置为signal也就是-1，返回false，继续2.3</span><br><span class="line">						2.3.3.2 前者返回true，进入parkAndCheckInterrupt()</span><br><span class="line">							2.3.3.2.1 LockSupport.park(this);阻塞当前线程，等待唤醒，正式入队</span><br><span class="line">							2.3.3.2.2 return Thread.interrupted(); 检查被唤醒的线程有没有被中断</span><br><span class="line">								2.3.3.2.2.1 返回false，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">								2.3.3.2.2.2 返回true，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">				2.4 最终：当2.3.3.2.2之后的流程进入2.3.2尝试获取锁成功时，返回值决定是否调用selfInterrupt();</span><br></pre></td></tr></table></figure>



<h3 id="CLH双向队列"><a href="#CLH双向队列" class="headerlink" title="CLH双向队列"></a>CLH双向队列</h3><img src="http://yrlzero.gitee.io/images/多线程/CLH.png" style="zoom:150%;" />]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware创建centos7虚拟机</title>
    <url>/2020/11/29/VMware%E5%88%9B%E5%BB%BAcentos7%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<img src="http://yrlzero.gitee.io/images/linux/centos/1.png" style="zoom:75%;" />

<a id="more"></a>

<img src="http://yrlzero.gitee.io/images/linux/centos/2.png" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/3.png" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/4.jpg" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/5.jpg" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/6.jpg" style="zoom:55%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/7.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/8.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/9.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/10.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/11.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/12.jpg" style="zoom:50%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/13.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/14.jpg" style="zoom:67%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/15.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/16.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/17.jpg" style="zoom:67%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/18.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/19.jpg" style="zoom:75%;" />]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot国际化（i18n）</title>
    <url>/2020/12/12/Spring%20Boot%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88i18n%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>i18n是internationalization（国际化单词的缩写，i和n之间有18个字母）</p>
<a id="more"></a>

<h3 id="二、依赖"><a href="#二、依赖" class="headerlink" title="二、依赖"></a>二、依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只需要导入web包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三、语言配置文件"><a href="#三、语言配置文件" class="headerlink" title="三、语言配置文件"></a>三、语言配置文件</h3><p>创建配置文件存放不同语言的消息文本:</p>
<p><img src="http://yrlzero.gitee.io/images/spring/message%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<h4 id="message-properties（此默认配置是必须的，兜底的配置）："><a href="#message-properties（此默认配置是必须的，兜底的配置）：" class="headerlink" title="message.properties（此默认配置是必须的，兜底的配置）："></a>message.properties（此默认配置是必须的，兜底的配置）：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">默认</span></span><br><span class="line"><span class="attr">abc</span>=<span class="string">默认abc</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">默认第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<h4 id="message-en-US-properties-英文配置-："><a href="#message-en-US-properties-英文配置-：" class="headerlink" title="message_en_US.properties(英文配置)："></a>message_en_US.properties(英文配置)：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">test&#123;0&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="message-zh-CN-properties-中文配置"><a href="#message-zh-CN-properties-中文配置" class="headerlink" title="message_zh_CN.properties(中文配置):"></a>message_zh_CN.properties(中文配置):</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">中文</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<p>当指定的语言文件中找不到对应的key时，会查询默认文件，如abc找到默认abc；默认文件也不存在时，会报<code>org.springframework.context.NoSuchMessageException: No message found under code &#39;a&#39; for locale &#39;&#39;.</code>这里的a就是操作的key</p>
<h3 id="四、yml配置"><a href="#四、yml配置" class="headerlink" title="四、yml配置"></a>四、yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-i18n</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">static/i18n/message</span> <span class="comment">#语言配置文件的基础名称（注意，message为语言配置文件的前缀）</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<h3 id="五、session默认解析器-指定默认的locale"><a href="#五、session默认解析器-指定默认的locale" class="headerlink" title="五、session默认解析器(指定默认的locale)"></a>五、session默认解析器(指定默认的locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	默认解析器 其中locale表示默认语言,当请求中未包含语种信息，则设置默认语种</span></span><br><span class="line"><span class="comment">     *	当前默认为CHINA,zh_CN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionLocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.CHINA);</span><br><span class="line">        <span class="keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、拦截器-设置客户端语言locale"><a href="#六、拦截器-设置客户端语言locale" class="headerlink" title="六、拦截器(设置客户端语言locale)"></a>六、拦截器(设置客户端语言locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String lang = request.getHeader(<span class="string">"lang"</span>);</span><br><span class="line">        <span class="comment">//拦截客户端传送的语言标识，获取对应的语言locale，没有传送则走默认</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(lang))&#123;</span><br><span class="line">            LocaleContextHolder.setLocale(<span class="keyword">new</span> Locale(lang));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、注册拦截器"><a href="#七、注册拦截器" class="headerlink" title="七、注册拦截器"></a>七、注册拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、控制器"><a href="#八、控制器" class="headerlink" title="八、控制器"></a>八、控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I18nController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/in"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数是语言配置的key、第二个参数是对象数组，对应语言包中的变量如&#123;0&#125;进行填充、第三个参数是语言区域对象</span></span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(param,<span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、工具类"><a href="#九、工具类" class="headerlink" title="九、工具类"></a>九、工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleMessageUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前区域上下文对应的语言</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前环境语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLanguage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocaleContextHolder.getLocale().getLanguage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h3><p>通过拦截器截取客户端放入head中的语言标识，生成对应的locale放入LocaleContextHolder中，线程走对应方法操作时，通过LocaleContextHolder.getLocale()可以获取其对应的语言区域，再从对应的语言配置文件获取文本。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>i18n</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>admin监控</title>
    <url>/2020/12/06/admin/</url>
    <content><![CDATA[<h2 id="admin服务端"><a href="#admin服务端" class="headerlink" title="admin服务端"></a>admin服务端</h2><a id="more"></a>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">       &lt;spring-boot-admin.version&gt;2.3.1&lt;&#x2F;spring-boot-admin.version&gt;</span><br><span class="line">       &lt;spring-cloud.version&gt;Hoxton.SR9&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">   &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-starter-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--admin--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-server-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--健康检查--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">      </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 邮件--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 加入密码认证 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;&#x2F;exclusion&gt;</span><br><span class="line">           &lt;&#x2F;exclusions&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-admin-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;&#x2F;dependencies&gt;</span><br><span class="line">   &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br><span class="line">       &lt;&#x2F;plugins&gt;</span><br><span class="line">   &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9304</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-admin</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">        <span class="attr">mail:</span></span><br><span class="line">          <span class="comment">#收邮件</span></span><br><span class="line">          <span class="attr">to:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">          <span class="comment"># 发件邮箱（要与邮件配置的username相同）</span></span><br><span class="line">          <span class="attr">from:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="comment"># 邮件设置</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">619876453</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">abc</span> <span class="comment">#授权码</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smpt:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka:eureka@localhost:9999/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不注册到eureka</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#服务监控</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">show-components:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="security安全认证"><a href="#security安全认证" class="headerlink" title="security安全认证"></a>security安全认证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSecurityConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">        successHandler.setTargetUrlParameter( <span class="string">"redirectTo"</span> );</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/assets/**"</span> ).permitAll()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/login"</span> ).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().loginPage( adminContextPath + <span class="string">"/login"</span> ).successHandler( successHandler ).and()</span><br><span class="line">                .logout().logoutUrl( adminContextPath + <span class="string">"/logout"</span> ).and()</span><br><span class="line">                .httpBasic().and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span><br><span class="line">                .ignoringAntMatchers(</span><br><span class="line">                        adminContextPath + <span class="string">"/instances"</span>,</span><br><span class="line">                        adminContextPath + <span class="string">"/actuator/**"</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="admin客户端（eureka服务端）"><a href="#admin客户端（eureka服务端）" class="headerlink" title="admin客户端（eureka服务端）"></a>admin客户端（eureka服务端）</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Admin 服务 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://admin:admin@localhost:9304</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="安全认证，放行健康检查"><a href="#安全认证，放行健康检查" class="headerlink" title="安全认证，放行健康检查"></a>安全认证，放行健康检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().antMatchers(<span class="string">"/actuator/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><img src="G:%5C%E7%AC%94%E8%AE%B0%5Ccloud%5Cadmin%5Cadmin%E7%9B%91%E6%8E%A7.jpg" alt=""></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><h3 id="邮件通知，查看上面配置"><a href="#邮件通知，查看上面配置" class="headerlink" title="邮件通知，查看上面配置"></a>邮件通知，查看上面配置</h3><h3 id="钉钉通知"><a href="#钉钉通知" class="headerlink" title="钉钉通知"></a>钉钉通知</h3><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DingDingNotifier <span class="title">dingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DingDingNotifier(repository);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String serviceName = instance.getRegistration().getName();</span><br><span class="line">        String serviceUrl = instance.getRegistration().getServiceUrl();</span><br><span class="line">        String status = instance.getStatusInfo().getStatus();</span><br><span class="line">        Map&lt;String, Object&gt; details = instance.getStatusInfo().getDetails();</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.append(<span class="string">"系统警告 : 【"</span> + serviceName + <span class="string">"】"</span>);</span><br><span class="line">        str.append(<span class="string">"【服务地址】"</span> + serviceUrl);</span><br><span class="line">        str.append(<span class="string">"【状态】"</span> + status);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str.append(<span class="string">"【详情】"</span> + objectMapper.writeValueAsString(details));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            DingDingMessageUtil.sendTextMessage(str.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送工具类"><a href="#发送工具类" class="headerlink" title="发送工具类"></a>发送工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingMessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String access_token = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setMsgtype(<span class="string">"text"</span>);</span><br><span class="line">            message.setText(<span class="keyword">new</span> MessageInfo(msg));</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"https://oapi.dingtalk.com/robot/send?access_token="</span> + access_token);</span><br><span class="line">            <span class="comment">// 建立 http 连接</span></span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">            conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/Json; charset=UTF-8"</span>);</span><br><span class="line">            conn.connect();</span><br><span class="line">            OutputStream out = conn.getOutputStream();</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            String textMessage = objectMapper.writeValueAsString(message);</span><br><span class="line">            <span class="keyword">byte</span>[] data = textMessage.getBytes();</span><br><span class="line">            out.write(data);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            InputStream in = conn.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] data1 = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data1);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data1));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息类"><a href="#消息类" class="headerlink" title="消息类"></a>消息类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageInfo</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msgtype;</span><br><span class="line">    <span class="keyword">private</span> MessageInfo text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgtype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgtype</span><span class="params">(String msgtype)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgtype = msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageInfo <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(MessageInfo text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钉钉群配置机器人"><a href="#钉钉群配置机器人" class="headerlink" title="钉钉群配置机器人"></a>钉钉群配置机器人</h4><p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA2.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA3.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>admin</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka原理解析</title>
    <url>/2020/12/26/eureka%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、Server启动原理"><a href="#一、Server启动原理" class="headerlink" title="一、Server启动原理"></a>一、Server启动原理</h2><ol>
<li>springboot会去加载META-INF下面的spring.factories自动装配<code>org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</code>这个类</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/eureka%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E7%B1%BB.jpg" alt=""></p>
<ol start="2">
<li><p>此类的判断条件注解标识需要有Mark这个类存在才会加载</p>
</li>
<li><p>而启动类加上<code>@EnableEurekaServer</code>时，会加载Mark类，从而使自动配置类生效，所以当我们需要使用eureka-server时，必须要在启动类加上此注解</p>
</li>
</ol>
<img src="http://yrlzero.gitee.io/images/cloud/eureka/eurekaServer注解.jpg" style="zoom:100%;" />

<h2 id="二、Eureka-Sever缓存"><a href="#二、Eureka-Sever缓存" class="headerlink" title="二、Eureka Sever缓存"></a>二、Eureka Sever缓存</h2><h3 id="1-三级缓存"><a href="#1-三级缓存" class="headerlink" title="1.三级缓存"></a>1.三级缓存</h3><h4 id="1-1（ConcurrentHashMap）registry"><a href="#1-1（ConcurrentHashMap）registry" class="headerlink" title="1.1（ConcurrentHashMap）registry"></a>1.1（ConcurrentHashMap）registry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry= <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>​        第一层的 ConcurrentHashMap 的 <code>key=spring.application.name</code> 也就是客户端实例注册的应用名；value 为嵌套的 ConcurrentHashMap。</p>
<p>​        第二层嵌套的 ConcurrentHashMap 的 <code>key=instanceId</code> 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="1-2-ReadOnlyMap（ConcurrentHashMap）"><a href="#1-2-ReadOnlyMap（ConcurrentHashMap）" class="headerlink" title="1.2  ReadOnlyMap（ConcurrentHashMap）"></a>1.2  ReadOnlyMap（ConcurrentHashMap）</h4><p>​        <strong>周期更新</strong>，类ResponseCacheImpl成员变量，默认每<strong>30s</strong>从readWriteCacheMap更新</p>
<p>​        ReadOnlyMap是一个只读缓存，供客户端获取注册信息时使用，默认情况下，定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。</p>
<h4 id="1-3-readWriteCacheMap（guava-LoadingCache）"><a href="#1-3-readWriteCacheMap（guava-LoadingCache）" class="headerlink" title="1.3  readWriteCacheMap（guava#LoadingCache）"></a>1.3  readWriteCacheMap（guava#LoadingCache）</h4><p>​        <strong>实时更新</strong>，类AbstractInstanceRegistry成员变量</p>
<p>​        readWriteCacheMap，本质上是 Guava 缓存，数据主要同步于registry。当获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。</p>
<p>​        定时器每60s清理超过90s未续约的节点。</p>
<p>​        缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。</p>
<h3 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h3><h4 id="2-1-注册一个服务实例"><a href="#2-1-注册一个服务实例" class="headerlink" title="2.1 注册一个服务实例"></a>2.1 注册一个服务实例</h4><p>​        向注册表中写入服务实例信息，并使得readWriteCacheMap缓存失效</p>
<h4 id="2-2-寻找一个服务"><a href="#2-2-寻找一个服务" class="headerlink" title="2.2 寻找一个服务"></a>2.2 寻找一个服务</h4><p>​        从ReadOnlyMap缓存中找，如果有则返回，如果没有则去ReadWriteMap缓存拿并更新，如果ReadWriteMap缓存已经失效，触发guava的回调函数从注册表中同步。</p>
<h4 id="2-3-数据同步定时器"><a href="#2-3-数据同步定时器" class="headerlink" title="2.3 数据同步定时器"></a>2.3 数据同步定时器</h4><p>​        默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而UI则从registry更新服务注册信息。</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.jpg" alt=""></p>
<h3 id="3-缓存相关配置"><a href="#3-缓存相关配置" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span> <span class="comment"># 续约到期时间，服务端收到最后一次心跳后等待的时间上限，默认90s，超时剔除服务</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#Client是否从readOnlyCacheMap更新数据，false则跳过readOnlyCacheMap直接从readWriteCacheMap更新，默认true</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>



<h3 id="4-多级缓存的优点"><a href="#4-多级缓存的优点" class="headerlink" title="4. 多级缓存的优点"></a>4. 多级缓存的优点</h3><p>​        尽可能保证了内存注册表中的数据不会出现频繁的读写冲突问题，进一步保证了对eurekaServer的大量请求，都是快速读取内存，提供性能</p>
<h3 id="5-优化eureka服务端"><a href="#5-优化eureka服务端" class="headerlink" title="5. 优化eureka服务端"></a>5. 优化eureka服务端</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false # 心跳保护机制，默认开启，自我保护机制，服务可用数量少于85%时默认开启自我保护机制，不会再剔除服务微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span><br><span class="line">    eviction-interval-timer-in-ms: 1000 # 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span><br><span class="line">    renewal-percent-threshold: 0.85 #自我保护机制触发的阈值，默认0.85</span><br><span class="line">    use-read-only-response-cache: false #是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span><br><span class="line">    response-cache-update-interval-ms: 1000 # readwrite 和readOnly 同步时间间隔，默认30 * 1000</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="三-、Eureka-Client缓存"><a href="#三-、Eureka-Client缓存" class="headerlink" title="三 、Eureka Client缓存"></a>三 、Eureka Client缓存</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h3><p>​        Eureka Client存在两种角色：<strong>服务提供者</strong>和<strong>服务消费者</strong>，作为服务消费者一般配合Ribbon（Feign内部使用Ribbon）使用。</p>
<p>​        Client启动后，作为服务提供者立即向Server注册，默认情况下每30s续约(renew)；作为服务消费者立即向Server全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon延时1s向Client获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。</p>
<h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h3><p>2.1 localRegionApps(Eureka Client缓存)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</span><br></pre></td></tr></table></figure>

<p>​        <strong>周期更新</strong>，类DiscoveryClient成员变量，Eureka Client保存服务注册信息，启动后立即向Server全量更新，默认每<strong>30s</strong>增量更新</p>
<p>2.2 upServerListZoneMap(ConcurrentHashMap,Ribbon缓存)</p>
<p>​        <strong>周期更新</strong>，类LoadBalancerStats成员变量，Ribbon保存使用且状态为<strong>UP</strong>的服务注册信息，启动后延时1s向Client更新，默认每<strong>30s</strong>更新</p>
<h3 id="3-缓存相关配置-1"><a href="#3-缓存相关配置-1" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka集群安装</title>
    <url>/2020/12/06/eureka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 服务端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 安全配置，服务之间注册需要校验 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查，用于服务之间的心跳检测 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-启动类添加注解"><a href="#2-启动类添加注解" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-节点一的yml配置"><a href="#3-1-节点一的yml配置" class="headerlink" title="3.1 节点一的yml配置"></a>3.1 节点一的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9991</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka1.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9991 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-节点二的yml配置"><a href="#3-2-节点二的yml配置" class="headerlink" title="3.2 节点二的yml配置"></a>3.2 节点二的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9992</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka2.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9992 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">456</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-节点三的yml配置"><a href="#3-3-节点三的yml配置" class="headerlink" title="3.3 节点三的yml配置"></a>3.3 节点三的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9993</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka3.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9993 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">789</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="二、-客户端"><a href="#二、-客户端" class="headerlink" title="二、 客户端"></a>二、 客户端</h2><h3 id="1-依赖-1"><a href="#1-依赖-1" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 客户端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-启动类添加注解-1"><a href="#2-启动类添加注解-1" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="3-yml配置"><a href="#3-yml配置" class="headerlink" title="3. yml配置"></a>3. yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9302</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-pay</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span></span><br><span class="line">        <span class="string">http://eureka:eureka@eureka1.com:9991/eureka/,http://eureka:eureka@eureka2.com:9992/eureka/,http://eureka:eureka@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<h2 id="三、控制台"><a href="#三、控制台" class="headerlink" title="三、控制台"></a>三、控制台</h2><p>当服务出现在available-replicas中才算搭建成功</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/eureka%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<h2 id="四、健康检查"><a href="#四、健康检查" class="headerlink" title="四、健康检查"></a>四、健康检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">managementUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator</span><br><span class="line">healthUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator&#x2F;health</span><br><span class="line">serviceUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="五、cap原则"><a href="#五、cap原则" class="headerlink" title="五、cap原则"></a>五、cap原则</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一致性（Consistency）</span><br><span class="line">可用性（Availability）</span><br><span class="line">分区容错性（Partition tolerance）</span><br><span class="line">1.eureka是ap，去中心化，每个节点是平等的，15分钟内，可用实例低于85%,开启心跳保护，不会剔除心跳异常的实例，保证可用性，仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用），所以实例调用需要有熔断机制保证</span><br><span class="line">2.zookpeer是cp，由leader提供服务，ZooKeeper选举Leader时候会造成服务一定时间内的不可用，保证了一致性，不保证可用性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载与创建</title>
    <url>/2021/01/03/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-01.png" alt="jvm"></p>
<a id="more"></a>

<h2 id="Class格式"><a href="#Class格式" class="headerlink" title="Class格式"></a>Class格式</h2><p>Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。</p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a><strong>无符号数</strong></h3><p>属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a><strong>表</strong></h3><p>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。表主要用于描述有层次关系的复合结构的数据，比如方法、字段。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的。具体的顺序定义如下：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-03.png" alt="jvm"></p>
<p>从二进制的数据来看：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-02.png" alt="jvm"></p>
<p>通过<code>javap</code>编译成可视化语言来看：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-06.png" alt="jvm"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cafe babe 0000 0034 000f 0a00 0300 0c07</span><br><span class="line">000d 0700 0e01 0006 3c69 6e69 743e 0100</span><br><span class="line">0328 2956 0100 0443 6f64 6501 000f 4c69</span><br><span class="line">6e65 4e75 6d62 6572 5461 626c 6501 0004</span><br><span class="line">6d61 696e 0100 1628 5b4c 6a61 7661 2f6c</span><br><span class="line">616e 672f 5374 7269 6e67 3b29 5601 000a</span><br><span class="line">536f 7572 6365 4669 6c65 0100 134a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 742e 6a61 7661</span><br><span class="line">0c00 0400 0501 0013 6b75 726f 2f4a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 7401 0010 6a61</span><br><span class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0021</span><br><span class="line">0002 0003 0000 0000 0002 0001 0004 0005</span><br><span class="line">0001 0006 0000 001d 0001 0001 0000 0005</span><br><span class="line">2ab7 0001 b100 0000 0100 0700 0000 0600</span><br><span class="line">0100 0000 0300 0900 0800 0900 0100 0600</span><br><span class="line">0000 1900 0000 0100 0000 01b1 0000 0001</span><br><span class="line">0007 0000 0006 0001 0000 0006 0001 000a</span><br><span class="line">0000 0002 000b</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">魔法数字： cafe babe</span><br><span class="line">次版本号： 0000</span><br><span class="line">主版本号： 0034			JDK1.8</span><br><span class="line">常量数量： 000f			从1开始</span><br><span class="line">#1常量 ： 0a			 表示表中第十项（CONSTANT_Methodref_info）</span><br><span class="line">      :  00 03		   指向#3常量</span><br><span class="line">      ： 00 0c		  指向#13常量</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-04.png" alt="jvm"></p>
<p>详情可查阅查阅：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-05.png" alt="jvm"></p>
<h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><p>​        使用new关键字创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>​        使用Class类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = A<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>​        使用Constructor类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;A&gt; constructor = A<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">A a = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>​        使用Clone方法创建对象</p>
<p>​        使用(反)序列化机制创建对象</p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-07.png" alt="jvm"></p>
<h3 id="加载-class-loading"><a href="#加载-class-loading" class="headerlink" title="加载(class loading)"></a>加载(class loading)</h3><blockquote>
<p>1.通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2.将这个字节流所代表的的静态存储结构转化成访问区的运行时数据结构。</p>
<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
</blockquote>
<h3 id="验证-class-verification"><a href="#验证-class-verification" class="headerlink" title="验证(class verification)"></a>验证(class verification)</h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证等等。</p>
<p>如验证是否以0xCAFEBABE开头</p>
<h3 id="准备-class-preparation"><a href="#准备-class-preparation" class="headerlink" title="准备(class preparation)"></a>准备(class preparation)</h3><p>为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p><strong>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中。</strong></p>
<p><strong>正常情况下，这里初始化的值是静态变量的数据类型的默认值，而不是属性指定的值，如果它还被final修饰了，那么将会在这个阶段直接初始化成属性指定的值。</strong></p>
<h3 id="解析-class-resolution"><a href="#解析-class-resolution" class="headerlink" title="解析(class resolution)"></a>解析(class resolution)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="类初始化-class-initalizing"><a href="#类初始化-class-initalizing" class="headerlink" title="类初始化(class initalizing)"></a>类初始化(class initalizing)</h3><p>类初始化就是执行<code>&lt;clinit&gt;()</code>方法，<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，<strong>静态语句块中只能访问到定义在静态语句之前的变量</strong>。</p>
<p>也就是说，静态属性和静态代码块的赋值和调用在<strong>初始化</strong>过程中执行，先执行父类的，再执行子类的。</p>
<h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><p>实例初始化过程，就是执行<code>&lt;init&gt;()</code>方法<br>         <code>&lt;init&gt;()</code>方法可能重载有多个，有几个构造器就有几个<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>         非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>         每次创建实例对象，调用对应构造器，执行的就是对应的<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法的首行是surper(或super(实参列表),即对应父类的<code>&lt;init&gt;</code>方法</p>
<h3 id="类初始化与实例初始化，在子父类内部执行顺序"><a href="#类初始化与实例初始化，在子父类内部执行顺序" class="headerlink" title="类初始化与实例初始化，在子父类内部执行顺序"></a>类初始化与实例初始化，在子父类内部执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类静态成员</span><br><span class="line">父类静态代码块</span><br><span class="line">	-&gt;子类静态成员</span><br><span class="line">	-&gt;子类静态代码块</span><br><span class="line">		-&gt;父类代码块</span><br><span class="line">		-&gt;父类成员变量</span><br><span class="line">		-&gt;父类构造器</span><br><span class="line">			-&gt;子类代码块</span><br><span class="line">			-&gt;子类成员变量</span><br><span class="line">			-&gt;子类构造器</span><br><span class="line">类初始化</span><br><span class="line">	静态成员赋值的代码、静态代码块（两者先后看顺序）</span><br><span class="line">实例初始化</span><br><span class="line">	super()</span><br><span class="line">	非静态赋值的代码、非静态代码块（两者先后看顺序）</span><br><span class="line">	无参构造</span><br></pre></td></tr></table></figure>

<p>​        样例：</p>
<img src="http://yrlzero.gitee.io/images/jvm/jvm-base/类实例化和类初始化.jpg" style="zoom:95%;" />

<p>上图执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、1、10、6、9、3、2、9、8、7</span><br><span class="line">9、3、2、9、8、7</span><br><span class="line"></span><br><span class="line">类初始化与实例初始化</span><br><span class="line">5  父类静态成员j调用父类的静态方法method()，静态方法不可重写，所以不会调用子类的</span><br><span class="line">1  父类静态代码块</span><br><span class="line">10 子类静态成员j调用子类的静态方法method()</span><br><span class="line">6  子类静态代码块</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br><span class="line"></span><br><span class="line">再次实例初始化</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 count = 2; T t = new T();---&gt;调用构造方法--&gt;count++;</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 T t = new T();---&gt;调用构造方法--&gt;count++; count = 1;</span></span><br><span class="line">        <span class="comment">//--按照顺序赋值静态变量 count = 2;（覆盖掉之前的值）</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果是<code>Object o = new Object()</code>，有以下几步：</strong></p>
<p>1、申请内存空间，这时候成员变量均是默认值</p>
<p>2、调用构造方法，初始化成员变量值</p>
<p>3、建立栈上和堆内存对象的关联关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们调用构造方法时，java的底层的字节码指令如下：</span></span><br><span class="line">0: new           #2                  // class java/lang/Object		申请内存空间</span><br><span class="line"><span class="number">3</span>: dup								 <span class="comment">// 复制内存空间地址，供以调用构造方法时出栈使用</span></span><br><span class="line">4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V    调用构造方法</span><br><span class="line"><span class="number">7</span>: astore_1							 <span class="comment">// Object o 指向开辟的内存地址</span></span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-08.png" alt="jvm"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-09.png" alt="jvm"></p>
<p>如果一个类加载器收到了类加载的请求，它不会先尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载。</p>
<p><strong>这里的父-子是通过使用组合关系，成员变量有个叫做parent的属性记录上层的类加载器，而不是继承关系。</strong></p>
<p><strong>父类加载器不是类加载器的加载器，也不是类加载器的父类加载器。双亲委派是一个孩子向父亲方向，然后父亲向孩子方向的双亲委派过程。</strong></p>
<blockquote>
<p>为什么用双亲委派机制？</p>
<p>安全，保证了Java程序的稳定运行。避免核心类库被用户覆盖。</p>
</blockquote>
<p>查看各个类加载器加载的路径及信息可以查阅<code>Launcher.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BootStrap ClassLoader:sun.boot.class.path</span><br><span class="line">ExtClassLoader:java.ext.dirs</span><br><span class="line">AppClassLoader：java.class.path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK破坏双亲委派机制的历史</p>
<p>双亲委派模型的第一次被破坏发生在双亲委派模型出现之前，由于双亲委派模型在JDK1.2之后才被引入，为了向前兼容，JDK1.2之后添加了一个findClass()方法。</p>
<p>双亲委派模型的第二次被破坏是由于模型自身的缺陷导致的，有些标准服务是由启动类加载器（Bootstrap）去加载的，但它又需要调用独立厂商实现并部署在应用程序的ClassPath下的代码，为了解决这个问题，引入了<strong>线程上下文类加载器</strong>，如果有了线程上下文类加载器，父类加载器将会请求子类加载器去完成类加载动作。</p>
<p>双亲委派模型的第三次被破坏是由于用户对程序动态性的追求导致的。如热替换、热部署。</p>
<p>假设每个程序都有一个自己的类加载器，当需要更换一个代码片段时，就把这个代码片段连同类加载器一起换掉实现代码的热替换。</p>
</blockquote>
<p>当我们需要定义自己的类加载器时，继承ClassLoad，重写findClass()方法，当调用loadClass()加载class，找不到时会调用我们自定义的findClass()，读取要加载的文件流，调用defineClass()去真正加载，保证了双亲委派机制</p>
<p>若要破坏双亲委派模型，我们可以直接重写loadClass()方法，直接加载指定的class，没有的情况下再走parent的loadClass()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//File To byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(<span class="string">"xxx"</span>));</span><br><span class="line">        <span class="comment">//调用父类的defineClass装载</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h2><p>Java默认采用混合模式，初期通过编译器编译Class文件的代码，当出现热点代码时，会通过<code>JIT</code>解释器把热点代码解释成本地代码，提高运行效率。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 热点代码的阈值频次</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CompileThreshold = 10000</span></span><br><span class="line"><span class="comment"># 使用编译器运行</span></span><br><span class="line"><span class="attr">-Xcomp</span></span><br><span class="line"><span class="comment">#使用解释器运行</span></span><br><span class="line"><span class="attr">-Xint</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>maven安装</title>
    <url>/2020/11/29/maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="1-下载地址：http-maven-apache-org-download-cgi"><a href="#1-下载地址：http-maven-apache-org-download-cgi" class="headerlink" title="1. 下载地址：http://maven.apache.org/download.cgi"></a>1. 下载地址：<code>http://maven.apache.org/download.cgi</code></h3><a id="more"></a>

<h3 id="2-解压："><a href="#2-解压：" class="headerlink" title="2. 解压："></a>2. 解压：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-重命名："><a href="#3-重命名：" class="headerlink" title="3. 重命名："></a>3. 重命名：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-maven-3.6.3 maven3.6.3</span><br></pre></td></tr></table></figure>



<h3 id="4-添加环境变量："><a href="#4-添加环境变量：" class="headerlink" title="4. 添加环境变量："></a>4. 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$M2_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<h3 id="5-让修改生效："><a href="#5-让修改生效：" class="headerlink" title="5. 让修改生效："></a>5. 让修改生效：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="6-验证："><a href="#6-验证：" class="headerlink" title="6. 验证："></a>6. 验证：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

<h3 id="7-修改配置文件"><a href="#7-修改配置文件" class="headerlink" title="7. 修改配置文件"></a>7. 修改配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3&#x2F;conf&#x2F;settings.xml</span><br><span class="line">	&lt;!-- 本地仓库 --&gt;</span><br><span class="line">	&lt;localRepository&gt;&#x2F;usr&#x2F;local&#x2F;mvn_repository&lt;&#x2F;localRepository&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--使用阿里云，速度比官方快很多行指定中央仓库的镜像。--&gt;</span><br><span class="line">	&lt;mirror&gt;</span><br><span class="line">		&lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">		&lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;</span><br><span class="line">	&lt;&#x2F;mirror&gt;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&lt;!--更改Maven的默认jdk版本 --&gt;</span><br><span class="line">	&lt;profile&gt;</span><br><span class="line">		&lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;activation&gt;</span><br><span class="line">			&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">			&lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;</span><br><span class="line">		&lt;&#x2F;activation&gt;</span><br><span class="line">		&lt;properties&gt;</span><br><span class="line">			&lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">			&lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">			&lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;</span><br><span class="line">		&lt;&#x2F;properties&gt;</span><br><span class="line">   &lt;&#x2F;profile&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>maven</category>
      </categories>
  </entry>
  <entry>
    <title>mycat基本安装及高可用部署</title>
    <url>/2021/05/07/mycat%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、<a href="http://dl.mycat.org.cn/1.6.7.5/2020-4-10/" target="_blank" rel="noopener">下载</a></h3><h3 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h3><p>解压安装包，<code>-C</code>指定安装目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.5-release-20200422133810-linux.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="3、前台启动"><a href="#3、前台启动" class="headerlink" title="3、前台启动"></a>3、前台启动</h3><p>进入mycat的bin目录下执行启动<code>cd /usr/local/mycat/bin</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/mycat%E7%9A%84bin%E7%9B%AE%E5%BD%95.jpg" alt=""></p>
<p>通过执行<code>./mycat help</code>查看相关命令，其中<code>console</code>为控制台启动，其余命令为后台操作</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/mycat%E7%9A%84help%E5%91%BD%E4%BB%A4.jpg" alt=""></p>
<p><code>./mycat console</code>控制台启动后，如图可以看到缺少日志目录而报错</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/mycat%E7%9A%84%E7%BC%BA%E5%B0%91%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95.jpg" alt="mycat的缺少日志目录"></p>
<p>查看mycat目录，确实没有logs层级需要<code>mkdir /usr/local/mycat/logs</code>创建对应的层级目录</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E6%9F%A5%E7%9C%8Bmycat%E7%9B%AE%E5%BD%95.jpg" alt=""></p>
<h3 id="4、登录"><a href="#4、登录" class="headerlink" title="4、登录"></a>4、登录</h3><p>mycat有两个端口，<code>9066</code>是管理控制台端口、<code>8066</code>是操作端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用8066端口连接mycat</span><br><span class="line">mysql -uroot -pRoot_123 -P 8066</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E8%BF%9E%E6%8E%A5mycat.jpg" alt=""></p>
<h3 id="5、环境变量"><a href="#5、环境变量" class="headerlink" title="5、环境变量"></a>5、环境变量</h3><p>配置环境变量，可以在任意地方直接使用<code>mycat</code>命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> MYCAT_HOME=/usr/<span class="built_in">local</span>/mycat</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$MYCAT_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#让添加的配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8console%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.jpg" alt=""></p>
<h3 id="6、配置"><a href="#6、配置" class="headerlink" title="6、配置"></a>6、配置</h3><h4 id="6-1、server-xml"><a href="#6-1、server-xml" class="headerlink" title="6.1、server.xml"></a>6.1、<code>server.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License"); </span></span><br><span class="line"><span class="comment">	- you may not use this file except in compliance with the License. - You </span></span><br><span class="line"><span class="comment">	may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 </span></span><br><span class="line"><span class="comment">	- - Unless required by applicable law or agreed to in writing, software - </span></span><br><span class="line"><span class="comment">	distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT </span></span><br><span class="line"><span class="comment">	WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the </span></span><br><span class="line"><span class="comment">	License for the specific language governing permissions and - limitations </span></span><br><span class="line"><span class="comment">	under the License. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:server <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"server.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>Root_123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSchema"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2、schema-xml"><a href="#6-2、schema-xml" class="headerlink" title="6.2、schema.xml"></a>6.2、<code>schema.xml</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- name：逻辑库名</span></span><br><span class="line"><span class="comment">             checkSQLschema ：是否自带库名</span></span><br><span class="line"><span class="comment">             sqlMaxLimit：默认数据查询限制，如果SQL语句没带限制，会默认带上，如果带了，则以带的为准</span></span><br><span class="line"><span class="comment">             dataNode:真实数据库节点</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			dataNode的name与schema的dataNode对应；</span></span><br><span class="line"><span class="comment">			dataHost属性与dataHost标签的name对应</span></span><br><span class="line"><span class="comment">			database:真正的库名</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"mytest"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			dbDriver="jdbc"修改为native </span></span><br><span class="line"><span class="comment">			maxCon:最大连接数</span></span><br><span class="line"><span class="comment">			minCon:最小连接数</span></span><br><span class="line"><span class="comment">			balance：读库和写库的负载均衡策略(具体策略看下文)</span></span><br><span class="line"><span class="comment">			writeType：表示写操作发送到哪台机器</span></span><br><span class="line"><span class="comment">			switchType：表示如何进行切换</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 心跳检测使用的sql语句 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            	<span class="comment">&lt;!-- 写库配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">	                    <span class="comment">&lt;!-- 读库配置，可以与写库在同一个库，可以不同（读写分离） --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3、负载策略"><a href="#6-3、负载策略" class="headerlink" title="6.3、负载策略"></a>6.3、负载策略</h4><ul>
<li>balance=0:不开启读写分离机制，所有读操作都发送到当前可用的writehost上</li>
<li>balance=1:全部的readhost和stand by writehost参与select 语句的负载均衡，简单的说，当双主双从模式下，其他的节点都参与select语句的负载均衡</li>
<li>balance=2:所有读操作都随机的在writehost，readhost上分发</li>
<li>balance=3:所有读请求随机的分发到readhost执行，writehost不负担读压力</li>
</ul>
<p>修改<code>balance=&quot;2&quot;</code>，<code>mycat restart</code>重启mycat，测试负载情况</p>
<img src="http://yrlzero.gitee.io/images/linux/mycat/mycat负载.jpg" style="zoom:80%;" />

<h3 id="7、后台启动"><a href="#7、后台启动" class="headerlink" title="7、后台启动"></a>7、后台启动</h3><p><code>mycat start</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/start%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.jpg" alt=""></p>
<p><code>mycat status</code>查看状态</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/mycat%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<hr>
<h2 id="二、mycat的高可用"><a href="#二、mycat的高可用" class="headerlink" title="二、mycat的高可用"></a>二、mycat的高可用</h2><p>​        在之前的操作中，我们已经实现了mysql机器的高可用，可以动态切换master，那么如果mycat崩溃了呢？我们应该如何处理呢？所以此时就需要搭建mycat的高可用集群了。</p>
<p>​        在mycat的权威指南中，介绍了多种高可用的方案，在这里我们讲解一种使用最多的方案，使用HAProxy+Keepalived配合使用来实现myact的高可用。</p>
<p>​        HAproxy实现了mycat多借点的集群高可用和负载均衡，而HAProxy自身的高可用则可以通过Keepalived来实现。</p>
<img src="http://yrlzero.gitee.io/images/linux/mycat/mycat高可用.png" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>编号</th>
<th>角色</th>
<th>IP地址</th>
<th>机器名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>mycat1</td>
<td>192.168.243.131</td>
<td>node01</td>
</tr>
<tr>
<td>2</td>
<td>mycat2</td>
<td>192.168.243.132</td>
<td>node02</td>
</tr>
<tr>
<td>3</td>
<td>HAProxy(master)</td>
<td>192.168.243.133</td>
<td>node03</td>
</tr>
<tr>
<td>4</td>
<td>Keepalived(master)</td>
<td>192.168.243.133</td>
<td>node03</td>
</tr>
<tr>
<td>5</td>
<td>HAProxy(backup)</td>
<td>192.168.243.135</td>
<td>node04</td>
</tr>
<tr>
<td>6</td>
<td>keepalived(backup)</td>
<td>192.168.243.135</td>
<td>node04</td>
</tr>
</tbody></table>
<hr>
<h3 id="1、安装配置HAProxy"><a href="#1、安装配置HAProxy" class="headerlink" title="1、安装配置HAProxy"></a>1、安装配置HAProxy</h3><p>​    在node-3和node-4安装<a href="https://src.fedoraproject.org/repo/pkgs/haproxy/" target="_blank" rel="noopener">HAProxy</a></p>
<h4 id="1-1、准备好HAProxy的安装包"><a href="#1-1、准备好HAProxy的安装包" class="headerlink" title="1.1、准备好HAProxy的安装包"></a>1.1、准备好HAProxy的安装包</h4><h4 id="1-2、解压到-usr-local目录"><a href="#1-2、解压到-usr-local目录" class="headerlink" title="1.2、解压到/usr/local目录"></a>1.2、解压到/usr/local目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf haproxy-1.8.25.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3、进入到解压后的目录，查看内核版本，进行编译"><a href="#1-3、进入到解压后的目录，查看内核版本，进行编译" class="headerlink" title="1.3、进入到解压后的目录，查看内核版本，进行编译"></a>1.3、进入到解压后的目录，查看内核版本，进行编译</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/haproxy-1.8.25/</span><br><span class="line">uname -r</span><br><span class="line">make TARGET=generic</span><br></pre></td></tr></table></figure>

<h4 id="1-4、编译完成之后，开始进行安装"><a href="#1-4、编译完成之后，开始进行安装" class="headerlink" title="1.4、编译完成之后，开始进行安装"></a>1.4、编译完成之后，开始进行安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make install PREFIX=/usr/<span class="built_in">local</span>/haproxy</span><br></pre></td></tr></table></figure>

<h4 id="1-5、安装完成之后，创建目录，创建HAProxy配置文件"><a href="#1-5、安装完成之后，创建目录，创建HAProxy配置文件" class="headerlink" title="1.5、安装完成之后，创建目录，创建HAProxy配置文件"></a>1.5、安装完成之后，创建目录，创建HAProxy配置文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/data/haproxy</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/haproxy/conf</span><br><span class="line">vi /usr/<span class="built_in">local</span>/haproxy/conf/haproxy.conf</span><br></pre></td></tr></table></figure>

<h4 id="1-6、向配置文件中添加配置信息"><a href="#1-6、向配置文件中添加配置信息" class="headerlink" title="1.6、向配置文件中添加配置信息"></a>1.6、向配置文件中添加配置信息</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">        <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">        <span class="comment">#log 127.0.0.1 local1 notice</span></span><br><span class="line">        <span class="comment">#log loghost local0 info</span></span><br><span class="line">        maxconn 4096</span><br><span class="line">        chroot /usr/<span class="built_in">local</span>/haproxy</span><br><span class="line">        pidfile /usr/data/haproxy/haproxy.pid</span><br><span class="line">        uid 99</span><br><span class="line">        gid 99</span><br><span class="line">        daemon</span><br><span class="line">        <span class="comment">#debug</span></span><br><span class="line">        <span class="comment">#quiet</span></span><br><span class="line">defaults</span><br><span class="line">		<span class="built_in">log</span> global</span><br><span class="line">		mode tcp</span><br><span class="line">		option abortonclose</span><br><span class="line">		option redispatch</span><br><span class="line">		retries 3</span><br><span class="line">		maxconn 2000</span><br><span class="line">		timeout connect 5000</span><br><span class="line">		timeout client 50000</span><br><span class="line">		timeout server 50000</span><br><span class="line">listen proxy_status</span><br><span class="line">	<span class="built_in">bind</span> :48066</span><br><span class="line">		mode tcp</span><br><span class="line">		balance roundrobin</span><br><span class="line">		server mycat_1 192.168.243.131:8066 check inter 10s</span><br><span class="line">		server mycat_2 192.168.242.132:8066 check inter 10s</span><br><span class="line">frontend admin_stats</span><br><span class="line">	<span class="built_in">bind</span> :7777</span><br><span class="line">		mode http</span><br><span class="line">		stats <span class="built_in">enable</span></span><br><span class="line">		option httplog</span><br><span class="line">		maxconn 10</span><br><span class="line">		stats refresh 30s</span><br><span class="line">		stats uri /admin</span><br><span class="line">		stats auth admin:123123</span><br><span class="line">		stats hide-version</span><br><span class="line">		stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure>

<h4 id="1-7、启动haproxy服务"><a href="#1-7、启动haproxy服务" class="headerlink" title="1.7、启动haproxy服务"></a>1.7、启动haproxy服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/haproxy/sbin/haproxy -f /usr/<span class="built_in">local</span>/haproxy/conf/haproxy.conf</span><br></pre></td></tr></table></figure>

<h4 id="1-8、查看haproxy的进程，如果存在则说明没有问题"><a href="#1-8、查看haproxy的进程，如果存在则说明没有问题" class="headerlink" title="1.8、查看haproxy的进程，如果存在则说明没有问题"></a>1.8、查看haproxy的进程，如果存在则说明没有问题</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep haproxy</span><br></pre></td></tr></table></figure>

<h4 id="1-9、打开浏览器访问-用户名为admin，密码为123123"><a href="#1-9、打开浏览器访问-用户名为admin，密码为123123" class="headerlink" title="1.9、打开浏览器访问,用户名为admin，密码为123123"></a>1.9、打开浏览器访问,用户名为admin，密码为123123</h4><p>​        <code>http://192.168.85.113:7777/admin</code></p>
<h4 id="1-10、任一连接一台haproxy登录访问"><a href="#1-10、任一连接一台haproxy登录访问" class="headerlink" title="1.10、任一连接一台haproxy登录访问"></a>1.10、任一连接一台haproxy登录访问</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h192.168.243.133 -P48066</span><br><span class="line">mysql -uroot -pRoot_123 -h192.168.243.134 -P48066</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/mycat/haproxy监控.jpg"  />

<hr>
<h3 id="2、安装配置Keepalived"><a href="#2、安装配置Keepalived" class="headerlink" title="2、安装配置Keepalived"></a>2、安装配置Keepalived</h3><p>​        在node-3和node-4安装<a href="https://www.keepalived.org/download.html" target="_blank" rel="noopener">Keepalived</a></p>
<h4 id="2-1、准备好Keepalived安装包"><a href="#2-1、准备好Keepalived安装包" class="headerlink" title="2.1、准备好Keepalived安装包"></a>2.1、准备好Keepalived安装包</h4><h4 id="2-2、解压到-usr-local目录"><a href="#2-2、解压到-usr-local目录" class="headerlink" title="2.2、解压到/usr/local目录"></a>2.2、解压到/usr/local目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf keepalived-1.4.5.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3、安装需要依赖的环境组件"><a href="#2-3、安装需要依赖的环境组件" class="headerlink" title="2.3、安装需要依赖的环境组件"></a>2.3、安装需要依赖的环境组件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install gcc openssl-devel popt-devel -y</span><br></pre></td></tr></table></figure>

<h3 id="2-4、进入到解压目录，进行编译"><a href="#2-4、进入到解压目录，进行编译" class="headerlink" title="2.4、进入到解压目录，进行编译"></a>2.4、进入到解压目录，进行编译</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span><br></pre></td></tr></table></figure>

<h4 id="2-5、编译完成之后，进行安装"><a href="#2-5、编译完成之后，进行安装" class="headerlink" title="2.5、编译完成之后，进行安装"></a>2.5、编译完成之后，进行安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="2-6、将keepalived的服务注册为系统服务"><a href="#2-6、将keepalived的服务注册为系统服务" class="headerlink" title="2.6、将keepalived的服务注册为系统服务"></a>2.6、将keepalived的服务注册为系统服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/</span><br><span class="line">mkdir /etc/keepalived</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</span><br></pre></td></tr></table></figure>

<h4 id="2-7、修改配置文件"><a href="#2-7、修改配置文件" class="headerlink" title="2.7、修改配置文件"></a>2.7、修改配置文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> etc/keepalived/</span><br><span class="line">vi keepalived.conf</span><br><span class="line"></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER <span class="comment">#备机需要修改此配置 backof</span></span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.243.100/24 dev ens33 label ens33:3:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8、启动keepalived"><a href="#2-8、启动keepalived" class="headerlink" title="2.8、启动keepalived"></a>2.8、启动keepalived</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/keepalived%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/vip.jpg" alt=""></p>
<h4 id="2-9、登录验证"><a href="#2-9、登录验证" class="headerlink" title="2.9、登录验证"></a>2.9、登录验证</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h 192.168.243.100 -P 48066</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、mycat监控工具"><a href="#三、mycat监控工具" class="headerlink" title="三、mycat监控工具"></a>三、mycat监控工具</h2><p>​        mycat-web是mycat可视化运维管理和监控平台，弥补了mycat在监控上的空白。帮mycat分担统计任务和配置管理任务。mycat-web引入了zookeeper作为配置中心，可以管理多个节点。mycat-web主要管理和监控mycat的流量、连接、活动现成和内存等，具备IP白名单、邮件告警等模块，还可以统计SQL并分析慢SQL和高频SQL等，为SQL的优化提供了依据。</p>
<h4 id="1、安装zookeeper"><a href="#1、安装zookeeper" class="headerlink" title="1、安装zookeeper"></a>1、安装zookeeper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载zookeeper安装包3.6.1</span><br><span class="line">2、安装拷贝到&#x2F;usr&#x2F;local目录，并解压</span><br><span class="line">3、进入到zookeeper解压后的目录conf,复制配置文件并改名</span><br><span class="line">	cp zoo_sample.cfg zoo.cfg</span><br><span class="line">4、进入到zookeeper的bin目录，运行启动命令</span><br><span class="line">	.&#x2F;zkServer.sh start</span><br><span class="line">5、执行如下命令，看zookeeper是否正常启动</span><br><span class="line">	netstat -nlpt | grep 2181</span><br></pre></td></tr></table></figure>

<h4 id="2、安装mycat-web"><a href="#2、安装mycat-web" class="headerlink" title="2、安装mycat-web"></a>2、安装mycat-web</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载mycat-web安装包1.0</span><br><span class="line">2、解压安装包到&#x2F;usr&#x2F;local目录</span><br><span class="line">3、进入mycat-web的目录运行启动命令</span><br><span class="line">	.&#x2F;start.sh &amp;</span><br><span class="line">4、mycat-web的服务端口是8082，查看服务是否启动</span><br><span class="line">	netstat -nlpt | grep 8082</span><br><span class="line">5、通过地址访问服务</span><br><span class="line">	192.168.85.111:8082&#x2F;mycat&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="3、mycat-web配置"><a href="#3、mycat-web配置" class="headerlink" title="3、mycat-web配置"></a>3、mycat-web配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、配置zookeeper</span><br><span class="line">	进入到mycat-web的&#x2F;usr&#x2F;local&#x2F;mycat-web&#x2F;mycat-web&#x2F;WEB-INF&#x2F;classes，修改mycat.properties文件，可以修改zookeeper的地址</span><br><span class="line">2、添加mycat实例</span><br><span class="line">	在页面的mycat配置--》mycat服务管理中添加mycat实例，需要填写相关的参数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8安装</title>
    <url>/2020/11/29/jdk1.8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、安装rz、sz命令"><a href="#一、安装rz、sz命令" class="headerlink" title="一、安装rz、sz命令"></a>一、安装rz、sz命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure>

<h2 id="二、rpm方式安装jdk"><a href="#二、rpm方式安装jdk" class="headerlink" title="二、rpm方式安装jdk"></a>二、rpm方式安装jdk</h2><a id="more"></a>

<h3 id="1-查看是否含有系统自带jdk"><a href="#1-查看是否含有系统自带jdk" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-上传安装包"><a href="#2-上传安装包" class="headerlink" title="2. 上传安装包"></a>2. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效"><a href="#3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效" class="headerlink" title="3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)"></a>3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh jdk-8u162-linux-x64.rpm</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/jdk/rpm安装jdk.jpg" style="zoom:100%;" />

<h3 id="4-修改系统环境变量"><a href="#4-修改系统环境变量" class="headerlink" title="4. 修改系统环境变量"></a>4. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容"><a href="#5-追加以下内容" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/jdk/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%E5%86%85%E5%AE%B9.jpg" alt=""></p>
<h3 id="6-让修改生效"><a href="#6-让修改生效" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态"><a href="#7-查看系统环境状态" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/jdk/%E8%AE%A9%E4%BF%AE%E6%94%B9%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.jpg" alt=""></p>
<h3 id="8-删除rpm安装的jdk"><a href="#8-删除rpm安装的jdk" class="headerlink" title="8. 删除rpm安装的jdk"></a>8. 删除rpm安装的jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br><span class="line">yum -y remove xxx</span><br></pre></td></tr></table></figure>

<h2 id="三、tar-gz包安装jdk"><a href="#三、tar-gz包安装jdk" class="headerlink" title="三、tar.gz包安装jdk"></a>三、tar.gz包安装jdk</h2><h3 id="1-查看是否含有系统自带jdk-1"><a href="#1-查看是否含有系统自带jdk-1" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2. 创建文件夹"></a>2. 创建文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure>

<h3 id="3-上传安装包"><a href="#3-上传安装包" class="headerlink" title="3. 上传安装包"></a>3. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="4-解压"><a href="#4-解压" class="headerlink" title="4. 解压"></a>4. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>-z　通过gzip指令处理备份文件<br>-x　从备份文件中还原文件<br>-v　显示指令执行过程<br>-f　指定备份文件</p>
<h3 id="5-修改系统环境变量"><a href="#5-修改系统环境变量" class="headerlink" title="5. 修改系统环境变量"></a>5. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容-1"><a href="#5-追加以下内容-1" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<h3 id="6-让修改生效-1"><a href="#6-让修改生效-1" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态-1"><a href="#7-查看系统环境状态-1" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从复制延迟问题</title>
    <url>/2021/05/02/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h2><p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt=""></p>
<ul>
<li>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进bin log，由于bin log是顺序写，所以效率很高。</li>
<li>master和slave之间的数据传输依靠了内部网络或专线，一般来说也是比较快的</li>
<li>slave读取master的数据写入relay log是追加日志，属于顺序io效率并不低</li>
<li>slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多</li>
<li>另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</li>
</ul>
<a id="more"></a>

<p>​        由此可以看出，延迟主要体现在<code>sql thread</code>处理数据入库阶段。</p>
<hr>
<h3 id="1、如何查看同步延迟状态？"><a href="#1、如何查看同步延迟状态？" class="headerlink" title="1、如何查看同步延迟状态？"></a>1、如何查看同步延迟状态？</h3><p>​            在从服务器上通过  show slave status 查看具体的参数，有几个参数比较重要：</p>
<p>​            <strong>master_log_file:    slave中的IO线程正在读取的主服务器二进制日志文件的名称</strong></p>
<p>​            <strong>read_master_log_pos:    在当前的主服务器二进制日志中，slave中的IO线程已经读取的位置</strong></p>
<p>​            <strong>relay_log_file:    sql线程当前正在读取和执行的中继日志文件的名称</strong></p>
<p>​            <strong>relay_log_pos:    在当前的中继日志中，sql线程已经读取和执行的位置</strong></p>
<p>​            <strong>relay_master_log_file:    由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称</strong></p>
<p>​            <strong>slave_io_running:    IO线程是否被启动并成功的连接到主服务器上</strong></p>
<p>​            <strong>slave_sql_running:    sql线程是否被启动</strong></p>
<p>​            <strong>seconds_behind_master:    从属服务器sql线程和从属服务器IO线程之间的事件差距，单位以秒计</strong></p>
<p>​            在观察同步延迟的时候，上述的几个参数都是比较重要的，其中有一个最最重要的参数需要我们引起注意，那就是<code>seconds_behind_master</code>，这个参数就表示当前备库延迟了多长时间，那么这个值是如何计算的呢？</p>
<p>​            在进行主从复制的时候，需要注意以下几个关键的时刻：</p>
<p>​            1、主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</p>
<p>​            2、之后传给备库B,我们把备库B接受完这个binlog的时刻记为T2;</p>
<p>​            3、备库B执行完成这个事务，我们把这个时刻记为T3;</p>
<p>​            所谓的主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到SBM。</p>
<p>​            如果刚刚的流程明白了，那么下面我们就要开始分析产生这个时间差值的原因有哪些了，以方便我们更好的解决生产环境中存在的问题。</p>
<h3 id="2、主从复制延迟产生的原因有哪些？"><a href="#2、主从复制延迟产生的原因有哪些？" class="headerlink" title="2、主从复制延迟产生的原因有哪些？"></a>2、主从复制延迟产生的原因有哪些？</h3><p>​        2.1、在某些部署环境中，slave所在的机器性能要比master所在的机器性能差。此时如果机器的资源不足的话就会影响slave同步的效率。</p>
<p>​        2.2、slave充当了读库，一般情况下主要写的压力在于master，那么slave会提供一部分读的压力，而如果slave的查询压力过大的话，slave的查询消耗了大量的CPU资源，那么必不可少的就会影响同步的速度。</p>
<p>​        2.3、大事务执行，如果master的一个事务执行了10分钟，而bin log的写入必须要等待事务完成之后，才会传入slave，那么此时在开始执行的时候就已经延迟了10分钟了。</p>
<p>​        2.4、master的对于bin log的写操作是追加日志，属于顺序写，slave单线程去master顺序读bin log，slave取到bin log之后在本地执行。mysql的主从复制都是<strong>单线程</strong>的操作，但是由于master是顺序写，所以效率很高，而slave也是顺序读取master的日志，此时的效率也是比较高的，但是当数据拉取回来之后，sql thread处理数据变成了随机的操作，而不是顺序的，所以此时成本会提高。</p>
<p>​        2.5、 slave在同步数据的同时，可能跟其他查询的线程发生锁抢占的情况，此时也会发生延时。</p>
<p>​        2.6、 当master的TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟。</p>
<p>​        2.7、 在进行bin log日志传输的时候，如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟。</p>
<p>​        这些就是可能会造成备库延迟的原因。</p>
<h3 id="3、如何解决复制延迟的问题"><a href="#3、如何解决复制延迟的问题" class="headerlink" title="3、如何解决复制延迟的问题"></a>3、如何解决复制延迟的问题</h3><p>​        先说一些虚的东西，什么叫虚的东西呢？就是一听上去感觉很有道理，但是在实施或者实际的业务场景中可能难度很大或者很难实现，下面我们从几个方面来进行描述：</p>
<h4 id="3-1、架构方面"><a href="#3-1、架构方面" class="headerlink" title="3.1、架构方面"></a>3.1、架构方面</h4><p>​            3.1.1、业务的持久化层的实现采用分库架构，让不同的业务请求分散到不同的数据库服务上，分散单台机器的压力</p>
<p>​            3.1.2、服务的基础架构在业务和mysql之间加入缓存层，减少mysql的读的压力，但是需要注意的是，如果数据经常要发生修改，那么这种设计是不合理的，因为需要频繁的去更新缓存中的数据，保持数据的一致性，导致缓存的命中率很低，所以此时就要慎用缓存了</p>
<p>​            3.1.3、使用更好的硬件设备，比如cpu，ssd等，但是这种方案一般对于公司而言不太能接受，原因也很简单，会增加公司的成本，而一般公司其实都很抠门，所以意义也不大，但是你要知道这也是解决问题的一个方法，只不过你需要评估的是投入产出比而已。</p>
<h4 id="3-2、从库配置方面"><a href="#3-2、从库配置方面" class="headerlink" title="3.2、从库配置方面"></a>3.2、从库配置方面</h4><p>​        <strong>3.2.1、修改sync_binlog的参数的值</strong></p>
<p>​        想要合理设置此参数的值必须要清楚的知道binlog的写盘的流程：</p>
<img src="http://yrlzero.gitee.io/images/linux/mysql/sync_binlog.png" style="zoom:80%;" />

<p>可以看到，每个线程有自己的bin log cache，但是共用同一份bin log。</p>
<p>​        图中的write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快</p>
<p>​        图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占用磁盘的IOPS</p>
<p>​        而write和fsync的时机就是由参数sync_binlog来进行控制的。</p>
<p>​        1、当sync_binlog=0的时候，表示每次提交事务都只write，不fsync</p>
<p>​        2、当sync_binlog=1的时候，表示每次提交事务都执行fsync</p>
<p>​        3、当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p>
<p>​        一般在公司的大部分应用场景中，我们建议将此参数的值设置为1，因为这样的话能够保证数据的安全性，但是如果出现主从复制的延迟问题，可以考虑将此值设置为100~1000中的某个数值，非常不建议设置为0，因为设置为0的时候没有办法控制丢失日志的数据量，但是如果是对安全性要求比较高的业务系统，这个参数产生的意义就不是那么大了。        </p>
<p>​        2、直接禁用salve上的bin log，当从库的数据在做同步的时候，有可能从库的binlog也会进行记录，此时的话肯定也会消耗io的资源，因此可以考虑将其关闭，但是需要注意，如果你搭建的集群是级联的模式的话，那么此时的bin log也会发送到另外一台从库里方便进行数据同步，此时的话，这个配置项也不会起到太大的作用。</p>
<p>​        3、设置innodb_flush_log_at_trx_commit 属性，这个属性用来表示每一次的事务提交是否需要把日志都写入磁盘，这是很浪费时间的，一共有三个属性值，分别是0（每次写到服务缓存，一秒钟刷写一次），1（每次事务提交都刷写一次磁盘），2（每次写到os缓存，一秒钟刷写一次），一般情况下我们推荐设置成2，这样就算mysql的服务宕机了，卸载os缓存中的数据也会进行持久化。</p>
<h3 id="4、从根本上解决主从复制的延迟问题"><a href="#4、从根本上解决主从复制的延迟问题" class="headerlink" title="4、从根本上解决主从复制的延迟问题"></a>4、从根本上解决主从复制的延迟问题</h3><p>​        大多数时候我们在线上的业务系统中都使用了mysql的主从复制，但是需要注意的是，并不是所有的场景都适合主从复制，一般情况下是读要远远多于写的应用，同时读的时效性要求不那么高的场景。如果真实场景中真的要求立马读取到更新之后的数据，那么就只能强制读取主库的数据，所以在进行实现的时候要考虑实际的应用场景，不要为了技术而技术，这是很严重的事情。</p>
<p>​        在mysql5.6版本之后引入了一个概念，就是我们通常说的<code>MTS</code>-Multi Thread Slave（并行复制），如下图：</p>
<img src="http://yrlzero.gitee.io/images/linux/mysql/并行复制.png" style="zoom:80%;" />

<p>通过上图我们可以发现其实所谓的<code>MTS-并行复制</code>，就是在中间添加了一个分发的环节，也就是说原来的<code>sql thread</code>变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看并行的slave的线程的个数，默认是0.表示单线程</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slave_parallel_workers'</span>;</span><br><span class="line"><span class="comment">-- 根据实际情况保证开启多少线程</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slave_parallel_workers = <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 设置并发复制的方式，默认是一个线程处理一个库，值为database</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slave_parallel_type%'</span>;</span><br><span class="line"><span class="comment">-- 停止slave</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="comment">-- 设置属性值</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slave_parallel_type=<span class="string">'logical_check'</span>;</span><br><span class="line"><span class="comment">-- 开启slave</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- 查看线程数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure>

<p>​        通过上述的配置可以完成我们说的<code>MTS</code>-并行复制，但是此时需要思考几个问题</p>
<blockquote>
<p>1、在并行操作的时候，可能会有并发的事务问题，slave在执行的时候可以按照轮询的方式发送给各个worker吗？</p>
<p>​        答案：不行，因为事务被分发给worker以后，不同的worker就开始独立执行了，但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。</p>
<p>2、同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p>
<p>​        答案：不行，举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。</p>
</blockquote>
<p>​        我们通过讲解上述两个问题的最主要目的是为了说明一件事，就是coordinator在进行分发的时候，需要遵循的策略是什么？</p>
<blockquote>
<p>1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p>
<p>2、同一个事务不能被拆开，必须放到同一个worker中。</p>
</blockquote>
<p>​        综上所述，我们来说一下具体实现的原理和过程。</p>
<p>​        如果让我们自己来设计的话，我们应该如何操作呢？这是一个值得思考的问题。其实如果按照实际的操作的话，我们可以按照粒度进行分类，分为按库分发，按表分发，按行分发。</p>
<p>​        其实不管按照什么方式进行分发，大家需要注意的就是在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一个hash表，用来保存当前这个work正在执行的事务所涉及到的表。hash表的key值按照不同的粒度需要存储不同的值：</p>
<p>​        按库分发：key值是数据库的名字，这个比较简单</p>
<p>​        按表分发：key值是库名+表名</p>
<p>​        按行分发：key值是库名+表名+唯一键</p>
<h4 id="4-1、MySQL5-6版本的并行复制策略"><a href="#4-1、MySQL5-6版本的并行复制策略" class="headerlink" title="4.1、MySQL5.6版本的并行复制策略"></a>4.1、MySQL5.6版本的并行复制策略</h4><p>​        其实从mysql的5.6版本开始就已经支持了并行复制，只是支持的粒度是按库并行，这也是为什么现在的版本中可以选择类型为database，其实说的就是支持按照库进行并行复制。</p>
<p>​        但是其实用过的同学应该都知道，这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好，但是如果主库的所有表都放在同一DB上，那么所有的操作都会分发给一个worker，变成单线程操作了，那么这个策略的效果就不好了，因此在实际的生产环境中，用的并不是特别多。</p>
<h4 id="4-2、mariaDB的并行复制策略"><a href="#4-2、mariaDB的并行复制策略" class="headerlink" title="4.2、mariaDB的并行复制策略"></a>4.2、mariaDB的并行复制策略</h4><p>​        在mysql5.7的时候采用的是基于组提交的并行复制，换句话说，slave服务器的回放与主机是一致的，即主库是如何并行执行的那么slave就如何怎样进行并行回放，这点其实是参考了mariaDB的并行复制，下面我们来看下其实现原理。</p>
<p>​        mariaDB的并行复制策略利用的就是这个特性：</p>
<p>​        1、能够在同一组里提交的事务，一定不会修改同一行；</p>
<p>​        2、master上可以并行执行的事务，slave上也一定是可以并行执行的。</p>
<p>​        在实现上，mariaDB是这么做的：</p>
<p>​        1、在一组里面一起提交的事务，有一个相同的commit_id,下一组就是commit_id+1;</p>
<p>​        2、commit_id直接写到binlog里面；</p>
<p>​        3、传到slave应用的时候，相同commit_id的事务会分发到多个worker执行；</p>
<p>​        4、这一组全部执行完成后，coordinator再去取下一批。</p>
<p>​        这是mariaDB的并行复制策略，大体上看起来是没有问题的，但是你仔细观察的话会发现他并没有实现“真正的模拟主库并发度”这个目标，在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>​        我们真正想要达到的并行复制应该是如下的状态，也就是说当第一组事务提交的是，下一组事务是运行的状态，当第一组事务提交完成之后，下一组事务会立刻变成commit状态。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/mariaDB1.png" alt=""></p>
<p>​        但是按照mariaDB的并行复制策略，那么备库上的执行状态会变成如下所示：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/mariaDB2.png" alt=""></p>
<p>可以看到，这张图跟上面这张图的最大区别在于，slave上执行的时候必须要等第一组事务执行完成之后，第二组事务才能开始执行，这样系统的吞吐量就不够了。而且这个方案很容易被大事务拖后腿，如果trx2是一个大事务，那么在备库应用的时候，trx1和trx3执行完成之后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费。</p>
<h4 id="4-3、mysql5-7的并行复制策略"><a href="#4-3、mysql5-7的并行复制策略" class="headerlink" title="4.3、mysql5.7的并行复制策略"></a>4.3、mysql5.7的并行复制策略</h4><p>​        mysql5.7版本的时候，根据mariaDB的并行复制策略，做了相应的优化调整后，提供了自己的并行复制策略，并且可以通过参数slave-parallel-type来控制并行复制的策略：</p>
<p>​        1、当配置的值为DATABASE的时候，表示使用5.6版本的按库并行策略；</p>
<p>​        2、当配置的值为LOGICAL_CLOCK的时候，表示跟mariaDB相同的策略。</p>
<p>​        此时，大家需要思考一个问题：<strong>同时处于执行状态的所有事务，是否可以并行？</strong></p>
<p>​        答案：不行，因为多个执行中的事务是有可能出现锁冲突的，锁冲突之后就会产生锁等待问题。</p>
<p>​        在mariaDB中，所有处于commit状态的事务是可以并行，因为如果能commit的话就说明已经没有锁的问题，但是大家回想下，我们mysql的日志提交是两阶段提交，如下图，其实只要处于prepare状态就已经表示没有锁的问题了。</p>
<img src="http://yrlzero.gitee.io/images/linux/mysql/两阶段提交.png" style="zoom: 45%;" />

<p>因此，mysql5.7的并行复制策略的思想是：</p>
<p>​        1、同时处于prepare状态的事务，在slave执行是可以并行的。</p>
<p>​        2、处于prepare状态的事务，与处于commit状态的事务之间，在slave上执行也是可以并行的。</p>
<p>​        基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置</p>
<p>​        1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</p>
<p>​        2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p>
<h3 id="5、基于GTID的主从复制问题"><a href="#5、基于GTID的主从复制问题" class="headerlink" title="5、基于GTID的主从复制问题"></a>5、基于GTID的主从复制问题</h3><p>​        在我们之前讲解的主从复制实操中，每次想要复制，必须要在备机上执行对应的命令，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.85.11'</span>,master_user=<span class="string">'root'</span>,master_password=<span class="string">'123456'</span>,master_port=<span class="number">3306</span>,master_log_file=<span class="string">'master-bin.000001'</span>,master_log_pos=<span class="number">154</span>;</span><br></pre></td></tr></table></figure>

<p>​        在此配置中我们必须要知道具体的bin log是哪个文件，同时在文件的哪个位置开始复制，正常情况下也没有问题，但是如果是一个主备主从集群，那么如果主机宕机，当从机开始工作的时候，那么备机就要同步从机的位置，此时位置可能跟主机的位置是不同的，因此在这种情况下，再去找位置就会比较麻烦，所以在5.6版本之后出来一个基于GTID的主从复制。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>
<p>​        GTID(global transaction id)是对于一个已提交事务的编号，并且是一个全局唯一的编号。GTID实际上是由UUID+TID组成的，其中UUID是mysql实例的唯一标识，TID表示该实例上已经提交的事务数量，并且随着事务提交单调递增。这种方式保证事务在集群中有唯一的ID，强化了主备一致及故障恢复能力。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM（一） 运行时数据区域</title>
    <url>/2021/01/03/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>​        <strong>Java 虚拟机在执行 Java 程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-1.png" alt="memory-1"></p>
<a id="more"></a>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​        程序计数器（<code>Program Counter Register</code>）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>​        <strong>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。</strong></p>
<p>​        因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”</strong>的内存。</p>
<p>​        如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <code>Native</code> 方法，这个计数器值则为空（<code>Undefined</code>）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何<code>OutOfMemoryError</code> 情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​        与程序计数器一样，Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）也是线程私有的，它的生命周期与线程相同。</p>
<p>​        <strong>虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧（<code>Stack Frame</code>）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></p>
<p>​        每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>​        经常有人把Java内存区分为<strong>堆内存</strong>（<code>Heap</code>）和<strong>栈内存</strong>（<code>Stack</code>），这种划分方式的流行只能说明大多数程序员最关注的、域对象内存分配关系最密切的内存区是这两块。Java 内存区域的划分实际上远比这复杂。</p>
<p>​        其中所指的“<strong>栈</strong>”就是虚拟机栈，或者说是虚拟机栈中的局部变量表。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-2.png" alt="memory-2"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>​        局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。</p>
<p>​        基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p>
<p>​        对象引用：<code>reference</code>类型，它不等同于对象本身，可能是个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他于此对象相关的位置</p>
<p>​        <code>returnAddress</code>类型：指向了一条字节码指令的地址</p>
<p>​        其中64位长度的 <code>long</code> 和 <code>double</code> 类型的数据会占用2个局部变量空间（<code>Slot</code>），其余的数据类型只占用1个。<code>Slot</code>是栈帧中的局部变量表的最小单位。</p>
<p>​        局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>​    虚拟机栈规定了两种异常情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常。</li>
<li>如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，将抛出<code>OutOfMemoryError</code>(<code>OOM</code>)异常。</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>​        Java 虚拟机的解释执行引擎被称为“ 基于栈的执行引擎 ”，其中所指的栈就是指－操作数栈。 <strong>操作数栈也常被称为操作栈</strong>，<strong>它是一个后入先出栈</strong>。</p>
<p>​        和局部变量表一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作( <strong>压栈和出栈</strong> )来访问的。</p>
<p>​        比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p>
<p>​        虚拟机在操作数栈中存储数据的方式和在局部变量表中是一样的。</p>
<p>​        虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>​        举例来说，在JVM中执行 <code>a = b + c</code>的字节码执行过程中操作数栈以及局部变量表的变化如下图所示。</p>
<p>​        局部变量表中存储着 <code>a、b、c</code> 三个局部变量，首先将 <code>b</code> 和 <code>c</code> 分别压入栈中，如下图<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-3.png" alt="memory-3"><br>​        将栈顶的两个数<strong>出栈执行求和操作，并将结果再次压入栈顶中</strong>，之后将栈顶的数出栈赋值给 <code>a</code>，如下图<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-4.png" alt="memory-4"></p>
<p>看一个比较经典的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncrementTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="keyword">int</span> j = i++;</span><br><span class="line">        <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">k = <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>代码分析：</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-5.png" alt="memory-5"></p>
<p>​        如上图，代码 <code>i = i++</code>，自增操作是在局部变量表中的，而不是在操作数栈中，因为是后++操作，所以i的值进入操作数栈之后自身才在局部变量表中自增，然后操作数栈的值会赋值回局部变量表，此时自增的结果被覆盖。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>i</code> 变量，此时 <code>i</code> 的值又变为了 <strong>1</strong></p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-6.png" alt="memory-6"></p>
<p>​        如上图，代码 <code>int j = i++</code>，因为是后++操作，i的值先进入操作数栈，自身再在局部变量表进行自增，操作数栈的值赋值给j。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>j</code> 变量，此时 <code>j</code> 的值为 <strong>1</strong></p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-7.png" alt="memory-7"></p>
<p>​        如上图，代码 <code>int k = i + ++i * i++</code></p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>2</strong> 压入操作数栈中</p>
</li>
<li><p>++i是先++，所以局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，再压入操作数栈中，此时 <code>i</code> 的值为 <strong>3</strong>，</p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-8.png" alt="memory-8"></p>
<p>如上图</p>
<ul>
<li>i++是后自增，i的值先进入操作数栈，而后局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code>的值为 <strong>4</strong></li>
<li>把操作数栈中前两个弹出求乘积<strong>（3 * 3 = 9）</strong>，将结果再次压入操作数栈中</li>
<li>把操作数栈中前两个弹出求和<strong>（9 + 2 = 11）</strong>，将结果再次压入操作数栈中</li>
<li>将操作数栈中的值 <strong>11</strong> 赋值给局部变量表中的 <code>k</code> 变量，此时 <code>k</code> 的值为 <strong>11</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>赋值 =，最后计算</li>
<li>= 右边的从左到右加载值依次压入操作数栈</li>
<li>根据运算符的优先级判断先算哪个</li>
<li><strong>自增和自减操作都是直接修改变量的值，不经过操作数栈</strong></li>
<li>最后赋值之前，临时结果都是保存在操作数栈中的</li>
</ul>
<p>值得提醒的是，<code>i++</code>和<code>++i</code>都不是原子操作，因为它并不会作为一个不可分割的操作来执行，实际上它包含三个独立的操作：</p>
<ul>
<li>读取<code>i</code>的值</li>
<li>将值加<code>1</code></li>
<li>然后将计算结果写入<code>i</code><br>这是一个<strong>读取-修改-写入</strong>的操作序列，并且其结果状态依赖于之前的状态。</li>
</ul>
<p>即使使用 <code>volatile</code> 修饰，保证了多个线程多<code>i</code>的可见性，每次从局部变量表读取的都是最新的值，也不是线程安全的。</p>
<p>如果假设 <strong>i=9</strong>，在某些情况下，多个线程读到的值都为 <strong>9</strong>，接着执行递增操作，并且都将<code>i</code>设置成 <strong>10</strong> ，显然不是线程安全的。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>​        每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p>
<p>​        Class 文件中存放了大量的符号引用，这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析，如静态方法、私有方法等等，另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。<br><strong>栈帧中保存了一个引用，指向该方法在运行时常量池中的位置，通过运行时常量池的符号引用（指向堆），完成将符号引用转化为直接引用</strong>。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>方法执行时有两种退出情况：</p>
<ul>
<li><p>正常退出，即正常执行到任何方法的返回字节码指令，如 <code>return</code>等</p>
</li>
<li><p>异常退出，即某些指令导致了 Java 虚拟机抛出异常并且没有处理</p>
</li>
</ul>
<p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p>
<ul>
<li><p>返回值压入上层调用栈帧。</p>
</li>
<li><p>异常信息抛给能够处理的栈帧。</p>
</li>
<li><p>PC计数器指向方法调用后的下一条指令。</p>
</li>
</ul>
<p>当方法执行正常退出时，当前栈帧承担着恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器、跳过刚才执行的方法调用指令等。调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​        本地方法栈（<code>Native Method Stack</code>）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <code>Native</code> 方法服务。<code>Sun HotSpot</code>虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<p>​        与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>​        对于大多数应用来说，Java 堆（<code>Java Heap</code>）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>​        Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做 “ <code>GC</code>堆 ”（<code>Garbage Collected Heap</code>）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 <code>Eden</code> 空间、<code>From Survivor</code> 空间、<code>To Survivor</code> 空间等。</p>
<p>​        从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（<code>Thread Local Allocation Buffer,TLAB</code>）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。</p>
<p>​        Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutOfMemoryError</code>异常。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-9.png" alt="memory-9"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-17.png" alt="memory"></p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>​        TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术，目的是提升在堆上创建对象的性能。</p>
<p>​        如果一个对象被创建到堆上时，需要在堆上申请指定大小的内存供新创建的对象使用，在这个过程中，堆会通过加锁或指针碰撞的方式防止同一块被重复申请，在JVM中，内存分配是一个非常频繁的动作，而给堆加锁或者校验碰撞指针的方式必定会影响内存创建效率，TLAB的出现就是为了优化这个问题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">TLAB是线程的一块私有内存:</span><br><span class="line"></span><br><span class="line">1.在线程启动的时候会在堆中为其申请一块指定大小的内存，这块内存只给当前线程使用，属于线程私有的.</span><br><span class="line">如果线程需要为线程内的对象分配内存，就在自己的空间上分配，这样就不存在内存分配竞争的情况了，大大的提升了分配效率。</span><br><span class="line"></span><br><span class="line">2.当TLAB空间容量不足时，就新申请一个TLAB，原来的那个TLAB区里的对象还维持现状，因为对象只能感知到自己在Eden区。</span><br><span class="line"></span><br><span class="line">3.TLAB空间的内存非常小，默认大小仅有Eden区的1%，一般用默认的就可以。</span><br><span class="line">也可以通过JVM参数-XX:TLABWasteTargetPercent设置TLAB空间占Eden空间的百分比大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">-UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置每个TLAB区域占Eden区的大小比例</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">TLABWasteTargetPercent</span></span><br></pre></td></tr></table></figure>

<p>​        每一个TLAB空间大小都是固定的，默认的是Eden区大小的的1%，既然大小是固定的，那么肯定会出现空间浪费的情况，比如TLAB大小是100kb，已经被使用了90kb，此时有一个12kb的对象来申请空间，但是TLAB的剩余空间已经不足以分配给这个对象了，此时怎么办？</p>
<p>​        是新申请一个TLAB，还是直接分配到Eden区？在设计TLAB的时候就已经考虑到这种情况了，<strong>使用变量refill_waste_limit来控制一个TLAB允许被浪费的空间大小</strong>。</p>
<p>​        当申请了新的TLAB后，旧的TLAB交由Eden管理。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-16.png" alt="memory"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-18.png" alt="memory"></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        方法区（<code>Method Area</code>）与 Java 堆一样，<strong>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。虽然<br><strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <code>Non-Heap</code>（非堆），目的应该是与 Java 堆区分开来。</p>
<p>​        Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<h4 id="HotSpot-虚拟机"><a href="#HotSpot-虚拟机" class="headerlink" title="HotSpot 虚拟机"></a><code>HotSpot</code> 虚拟机</h4><p>​        它是<code>Sun JDK</code>和<code>OpenJDK</code>中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。<br>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，Oracle同时拥有了两款优秀的Java虚拟机：<code>JRockit VM</code>和<code>HotSpot VM</code>。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-10.png" alt="memory-10"></p>
<h4 id="永久代、元空间"><a href="#永久代、元空间" class="headerlink" title="永久代、元空间"></a>永久代、元空间</h4><p>​        方法区只是 <code>JVM</code> 的一种规范，不同的虚拟机实现的原理不一样，只有JDK1.7及以下才有永久代的概念，JDK1.8称为元空间。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="class常量池"><a href="#class常量池" class="headerlink" title="class常量池"></a>class常量池</h4><p>​        我们写的每一个 Java 类被编译后，就会形成一份<code>class</code> 文件。<code>class</code> 文件中除了包含类的<strong>版本、字段、方法、接口等描述信息外，还有一项信息就是常量池</strong>(<code>constant pool table</code>)，用于存放编译器生成的各种<strong>字面量</strong>(<code>Literal</code>)和<strong>符号引用</strong>(<code>Symbolic References</code>)。</p>
<p>​        每个class文件都有一个class常量池。</p>
<p>字面量包括：</p>
<ul>
<li>文本字符串</li>
<li>八大基本类型的值</li>
<li>被申明为<code>final</code>的常量</li>
</ul>
<p>符号引用包括：</p>
<ul>
<li>类和方法的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<strong>class文件常量池将在类加载后进入方法区的运行时常量池中存放</strong>。</p>
<p>​        一般来说，除了保存 <code>Class</code> 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​        <strong>运行时常量池相对于 <code>Class</code> 文件常量池的另外一个重要特征是具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 <code>Class</code> 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</p>
<p>​        既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，<strong>当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常</strong>。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>​        在<code>HotSpot</code>虚拟机里实现的字符串常量池(<code>string pool</code>)功能的是一个<code>StringTable</code>类，它是一个<code>Hash</code>表，这个<code>StringTable</code>在每个<code>HotSpot</code>虚拟机的实例<strong>只有一份</strong>，被所有的类共享。字符串常量由一个一个字符组成，放在了<code>StringTable</code>上。</p>
<h4 id="JDK版本变化"><a href="#JDK版本变化" class="headerlink" title="JDK版本变化"></a>JDK版本变化</h4><p>​        <strong>JDK1.6及以前的版本，字符串常量池是存放在永久代中。</strong></p>
<p>​        <strong>在JDK1.7的版本中，字符串常量池从永久代移出到正常的Java 堆(Java Heap)中，原因是因为永久代空间太小，容易造成OOM。</strong></p>
<p>​        <strong>在JDK1.8的版本中，Hotspot虚拟机废除了永久代，开始使用元空间（Metaspace）实现方法区，字符串常量池依旧保留在堆内存中，其他内容移至元空间，元空间直接在本地内存分配，而不需要占用堆内存，所以不会造成OOM现象。</strong></p>
<p>​        <strong>值得注意的是，方法区只是Jvm的一种规范，Hotspot通过废除永久代，使用元空间实现方法区，并不存在废除方法区、方法区被元空间代替这种说法。</strong></p>
<p>​        <strong>为什么要使用元空间取代永久代的实现？</strong></p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为 <code>GC</code> 带来不必要的复杂度，并且回收效率偏低</li>
<li>将 <code>HotSpot</code> 与 <code>JRockit</code> 合二为一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"String"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        str.intern();</span><br><span class="line">        str = str + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-11.png" alt="memory-11"><br>        使用<strong>JDK1.7 或者 1.8</strong> 能够看到，往字符串常量池中无限增加，最终 <code>OOM</code> 的位置是在Java 堆（<code>Java heap</code>）中。</p>
<p>​        <strong><code>String.intern()</code>用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。</strong></p>
<p>​        看一道比较常见的面试题，在不考虑 <code>GC</code> 的情况下，下面的代码创建了多少个 <code>String</code> 对象，输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure>
<p><strong>答案：</strong></p>
<ul>
<li>在 JDK 1.6 下输出是 <strong><code>false</code></strong>，<strong>创建了 6 个对象</strong></li>
<li>在 JDK 1.7 之后的版本输出是 <strong><code>true</code></strong>，<strong>创建了 5 个对象</strong></li>
</ul>
<p><strong>代码分析：</strong></p>
<p>​        为什么输出会有这些变化呢？主要还是字符串池从永久代中脱离、移入堆区的原因， <code>intern()</code> 方法也相应发生了变化：</p>
<ul>
<li><p>在 <code>JDK 1.6</code> 中，调用 <code>intern()</code> 首先会在字符串池中寻找<code>equal()</code> 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，<strong>虚拟机会重新在永久代上创建一个实例</strong>，将 <code>StringTable</code> 的一个表项指向这个新创建的实例。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-12.png" alt="memory-12"></p>
</li>
<li><p>在 <code>JDK 1.7</code> 中，由于字符串池不在永久代了，<code>intern()</code> 做了一些修改，更方便地利用堆中的对象。字符串存在时和 <code>JDK 1.6</code>一样返回常量池的引用，不存在时如果堆中存在，那也不需要再拷贝字符串的实例到常量池，既然字符串常量池已经移到Java堆中，只需要在常量池里记录一下首次出现的实例引用即可。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-13.png" alt="memory-13"></p>
</li>
</ul>
<p>我们基于JDK1.7版本，来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>由于字符串常量池中已存在<code>abc</code>，所以返回了字符串常量池中的引用，如下图所示<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-14.png" alt="memory-14"></p>
<p>再来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">str1.intern();</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>​        该结果等于<code>true</code>应该是能够理解的，不理解的可以查看上文针对该代码的实例分析图</p>
<p>​        这里扩展一点，若是把<code>str1.intern();</code>代码注释掉，则产生的结果为<code>false</code>。</p>
<p>​        其原因在于<code>str1</code>对象是通过<code>new</code>对象拼接产生的，字符串常量池中并不存在字符串<code>hello</code>，当调用<code>String str2=&quot;hello&quot;;</code>代码时字符串常量池中产生才该字符串，所以他们并不是同一个地址引用。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>​        <strong>直接内存（<code>Direct Memory</code>）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</strong>。</p>
<p>​        在 <code>JDK 1.4</code> 中新加入了 <code>NIO</code>，引入了一种基于通道（<code>Channel</code>）与缓冲区（<code>Buffer</code>）的 <code>I/O</code> 方式，它可以使用 <code>Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>​        显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-15.png" alt="memory-15"></p>
<hr>
<blockquote>
<p>“本篇文章主要摘自《深入理解Java虚拟机_JVM高级特性与最佳实践 第2版》”</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从复制</title>
    <url>/2021/04/28/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。</p>
<p>​        MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<a id="more"></a>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>​        （1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</p>
<p>​        （2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p>
<p>​        （3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。        </p>
<p><strong>也就是说</strong>：</p>
<ul>
<li>从库会生成两个线程,一个<code>I/O线程</code>,一个<code>SQL线程</code>;</li>
<li><code>I/O线程</code>会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li>
<li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li>
<li><code>SQL线程</code>,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li>
<li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li>
<li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li>
<li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</li>
<li>master和slave两节点间时间需同步</li>
</ul>
<p><strong>具体步骤</strong>：</p>
<p>1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</p>
<p>2、从库的IO线程和主库的dump线程建立连接。</p>
<p>3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p>
<p>4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p>
<p>5、从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p>
<p>6、从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p>
<hr>
<h2 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h2><p>延迟问题请点击跳转<a href="https://yrlzero.gitee.io/2021/05/02/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F">主从复制延迟专题</a></p>
<h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改<code>master</code>配置文件<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启动二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment">#设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="comment">#设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br></pre></td></tr></table></figure>

<p>修改<code>slave</code>配置文件<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p>重启master和slave的mysql服务</p>
<p><code>service mysql restart</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E9%87%8D%E5%90%AFmysql%E6%9C%8D%E5%8A%A1.jpg" alt=""></p>
<h3 id="授权账户"><a href="#授权账户" class="headerlink" title="授权账户"></a>授权账户</h3><p>登录master的mysql服务，授权账户主从复制权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Root_123&#39;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7slave%E6%9D%83%E9%99%90.jpg" alt=""></p>
<h3 id="查看master状态"><a href="#查看master状态" class="headerlink" title="查看master状态"></a>查看master状态</h3><p>登录master的mysql服务中，执行<code>show master status</code>查询master状态</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bmaster%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<p>File和Position的值在下面的slave服务中会使用到；</p>
<p>可以通过<code>start master</code>、<code>stop master</code>、<code>reset master</code>等命令操作master，但是操作之后的master状态值可能发生变化</p>
<h3 id="slave执行主从复制命令"><a href="#slave执行主从复制命令" class="headerlink" title="slave执行主从复制命令"></a>slave执行主从复制命令</h3><p>登录slave的mysql服务中，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-slave%E6%89%A7%E8%A1%8C%E5%A4%8D%E5%88%B6%E6%8C%87%E4%BB%A4.jpg" alt=""></p>
<h3 id="查看slave状态"><a href="#查看slave状态" class="headerlink" title="查看slave状态"></a>查看slave状态</h3><p>在slave的mysql服务中执行<code>show slave status\G</code>查看slave状态</p>
<p>这时可以看到Slave_IO_Running，Slave_SQL_Running这两个属性都是NO</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bslave%E7%8A%B6%E6%80%81.jpg" alt=""></p>
<h3 id="启动slave"><a href="#启动slave" class="headerlink" title="启动slave"></a>启动slave</h3><p>此时需要执行<code>start slave</code>命令，启动slave</p>
<p>当看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示主从复制已经准备好了，可以进行具体的操作了</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%9F%A5%E7%9C%8Bslave%E7%8A%B6%E6%80%81-02.jpg" alt=""></p>
<p>关于slave，也可以通过<code>start slave</code>、<code>stop slave</code>、<code>reset slave</code>等命令操作slave</p>
<h3 id="建库同步"><a href="#建库同步" class="headerlink" title="建库同步"></a>建库同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave查看数据库，都没有mytest这个库</span><br><span class="line">-- 在master执行建库语句</span><br><span class="line">create database mytest;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E5%BB%BA%E5%BA%93%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中创建的mytest库</p>
<h3 id="建表同步"><a href="#建表同步" class="headerlink" title="建表同步"></a>建表同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave中进入mytest数据库，查看表格，都没有t1这个表</span><br><span class="line">-- 在master执行建表语句</span><br><span class="line">create table t1(id int,name varchar(10));</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E5%BB%BA%E8%A1%A8%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中创建的t1表</p>
<h3 id="语句同步"><a href="#语句同步" class="headerlink" title="语句同步"></a>语句同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分别在master和slave中进入mytest数据库，查看t1表格数据，都为空</span><br><span class="line">-- 在master执行insert语句</span><br><span class="line">insert into t1 values(1,&#39;zhangsan&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-insert%E5%90%8C%E6%AD%A5.jpg" alt=""></p>
<p>此时可以看到右边的slave出现了在master中执行insert命令插入的数据</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当master执行的语句被同步到slave时，如果slave存在对应的语句在约束上与master同步过来的语句冲突时，同步会失败，在<code>/var/log/mysqld.log</code>中可以看到错误。</p>
<p>所以一般来说从库不允许写入，只能读取。</p>
<hr>
<h2 id="多主多从"><a href="#多主多从" class="headerlink" title="多主多从"></a>多主多从</h2><p>​    在上述的一主一从的架构设计中，很容易出现单点的问题，所以我们要想让生产环境中的配置足够稳定，可以配置双主双从，解决单点的问题。</p>
<img src="http://yrlzero.gitee.io/images/linux/mycat/mycat多主多从.jpg" style="zoom: 67%;" />

<p>在此架构中，可以让一台主机用来处理所有写请求，此时，它的从机和备机，以及备机的从机复制所有读请求，当主机宕机之后，另一台主机负责写请求，两台主机互为备机。</p>
<p>主机分布如下：    </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>角色</th>
<th>ip</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>master-1</td>
<td>192.168.243.131</td>
<td>centos-1</td>
</tr>
<tr>
<td>2</td>
<td>slave-1</td>
<td>192.168.243.132</td>
<td>centos-2</td>
</tr>
<tr>
<td>3</td>
<td>master-2</td>
<td>192.168.243.133</td>
<td>centos-3</td>
</tr>
<tr>
<td>4</td>
<td>slave-2</td>
<td>192.168.243.134</td>
<td>centos-4</td>
</tr>
</tbody></table>
<p><code>master-1</code>与<code>slave-1</code>为主从关系、<code>master-2</code>与<code>slave-2</code>为主从关系、<code>master-1</code>与<code>master-2</code>互为主备关系</p>
<h3 id="master-1"><a href="#master-1" class="headerlink" title="master-1"></a><code>master-1</code></h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=my_multi_test</span><br><span class="line"><span class="comment">#设置binlog的格式row（生产推荐使用，在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h3 id="master-2"><a href="#master-2" class="headerlink" title="master-2"></a><code>master-2</code></h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=my_multi_test</span><br><span class="line"><span class="comment">#设置binlog的格式row（生产推荐使用，在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates</span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h3 id="slave-1"><a href="#slave-1" class="headerlink" title="slave-1"></a>slave-1</h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="slave-2"><a href="#slave-2" class="headerlink" title="slave-2"></a>slave-2</h3><p>修改配置<code>vi /etc/my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启启动4台mysql <code>service musqld restart</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E9%87%8D%E5%90%AFmysql.jpg" alt=""></p>
<h3 id="授权账户-1"><a href="#授权账户-1" class="headerlink" title="授权账户"></a>授权账户</h3><p>登录<code>master-1</code>、<code>master-2</code>的mysql服务，授权账户主从复制权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Root_123&#39;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E-%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7slave%E6%9D%83%E9%99%90.jpg" alt=""></p>
<h3 id="slave执行主从复制命令-1"><a href="#slave执行主从复制命令-1" class="headerlink" title="slave执行主从复制命令"></a>slave执行主从复制命令</h3><p>因为<code>master-1</code>之前生成过bin log文件所以file为mysql-bin.000006，可以通过执行重置命令<code>reset master</code>解决，回归初始状态</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E9%87%8D%E7%BD%AEmaster.jpg" alt=""></p>
<p>登录<code>slave</code>的mysql服务中，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- slave-1中执行命令，对master-1进行主从复制</span><br><span class="line">-- MASTER_HOST为master-1的ip、MASTER_LOG_FILE为master-1的File名、MASTER_LOG_POS为master-1的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br><span class="line"></span><br><span class="line">-- slave-2中执行命令，对master-2进行主从复制</span><br><span class="line">-- MASTER_HOST为master-2的ip、MASTER_LOG_FILE为master-2的File名、MASTER_LOG_POS为master-2的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.133&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;442;</span><br></pre></td></tr></table></figure>

<h3 id="启动slave-1"><a href="#启动slave-1" class="headerlink" title="启动slave"></a>启动slave</h3><p>此时需要执行<code>start slave</code>命令，启动slave</p>
<h3 id="查看slave状态-1"><a href="#查看slave状态-1" class="headerlink" title="查看slave状态"></a>查看slave状态</h3><p>在slave的mysql服务中执行<code>show slave status\G</code>查看slave状态</p>
<p>当看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示主从复制已经准备好了，可以进行具体的操作了</p>
<h3 id="主备同步"><a href="#主备同步" class="headerlink" title="主备同步"></a>主备同步</h3><p>让<code>master-1</code>、<code>master-2</code>之间相互进行主从复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- master-1中执行命令，对master-2进行主从复制</span><br><span class="line">-- MASTER_HOST为master-2的ip、MASTER_LOG_FILE为master-2的File名、MASTER_LOG_POS为master-2的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.133&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;442;</span><br><span class="line"></span><br><span class="line">-- master-2中执行命令，对master-1进行主从复制</span><br><span class="line">-- MASTER_HOST为master-1的ip、MASTER_LOG_FILE为master-1的File名、MASTER_LOG_POS为master-1的Position值</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.243.131&#39;,MASTER_USER&#x3D;&#39;root&#39;,MASTER_PASSWORD&#x3D;&#39;Root_123&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,MASTER_LOG_POS&#x3D;154;</span><br></pre></td></tr></table></figure>

<p>执行<code>start slave</code>命令，启动slave</p>
<p>当两台master执行<code>show slave status\G</code>都看到Slave_IO_Running，Slave_SQL_Running这两个属性都是yes的时候，表示互为主备成功</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在<code>master-1</code>中执行<code>create database my_multi_test</code>语句创建数据库，如下图可以看到<code>master-1</code>执行完之后其余三台mysql均能查询到my_multi_test库；在<code>master-1</code>进入该数据库创建表t1，并在其他mysql能够查到，证明主从和主备搭建成功</p>
<img src="http://yrlzero.gitee.io/images/linux/mysql/双主双从-01.jpg" style="zoom: 80%;" />

<img src="http://yrlzero.gitee.io/images/linux/mysql/双主双从-02.jpg" style="zoom: 80%;" />

<hr>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>使用<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#读写分离">mycat</a>进行读写分离，具体细节请点击查看<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#读写分离">mycat-读写分离</a></p>
<hr>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>如果在运行时发现从库数据没有同步，则需要执行<code>show slave status\G</code>查看slave状态，如果看到Slave_IO_Running，Slave_SQL_Running这两个属性任一出现NO，则需要进行重置操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- master-1</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">master</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- slave-1</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- master-2</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">master</span></span><br><span class="line"><span class="comment">-- slave-2</span></span><br><span class="line">	<span class="keyword">stop</span> <span class="keyword">slave</span></span><br><span class="line">	<span class="keyword">reset</span> <span class="keyword">slave</span></span><br><span class="line"><span class="comment">-- 再执行主从命令	</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line"><span class="comment">-- 启动每个mysql的slave</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br></pre></td></tr></table></figure>

<p>此时再查看可以发现数据可以进行同步，但是之前的旧数据仍保持不变，之前同步失败的仍旧不会同步过来；</p>
<p>如果需要将之前的旧数据进行同步，那么slave节点的mysql需要清空数据，再重置，执行<code>CHANGE MASTER TO</code>主从命令；</p>
<p>但是需要注意的是主从命令参数中的<code>MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,MASTER_LOG_POS=154</code>需要是主节点最初的对应的参数；</p>
<p>因此，建议搭建之后保存相关的参数命令以便以后操作。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8 HashMap和ConcurrentHashMap 源码和实现</title>
    <url>/2021/03/31/jdk8-hashmap/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>AVL树：</p>
<p>在计算机科学中，<strong>AVL树</strong>是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的<strong>高度最大差别为1</strong>，所以它也被称为<strong>高度平衡树</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>特点：</p>
<p>1.本身首先是一棵二叉搜索树。</p>
<p>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p>
<p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p>
</blockquote>
<a id="more"></a>

<p><strong>树的左旋</strong>：绕着子结点逆时针转动，如下图：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-01.png" alt="source-01"></p>
<p><strong>树的右旋</strong>：绕着子结点顺时针转动，如下图</p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-02.png" alt="source-02"></p>
<blockquote>
<p>红黑树：</p>
<p>是一种自平衡二叉查找树，是一种特化的AVL树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 </p>
<p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在<strong>O(log n)</strong>时间内做查找，插入和删除，这里的n 是树中元素的数目。</p>
<p>若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。</p>
<p>红黑树的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet。</p>
</blockquote>
<blockquote>
<p>红黑树的定义如下：</p>
<p>1.每个结点是红的或者黑的</p>
<p>2.根结点是黑的</p>
<p>3.每个叶结点是黑的（每个结点有默认的黑色的NULL结点）</p>
<p>4.如果一个结点是红的，则它的两个儿子都是黑的（父子结点之间不能出现两个连续的红结点）</p>
<p>5.对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点（黑色平衡）</p>
</blockquote>
<p><strong>在算法导论中，新插入的结点优先默认是红色的，优先满足第五条定义，再满足其他定义。</strong></p>
<hr>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><blockquote>
<p>1.假设现在插入一个根结点（10）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-03.png" alt="source-03"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先插入一个红色的结点，满足第五条定义</span><br><span class="line">2.不满足第二条定义---&gt;变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.再插入一个结点（20）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-04.png" alt="source-04"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先和根节点比大小，判断要落在根节点的右边</span><br><span class="line">2.校验是否满足所有定义---&gt;满足</span><br></pre></td></tr></table></figure>

<p><strong>这是一颗正常的红黑树</strong>。因为每个节点，它的末尾节点都有隐藏的黑色空节点，所以满足第三条定义。</p>
<blockquote>
<p>再插入一个结点（30）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-05.png" alt="source-05"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.插入节点后判断是否满足第五定义---&gt;左旋</span><br><span class="line">2.左旋后判断是否满足第二定义---&gt;需要变色</span><br><span class="line">3.旋转的结点和中心结点进行变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入一个结点（40）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-06.png" alt="source-06"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.插入结点后判断是否满足第四定义---&gt;变色</span><br><span class="line">2.判断是否满足第二定义---&gt;变色</span><br><span class="line">结论：</span><br><span class="line">父节点是黑色的，则不需要调整</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入两个结点（5）（25）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-09.png" alt="source-09"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">父节点是黑色的，不需要调整</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入一个结点（50）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-10.png" alt="source-10"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.父节点和叔叔节点变色</span><br><span class="line">2.祖父节点变色</span><br><span class="line">结论：父节点是红色时，叔叔节点也是红色时，则父节点和叔叔节点变色，祖父节点变色。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入两个结点（35）（60）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-11.png" alt="source-11"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.先保证红框中的子树是一颗红黑树</span><br><span class="line">2.按照上文案例的结论，父节点和叔叔节点变色，祖父节点变色</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-12.png" alt="source-12"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.在上面步骤的基础上，达到了子树是一颗红黑树</span><br><span class="line">2.然后把变色的结点（40）当做是一个新节点，插入到红框中的树中</span><br><span class="line">3.在这种情况下进行红框树的调整</span><br><span class="line">4.先左旋，结点重连，然后旋转的节点和中心节点变色</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再插入个结点（6）</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-13.png" alt="source-13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.(5)结点以(6)为中心，进行左旋</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-14.png" alt="source-14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">2.然后就和上文插入(60)结点步骤相同</span><br><span class="line">3.先进行右旋，然后变色</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>当插入一个新节点（红色）时</strong>：</p>
<blockquote>
<p>父节点是黑色的，不用进行调整</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-07.png" alt="source-07"></p>
<blockquote>
<p>父节点是红色的，并且</p>
</blockquote>
<p><strong>1.叔叔是空的，旋转+变色</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-08.png" alt="source-08"></p>
<p><strong>2.叔叔是红色，父节点+叔叔节点变黑色，祖父节点变红色</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-10.png" alt="source-10"></p>
<p><strong>3.叔叔是黑色，旋转+变色</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-12.png" alt="source-12"></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="树化条件"><a href="#树化条件" class="headerlink" title="树化条件"></a>树化条件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当链表长度达到阈值8时，转换成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//满足树化的最小数组长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//当扩容红黑树拆分链表后判断其数量是否大于6，大于则重组红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h5 id="红黑树存储结构-TreeNode"><a href="#红黑树存储结构-TreeNode" class="headerlink" title="红黑树存储结构-TreeNode"></a>红黑树存储结构-TreeNode</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树存储结构对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">//双向链表的前一个结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">//继承Node得到，双向链表的下一个结点</span></span><br><span class="line">    <span class="comment">//Node&lt;K,V&gt; next;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeNode继承的LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedHashMap.Entry继承Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，上文<code>TreeNode</code>实际上是<code>Node</code>的子类，它有着两个属性，一个<code>next</code>，一个<code>prev</code>，也就是说，<strong><code>TreeNode</code>还是一个双向链表</strong>。</p>
<hr>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JDK1.8的HashMap有了红黑树的保障，所以相对于计算Hash值没有JDK1.7那么复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">//对数组初始化或扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 计算数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果头结点的key等于插入的key，赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果P是个红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果P是个链表，HashMap默认</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//使用尾插法插入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当插入第九个元素时，调用树化方法</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当插入的数据刚好落在链表中时</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否要更新，并且返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//自增size后判断是否超过扩容因子（JDK1.7时还有判断当前链表是否有元素）</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h6><h6 id="数组扩容或构建双向链表"><a href="#数组扩容或构建双向链表" class="headerlink" title="数组扩容或构建双向链表"></a>数组扩容或构建双向链表</h6><p><strong>在JDK1.7中，采用头插法插入到链表的头部，而在JDK1.8中，采用的是尾插法插入到链表中，并且当链表的数量大于8时，也就是添加第九个元素时，会调用树化方法<code>treeifyBin</code>，根据条件将链表转换成红黑树。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表树化红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果当前数组为空 或者 数组长度小于64时</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//对数组进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//把Node类型转换成红黑树的TreeNode类型</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//缓存头结点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//建立双向链表关系</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//hd作为链表的头结点，也是红黑树的根节点，遍历链表把其他数值逐个插入到红黑树中</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把Node类型转换成TreeNode类型</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-20.png" alt="source-20"></p>
<h6 id="真正树化"><a href="#真正树化" class="headerlink" title="真正树化"></a>真正树化</h6><p>接下来是真正的将链表树化的逻辑方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//this（链表的头结点），开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//获取链表的下一个结点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//设置结点左右子结点都是NULL</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果root根节点对象等于null，则赋值root根节点对象，并且变黑色</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新增结点的Key的值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//新增结点的hash值</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//Key的数据类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//根节点的key值</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//如果根结点的hash值大于新增结点的hash值，则放在左树上（dir = -1）代表左边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则放在右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果hash值相同，获取key的数据类型，判断是否实现Comparable接口，则调用实现的compareTo方法</span></span><br><span class="line">                <span class="comment">//如果compareTo还相同或者没实现Compareable接口，则调用tieBreakOrder</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//比较getClass().getName() 和 System.identityHashCode</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//一直遍历直到想放的位置没有结点，等于 null</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//赋值新节点x的父节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//如果左边放左边，如果右边放右边</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//执行插入红黑树过程</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把根节点存储到数组中,并且把红黑树的根节点设置成双向链表的根节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="根节点移动到双向链表头部"><a href="#根节点移动到双向链表头部" class="headerlink" title="根节点移动到双向链表头部"></a>根节点移动到双向链表头部</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            <span class="comment">//把红黑树的根节点赋值在数组上</span></span><br><span class="line">            tab[index] = root;</span><br><span class="line">            <span class="comment">//获取红黑树的根节点在双向链表中的前一个结点rp</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="comment">//如果红黑树根节点在双线链表中的下一个结点rn不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//下一个结点的prev指向rp（等于跳过了root）</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="comment">//如果上一个结点rp不为空，它的next指向rn（等于跳过了root）</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="comment">//如果原数组中的存储的链表头结点不为空，则通过头插法，把root插入到first之上</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="红黑树添加新节点"><a href="#红黑树添加新节点" class="headerlink" title="红黑树添加新节点"></a>红黑树添加新节点</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//查找key是否属于红黑树中</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  红黑树的插入逻辑</span></span><br><span class="line"><span class="comment">  @Params</span></span><br><span class="line"><span class="comment">  root 	根节点</span></span><br><span class="line"><span class="comment">  x		即将插入的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新节点默认为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//xp表示父节点，xpp表示x的祖父节点，xppl表示xpp的左孩子结点，xppr表示xpp的右孩子结点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//如果x没有父节点，则表示x是第一个结点，自动成为根节点，根节点为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果父节点是黑色的，不需要做调整</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//上面逻辑已经处理了父节点是黑色的情况，所以下面的逻辑父节点一定是红色的</span></span><br><span class="line">        <span class="comment">//当新节点的父节点是xpp的左叶子节点时</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//叔叔节点不为空 且 叔叔节点等于红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//叔叔节点变黑色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//父节点变黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//祖父节点变红色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//子树调整完成，可能需要递归调整，把祖父节点赋值给x，递归调整</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入else语句 叔叔节点为空或者等于黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当新节点落在父节点的右边时</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    <span class="comment">//重新赋值xp 和xpp的值</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果xp（也就是之前插入的新节点）不为null</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把xp变成黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//祖父节点不为null时，变成红色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//进行右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当新节点的父节点是xpp的右叶子节点，且它的叔叔节点不为空且红色</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//如果新增的父节点p不等于null且 p的右子结点（新增节点） 不等于null</span></span><br><span class="line">    <span class="comment">//1.r = p.right （把新增节点赋值给 r）</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2.p.right = r.left解释：</span></span><br><span class="line">        <span class="comment">//新增的节点r.left默认为null ，将null 赋值给 p.right，等于取消p对r的指针</span></span><br><span class="line">        <span class="comment">//rl != null 时主要用于递归父树左旋</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="comment">//3.r.parent = p.parent</span></span><br><span class="line">        <span class="comment">//将新增的节点r.parent指向p.parent上，也就是新增节点的祖父节点pp</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果等于根节点，赋值黑色</span></span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//用于定位p节点处于pp节点的左侧还是右侧，然后断开pp对p的指向，修改成pp对r的指向</span></span><br><span class="line">        <span class="comment">//如果父节点落在祖父节点的左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            <span class="comment">//把r当做pp的左叶子节点</span></span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="comment">//如果父节点落在祖父节点的右边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//把r当做pp右叶子节点</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        <span class="comment">//把p当做r的左叶子节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-15.png" alt="source-15"></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-16.png" alt="source-16"></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-17.png" alt="source-17"></p>
<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-18.png" alt="source-18"></p>
<p>完成左旋之后进行变色，变完色之后右旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用  root = rotateLeft(root, xpp); 所以参数 p = xpp</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="comment">//祖父节点p和它的左子节点l不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//用于右旋之后节点分配</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="comment">//如果祖父节点p是根节点，则p.parent等于null，右旋之后，l将作为根节点，所以变色黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果祖父节点p不是根节点，则获取p的父节点pp，右旋之后，pp指向l</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        <span class="comment">//把p作为l的右结点</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk8-hashmap/source-19.png" alt="source-19"></p>
<hr>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>再看一下扩容方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//扩容，长度左移</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//新数组的大小乘以扩容因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果老数组不为空，也就是扩容逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果链表上只有一个元素，直接移动过去并且赋值到数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果数组上的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//链表转移，使用尾插法，链表元素的hash值&amp;旧数组长度，等于0的元素转移到lo链表、其余的元素转移到hi链表，最终newTab[j] = loHead、newTab[j + oldCap] = hiHead完成链表扩容</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//hash值和原数组长度相与，等于0原数组</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//赋值低位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接低位index的结点</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="comment">//赋值高位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接高位index的结点</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表赋值到数组的低位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="comment">//链表赋值到数组的高位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链表扩容"><a href="#链表扩容" class="headerlink" title="链表扩容"></a>链表扩容</h6><p>​    链表转移，使用尾插法，链表元素的hash值&amp;旧数组长度，等于0的元素转移到lo链表、其余的元素转移到hi链表，最终newTab[j] = loHead、newTab[j + oldCap] = hiHead完成链表扩容</p>
<h6 id="红黑树扩容"><a href="#红黑树扩容" class="headerlink" title="红黑树扩容"></a>红黑树扩容</h6><p>​        遍历数组，获取数组上的红黑树root节点进行操作，树节点（treeNode）存在双向链表结构，使用next指针如链表转移一般进行操作，构建高低位链表，记录高位、低位节点个数，头部节点放入数组索引位置</p>
<p>a、节点个数如果小于6则结构改回单向链表（TreeNode-&gt;Node）<br>b、大于6个，如果高低位链表仅存在一个，不需要额外操作，因为整棵树已经迁移；如果两个都存在，重新进行树化<br>c、tab[index] = loHead，tab[index + bit] = hiHead</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组上的红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历红黑树的双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//计数低位index的链表的个数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//计数高位index的链表的个数</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拆分成两个链表之后，比较</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表长度&lt;=6</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//退化成链表赋值到数组中</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当hiHead == null时，则等于红黑树不需要拆分，直接把整棵树（也就是根节点）移动到数组上</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//hiHead不为空时，对低位链表进行树化，整个链表重新创建红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下逻辑和低位链表逻辑相同</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//新数组下标 = 原数组下标 + 原数组长度</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历双向链表，把TreeNode类型转换成Node类型，建立单向链表，返回头结点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a><code>get</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">//如果刚好等于根节点，返回</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它是红黑树，则调用红黑树的查找算法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//否则循环链表查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* h: get的Key的hash值</span></span><br><span class="line"><span class="comment">* k: get的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//判断hash在左边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//在右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//相等且key相同，返回节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//如果左边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//如果右边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果key自定义了比较算法，compare之类的判断走哪一边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">//否则递归查询</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示当前的整个ConcurrentHashMap正在扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建数组时用于Cas操作，设置成 -1 则代表CAS操作成功，然后创建数组，计算扩容的阈值并赋值到sizeCtl上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap中元素的最大值 2的31次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当扩容数组时，待迁移的数组长度值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储扩容时的数组，用以迁移新旧数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure>

<h5 id="红黑树结构对象-TreeBin"><a href="#红黑树结构对象-TreeBin" class="headerlink" title="红黑树结构对象-TreeBin"></a>红黑树结构对象-TreeBin</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把整个红黑树结构封在TreeBin对象中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;\</span><br><span class="line">    <span class="comment">//红黑树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的数组中将存储<code>Node</code>类型和``TreeBin<code>类型，</code>TreeBin<code>用于承载红黑树的整个结构，其中有一个</code>root`属性存储红黑树的根节点。</p>
<p>这样做的目的是为了后面对红黑树根节点加锁时，直接对<code>TreeBin</code>对象加锁，可以不用考虑在加锁的过程中，红黑树的根节点变化情况。</p>
<h5 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//获取数组下标的Node对象并赋值到f中，并判断是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过cas操作赋值到数组下标中，如果失败则重新循环（就不会再进到这个条件了，因为数组下标内容已经不为空）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ConcurrentHashMap正在扩容，则帮助它进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对链表/红黑树的头节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断加完锁之后头结点是否还是f（避免加锁时被修改了）</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//统计链表长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表，插入</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//尾插法</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度大于8，则进行树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素，总元素数量加1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//放弃对CPU资源的控制，再和其他线程竞争CPU资源</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//CAS对sizeCtl减1，如果成功则创建tab数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 16 - 4 = 12 扩容阈值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//赋值扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//树化前加锁链表头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//改成双向链表</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//链表头结点</span></span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//通过TreeBin的构造方法创建红黑树并赋值到数组上</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于累加计数元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于分治对baseCount进行CAS失败后的资源竞争，等同于LongAdder的计算思想</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于创建CounterCell数组时加锁的状态位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x 表示需要增加的值</span></span><br><span class="line"><span class="comment">//通过CAS对baseCount进行累加操作，若CAS失败，则退而求其次，将累加的值累加到CounterCell篮子里</span></span><br><span class="line"><span class="comment">//避免了多线程情况下对同一个资源竞争，分治，一个资源分散成多个资源CAS</span></span><br><span class="line"><span class="comment">//复制了LongAdder的写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//如果CounterCell数组非空  或  CAS修改BaseCount失败时进入下面逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//满足条件：1.[as == null] 或者 2.[长度小于0] 或者 3.[对应下标的CounterCell对象为空]</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">//下标计算规则：随机数 &amp; as.length - 1</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">//上面的条件均不满足时，也就是CounterCell对象不为空，则将执行第四个逻辑分支</span></span><br><span class="line">            <span class="comment">//4.对CounterCell里的值进行CAS累加</span></span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若上面四个分支条件有一个满足，则进入这个方法</span></span><br><span class="line">            <span class="comment">//进行数组初始化、CounterCell对象初始化、累加x</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当累加操作成功执行后，进入扩容检查逻辑</span></span><br><span class="line">    <span class="comment">//小于0（delete操作）则跳过，大于等于0（add操作）则开启扩容检查</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//当元素大小大于扩容阈值，并且数组长度小于最大值 MAXIMUM_CAPACITY 时，进入扩容逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS将sc 改成一个很小的负数值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//进入扩容逻辑，在该逻辑中会赋值nextTable属性</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x:累加值  wasUncontended: false 表示已经进行过CAS操作并且失败了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//计算数组下标，ThreadLocalRandom.getProbe()同一个线程调用会得到相同的随机数</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//当counterCells数组不为空时</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当对应index的CounterCell对象 == null时</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//并且cellsBusy状态位为0时</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化CounterCell对象</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//通过CAS设置cellsBusy状态位</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//若获得cellsBusy锁时，再进行doubleCheck</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//赋值对象到数组中</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">//设置创建状态</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//重置锁状态位</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//创建状态成功时，跳出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//否则重新进入循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作已经失败过了，则设置它为true，后续的重新循环就不走这个分支了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//对当前的CounterCell对象进行cas操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//当数组和当前对象不符（有其他线程扩容过）或者大于CPU核心数，则把扩容标志位设置成false</span></span><br><span class="line">            <span class="comment">//目的是用来防止无限次扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//CAS失败或者cellsBusy被占用繁忙时，第一次循环会先进行重新计算index下标</span></span><br><span class="line">            <span class="comment">//当第二次循环依旧失败时，走到这个逻辑时，则设置扩容标志位等于true</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//第三次循环进来时，当扩容标志位等于ture时，进行CAS加锁并且扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        <span class="comment">//数组扩容一倍</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据现有的下标重新计算一个新的下标并赋值到 h 上</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果counterCells数组没有初始化，则对cellsBusy进行CAS赋值，类似于Lock状态位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">//doubleCheck，判断依旧没初始化</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    <span class="comment">//初始化CounterCell数组，赋值长度 = 2</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">//创建下标index = 1的CounterCell对象</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    <span class="comment">//设置初始化成功标志位</span></span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//初始化成功，重置状态位</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳出死循环</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上述所有分支时，或者多线程竞争cellsBusy失败时，就CAS竞争baseCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用该对象占用在数组上，表示这个位置正在扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在putval中，有一个分值逻辑代码是这样的，表示如果当前的f.hash == MOVED时，则进行帮助扩容逻辑</span></span><br><span class="line"><span class="comment">//也就是说，在putval的过程中，如果数组中的元素类型是ForwardingNode，则代表它正在扩容</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程进行扩容操作</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//判断数组元素类型，并且扩容数组nextTab是否产生</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//CAS对cs进行加1，sc在扩容时会被设置成一个负数，来一个线程扩容，该值就会加1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tab 原数组  , nextTab 新数组</span></span><br><span class="line"><span class="comment">//这里的扩容逻辑是从右往左，多线程并发扩容，每个线程依次获取某段长度=stride的数据进行扩容迁移</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//计算扩容的步长，多线程情况下，每个线程拾取相对步长的元素进行迁移，并发扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果新数组等于null，则初始化新数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容一倍长度的数组对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值到nextTable属性上</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//待迁移的数组长度</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//创建一个标识正在扩容的对象</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//标记当前线程是否具备继续往左进行数组元素迁移的能力（false表示正在迁移中）</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//标记当前线程是否已经完成了它自身所能够涉及到的数据迁移（我向左找不到了）</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//如果右下标大于左下标（表示有待迁移的数据,右下标自减一直缩），或者当前线程已经完成了扩容迁移</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//赋值nextIndex，并且判断是否有待处理的数组元素，若没有，则设置 i = -1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS修改待迁移的数组长度，假设 transferIndex = 4， stride = 2的话</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      <span class="comment">//计算该线程的应该负责迁移数组元素的起始下标 通过计算得到 4 - 2 = 2</span></span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//表示当前线程需要负责的起始下标，若CAS成功，则赋值到bound = 2</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//表示当前线程需要负责的结束下标 4 - 1 = 3，所以最终该线程负责[2,3]区域</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//获得待负责的区域了，设置状态false</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当上文逻辑判断没有待处理的数组元素时，i = -1 ，会进入当前分支</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//当完成迁移了</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//将新的数组设置到旧的数组属性上</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//重新设置扩容阈值</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程执行完扩容操作，对sc进行自减</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前的sc和之前计算的sc是否相等，若不等则有其他线程还在进行扩容操作，扩容还没完成</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//若相等，则表示所有线程都已经扩容完成，设置完成标识位</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前位置的元素 == null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将ForwardingNode设置到 旧数组tab上，其他线程访问时判断是该对象类型，则会帮助扩容</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//若当前位置已经被迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//锁数组的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//doubleCheck</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//链表的扩容逻辑，和JDK1.7的ConcurrentHashMap迁移一样</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//把旧数组的上的元素改成fwd对象</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置true，继续往左走</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树迁移逻辑，和JDK1.8的HashMap一样</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//把旧数组的上的元素改成fwd对象</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置true，继续往左走</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析完添加元素和累加计数的分治方法之后，再看看统计元素大小的<code>size</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//baseCount + CounterCell[] 的数据，累加起来就是总的Size</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>“本篇文章主要摘自<a href="https://www.bilibili.com/video/BV1x741117jq?p=3" target="_blank" rel="noopener">参考资料</a>”</p>
</blockquote>
]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat使用</title>
    <url>/2021/05/07/mcat%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、读写分离"><a href="#一、读写分离" class="headerlink" title="一、读写分离"></a>一、读写分离</h2><p>​    通过<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#%E5%AE%89%E8%A3%85">mycat</a>和<a href="https://yrlzero.gitee.io/2021/04/28/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/#%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E">mysql的主从复制</a>配合搭建数据库的读写分离，可以实现mysql的高可用性。</p>
<p>修改mycat的<code>schema.xml</code>配置</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"my_multi_test"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改负载策略</span></span><br><span class="line"><span class="comment">	balance=1:全部的readhost和stand by writehost参与select 语句的负载均衡，简单的说，当双主双从模式下，其他的节点都参与select语句的负载均衡	</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">       	 <span class="comment">&lt;!--master-1--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!--slave-1--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        	<span class="comment">&lt;!--master-2--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.133:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!--slave-2--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.134:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="writeType"><a href="#writeType" class="headerlink" title="writeType"></a>writeType</h3><p>​    表示写操作发送到哪台机器</p>
<ul>
<li>writeType=0:所有写操作都发送到配置的第一个writeHost，第一个挂了切换到还生存的第二个</li>
<li>writeType=1:所有写操作都随机的发送到配置的writehost中，1.5之后废弃</li>
</ul>
<h3 id="switchType"><a href="#switchType" class="headerlink" title="switchType"></a>switchType</h3><p>​    表示如何进行切换</p>
<ul>
<li><p>switchType=1:默认值，自动切换</p>
</li>
<li><p>switchType=-1:表示不自动切换</p>
</li>
<li><p>switchType=2：基于mysql主从同步的状态决定是否切换</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>重启<code>mycat restart</code></p>
<p>连接mycat <code>mysql -uroot -pRoot_123 -P 8066 -h 192.168.243.131</code></p>
<p>执行插入语句 <code>insert into t1 values(2,@@hostname);</code></p>
<p>分别连接四台mysql查询结果</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mycat/mycat%E6%8F%92%E5%85%A5.jpg" alt=""></p>
<p>连接mycat查询结果</p>
<img src="http://yrlzero.gitee.io/images/linux/mycat/读写分离查询.jpg" style="zoom: 80%;" />



<p>到此，mysql双主双从结合mycat搭建读写分离完成，架构如下图所示</p>
<img src="http://yrlzero.gitee.io/images/linux/mycat/mycat多主多从.jpg" style="zoom: 60%;" />

<ul>
<li>当查询时，会被分发到<code>slave-1</code>、<code>master-2</code>、<code>slave-2</code>这三台机器上；</li>
<li>当写操作时，会被分发到<code>master-1</code>上；</li>
<li>如果<code>master-1</code>宕机，mycat会将写操作自动切换到<code>master-2</code>，之后如果<code>master-1</code>恢复（从master-2同步数据，slave-1再从master-1同步数据），也只提供读服务，写仍由<code>master-2</code>提供。</li>
</ul>
<hr>
<h2 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h2><p>​        数据的切分，主要有两种方式，分别是垂直切分和水平切分，所谓的垂直切分就是将不同的表分布在不同的数据库实例中，而水平切分指的是将一张表的数据按照不同的切分规则切分在不同实例的相同名称的表中。</p>
<h3 id="1、分库"><a href="#1、分库" class="headerlink" title="1、分库"></a>1、分库</h3><p>将不同的表分布在不同的库中，但是访问的时候使用的是同一个mycat的终端，这些操作都由mycat来完成的，我们只需修改相应的配置即可。</p>
<h4 id="1-1、修改-etc-my-cnf文件"><a href="#1-1、修改-etc-my-cnf文件" class="headerlink" title="1.1、修改/etc/my.cnf文件"></a>1.1、修改<code>/etc/my.cnf</code>文件</h4><p>​        在mycat操作时它是不区分表明大小写的，需要在mysql的配置文件中添加<code>lower_case_table_names=1</code>参数，来保证查询的时候能够进行正常的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_case_table_names&#x3D;1</span><br></pre></td></tr></table></figure>

<h4 id="1-2、重启mysql"><a href="#1-2、重启mysql" class="headerlink" title="1.2、重启mysql"></a>1.2、重启mysql</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">service mysqld status</span><br></pre></td></tr></table></figure>

<h4 id="1-3、修改schema-xml文件"><a href="#1-3、修改schema-xml文件" class="headerlink" title="1.3、修改schema.xml文件"></a>1.3、修改<code>schema.xml</code>文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定customer表分发到db2进行操作，其余未指定的表默认dn1 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> = <span class="string">"customer"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"host1"</span> <span class="attr">database</span>=<span class="string">"my_db"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"host2"</span> <span class="attr">database</span>=<span class="string">"my_db"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--master-1--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.131:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--slave-1--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.243.132:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host2"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">				<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--master-2--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.133:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--slave-2--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.243.134:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"Root_123"</span>&gt;</span><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4、重启mycat"><a href="#1-4、重启mycat" class="headerlink" title="1.4、重启mycat"></a>1.4、重启mycat</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">mycat restart</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">mycat status</span><br></pre></td></tr></table></figure>

<h4 id="1-5、停止master的slave服务"><a href="#1-5、停止master的slave服务" class="headerlink" title="1.5、停止master的slave服务"></a>1.5、停止<code>master</code>的slave服务</h4><p>​        使用mycat进行分库操作之前，需要分别登陆<code>master-1</code>和<code>master-2</code>执行<code>stop slave</code>，将它们的主备关系去除，否则相互之间会进行数据同步，起不到分库的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 停止slave服务</span><br><span class="line">stop slave;</span><br><span class="line">-- 查看状态</span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>

<p>登陆<code>master-1</code>和<code>master-2</code>的mysql服务分别创建my_db数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database my_db;</span><br></pre></td></tr></table></figure>

<h4 id="1-6、验证"><a href="#1-6、验证" class="headerlink" title="1.6、验证"></a>1.6、验证</h4><h5 id="登陆mcat"><a href="#登陆mcat" class="headerlink" title="登陆mcat"></a>登陆mcat</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pRoot_123 -h 192.168.243.131 -P 8066</span><br></pre></td></tr></table></figure>

<h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E5%BA%93-01.jpg" alt=""></p>
<blockquote>
<p>由上图可以看到，<code>mycat</code>的建表语句被分发到了<code>master-2</code>执行，并且因为<code>master-2</code>与<code>slave-2</code>主从同步，<code>slave-2</code>也出现了customer表。</p>
</blockquote>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E5%BA%93-02.jpg" alt=""></p>
<blockquote>
<p>由上图可以看到，<code>mycat</code>插入的语句被分发到了<code>master-2</code>执行，并且因为<code>master-2</code>与<code>slave-2</code>主从同步，<code>slave-2</code>也出现了相关的数据。</p>
</blockquote>
<hr>
<h3 id="2、分表（分片）"><a href="#2、分表（分片）" class="headerlink" title="2、分表（分片）"></a>2、分表（分片）</h3><p>​        相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中 包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中 。</p>
<h4 id="2-1、取模运算"><a href="#2-1、取模运算" class="headerlink" title="2.1、取模运算"></a>2.1、取模运算</h4><p>​        <code>把customer_id按照取模运算进行数据拆分</code></p>
<h5 id="修改schema-xml文件"><a href="#修改schema-xml文件" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><p>​        在上文<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#1-3%E3%80%81%E4%BF%AE%E6%94%B9schema-xml%E6%96%87%E4%BB%B6">分库的schema文件</a>基础上修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span>		</span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> = <span class="string">"customer"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> =<span class="string">"orders"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"mod_rule"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件"><a href="#修改rule-xml文件" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><p>​        配置取模运算规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span>		</span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat"><a href="#重启mycat" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-1"><a href="#建表-1" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">	order_type <span class="built_in">INT</span>,</span><br><span class="line">	customer_id <span class="built_in">INT</span>,</span><br><span class="line">	amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-1"><a href="#插入数据-1" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E8%A1%A8-%E5%8F%96%E6%A8%A1.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>customer_id</code>字段值%2，结果为0的分发到<code>master-1</code>，为1分发<code>master-2</code></p>
</blockquote>
<hr>
<h4 id="2-2、分片枚举"><a href="#2-2、分片枚举" class="headerlink" title="2.2、分片枚举"></a>2.2、分片枚举</h4><p>​        <code>通过在配置文件中配置可能存在的值，配置分片。</code></p>
<h5 id="修改schema-xml文件-1"><a href="#修改schema-xml文件-1" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"orders_ware_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_intfile"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-1"><a href="#修改rule-xml文件-1" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_intfile"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数,对应下面的function标签 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile： 标识配置文件名称--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  type： 0为int型、 非0为String --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span></span><br><span class="line"><span class="comment">	设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-hash-int-txt文件"><a href="#修改partition-hash-int-txt文件" class="headerlink" title="修改partition-hash-int.txt文件"></a><strong>修改<code>partition-hash-int.txt</code>文件</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#10000&#x3D;0</span><br><span class="line">#10010&#x3D;1</span><br><span class="line">110&#x3D;0</span><br><span class="line">120&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-1"><a href="#重启mycat-1" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-2"><a href="#建表-2" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_ware_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'订单编号'</span>,</span><br><span class="line">    <span class="string">`address`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">comment</span> <span class="string">'地址'</span>,</span><br><span class="line">    <span class="string">`areacode`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">'区域编号'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-2"><a href="#插入数据-2" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">'北京'</span>,<span class="string">'110'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">2</span>,<span class="string">'天津'</span>,<span class="string">'120'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E7%89%87-%E5%88%86%E7%89%87%E6%9E%9A%E4%B8%BE.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>areacode</code>值与<code>partition-hash-int.txt</code>文件中配置参数比对确定存放的节点，110被分发到<code>node-1</code>，120被分发到<code>node-2</code></p>
</blockquote>
<hr>
<h4 id="2-3、范围分片"><a href="#2-3、范围分片" class="headerlink" title="2.3、范围分片"></a>2.3、范围分片</h4><p>​    根据分片字段，约定好属于哪一个范围</p>
<h5 id="修改schema-xml文件-2"><a href="#修改schema-xml文件-2" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"payment_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-2"><a href="#修改rule-xml文件-2" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto-sharding-long"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile： 标识配置文件名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span></span><br><span class="line"><span class="comment">	设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改autopartition-long-txt文件"><a href="#修改autopartition-long-txt文件" class="headerlink" title="修改autopartition-long.txt文件"></a>修改<code>autopartition-long.txt</code>文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K&#x3D;1000,M&#x3D;10000.</span><br><span class="line">#0-500M&#x3D;0</span><br><span class="line">#500M-1000M&#x3D;1</span><br><span class="line">#1000M-1500M&#x3D;2</span><br><span class="line">0-102&#x3D;0</span><br><span class="line">103-200&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-2"><a href="#重启mycat-2" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-3"><a href="#建表-3" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'订单编号'</span>,</span><br><span class="line">    <span class="string">`payment_status`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'支付状态'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-3"><a href="#插入数据-3" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id ,payment_status) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-1"><a href="#查询结果-1" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E7%89%87-%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>order_id</code>值与<code>autopartition-long.txt</code>文件中配置参数比对确定存放的节点</p>
</blockquote>
<hr>
<h4 id="2-4、范围求模算法"><a href="#2-4、范围求模算法" class="headerlink" title="2.4、范围求模算法"></a>2.4、范围求模算法</h4><p>​    该算法为先进行<code>范围分片</code>，计算出分片组，<code>组内再求模</code>，综合了范围分片和求模分片的优点。</p>
<p>​    分片组内使用求模可以保证组内的数据分步比较均匀，分片组之间采用范围分片可以兼顾范围分片的特点。事先规定好分片的数量，数据扩容时按分片组扩容，则原有分片组的数据不需要迁移。由于分片组内的数据分步比较均匀，所以分片组内可以避免热点数据问题。</p>
<h5 id="修改schema-xml文件-3"><a href="#修改schema-xml文件-3" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-rang-mod"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-3"><a href="#修改rule-xml文件-3" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto-sharding-rang-mod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-mod<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-mod"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByRangeMod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-range-mod-txt文件"><a href="#修改partition-range-mod-txt文件" class="headerlink" title="修改partition-range-mod.txt文件"></a><strong>修改partition-range-mod.txt文件</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node group size</span><br><span class="line"># 0-200M&#x3D;5</span><br><span class="line"># 200M1-400M&#x3D;1</span><br><span class="line"># 400M1-600M&#x3D;4</span><br><span class="line"># 600M1-800M&#x3D;4</span><br><span class="line"># 800M1-1000M&#x3D;6</span><br><span class="line">0-1M&#x3D;2</span><br><span class="line">1M1-2M&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-3"><a href="#重启mycat-3" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-4"><a href="#建表-4" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-4"><a href="#插入数据-4" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">9999</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">10000</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">10001</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">20000</span>,<span class="string">'zhangsan4'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-2"><a href="#查询结果-2" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><p><img src="http://yrlzero.gitee.io/images/linux/mycat/%E5%88%86%E7%89%87-%E8%8C%83%E5%9B%B4%E6%B1%82%E6%A8%A1.jpg" alt=""></p>
<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>partition-range-mod.txt</code>文件中配置参数比对，确定存放在哪个分片，如果该分片只有一个节点直接放入，分片存在多个节点时，需要对<code>id</code>值进行取模运算确定存放的节点</p>
<p>先匹配范围，再取模</p>
</blockquote>
<hr>
<h4 id="2-5、固定分片hash算法"><a href="#2-5、固定分片hash算法" class="headerlink" title="2.5、固定分片hash算法"></a>2.5、固定分片hash算法</h4><p>​        类似于十进制的求模运算，但是为二进制的操作，取id的二进制低10位，即id的二进制 &amp; 1111111111，结果落在0-1023之间，所以默认最大分片为1024.</p>
<p>​        此算法的优点在于如果按照十进制取模运算，则在连续插入1<del>10时，1</del>10会被分到1~10个分片，增大了插入事务的控制难度。而此算法根据二进制则可能会分到连续的分片，降低了插入事务的控制难度。</p>
<h5 id="修改schema-xml文件-4"><a href="#修改schema-xml文件-4" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-4"><a href="#修改rule-xml文件-4" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionCount为分片个数列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionLength为分片范围列表，分区长度默认最大为1024，即最大支持1024个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-4"><a href="#重启mycat-4" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-5"><a href="#建表-5" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-5"><a href="#插入数据-5" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1023</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1024</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">266</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">255</span>,<span class="string">'zhangsan4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1025</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1025</span>,<span class="string">'zhangsan5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1257</span>,<span class="string">'zhangsan6'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1281</span>,<span class="string">'zhangsan7'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">256</span>,<span class="string">'zhangsan8'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">511</span>,<span class="string">'zhangsan9'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">512</span>,<span class="string">'zhangsan10'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-3"><a href="#查询结果-3" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-固定分片hash算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>rule.xml</code>文件中配置参数比对，确定存放在哪个分片，当数值超过1024时会减去1024再进行范围匹配</p>
<p>最大分片数为1024，范围从0-1023</p>
</blockquote>
<hr>
<h4 id="2-6、取模范围算法"><a href="#2-6、取模范围算法" class="headerlink" title="2.6、取模范围算法"></a>2.6、取模范围算法</h4><p>​    取模运算与范围约束的结合主要是为后续的数据迁移做准备，即可以自主决定取模后数据的节点分布。</p>
<h5 id="修改schema-xml文件-5"><a href="#修改schema-xml文件-5" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user2"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-pattern"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-5"><a href="#修改rule-xml文件-5" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-pattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByPattern"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile：切分规则配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- patternValue：求模基数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patternValue"</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultNode：默认节点，小于0表示不设置默认节点，大于等于0表示设置默认节点，如果超出配置的范围，则使用默认节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-pattern-txt文件"><a href="#修改partition-pattern-txt文件" class="headerlink" title="修改partition-pattern.txt文件"></a>修改partition-pattern.txt文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-86&#x3D;0</span><br><span class="line">87-173&#x3D;1</span><br><span class="line">174-256&#x3D;2</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-5"><a href="#重启mycat-5" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-6"><a href="#建表-6" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-6"><a href="#插入数据-6" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">85</span>,<span class="string">'zhangsan1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">100</span>,<span class="string">'zhangsan2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">200</span>,<span class="string">'zhangsan3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">257</span>,<span class="string">'zhangsan4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">343</span>,<span class="string">'zhangsan5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">430</span>,<span class="string">'zhangsan6'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-4"><a href="#查询结果-4" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-取模范围算法-1620120538787.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>id</code>值与<code>rule.xml</code>文件中配置的取模基数<code>patternValue</code>进行计算，看结果落在哪个范围分片，最终确定存放在哪个节点</p>
<p>先取模，再匹配范围</p>
</blockquote>
<hr>
<h4 id="2-7、字符串hash求模范围算法"><a href="#2-7、字符串hash求模范围算法" class="headerlink" title="2.7、字符串hash求模范围算法"></a>2.7、字符串hash求模范围算法</h4><p>​        与取模范围算法类似，该算法支持数值、符号、字母取模，此方式就是将指定位数的字符的ascll码的和进行取模运算。</p>
<h5 id="修改schema-xml文件-6"><a href="#修改schema-xml文件-6" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-prefixpattern"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-6"><a href="#修改rule-xml文件-6" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-prefixpattern"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns标识将要分片的表字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm为分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-prefixpattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-prefixpattern"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByPrefixPattern"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mapFile：切分规则配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- patternValue：求模基数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patternValue"</span>&gt;</span>256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prefixLength:ASCII 截取的位数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefixLength"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改partition-pattern-txt文件-1"><a href="#修改partition-pattern-txt文件-1" class="headerlink" title="修改partition-pattern.txt文件"></a>修改partition-pattern.txt文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ASCII</span><br><span class="line"># 8-57&#x3D;0-9 阿拉伯数字</span><br><span class="line"># 64、 65-90&#x3D;@、 A-Z</span><br><span class="line"># 97-122&#x3D;a-z  </span><br><span class="line">0-86&#x3D;0</span><br><span class="line">87-173&#x3D;1</span><br><span class="line">174-256&#x3D;2</span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-6"><a href="#重启mycat-6" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-7"><a href="#建表-7" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user3`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-7"><a href="#插入数据-7" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'wangwu'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'zzzzzzz'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'z99'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-5"><a href="#查询结果-5" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-字符串hash求模范围算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>name</code>值的前五位进行截取计算ASCII值，结果值再与<code>rule.xml</code>文件中配置的取模基数<code>patternValue</code>进行取模计算，看取模结果落在哪个范围分片，最终确定存放在哪个节点</p>
<p>先截取换算ASCII值，取模计算，再匹配范围</p>
</blockquote>
<hr>
<h4 id="2-8、应用指定的算法"><a href="#2-8、应用指定的算法" class="headerlink" title="2.8、应用指定的算法"></a>2.8、应用指定的算法</h4><p>​    在运行阶段由应用程序自主决定路由到哪个分片。</p>
<h5 id="修改schema-xml文件-7"><a href="#修改schema-xml文件-7" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user4"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-substring"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-7"><a href="#修改rule-xml文件-7" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-substring"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-substring"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionDirectBySubString"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始的索引值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startIndex"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取值长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分片数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认的分片节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultPartition"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-7"><a href="#重启mycat-7" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-8"><a href="#建表-8" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user4`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-8"><a href="#插入数据-8" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'0-zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'1-lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user4(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'2-wangwu'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-6"><a href="#查询结果-6" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-应用指定的算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据根据<code>name</code>值从<code>startIndex</code>截取<code>size</code>数量的字符，结果值匹配分片的索引，最终确定存放在哪个节点</p>
</blockquote>
<hr>
<h4 id="2-9、字符串hash解析算法"><a href="#2-9、字符串hash解析算法" class="headerlink" title="2.9、字符串hash解析算法"></a>2.9、字符串hash解析算法</h4><p>​        字符串hash解析分片，其实就是根据配置的hash预算位规则，将截取的字符串进行hash计算后，得到的int数值即为datanode index(分片节点索引，从0开始)。</p>
<h5 id="修改schema-xml文件-8"><a href="#修改schema-xml文件-8" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user5"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-stringhash"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml5文件"><a href="#修改rule-xml5文件" class="headerlink" title="修改rule.xml5文件"></a><strong>修改<code>rule.xml5</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-stringhash"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns标识将要分片的表字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm为分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-stringhash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">partitionLength:求模基数</span></span><br><span class="line"><span class="comment">partitionCount:分片数量</span></span><br><span class="line"><span class="comment">hashslice： hash预算位，即根据子字符串中 int 值 hash 运算</span></span><br><span class="line"><span class="comment">    0 代表 str.length(), -1 代表 str.length()-1，大于0只代表数字自身</span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">    * “2” -&gt; (0,2)</span></span><br><span class="line"><span class="comment">    * “1:2” -&gt; (1,2)</span></span><br><span class="line"><span class="comment">    * “1:” -&gt; (1,0)</span></span><br><span class="line"><span class="comment">    * “-1:” -&gt; (-1,0)</span></span><br><span class="line"><span class="comment">    * “:-1” -&gt; (0,-1)</span></span><br><span class="line"><span class="comment">    * “:” -&gt; (0,0)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-stringhash"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByString"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionLength为分片范围列表，分区长度默认最大为1024，即最大支持1024个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512,256<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- partitionCount为分片个数列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>1,2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashSlice"</span>&gt;</span>0:6<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-8"><a href="#重启mycat-8" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-9"><a href="#建表-9" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user5`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-9"><a href="#插入数据-9" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1111111</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2222222</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3333333</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4444444</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user5(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8960000</span>,<span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-7"><a href="#查询结果-7" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-字符串hash解析算法.jpg" style="zoom:80%;" />

<blockquote>
<p>由上图可以看出，<code>mycat</code>会将我们插入的数据中的<code>id</code>值根据<code>hashslice</code>截取合适的字符串进行hash值计算，再从长度是1024的数组中获取对应的节点索引值，将结果存入该节点</p>
<p>最大分片数为1024，范围从0-1023</p>
</blockquote>
<hr>
<h4 id="2-10、按照日期范围分片"><a href="#2-10、按照日期范围分片" class="headerlink" title="2.10、按照日期范围分片"></a>2.10、按照日期范围分片</h4><p>​        按照某个指定的日期进行分片</p>
<h5 id="修改schema-xml文件-9"><a href="#修改schema-xml文件-9" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"login_info"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding_by_date"</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-8"><a href="#修改rule-xml文件-8" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding_by_date"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns：分片字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm：分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"shardingByDate"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByDate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ：开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ：开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-06-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sEndDate：结束日期,则代表数据达到了这个日期的分片后循环从开始分片插入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sEndDate"</span>&gt;</span>2020-06-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay ：分区天数，即默认从开始日期算起，分隔 2 天一个分区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-9"><a href="#重启mycat-9" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-10"><a href="#建表-10" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> login_info</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">'用户编号'</span>,</span><br><span class="line">    <span class="string">`login_date`</span> <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">'登录日期'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-10"><a href="#插入数据-10" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="string">'2020-06-01'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="string">'2020-06-02'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="string">'2020-06-03'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="string">'2020-06-04'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">103</span>,<span class="string">'2020-06-05'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">6</span>,<span class="number">104</span>,<span class="string">'2020-06-06'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-8"><a href="#查询结果-8" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-按照日期范围分片.jpg" style="zoom:80%;" />

<blockquote>
<p>按照某个指定的日期进行分片,达到结束日期后循环开始分片插入</p>
</blockquote>
<hr>
<h4 id="2-11、按单月小时分片"><a href="#2-11、按单月小时分片" class="headerlink" title="2.11、按单月小时分片"></a>2.11、按单月小时分片</h4><p>​        此规则是单月内按照小时拆分，最小粒度是小时，可以一天最多24个分片，最少一个分片，一个月完成后下个月开始循环，每个月月尾，需要手工清理数据。</p>
<h5 id="修改schema-xml文件-10"><a href="#修改schema-xml文件-10" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user6"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-hour"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-9"><a href="#修改rule-xml文件-9" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-hour"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns： 拆分字段，字符串类型（yyyymmddHH） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-hour<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-hour"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.LatestMonthPartion"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- splitOneDay ：一天切分的分片数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"splitOneDay"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-10"><a href="#重启mycat-10" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-11"><a href="#建表-11" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user6(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    create_time <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-11"><a href="#插入数据-11" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060100'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060101'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060102'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060103'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060104'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060105'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060106'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060107'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060108'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060109'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060110'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060111'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060112'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060113'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060114'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060115'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060116'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060117'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060118'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060119'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060120'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060121'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060122'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060123'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060200'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060201'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060202'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060203'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060204'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060205'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060206'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060207'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060208'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060209'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060210'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user6(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020060211'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-9"><a href="#查询结果-9" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分表-按单月小时分片.jpg" style="zoom:67%;" />

<blockquote>
<p>当运行完成之后会发现，第一天的数据能够正常的插入成功，均匀的分散到3个分片上，但是第二天的数据就无法成功分散了，原因就在于我们的数据分片不够，所以这种方式几乎没有人使用。</p>
<p>ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER6 -&gt; CREATE_TIME -&gt; 2020060200 -&gt; Index : 3</p>
</blockquote>
<hr>
<h4 id="2-12、日期范围hash分片"><a href="#2-12、日期范围hash分片" class="headerlink" title="2.12、日期范围hash分片"></a>2.12、日期范围hash分片</h4><p>​        思想与范围求模一致，当由于日期在取模会有数据集中问题，所以改成了hash方法。先根据时间hash使得短期内数据分布的更均匀，有点可以避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题，要求日期格式尽量精确，不然达不到局部均匀的目的。</p>
<h5 id="修改schema-xml文件-11"><a href="#修改schema-xml文件-11" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user7"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"rangeDateHash"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-10"><a href="#修改rule-xml文件-10" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rangeDateHash"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- columns： 拆分字段，字符串类型（yyyymmddHH） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- algorithm:分片函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>range-date-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"range-date-hash"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByRangeDateHash"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate:指定开始的日期，与dateFormat格式一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2020-06-01 00:00:00<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay:代表多少天一组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dateFormat:指定的日期格式，符合java标准 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一组分片的分片数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"groupPartionSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-11"><a href="#重启mycat-11" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-12"><a href="#建表-12" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user7(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    create_time <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-12"><a href="#插入数据-12" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-01 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-02 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-03 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-04 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-05 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-06 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-07 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-08 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-09 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-10 00:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user7(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'steven'</span>,<span class="string">'2020-06-11 00:00:00'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-10"><a href="#查询结果-10" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分表-日期范围hash分片.jpg" style="zoom: 67%;" />

<blockquote>
<p>通过结果也可以看出，每三天一个分片，那么我们只有三个数据节点，所以到10号的数据的时候，没有办法进行数据的插入了，原因就在于没有足够多的数据节点。</p>
<p>insert into user7(id,name,create_time) values(1,’steven’,’2020-06-11 00:00:00’);ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER7 -&gt; CREATE_TIME -&gt; 2020-06-10 00:00:00 -&gt; Index : 3</p>
</blockquote>
<hr>
<h4 id="2-13、冷热数据分片"><a href="#2-13、冷热数据分片" class="headerlink" title="2.13、冷热数据分片"></a>2.13、冷热数据分片</h4><p>​        根据日期查询冷热数据分布，最近n个月的到实时交易库查询，其他的到其他库中</p>
<h5 id="修改schema-xml文件-12"><a href="#修改schema-xml文件-12" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user8"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-hotdate"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-11"><a href="#修改rule-xml文件-11" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-hotdate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-hotdate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-hotdate"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByHotDate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dataFormat：时间格式化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sLastDay:热数据的天数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sLastDay"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sPartionDay:冷数据的分片天数（按照天数分片）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sPartionDay"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-12"><a href="#重启mycat-12" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-13"><a href="#建表-13" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  user8(create_time <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>  ,<span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-13"><a href="#插入数据-13" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-10'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-11'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-21'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-04-30'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-01'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-10'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-05-30'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-24'</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user8 (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2021-03-25'</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-11"><a href="#查询结果-11" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分表-冷热数据分片.jpg" style="zoom:67%;" />

<blockquote>
<p>当前时间之后及前<code>sLastDay</code>天的数据放入第一个节点</p>
<p>当前操作时间前<code>sPartionDay</code>-当前操作时间前<code>sLastDay</code>天内的数据放入第二个节点</p>
<p>其余当如第三个节点</p>
</blockquote>
<hr>
<h4 id="2-14、自然月分片"><a href="#2-14、自然月分片" class="headerlink" title="2.14、自然月分片"></a>2.14、自然月分片</h4><h5 id="修改schema-xml文件-13"><a href="#修改schema-xml文件-13" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user9"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-month"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-12"><a href="#修改rule-xml文件-12" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-month"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-month<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-month"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMonth"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dateFormat ： 日期字符串格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sBeginDate ： 开始日期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2021-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-13"><a href="#重启mycat-13" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-14"><a href="#建表-14" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  user9(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),create_time <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-14"><a href="#插入数据-14" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-01-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-03-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-05-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-07-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-09-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-11-01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user9(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time) <span class="keyword">values</span>(<span class="number">111</span>,<span class="string">'zhangsan'</span>,<span class="string">'2021-02-01'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-12"><a href="#查询结果-12" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-自然月分片.jpg" style="zoom:67%;" />

<blockquote>
<p>从<code>sBeginDate</code>指定的月份开始，根据配置的节点数进行分片，因为配置了三个节点，所以如图所示，只有前三个月的数据会被会被分配插入，其余的报错ERROR 1064 (HY000): Can’t find a valid data node for specified node index :USER9 -&gt; CREATE_TIME -&gt; 2021-11-01 -&gt; Index : 10  因为无法找到对应有效的节点</p>
</blockquote>
<hr>
<h4 id="2-15、一致性hash分片"><a href="#2-15、一致性hash分片" class="headerlink" title="2.15、一致性hash分片"></a>2.15、一致性hash分片</h4><p>​        实现方式：一致性hash分片，利用一个分片节点对应一个或者多个虚拟hash桶的思想，尽可能减少分片扩展时的数据迁移。将指定的列值进行hash再对2^32进行取模得到hash环的对应位置</p>
<p>​        优点：有效解决了分布式数据库的扩容问题。</p>
<p>​        缺点：在横向扩展的时候，需要迁移部分数据；由于虚拟桶倍数与分片节点数都必须是正整数，而且要服从”虚拟桶倍数×分片节点数=设计极限”，因此在横向扩容的过程中，增加分片节点并不是一台一台地加上去的，而是以一种因式分解的方式增加，因此有浪费物理计算力的可能性。</p>
<h5 id="修改schema-xml文件-14"><a href="#修改schema-xml文件-14" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"user10"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-murmur"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改rule-xml文件-13"><a href="#修改rule-xml文件-13" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-murmur"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"murmur"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMurmurHash"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认是 0--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"seed"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的 160 倍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"virtualBucketTimes"</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--节点的权重，没有指定权重的节点默认是 1。以 properties 文件的格式填写，以从 0 开始到 count-1 的整数值也就是节点索引为 key，以节点权重值为值。所有权重值必须是正整数，否则以 1 代替 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="weightMapFile"&gt;weightMapFile&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的 murmur hash 值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bucketMapPath"</span>&gt;</span>/etc/mycat/bucketMapPath<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重启mycat-14"><a href="#重启mycat-14" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h5><h5 id="建表-15"><a href="#建表-15" class="headerlink" title="建表"></a><strong>建表</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user10(<span class="keyword">id</span> <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<h5 id="插入数据-15"><a href="#插入数据-15" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1111111</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2222222</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3333333</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">4444444</span>,<span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user10(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8960000</span>,<span class="keyword">database</span>());</span><br></pre></td></tr></table></figure>

<h5 id="查询结果-13"><a href="#查询结果-13" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h5><img src="http://yrlzero.gitee.io/images/linux/mycat/分片-一致性hash.jpg" style="zoom: 55%;" />

<blockquote>
<p>根据<code>count</code>指定分片的节点数量，每个节点会被映射<code>virtualBucketTimes</code>倍的虚拟节点，将<code>columns</code>字段计算hash值再对2^32取模得出hash槽位，顺时针寻找该位最近的节点进行存储</p>
</blockquote>
<hr>
<h2 id="三、分片join"><a href="#三、分片join" class="headerlink" title="三、分片join"></a>三、分片join</h2><p>​        Join绝对是关系型数据库中最常用的一个特性，然而在分布式环境中，跨分配的join却是最复杂的，最难解决的一个问题。</p>
<p>​        性能建议：</p>
<ol>
<li>尽量避免使用left join或right join，而用inner join</li>
<li>在使用left join或right join时，on会优先执行，where条件在最后执行，所以再使用过程中，条件尽可能的在on语句中判断，减少where的执行</li>
<li>少使用子查询，而用join</li>
</ol>
<p>​        mycat目前版本支持跨分配的join，主要有四种实现方式：<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#%E5%85%A8%E5%B1%80%E8%A1%A8"><code>全局表</code></a>、<a href="https://yrlzero.gitee.io/2021/04/29/mycat%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/#ER%E5%88%86%E7%89%87"><code>ER分片</code></a>、<code>catletT(人工智能)</code>、<code>ShareJoin</code></p>
<h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a><strong>全局表</strong></h3><p>​        在分片的情况下，当业务表因为规模而进行分片之后，业务表与这个字典表的之间关联会变得比较棘手，因此，在mycat中存在一种全局表，他具备以下特性：</p>
<ol>
<li>全局表的插入、更新操作会实时的在所有节点上执行，保持各个分片的数据一致性</li>
<li>全局表的查询操作，只从一个节点获取</li>
<li>全局表可以跟任何一个表进行join操作</li>
</ol>
<h4 id="修改schema-xml文件-15"><a href="#修改schema-xml文件-15" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"dict_order_type"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">type</span>=<span class="string">"global"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-15"><a href="#重启mycat-15" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-16"><a href="#建表-16" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dict_order_type(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-16"><a href="#插入数据-16" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">101</span>,<span class="string">'type1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">102</span>,<span class="string">'type2'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-14"><a href="#查询结果-14" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><img src="http://yrlzero.gitee.io/images/linux/mycat/全局表.jpg" style="zoom:67%;" />

<blockquote>
<p>由图可以看出，每个节点都保存了一份数据，而查询只会从一个节点获取，相当于每个节点都冗余了一个全局表，以便节点内的数据join操作</p>
</blockquote>
<hr>
<h3 id="ER分片"><a href="#ER分片" class="headerlink" title="ER分片"></a><strong>ER分片</strong></h3><p>​        在mycat中，我们已经将orders进行了数据分片，但是orders表跟orders_detail发生关联，如果只把orders_detail放到一个分片上，那么跨库的join很麻烦，所以提出了ER关系的表分片。什么意思呢？<code>就是通过关联关系，将子表与父表关联的记录放在同一个数据分片上。</code></p>
<h4 id="修改schema-xml文件-16"><a href="#修改schema-xml文件-16" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span> =<span class="string">"orders"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">"orders_detail"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">joinKey</span>=<span class="string">"order_id"</span> <span class="attr">parentKey</span>=<span class="string">"id"</span> /&gt;</span>	<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>修改<code>rule.xml</code>文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod_rule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-16"><a href="#重启mycat-16" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-17"><a href="#建表-17" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--订单表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_type <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span>,</span><br><span class="line">    amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--订单详细表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_detail(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">    detail <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    order_id <span class="built_in">INT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-17"><a href="#插入数据-17" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'detail1'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'detail1'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'detail1'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'detail1'</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'detail1'</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">'detail1'</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-15"><a href="#查询结果-15" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><img src="http://yrlzero.gitee.io/images/linux/mycat/er分片.jpg" style="zoom:60%;" />

<blockquote>
<p>关联关系，将子表与父表关联的记录放在同一个数据分片上，以便数据之间的join关联</p>
</blockquote>
<hr>
<h3 id="Share-join"><a href="#Share-join" class="headerlink" title="Share join"></a>Share join</h3><p>​        ShareJoin是一个简单的跨分片join,基于HBT的方式实现。目前支持2个表的join，原理是解析SQL语句，拆分成单表的SQL语句执行，然后把各个节点的数据汇集。</p>
<h4 id="修改schema-xml文件-17"><a href="#修改schema-xml文件-17" class="headerlink" title="修改schema.xml文件"></a><strong>修改<code>schema.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"company"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"customers"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-intfile"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改rule-xml文件-14"><a href="#修改rule-xml文件-14" class="headerlink" title="修改rule.xml文件"></a><strong>修改<code>rule.xml</code>文件</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod-long"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-intfile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByFileMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改partition-hash-int-txt文件-1"><a href="#修改partition-hash-int-txt文件-1" class="headerlink" title="修改partition-hash-int.txt文件"></a>修改partition-hash-int.txt文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10000&#x3D;0</span><br><span class="line">10010&#x3D;1</span><br></pre></td></tr></table></figure>

<h4 id="重启mycat-17"><a href="#重启mycat-17" class="headerlink" title="重启mycat"></a><strong>重启mycat</strong></h4><h4 id="建表-18"><a href="#建表-18" class="headerlink" title="建表"></a><strong>建表</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> company(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),company_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,sharding_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="插入数据-18"><a href="#插入数据-18" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'mycat'</span>);</span><br><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'ibm'</span>);</span><br><span class="line"><span class="keyword">insert</span> company (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'hp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(<span class="keyword">id</span>,<span class="keyword">name</span>,company_id,sharding_id)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'wang'</span>,<span class="number">1</span>,<span class="number">10000</span>),(<span class="number">2</span>,<span class="string">'xue'</span>,<span class="number">2</span>,<span class="number">10010</span>),(<span class="number">3</span>,<span class="string">'feng'</span>,<span class="number">3</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询结果-16"><a href="#查询结果-16" class="headerlink" title="查询结果"></a><strong>查询结果</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可以看到有时可以查出对应的结果，有时则查询不到</span></span><br><span class="line"><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a,company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">--可以看到每次都可以直接查询到结果</span></span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a,company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">--其他写法</span></span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a <span class="keyword">join</span> company b <span class="keyword">on</span> a.COMPANY_ID=b.ID;</span><br><span class="line"><span class="comment">/*!mycat:catlet=io.mycat.catlets.ShareJoin */</span><span class="keyword">select</span> a.*,b.ID,b.NAME <span class="keyword">as</span> tit <span class="keyword">from</span> customers a <span class="keyword">join</span> company b <span class="keyword">where</span> a.COMPANY_ID=b.ID;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、全局序列号"><a href="#四、全局序列号" class="headerlink" title="四、全局序列号"></a>四、全局序列号</h2><h3 id="1、本地文件方式"><a href="#1、本地文件方式" class="headerlink" title="1、本地文件方式"></a>1、本地文件方式</h3><p>​        使用此方式的时候，mycat讲sequence配置到文件中，当使用到sequence中的配置，mycat会更新sequence_conf.properties文件中sequence当前的值。</p>
<p>​        <strong>配置方式：</strong></p>
<p>​        在 sequence_conf.properties 文件中做如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">GLOBAL_SEQ.HISIDS</span>=<span class="string"></span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.MINID</span>=<span class="string">10001</span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.MAXID</span>=<span class="string">20000</span></span><br><span class="line"><span class="meta">GLOBAL_SEQ.CURID</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure>

<p>​        其中 HISIDS 表示使用过的历史分段(一般无特殊需要可不配置)， MINID 表示最小 ID 值， MAXID 表示最大<br>ID 值， CURID 表示当前 ID 值。<br>​        server.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        注： sequnceHandlerType 需要配置为 0，表示使用本地文件方式。  </p>
<p>​        案例使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab1(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="string">'test3'</span>);</span><br></pre></td></tr></table></figure>

<p>​        缺点：当mycat重新发布后，配置文件中的sequence会恢复到初始值</p>
<p>​        优点：本地加载，读取速度较快</p>
<h3 id="2、数据库方式"><a href="#2、数据库方式" class="headerlink" title="2、数据库方式"></a>2、数据库方式</h3><p>​        在数据库中建立一张表，存放sequence名称（name）,sequence当前值(current_value),步长（increment int类型，每次读取多少个sequence，假设为K）等信息；</p>
<p>​        <strong>获取数据步骤</strong>：</p>
<p>​        1、当初次使用该sequence时，根据传入的sequence名称，从数据库这张表中读取current_value和increment到mycat中，并将数据库中的current_value设置为原current_value值+increment值。</p>
<p>​        2、mycat将读取到current_value+increment作为本次要使用的sequence值，下次使用时，自动加1，当使用increment次后，执行步骤1中的操作</p>
<p>​        3、mycat负责维护这张表，用到哪些sequence，只需要在这张表中插入一条记录即可，若某次读取的sequence没有用完，系统就停掉了，则这次读取的sequence剩余值不会再使用</p>
<p>​        <strong>配置方式：</strong></p>
<p>​        1、修改server.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        2、修改schema.xml文件        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"mycat_sequence"</span> <span class="attr">primaryKey</span>=<span class="string">"name"</span> <span class="attr">dataNode</span>=<span class="string">"dn2"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        3、修改mycat配置文件sequence_db_conf.properties，添加属性值</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sequence stored in datanode</span></span><br><span class="line"><span class="attr">GLOBAL</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">COMPANY</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">CUSTOMER</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">ORDERS</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">MYCAT</span>=<span class="string">dn2</span></span><br></pre></td></tr></table></figure>

<p>​        4、在dn2上添加mycat_sequence表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_sequence;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mycat_sequence (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="keyword">increment</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">100</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">name</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>​        5、在dn2上的mycat_sequence表中插入初始记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mycat_sequence(<span class="keyword">name</span>,current_value,<span class="keyword">increment</span>) <span class="keyword">VALUES</span> (<span class="string">'mycat'</span>, <span class="number">-99</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>​        6、在dn2上创建函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建函数</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_currval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_currval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>)     <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> retval <span class="built_in">VARCHAR</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">SET</span> retval=<span class="string">"-999999999,null"</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="keyword">CAST</span>(current_value <span class="keyword">AS</span> <span class="built_in">CHAR</span>),<span class="string">","</span>,<span class="keyword">CAST</span>(<span class="keyword">increment</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>)) <span class="keyword">INTO</span> retval <span class="keyword">FROM</span> mycat_sequence <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--设置sequence值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_setval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_setval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),<span class="keyword">value</span> <span class="built_in">INTEGER</span>) <span class="keyword">RETURNS</span>     <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> mycat_sequence</span><br><span class="line"><span class="keyword">SET</span> current_value = <span class="keyword">value</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--获取下一个sequence值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> mycat_seq_nextval;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_nextval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>)     <span class="keyword">CHARSET</span> utf8</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> mycat_sequence</span><br><span class="line"><span class="keyword">SET</span> current_value = current_value + <span class="keyword">increment</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>​        <strong>数据测试：</strong></p>
<p>​        1、插入数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>​        2、查询对应的序列数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mycat_sequence;</span><br></pre></td></tr></table></figure>

<p>​        3、向表中插入数据，可以多执行几次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_MYCAT,(<span class="keyword">select</span> <span class="keyword">database</span>()));</span><br></pre></td></tr></table></figure>

<p>​        4、查询添加的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>​        5、重新启动mycat，重新添加数据，查看结果，重启之后从101开始</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mycat_sequence;</span><br></pre></td></tr></table></figure>

<p>​        6、重新查询数据表test</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>​        大家在使用的时候会发现报错的情况，这个错误的原因不是因为我们的配置，是因为我们的版本问题，简单替换下版本即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into test(id,name) values(next value for MYCATSEQ_MYCAT,(select database()));</span><br><span class="line">ERROR 1003 (HY000): mycat sequnce err.java.lang.NumberFormatException: null</span><br></pre></td></tr></table></figure>

<h3 id="3、本地时间戳方式"><a href="#3、本地时间戳方式" class="headerlink" title="3、本地时间戳方式"></a>3、本地时间戳方式</h3><p>​        ID= 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加)。</p>
<p>​        换算成十进制为 18 位数的 long 类型，每毫秒可以并发 12 位二进制的累加。  </p>
<p>​        <strong>使用方式：</strong></p>
<p>​        1、配置server.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        2、修改sequence_time_conf.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">WORKID</span>=<span class="string">06 #任意整数</span></span><br><span class="line"><span class="attr">DATAACENTERID</span>=<span class="string">06  #任意整数</span></span><br></pre></td></tr></table></figure>

<p>​        3、修改schema.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"test2"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2,dn3"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        4、启动mycat，并且创建表进行测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2(<span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment primary <span class="keyword">key</span>,xm <span class="built_in">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2(<span class="keyword">id</span>,xm) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL，<span class="string">'lisi'</span>) ;</span><br></pre></td></tr></table></figure>

<p>​        此方式的优点是配置简单，但是缺点也很明显就是18位的id太长，需要耗费多余的存储空间。</p>
<h3 id="4、自定义全局序列"><a href="#4、自定义全局序列" class="headerlink" title="4、自定义全局序列"></a>4、自定义全局序列</h3><p>​        用户还可以在程序中自定义全局序列，通过java代码来实现，这种方式一般比较麻烦，因此在能使用mycat提供的方式满足需求的前提下一般不需要自己通过java代码来实现。</p>
<h3 id="5、分布式ZK-ID生成器"><a href="#5、分布式ZK-ID生成器" class="headerlink" title="5、分布式ZK ID生成器"></a>5、分布式ZK ID生成器</h3><p>​        如果在搭建的时候使用了zookeeper，也可以使用zk来生成对应的id，此方式需要zk的配合，此处不再展示，有兴趣的同学下去自己演示即可。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.7 HashMap和ConcurrentHashMap 源码和实现</title>
    <url>/2021/03/31/jdk7-hashmap/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>问题：JDK1.7中，HashMap是通过什么原理实现的呢？</p>
<p>答案：数组+链表</p>
<p>问题：什么叫哈希碰撞（哈希冲突）？</p>
<p>不同的键值通过哈希函数运算得到相同的哈希值，解决哈希冲突的方式有开放寻址法和链表法，ThreadLocalMap由于其元素个数较少，采用的是开放寻址法，而HashMap采用的是链表法来解决哈希冲突，即所有散列值相同的元素都放在相同槽对应的链表中（也就是数组+链表的方式）。</p>
</blockquote>
<a id="more"></a>

<h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><p>先分析一下HashMap的关键属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap初始化容量大小，默认是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">* by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">* MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap最大的容量大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap的扩容因子，默认是0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// If table == EMPTY_TABLE then this is the initial capacity at which the</span></span><br><span class="line"><span class="comment">// table will be created when inflated.</span></span><br><span class="line"><span class="comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；</span></span><br><span class="line"><span class="comment">//当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">//HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//当前HashMap存储的键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">* Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">* the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">* rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">* the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//用于计算链表中的修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap内部的存储结构是一个数组，此处数组为空，即没有初始化之前的状态  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//HashMap的主干数组，就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>

<p>HashMap的主干是一个<strong>Entry数组</strong>。Entry是HashMap的基本组成单元，Entry是一个链表，每一个Entry包含一个<code>key-value</code>键值对，每一个Entry都有一个<code>next</code>属性指向下一个<code>Entry</code>对象。</p>
<p>Entry是HashMap中的一个静态内部类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Entry有一个构造函数，该构造函数第三个参数是<code>Entry&lt;K,V&gt; n</code>，<strong>主要用于链表的头插入，传入链表的链表头，将新生成的Entry对象作为链表的头部，<code>next</code>属性指向原链表头。</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-01.png" alt="source-01"></p>
<hr>
<p>接着看一下<code>HashMap</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当初始化的容量小于0时抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//当初始化容量大于最大值时，修改成最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//这里先把初始化的容量大小赋值给 threshold阈值</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//LinkedHashMap初始化的使用，HashMap类是个空方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>在看HashMap的<code>put</code>方法之前，先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">		String a = map.put(<span class="string">"1"</span>, <span class="string">"3"</span>);</span><br><span class="line">		System.out.println(a);   <span class="comment">//输出结果：2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会输出结果是【2】呢？来HashMap的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用了懒加载，初始化HashMap对象时并未真正赋予其数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当Key等于null时，默认其存储的数组下标是0</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算Key的Hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//将Hash值进行算法计算，得出存储的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历寻找key值是否存在于链表中，存在则替换value成新值，并且返回旧值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//修改次数++</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//不存在于链表中，执行添加操作</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒加载初始化"><a href="#懒加载初始化" class="headerlink" title="懒加载初始化"></a>懒加载初始化</h4><p>接着解析一下<code>put</code>方法的逻辑，可以看到它懒加载时调度了<code>inflateTable</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inflates the table. </span></span><br><span class="line"><span class="comment">* 初始化table数组大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">// 用于获取toSize 大于或等于的 2的次方数 HashMap规定了容量大小必须是2个次方倍</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在看以下运算之前，我们应该了解到，2的幂次方数在二进制位数上只有一个1的存在</span></span><br><span class="line"><span class="comment">	2  0000 0010</span></span><br><span class="line"><span class="comment">	4  0000 0100</span></span><br><span class="line"><span class="comment">	8  0000 1000</span></span><br><span class="line"><span class="comment">	16 0001 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//int java.lang.Integer.highestOneBit(int i) </span></span><br><span class="line"><span class="comment">//返回小于等于i的2的次方数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1			比如：i=17  binary（17）= 0001 0001</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);				<span class="comment">//0001 0001 | 0000 1000 = 0001 1001</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);				<span class="comment">//0001 1001 | 0000 0110 = 0001 1110</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);				<span class="comment">//以下也如此，主要是为了把低数值都填充为1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);				<span class="comment">//0001 1111 | 0000 0000 = 0001 1111</span></span><br><span class="line">    <span class="comment">//以上操作时为了将低位全部变成1</span></span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);		<span class="comment">//0001 1111 - 0000 1111 = 0001 0000</span></span><br><span class="line">    <span class="comment">//如此以上操作我们就得到了小于等于2的幂次方数，因为传入的数值经过左移1处理，即数值翻倍，所以得到的次方数为大于等于原始数值的2的幂次方数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关注代码：<code>Integer.highestOneBit((number - 1) &lt;&lt; 1)</code><br>1、highestOneBit获取的是<strong>小于等于i</strong>的2次方数，而这里需要获取<strong>大于等于i</strong>的2次方数</p>
<p>2、传入的参数值通过向左位移一位，将数字扩大两倍，如number=10，需要将它左移后得到20，通过highestOneBit方法可以获取到小于等于传入值的2次方数，即16，如此便可获得大于等于number的2次方数</p>
<p>3、（number - 1）是为了兼容特殊场景，number刚好等于2的次方数 ，例如16，此时如果直接左位移后传入计算，则得到的数字为32，远远超出我们的需求，所以需要进行减1操作，适配这种情况</p>
</blockquote>
<hr>
<blockquote>
<p>思考：HashMap的采用的数组+链表的存储方式，那么当一个键值对put进来时，它的下标是怎么计算的呢？</p>
<p>思考：为什么HashMap规定了其容量的大小必须是2的幂次方数？其原因是什么？</p>
</blockquote>
<p><code>put</code>方法接着往下看，可以看到，它把<code>Key</code>值拿去做了<code>HashCode</code>运算，并调用<code>indexFor</code>，根据返回的<code>HashCode</code>值<strong>计算该键值对应该存放的Entry数组下标</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns index for hash code h.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>意义</th>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>0001 0000</td>
<td>16</td>
</tr>
<tr>
<td>length-1</td>
<td>0000 1111</td>
<td>15</td>
</tr>
<tr>
<td>HashCode</td>
<td>1010 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0000 1010</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到下标的结果将落在了【0 - 15】 中，通过<code>length -1</code>，将低位全部变成1，进行与运算后，下标必定落在其范围中，这也是为什么规定了HashMap的容量必须是2的次方数。</p>
<p>(Length - 1) &amp; HashCode公式中，因为数组长度需要其加入&amp;运算，当长度减1时，高位变成0，低位全部变成1，与HashCode值进行&amp;运算之后的数值必定落的[0,Length -1]之间,因此保证长度为2的幂次方时，运算可以等同于HashCode%数组长度</p>
<p>细心的同学可以发现，这里参与计算的只有<code>HashCode</code>的地位，而HashCode的高位并没有参与计算，那么就会导致数据分散在数组中会很不均匀，这时候回过头再来看上一行的<code>hash</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当hashSeed!=0时，计算时hash值将加入哈希种子打散hash值的分布</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当取到了<code>hashCode</code>之后，对<code>hashCode</code>进行了右移的异或运算，再将得出的结果拿去计算数组下标，这是为了让<code>hashcode</code>的高位也能参与到数组下标的计算过程当中，解决数据分布不均匀的问题。</p>
<hr>
<p>再接着往下看<code>put</code>方法的执行，定位到数组下标后遍历其链表，判断链表是否存在相同的<code>key</code>值，如果找到，新值覆盖旧值，并且返回旧值。这也是为什么上文例子中，输出的结果是【2】的原因。</p>
<h4 id="扩容判断及添加元素"><a href="#扩容判断及添加元素" class="headerlink" title="扩容判断及添加元素"></a>扩容判断及添加元素</h4><p>接着详细看看<code>put</code>方法中执行的<code>addEntry</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* int hash:	当前Key的Hash值</span></span><br><span class="line"><span class="comment">* bucketIndex:	数组下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//需要扩容时，传参传入了table.length的长度的两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前链表的表头，即数组bucketIndex索引上的元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将key-value键值对赋予到新Entry对象中，并通过头插入法，其Entry的next属性指向原链表表头</span></span><br><span class="line">    <span class="comment">//则新的Entry对象成为了链表的新表头，并将该表头存储在table数组中。</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//添加新元素，hashMap的元素数量++</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：根据源码可以得出，JDK1.7的HashMap插入链表采用的是“头插入”法。</strong></p>
<p>问题：为什么采用头插法呢？</p>
<p>答案：因为头插法效率高，不需要遍历链表。</p>
<p>​        但其实插入之前都需要遍历链表的旧元素，判断是否存在相同的key，存在则修改，没有才会在遍历之后进行头插入新增；所以这里并不能体现出头插法的优势。因为在我们遍历旧链表时，新增情况下，我们可以知道尾节点的元素，因此尾插法也可以直接将元素添加上去；如若修改和插入的方法进行分离，无法记录尾节点的情况下，头插法才能在插入时体现出效率优势。</p>
<p>​        </p>
<p>问题：在添加新的键值对的时候，需要判断是否需要扩容，那么它什么情况下需要扩容？</p>
<p>答案：</p>
<p>1.当前HashMap的键值对数量（size）&gt;= <code>threshold</code>【threshold=capacity（当前数组容量）*loadFactory（扩容因子）】</p>
<p>2.Entry数组上的元素不为空</p>
</blockquote>
<hr>
<blockquote>
<p>问题：HashMap为什么需要扩容？</p>
<p>答案：初始化的Entry数组容量是16，元素过多会导致链表过长，当调用get方法遍历链表时会增加耗时，所以需要通过扩容，将一条链表的数据内容分散成多条链表，添加到扩容数组的新下标中。</p>
</blockquote>
<h4 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h4><p>接下来看看他的扩容逻辑，当满足扩容条件（size大于等于阈值 &amp;&amp; 数组当前索引位置不为空）时，调度了<code>resize</code>方法：</p>
<p>重新计算链表元素的索引位置（h &amp; (length-1)），使用头插法，旧元素next指向新链表索引位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历原Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">//遍历链表中的每一个非空Entry</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新计算该Entry需要存储的数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//将next属性指向原链表头</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">//替换数组中的链表头位置</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//将e元素指向下一个链表中的Entry</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>key的<code>rehash</code>是有条件的</strong>，需要根据参数的布尔值决定它是否需要重新计算hash值，<strong>并不是所有扩容都需要重新计算key的Hash值。</strong></p>
<blockquote>
<p>假设链表中有三个元素，分别是【1、2、3】，具体行为如下：</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-02.png" alt="source-02"></p>
<p>在遍历过程中，由于数组下标没有发生变化，其Entry对象依旧将指向新数组的同一个下标，接着循环遍历链表的第二个元素。</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-03.png" alt="source-03"></p>
<p>遍历第二个元素时，通过表头插入法，其next指向原链表表头，并将自身作为Entry数组的链表头，最终得出的结果如下：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-04.png" alt="source-04"></p>
<p>可以看到，<strong>在扩容过程中，计算出来的数组下标没有发生变化时，链表被反序存储了。</strong></p>
<hr>
<blockquote>
<p>问题：怎么将一条链表的数据内容分散成多条链表，添加到扩容数组的新下标中？新下标满足什么规律？</p>
</blockquote>
<p>假设原数组长度是16，那么扩容后则等于32，看看其计算下标的变化：</p>
<table>
<thead>
<tr>
<th>意义</th>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>0010 0000</td>
<td>32</td>
</tr>
<tr>
<td>length-1</td>
<td>0001 1111</td>
<td>31</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Akey：HashCode</td>
<td>1010 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0000 1010</td>
<td>index=10</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bkey：HashCode</td>
<td>1011 1010</td>
<td></td>
</tr>
<tr>
<td>hashCode &amp; (length-1)</td>
<td>0001 1010</td>
<td>index=26</td>
</tr>
</tbody></table>
<p>可以看到，当<code>Akey=HashCode=1010 1010</code>时，计算的数组下标未发生变化，而当<code>Bkey=HashCode=1011 1010</code>时，计算的等于26，也就是说，<strong>通过这种方式，就能够将属于同一个链表的元素，在重新计算下标的过程中，将链表元素分配到其他新的链表中。</strong></p>
<p><strong>在Hash值未被重新计算的前提下，若链表元素被分配到其他新链表时，其新链表的下标=原下标+原数组长度</strong>。</p>
<hr>
<blockquote>
<p>问题：HashMap为什么在多线程并发的情况下会出现问题？著名的HashMap死锁问题原因是什么？</p>
</blockquote>
<p>假设现在有两条线程同时对同一个HashMap操作，执行<code>put</code>方法，而且<strong>刚好满足扩容条件</strong>时，假设这时候两条线程都运行到了<code>transfer</code>方法的循环语句，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//假设两条多线程都运行到该行位置</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;	</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<strong>代码中遍历的<code>table</code>数组是一个成员变量，是共享的</strong>，所以循环到该点时的指向如下图：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-05.png" alt="source-05"></p>
<p>由于Java的多线程并发是通过CPU上下文切换交替执行的，<strong>假设这时候线程2被CPU挂起了，线程1执行完扩容操作，线程2再恢复执行，那么当线程1执行完扩容后，其对应的<code>table</code>数组内容已经发生改变，当线程2被CPU唤醒继续执行扩容时，其结构图如下：</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-06.png" alt="source-06"></p>
<p>按照代码的流程走向，经过一次while循环以后，值得注意的是，其<strong>e对象指向Entry对象（1），其next对象指向Entry（2）</strong>，得到如下：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-07.png" alt="source-07"></p>
<p>再经过一次while循环以后，其原本的<strong>Entry对象（2）的next属性指向Entry对象（1），所以其next对象将会重新指向Entry对象（1）</strong>，将得到下图：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-08.png" alt="source-08"></p>
<p>再经过一次while循环以后，<strong>其next对象将会指向null值，而Entry对象（1）的next属性将会指向原表头Entry对象（2）</strong>，将得到下图：</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-09.png" alt="source-09"></p>
<blockquote>
<p>从逻辑上可以看出，在多线程情况下造成了循环链表，由于最后的循环中的next对象指向了null，所以线程2的扩容是可以执行的，但是当有其他线程遍历该循环链表时，将会造成死循环，耗尽CPU资源，这就是HashMap在多线程并发情况下造成的死锁问题。</p>
</blockquote>
<blockquote>
<p>问题：如何在多线程情况下避免HashMap的死锁问题？</p>
<p>答案：如果已知了数据长度时，可以使用<code>public HashMap(int initialCapacity, float loadFactor)</code>构造函数设置其大小以及扩容因子，使得<code>size &gt;= threshold</code>条件不成立，避免造成扩容。</p>
</blockquote>
<hr>
<p>接着再回去看看<code>resize</code>和<code>transfer</code>方法，通过源码得知，<code>initHashSeedAsNeeded</code>方法是控制是否需要重算<code>hash</code>值，在它在什么情况下需要重算<code>key</code>的<code>hash</code>值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始条件下 哈希种子hashSeed=0，所以currentAltHashing = false;</span></span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//具体逻辑：当capacity 大于 Holder.ALTERNATIVE_HASHING_THRESHOLD时，才可能重算Hash</span></span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">        (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="comment">//取异或 不相等才返回true</span></span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后跟踪源码得知，<strong>在默认情况下，无论怎么扩容都不会造成重算Hash值，除非配置了JVM启动参数<code>jdk.map.althashing.threshold</code>。这里哈希种子的目的就是为了打散链表的hash值，使得每次扩容时，各链表分布更加均匀，</strong>这里就不再详细讨论了。</p>
<hr>
<p>在<code>HashMap</code>的属性中，定义了一个<code>transient int modCount;</code>，用来记录该对象的修改次数，<strong>是hashMap提供的一种快速失败机制（<code>fast fail</code>），用于迭代遍历时校验对象是否被修改，当集合在迭代过程中对象被其他线程并发修改时，将会抛出<code>ConcurrentModificationException</code>异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在遍历集合之前会将modCount赋值给expectedModCount，接着遍历过程中会不断验证modCount是否发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    current = e;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：那想要在遍历集合的过程中删除集合的元素，该如何实现？</p>
<p>答案：通过使用<code>Iterator</code>迭代器遍历集合，调用迭代器的<code>remove</code>方法删除元素，该方法在删除元素的时候会重新对<code>expectedModCount</code>赋值，保证了<code>modCount == expectedModCount</code>。</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>众做周知，HashMap就算避免了死锁问题，也不是一个线程安全的集合，而<strong><code>HashTable</code>类就是达到通过对HashMap里的各个方法加<code>synchronized</code>锁实现HashMap集合的线程安全，<code>HashTable</code>是一个同步容器类</strong>。</p>
<h4 id="属性结构-1"><a href="#属性结构-1" class="headerlink" title="属性结构"></a>属性结构</h4><p>而<code>ConcurrentHashMap</code>是一个并发容器类，底层使用了<code>Segment</code>分段锁的原理，先从源码中看看它和<code>HashMap</code>相比，属性上的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default concurrency level for this table, used when not</span></span><br><span class="line"><span class="comment">* otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//并发级别，用于计算一个Segment负责管理多少个Entry数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The minimum capacity for per-segment tables.  Must be a power</span></span><br><span class="line"><span class="comment">* of two, at least two to avoid immediate resizing on next use</span></span><br><span class="line"><span class="comment">* after lazy construction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//规定了segment中的HashEntry数组最小容量，数组容量必须是2的次方数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum number of times to tryLock in a prescan before</span></span><br><span class="line"><span class="comment">* possibly blocking on acquire in preparation for a locked</span></span><br><span class="line"><span class="comment">* segment operation. On multiprocessors, using a bounded</span></span><br><span class="line"><span class="comment">* number of retries maintains cache acquired while locating</span></span><br><span class="line"><span class="comment">* nodes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取锁失败时，tryLock循环的最大次数，获取当前CPU核数，大于1则设置成64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">    Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum number of segments to allow; used to bound</span></span><br><span class="line"><span class="comment">* constructor arguments. Must be power of two less than 1 &lt;&lt; 24.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//规定了segment数组的最大值不能超过2的16次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Mask value for indexing into segments. The upper bits of a</span></span><br><span class="line"><span class="comment">* key's hash code are used to choose the segment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//segmentMask = segment[].length - 1 用来执行【haschCode &amp; segmentMask】计算Hash值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//ConcurrentHashMap的分段锁对象，自身带了一把锁且存储了链表结构</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<hr>
<p>在<code>HashEntry</code>类<code>ConcurrentHashMap</code>是的基础单元(节点)，是实际数据的载体，等同于<code>HashMap</code>中的<code>Entry</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-10.png" alt="source-10"></p>
<hr>
<p><code>Segment</code> 继承 <code>ReentrantLock</code> 锁,用于存放数组 <code>HashEntry[]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">* subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">* simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum number of times to tryLock in a prescan before</span></span><br><span class="line"><span class="comment">    * possibly blocking on acquire in preparation for a locked</span></span><br><span class="line"><span class="comment">    * segment operation. On multiprocessors, using a bounded</span></span><br><span class="line"><span class="comment">    * number of retries maintains cache acquired while locating</span></span><br><span class="line"><span class="comment">    * nodes.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//HashEntry数组，ConcurrentHashMap数据的存储的载体</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment">    * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//HashEntry的数组中的所有HashEntry大小（包括链表）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//HashEntry数组的变化次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">	<span class="comment">//扩容阈值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">	<span class="comment">//扩容因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-12.jpg" alt="source-12"></p>
<hr>
<h4 id="构造初始化"><a href="#构造初始化" class="headerlink" title="构造初始化"></a>构造初始化</h4><p>在看看<code>ConcurrentHashMap</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">     * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//规定了不能大于2的16次方</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">//该值用于存储segment数组容量的次方数</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//ssize小于并发级别则循环，并发级别默认16，该循环主要是找大于等于concurrencyLevel的2的次方数</span></span><br><span class="line">    <span class="comment">//默认的并发级别concurrencyLevel=16，循环4次后，sshift=4,ssize=16</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;<span class="comment">//28 = 32 - 4</span></span><br><span class="line">    <span class="comment">//ssize为segment[]的数组长度，所以segmentMask=segment.length-1</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//c相当于initialCapacity与ssize相差的倍数值，因除法可能舍弃小数位，所以有c * ssize &lt; initialCapacity的判断，进行自增，有小数位的情况下c会自增1</span></span><br><span class="line">    <span class="comment">//用于之后的cap计算</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">//cap是HashEntry数组大小，默认最小值为2</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//规定HashEntry数组必须是2的次方数，所以循环获取大于等于计算的HashEntry数组大小的2的次方数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">//在初始化Segment数组时默认初始化segment[0]，主要是为了生成原型，当初始化其他segment对象时无需再计算HashEntry数组大小</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其构造函数相比<code>HashMap</code>，多了一个<code>concurrencyLevel</code>参数，该参数主要是用来设置并发级别，用于</p>
<p>计算每个<code>segment</code>的<code>HashEntry</code>数组大小，<code>ConcurrentHashMap</code>规定了<code>segment</code>数组和<code>HashEntry</code>数组的大小必须是2的次方数，其缘由与<code>HashMap</code>一致。</p>
<blockquote>
<p><code>ConcurrentHashMap</code>构造方法的执行步骤：</p>
<p>1.判断参数的范围合法性</p>
<p>2.计算<code>concurrencyLevel</code>大于等于2的次方数</p>
<p>3.设置<code>segmentMask</code>的值</p>
<p>4.计算<code>segment</code>对象的<code>HashEntry</code>数组长度</p>
<p>5.设置<code>HashEntry</code>数组长度的合理长度（2&lt;=计算的HashEntry数组长度&lt;=合理长度=2的次方数）</p>
<p>6.根据合理的<code>segment</code>数组长度及<code>HashEntry</code>数组长度初始化<code>Segment[]</code>和<code>Segment[0]</code></p>
</blockquote>
<hr>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>接着看<code>ConcurrentHashMap</code>的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">//concurrentHashMap规定了Key和Value不能为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算Key的Hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//计算需要存储的segment数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//获取segment数组中的第j个位置的segment对象并赋值给对象s，如果为null，则初始化segment对象并存储进数组中</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">//将key-value键值对存储到segment中的HashEntry数组中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文中通过调用<code>UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)</code>获取<code>Segment</code>数组中的第<code>j</code>个下标的<code>segment</code>对象，因为通过这种偏移量获取对象效率会高很多。</p>
<blockquote>
<p>问题：在计算segment数组下标时，为什么需要执行<code>(hash &gt;&gt;&gt; segmentShift)</code>向右位移呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过观察ConcurrentHashMap的构造函数，其中有部分代码如下：</span></span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br></pre></td></tr></table></figure>

<p>上文分析了构造函数，该循环用于计算大于等于<code>concurrencyLevel</code>的2的次方数，假设<code>concurrencyLevel=16</code>，那么通过循环得知<code>sshift=4</code>，<code>segmentShift = 32 - sshift = 28</code>。</p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-13.png" alt="source-13"></p>
<p>如上图，其向右无符号位移28（<code>segmentShift=28</code>）位，最后将保留<code>HashCode</code>的高4（<code>sshift=4</code>）位，并使用<code>HashCode</code>的高位和<code>segmentMark</code>相与计算所在的<code>segment</code>数组下标。</p>
<p><strong>总而言之，就是取了<code>HashCode</code>的高位，和<code>segmentMask</code>计算数组下标</strong>，向右偏移获取<code>HashCode</code>高位的数量取决于初始化的<code>concurrencyLevel</code>的值，是2的几次方。</p>
<hr>
<p>当<code>put</code>方法执行计算<code>Segment[]</code>下标后，获取的<code>segment</code>对象有可能尚未初始化，根据逻辑会调度<code>ensureSegment</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">//进入方法后重新判断是否被其他线程初始化，若被初始化，则直接赋值seg对象并返回</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取segment[0]对象，以它为原型初始化segment对象</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">//获取原型的HashEntry数组长度</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="comment">//获取扩容因子</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="comment">//计算阈值</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">//double Check，再次判断是否已被其他线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">//创建Segment对象</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">//采用CAS自旋，将新生成的Segment对象塞进数组中，若失败，则获取数组对象返回</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析，当有多个线程同时并发执行创建同一个数组下标的<code>segment</code>对象时，由于<code>CAS</code>自旋机制，最终只会有一个线程创建成功，其他线程将获取数组对象并返回，从而达到在并发情况下的线程安全。</p>
<hr>
<p>创建完<code>segment</code>对象后，将调用<code>Segment.put()</code>方法，添加<code>key-value</code>键值对到<code>Segment</code>对象中，我们来看看<code>Segment</code>类的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试加锁 tryLock不阻塞</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//计算存储的HashEntry数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取HashEntry数组中的index下标，这里命名的first指的是HashEntry中的链表的头结点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//普通put方法的onlyIfAbsent=false，有相同的key，进入判断，更新旧值，返回旧值，</span></span><br><span class="line">                    <span class="comment">//putIfAbsent方法的onlyIfAbsent=true，有相同的key，不会进入此判断，不更新旧值，返回旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设遍历到最后节点均未匹配到相同的key由于它是最后的链表节点，e.next==null</span></span><br><span class="line">                <span class="comment">//再次循环时，将会运行到下面的else条件新建节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当获取锁失败时，会调用scanAndLockForPut提前生成node对象，这里只需设置链表头即可</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建HashEntry对象，采用头插法，新的HashEntry对象的next属性指向first</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//HashEntry总数+1</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果数量达到了扩容的阈值，则进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//添加HashEntry对象到数组中，并替换数组中的链表头（替换成新创建的HashEntry对象）</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                <span class="comment">//Setment中累加变化次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//赋值新计算的count值</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁ReentrantLock</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>Segment</code>继承了<code>ReentrantLock</code>，当它在插入元素时会调用<code>tryLock</code>非阻塞尝试获取锁，当获取锁失败时，调用<code>scanAndLockForPut</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment">* acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment">* return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment">* methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment">* traversal speed doesn't matter, we might as well help warm</span></span><br><span class="line"><span class="comment">* up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Hash值计算数组下标并获取链表的表头</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用这个变量来控制循环的逻辑</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">//循环尝试获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当链表的表头 == null 或者遍历链表后未匹配到元素时，创建HashEntry对象</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//设置retries=0用以下次循环时调用其他逻辑</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当链表表头不为空时，遍历链表，寻址到链表元素时设置retries=0调用其他逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//当链表遍历到最后一个节点，e.next=null,当再次循环时，会调用创建HashEntry对象的逻辑</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当重试次数大于一定的次数时，直接调用阻塞的Lock方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(retries &amp; 1) == 0 ：当retries是偶数时，返回true，表示每隔一次才去判断链表表头是否发生变化</span></span><br><span class="line">        <span class="comment">//重新获取链表表头，当链表表头与原来获取的first不同时，设置retries=-1，重新遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了，当尝试获取锁失败而调度<code>scanAndLockForPut</code>方法，其目的是为了在无法获取锁的时候能够提前创建<code>HashEntry</code>对象并返回。</p>
<hr>
<blockquote>
<p>回头接着看<code>Segment</code>的<code>put</code>方法的步骤：</p>
<p>1.当<code>Segment</code>获取到锁之后，先进行遍历，判断<code>HashEntry</code>是否有同样的<code>key</code>值存在</p>
<p>2.若key值存在，根据参数<code>onlyIfAbsent</code>判断是否覆盖<code>value</code>值，并返回旧值</p>
<p>3.若key值不存在，则创建HashEntry对象并设置链表头（有可能在获取锁时创建）</p>
<p>4.判断其扩容条件，若需要扩容，则进行链表重排</p>
<p>5.若不需要扩容，则添加HashEntry对象到数组中，并替换数组中的链表头</p>
<p>6.更新count值和modCount值</p>
</blockquote>
<hr>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>接着来看看其扩容的方法，当满足<code>count + 1 &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>条件时，将调用<code>rehash</code>扩容方法：</p>
<p>segement数组不扩容，HashEntry数组进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：这里传的参数是新的HashEntry对象，其next属性指向原链表的头部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//向左偏移1位，扩容一倍大小</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">//初始化新的HashEntry数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">//HashEntry[].length - 1 用于计算Hash值</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历旧的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//计算出新的HashEntry数组下标</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="comment">//当链表中只有一个元素时，直接将该元素赋值到数组中</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">//该循环的目的是从链表尾部截取出一条与链表末尾节点的新数组下标相同，并且相连的链表</span></span><br><span class="line">                <span class="comment">//并存储该截取链表的头对象到lastRun对象，存储新数组下标到lastIdx中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//直接移动尾部截取的链表到新的数组下标中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">//重新顺着从原链表头开始遍历，遍历到lastRun，也就是链表截取处时，跳出循环</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">//采用头插法讲一个个元素分别插入到链表头中，并赋值给HashEntry数组</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原链表扩容完成之后，计算新的HashEntry的下标</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">//替换链表头</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    <span class="comment">//赋值到HashEntry数组中</span></span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的扩容逻辑和<code>HashMap</code>不太一样，<code>HashMap</code>存在逻辑判断可能会重新计算<code>key</code>的<code>hash</code>值，而<code>ConcurrentHashMap</code>并没有，所以它的必定满足<strong>新数组下标=原下标+原数组长度</strong>。</p>
<p><strong>它的扩容并非直接遍历整张链表，而是先遍历一次链表，计算每个元素的新数组下标，如果从某个A元素开始，一直到链表遍历完成，他们计算的新数组下标均相同，意味着可以直接截取该链表，从A元素开始一致到末尾，整条迁移到新节点上，如下图：</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jdk7-hashmap/source-11.png" alt="source-11"></p>
<p><strong>当迁截取部分链表赋值到新数组之后，遍历原链表，采用头插法插入链表，并赋值到新数组中，一直遍历到截取的A元素位置时挑出循环。最后才将新增的元素对象插入到扩容的数组中。</strong></p>
<hr>
<p>最后看看<code>Segment</code>类中的<code>put</code>方法中调用的<code>setEntryAt</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the ith element of given table, with volatile write</span></span><br><span class="line"><span class="comment">     * semantics. (See above about use of putOrderedObject.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setEntryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>UNSAFE</code>调用CPU指令，意思是将<code>HashEntry</code>对象赋值到<code>HashEntry</code>数组的<code>index</code>下标中。</p>
<hr>
<h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><p>接着看看<code>ConcurrentHashMap</code>的<code>size</code>方法，它的设计思想可以在编码中借鉴：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//当重试次数超过2次时，开启加锁计算</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//累加各个segment的修改次数</span></span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="comment">//累加各个segment的元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次循环：当ConcurrentHashMap的modCount=0时，代表没元素，跳出循环</span></span><br><span class="line">                <span class="comment">//第二次循环：和上一次循环计算的元素总数量数比较，如果相同返回，不同则加锁</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//第一次循环计算的元素总数量赋值给last</span></span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实它的实现逻辑很简单，先在不加锁的情况下，进行计算，第一次计算的结果和第二次计算的结果相同时，就认为这个结果是稳定的，直接返回，当两次计算的结果不相同时，则进行加锁计算。</p>
<hr>
<blockquote>
<p>“本篇文章主要摘自<a href="https://www.bilibili.com/video/BV1x741117jq?p=3" target="_blank" rel="noopener">参考资料</a>”</p>
</blockquote>
]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务、日志</title>
    <url>/2021/04/21/mysql%E4%BA%8B%E5%8A%A1%E3%80%81%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="1、操作事务"><a href="#1、操作事务" class="headerlink" title="1、操作事务"></a>1、操作事务</h3><h4 id="1-1、手动提交"><a href="#1-1、手动提交" class="headerlink" title="1.1、手动提交"></a>1.1、手动提交</h4><p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.jpg" alt=""></p>
<a id="more"></a>

<p><code>set autocommit=0</code>:当前session禁用自动提交事物.</p>
<p><code>begin</code>或<code>start transaction</code>：显式的开启一个事务.</p>
<p><code>commit</code>：提交事务，并使已对数据库进行的所有修改成为永久性的。</p>
<p><code>rollback</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改.</p>
<h4 id="1-2、自动提交"><a href="#1-2、自动提交" class="headerlink" title="1.2、自动提交"></a>1.2、自动提交</h4><p><code>set autocommit=1</code>开启自动提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL的每⼀条DML(增删改)语句都是⼀个单独的事务，每条语句都会⾃动开启⼀个事务，执⾏完毕⾃</span><br><span class="line">动提交事务，MySQL默认开始⾃动提交事务</span><br></pre></td></tr></table></figure>

<h4 id="1-3、回滚点"><a href="#1-3、回滚点" class="headerlink" title="1.3、回滚点"></a>1.3、回滚点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前⾯操作都已经成功，可以在当前成功的位置设置⼀个回滚点。</span><br><span class="line">可以供后续失败操作返回到该位置，⽽不是返回所有操作，这个点称之为回滚点。</span><br></pre></td></tr></table></figure>

<p>设置回滚点语法： <code>savepoint 回滚点名字</code></p>
<p>回到回滚点语法：<code>rollback to 回滚点名字</code></p>
<p>总结：设置回滚点可以让我们在失败的时候回到回滚点，⽽不是回到事务开启的时候。</p>
<h3 id="2、隔离级别"><a href="#2、隔离级别" class="headerlink" title="2、隔离级别"></a>2、隔离级别</h3><h4 id="2-1、查看"><a href="#2-1、查看" class="headerlink" title="2.1、查看"></a>2.1、查看</h4><p><code>show variables like &#39;%isolation%&#39;</code></p>
<h4 id="2-2、设置"><a href="#2-2、设置" class="headerlink" title="2.2、设置"></a>2.2、设置</h4><p><code>set global transaction isolation level &#39;级别字符串&#39;</code></p>
<h4 id="2-3、级别对比"><a href="#2-3、级别对比" class="headerlink" title="2.3、级别对比"></a>2.3、级别对比</h4><table>
<thead>
<tr>
<th>名字</th>
<th>隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th>实现</th>
<th>默认级别</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>READ UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td>每次都读取最新的数据</td>
<td></td>
</tr>
<tr>
<td>读已提交</td>
<td>READ COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td>每次读取之前创建read view，<br/>通过mvcc控制</td>
<td>Oracle、Sql Server</td>
</tr>
<tr>
<td>可重复读</td>
<td>REPEATABLE READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td>每次读取之前创建read view，<br/>通过mvcc控制</td>
<td>Mysql</td>
</tr>
<tr>
<td>串行化</td>
<td>SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td>加锁</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-4、不同级别出现的问题"><a href="#2-4、不同级别出现的问题" class="headerlink" title="2.4、不同级别出现的问题"></a>2.4、不同级别出现的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>一个事务读到了另一个事务未提交的事务</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E8%84%8F%E8%AF%BB%E6%BC%94%E7%A4%BA.jpg" alt=""></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>一个事务多次读取数据结果不一致</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%AF%BB%E6%BC%94%E7%A4%BA.jpg" alt=""></p>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E5%B9%BB%E8%AF%BB.jpg" alt=""></p>
<p>图中第四步的update是当前读，更新了数据的同时也更新了隐藏字段的<code>DB_TRX_ID</code>，之后在进行select快照读时，此数据对于当前事务课件，所以会将该数据读出。</p>
<p><strong>如果事务中都是用快照读，那么不会产生幻读的问题，但是快照读和当前读一起使用的时候就会产生幻读</strong>。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>T1</td>
<td>select * from user where age =20 for update;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into user values(25,’25’,20);此时会阻塞等待锁</td>
</tr>
<tr>
<td>T3</td>
<td>select * from user where age =20 for update;</td>
<td></td>
</tr>
</tbody></table>
<p>此时，可以看到事务2被阻塞了，需要等待事务1提交事务之后才能完成，其实本质上来说采用的是间隙锁的机制解决幻读问题。</p>
<h4 id="2-5、如何实现？"><a href="#2-5、如何实现？" class="headerlink" title="2.5、如何实现？"></a>2.5、如何实现？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读未提交，每次都读取最新的数据</span><br><span class="line">读已提交，每次读取之前创建read view，通过mvcc控制</span><br><span class="line">可重复读，第一次读取才创建read view，通过mvcc控制</span><br><span class="line">序列化，加锁</span><br></pre></td></tr></table></figure>

<p>​    <strong>总的来说，数据库的隔离级别依靠<code>MVCC</code>和<code>锁</code>实现；而<code>MVCC</code>依靠<code>隐藏字段</code>、<code>read view</code>、<code>undo log</code>实现。</strong></p>
<h3 id="3、事务四大特点"><a href="#3、事务四大特点" class="headerlink" title="3、事务四大特点"></a>3、事务四大特点</h3><table>
<thead>
<tr>
<th>事务特性</th>
<th>含义</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>A-原子性</td>
<td>事务中的多条SQL语句是⼀个整体，不可再分割，<br/>一起成功，一起失败。</td>
<td>通过undo log来保证</td>
</tr>
<tr>
<td>C-一致性</td>
<td>事务前后的数据要保证⼀致</td>
<td>通过原子性、隔离性、持久性来保证</td>
</tr>
<tr>
<td>I-隔离性</td>
<td>⼀个事务执⾏的结果不能影响另⼀个事务。</td>
<td>通过mvcc、间隙锁来保证</td>
</tr>
<tr>
<td>D-持久性</td>
<td>事务⼀旦提交，对数据库的数据影响是永久了。</td>
<td>通过redo log来保证</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、log"><a href="#二、log" class="headerlink" title="二、log"></a>二、log</h2><h3 id="1、bin-log（二进制日志、归档日志）"><a href="#1、bin-log（二进制日志、归档日志）" class="headerlink" title="1、bin log（二进制日志、归档日志）"></a>1、bin log（二进制日志、归档日志）</h3><p>server层面的日志，属于逻辑日志，以二进制形式记录相关语句的原始逻辑，没有crash-safe能力</p>
<h3 id="2、redo-log（重做日志）"><a href="#2、redo-log（重做日志）" class="headerlink" title="2、redo log（重做日志）"></a>2、redo log（重做日志）</h3><ul>
<li>是innodb存储引擎的日志，当发生数据修改时，先写到redolog中并更新内存；</li>
<li>该文件的大小是固定的，所以当记录满后从头循环继续写；</li>
<li>有了redolog日志，可以保证异常重启时数据不丢失,具有crash-safe能力</li>
</ul>
<img src="http://yrlzero.gitee.io/images/linux/mysql/write_pos、check_point.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkpoint，在检查点之前的日志已经被记录到磁盘并擦除；</span><br><span class="line">write post表示当前写的位置；</span><br><span class="line">当两者相遇表示redo log日志已经写满，此时数据库停止进行相关的语句更新，转而进行redo log日志同步到磁盘的操作</span><br></pre></td></tr></table></figure>

<p>redo log刷盘</p>
<p>MariaDB/MySQL是工作在用户空间的，它们的log buffer要写入磁盘需要经过操作系统内核空间的os buffer，再调用fsync()将OS buffer中的日志刷到磁盘上的log file中</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/redo-logbuffer.jpg" alt=""></p>
<p>如右图所示，redo log的刷盘存在三种方式，可以通过<code>innodb_flush_log_at_trx_commit</code>参数进行调整，主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2</p>
<ul>
<li>值0：在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync()刷新IO缓存。</li>
<li>值1：在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，并调用操作系统fsync()刷新IO缓存。</li>
<li>值2：在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，但并不马上调用fsync()来刷新IO缓存，而是每秒只做一次磁盘IO缓存刷新操作。</li>
</ul>
<p>执行<code>SHOW VARIABLES LIKE &#39;innodb_flush_log_at_trx_commit&#39;</code>命令可知，mysql默认值为1</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/innodb_flush.jpg" alt=""></p>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认设置为1，这是为了保证数据的持久性。当然，我们可以将这个配置项设置为1以外的值来换取更高的性能，但是在系统崩溃的时候，将会丢失1秒的数据。</span><br><span class="line"></span><br><span class="line">设置为0的话，Mysql进程崩溃的时候，就会丢失最后1秒的事务。</span><br><span class="line"></span><br><span class="line">设置为2的话，只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</span><br></pre></td></tr></table></figure>

<h3 id="3、relo-log两阶段提交"><a href="#3、relo-log两阶段提交" class="headerlink" title="3、relo log两阶段提交"></a>3、relo log两阶段提交</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="http://yrlzero.gitee.io/images/linux/mysql/redo%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>a、执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回<br>b、执行器拿到数据之后会先修改数据，然后调用引擎接口重新写入数据<br>c、引擎将数据更新到内存，同时写数据到redo中，此时处于<code>prepare</code>阶段，并通知执行器执行完成，随时可以操作<br>d、执行器生成这个操作的<code>bin log</code><br>f、执行器调用引擎的事务提交接口，引擎把刚刚写完的redo改成<code>commit</code>状态，更新完成</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>先写redo log后写bin log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设在redo log写完，bin log还没写完的时候，mysql进程异常启动。</span><br><span class="line">由于redo log写完之后，系统即使崩溃，仍然能把数据恢复回来，所以恢复后这一行数据值。</span><br><span class="line">但是由于bin log没写完就crash了，这时候bin log里面没有记录这个语句。</span><br><span class="line">因此，备份日志的时候，存起来的bin log里面就没有这条语句。</span><br><span class="line">之后如果使用这个bin log来恢复时，由于这条语句的丢失，恢复过来的数据会缺少此次的修改，与原数据值不同。</span><br></pre></td></tr></table></figure>

<p>先写bin log后写redo log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在bin log写完之后creash，由于redo log还没完，崩溃恢复以后这个事务无效，所以这样记录的值没有恢复。</span><br><span class="line">但是bin log里面已经记录了此次修改。</span><br><span class="line">在之后用bin log来恢复时就多出了一个事务，恢复的数据多出了这个值，与原库不一致</span><br></pre></td></tr></table></figure>

<h3 id="4、bin-log和redo-log区别"><a href="#4、bin-log和redo-log区别" class="headerlink" title="4、bin log和redo log区别"></a>4、bin log和redo log区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redo log是属于innoDB层面；</span><br><span class="line">binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</span><br><span class="line"></span><br><span class="line">redo log是物理日志，记录该数据页更新的内容；</span><br><span class="line">binlog是逻辑日志，记录的是这个更新语句的原始逻辑</span><br><span class="line"></span><br><span class="line">redo log是循环写，日志空间大小固定；</span><br><span class="line">binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</span><br><span class="line"></span><br><span class="line">binlog在事务提交后才会写入，可以作为恢复数据使用，主从复制搭建，在事务进行中数据修改前写入，然后才对缓存中的数据进行修改;</span><br><span class="line">redo log作为异常宕机或者介质故障后的数据恢复使用。</span><br></pre></td></tr></table></figure>

<h3 id="5、undo-log（回滚日志）"><a href="#5、undo-log（回滚日志）" class="headerlink" title="5、undo log（回滚日志）"></a>5、undo log（回滚日志）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份数据，实现事务的回滚操作保证原子性，当出现错误或者执行rollback语句，系统利用undo log中的备份数据恢复到事务开始之前的状态</span><br><span class="line">提供innodb中实现MVCC功能</span><br><span class="line">undo log采用回滚段方式记录，5.5之后每个回滚段中有1024个undo log segment</span><br><span class="line">当删除时不会从undo log直接删除，只会记录delete_flag，之后再由purge线程判断是否删除</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。</span><br><span class="line">MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</span><br><span class="line"></span><br><span class="line">MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</span><br></pre></td></tr></table></figure>

<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像select lock in share mode(共享锁), select...for update; update, insert ,delete(排他锁)这些操作都是一种当前读;</span><br><span class="line"></span><br><span class="line">为什么叫当前读？</span><br><span class="line">就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</span><br></pre></td></tr></table></figure>

<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">像不加锁的select操作就是快照读，即不加锁的非阻塞读；</span><br><span class="line">快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；</span><br><span class="line">之所以出现快照读的情况，是基于提高并发性能的考虑;</span><br><span class="line">快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；</span><br><span class="line">既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</span><br></pre></td></tr></table></figure>

<h3 id="当前读、快照读、MVCC关系"><a href="#当前读、快照读、MVCC关系" class="headerlink" title="当前读、快照读、MVCC关系"></a>当前读、快照读、MVCC关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现MVCC的一个非阻塞读功能。</span><br><span class="line">MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。</span><br></pre></td></tr></table></figure>

<h3 id="3个隐式字段"><a href="#3个隐式字段" class="headerlink" title="3个隐式字段"></a>3个隐式字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_TRX_ID：6byte,最近修改事务ID，记录最后一次操作（首次创建、最后一个更新）这条记录的事务id</span><br><span class="line">DB_ROLL_PTR：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment）</span><br><span class="line">DB_ROW_ID：6byte，隐藏主键，当表没有主键或者唯一键时，会自动创建该隐藏的自增id</span><br></pre></td></tr></table></figure>

<h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>Read View是事务进行快照读操作的时候生产的读视图，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。</p>
</li>
<li><p>其实Read View的最大作用是用来做可见性判断的，也就是说当某个事务在执行快照读的时候，对该记录创建一个Read View的视图，把它当作条件去判断当前事务能够看到哪个版本的数据，有可能读取到的是最新的数据，也有可能读取的是当前行记录的undolog中某个版本的数据</p>
</li>
<li><p>Read View遵循的可见性算法主要是将要被修改的数据的最新记录中的DB_TRX_ID（当前事务id）取出来，与系统当前其他活跃事务的id去对比，如果DB_TRX_ID跟Read View的属性做了比较，不符合可见性，那么就通过DB_ROLL_PTR回滚指针去取出undolog中的DB_TRX_ID做比较，即遍历链表中的DB_TRX_ID，直到找到满足条件的DB_TRX_ID，这个DB_TRX_ID所在的旧记录就是当前事务能看到的最新老版本数据。</p>
</li>
</ul>
<h4 id="read-view生成时机"><a href="#read-view生成时机" class="headerlink" title="read view生成时机"></a>read view生成时机</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RC-读已提交：每次读取数据前，都生成read view</span><br><span class="line">RR-可重复读：在第一次读取数据前，生成read view</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在RR（可重复读）级别下的某个事务的对某条记录的第一次快照读会创建一个快照即Read View，将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View；只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见</p>
</li>
<li><p>在RR（可重复读）级别下，快照读生成Read View时，Read View会记录此时所有其他活动和事务的快照，这些事务的修改对于当前事务都是不可见的，而早于Read View创建的事务所做的修改均是可见</p>
</li>
<li><p>在RC（可重复读）级别下，事务中，每次快照读都会新生成一个快照和Read View,这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p>
</li>
</ul>
<p>​        <strong>总结：在RC（可重复读）隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR（可重复读）隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View.</strong></p>
<h4 id="Read-View的全局属性"><a href="#Read-View的全局属性" class="headerlink" title="Read View的全局属性"></a>Read View的全局属性</h4><p>​        <code>trx_list</code>：一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</p>
<p>​        <code>up_limit_id</code>：记录trx_list列表中事务ID最小的ID，以下用min_trx_id 来表示方便理解</p>
<p>​        <code>low_limit_id</code>：Read View生成时刻系统尚未分配的下一个事务ID，以下用max_trx_id来表示方便理解</p>
<p>​        <code>create_trx_id</code>：当前事务id</p>
<h4 id="数据可见性判断"><a href="#数据可见性判断" class="headerlink" title="数据可见性判断"></a>数据可见性判断</h4><p>​    情况一：<code>DB_TRX_ID</code>与<code>create_trx_id</code>相等</p>
<ul>
<li>表明该数据是当前事务修改的记录</li>
</ul>
<p>​    当出现数据事务id不等于当前事务id时，根据undo log中的数据版本链往上追溯进行判断</p>
<p>​    情况二：<code>DB_TRX_ID</code> &lt;<code>min_trx_id</code></p>
<ul>
<li>当前<code>DB_TRX_ID</code>(记录的事务id)小于<code>min_trx_id</code>(最小活跃事务id)，这表明这条记录在其他活跃事务事前已经提交，所以数据对于当前事务可见</li>
</ul>
<p>情况三：<code>DB_TRX_ID</code> &gt;= <code>max_trx_id</code></p>
<ul>
<li>当前DB_TRX_ID (记录的事务id)大于<code>max_trx_id</code>(未分配事务id)，这表明在当前事务开启之后又有新的事务开启，并且修改提交了该数据，所以数据对于当前事务不可见</li>
</ul>
<p>情况四：<code>min_trx_id</code> &lt;= <code>DB_TRX_ID</code> &lt; <code>max_trx_id</code>，数据在两者之间需要分情况分析</p>
<ul>
<li><p>在区间内，<code>DB_TRX_ID</code> 也在<code>trx_list</code>中，那么当前事务不能读取。这表明该行数据是与当前事务一起开启的事务提交后生成的数据，所以数据对当前事务不可见</p>
</li>
<li><p>在区间内，但是<code>DB_TRX_ID</code> 不在<code>trx_list</code>中，在区间内表明之前存在多个开启事务，不在<code>DB_TRX_ID</code> 表明在之前的多个热点事务中，id处于中间的某个事务提交，所以当前的事务读取的行数据为之前提交的事务数据，所以数据对于当前事务可见</p>
</li>
<li><p>总得来说就是判断<code>DB_TRX_ID</code> 是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，未修改的数据，当前事务也是看不到；如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</p>
</li>
</ul>
<h4 id="purge与read-view"><a href="#purge与read-view" class="headerlink" title="purge与read view"></a>purge与read view</h4><p>​    为了节省磁盘空间，innodb有专门的<code>purge</code>线程来清理delete_bit为true的记录。为了不影响mvcc的正常工作，<code>purge</code>线程自己维护一个read view；如果某个记录的delete_bit为true，同时它的DB_TRX_ID（事务id）存在于<code>purge</code>线程的read view中，那么该记录可以被安全删除</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020/12/06/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、下载地址："><a href="#一、下载地址：" class="headerlink" title="一、下载地址："></a>一、下载地址：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/1.png" alt=""></p>
<a id="more"></a>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/2.png" alt=""></p>
<h2 id="二、-删除旧有版本"><a href="#二、-删除旧有版本" class="headerlink" title="二、 删除旧有版本"></a>二、 删除旧有版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看MySql与mariadb安装情况</span><br><span class="line"># grep -i是不分大小写字符查询，只要含有mysql就显示</span><br><span class="line">rpm -qa | grep -i mysql </span><br><span class="line">rpm -qa | grep mariadb</span><br><span class="line"></span><br><span class="line"># 卸载mariadb(会与mysql冲突)</span><br><span class="line">rpm -e --nodeps xxxxx</span><br></pre></td></tr></table></figure>

<h2 id="三、-rpm安装新MySQL"><a href="#三、-rpm安装新MySQL" class="headerlink" title="三、 rpm安装新MySQL"></a>三、 rpm安装新MySQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建新文件夹</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line"></span><br><span class="line"># 上传文件</span><br><span class="line"></span><br><span class="line"># 对”mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar”解包，不是压缩文件不需要解压缩</span><br><span class="line">tar -xvf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E8%A7%A3%E5%8E%8Bmysqltar%E5%8C%85.jpg" alt=""></p>
<p>执行如下安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、安装 mysql-community-common</span><br><span class="line">rpm -ivh mysql-community-common-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 2、安装 mysql-community-libs</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 3、安装 mysql-community-client </span><br><span class="line">rpm -ivh mysql-community-client-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 4、安装 mysql-community-server</span><br><span class="line">yum -y install perl</span><br><span class="line">rpm -ivh mysql-community-server-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 5、安装 mysql-community-devel</span><br><span class="line">rpm -ivh mysql-community-devel-5.7.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>安装完成。MySql默认安装文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;    #数据库目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;mysql   #配置文件目录</span><br><span class="line">&#x2F;usr&#x2F;bin             #相关命令目录</span><br><span class="line">&#x2F;etc&#x2F;my.cnf         #核心配置文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;mysqld.log #mysql日志存在位置</span><br></pre></td></tr></table></figure>

<h2 id="四、配置MySQL"><a href="#四、配置MySQL" class="headerlink" title="四、配置MySQL"></a>四、配置MySQL</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动mysql </span><br><span class="line">service mysqld start</span><br><span class="line">#重启mysql </span><br><span class="line">service mysqld restart</span><br><span class="line">#停止mysql</span><br><span class="line">service mysqld stop</span><br><span class="line">#查看mysql状态</span><br><span class="line">service mysqld status</span><br><span class="line"></span><br><span class="line"># 设置开机启动Mysql</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"># 设置开机不启动Mysql</span><br><span class="line">systemctl disable mysqld</span><br></pre></td></tr></table></figure>

<p>修改root密码</p>
<p>MySQL安装成功后，会生成一个临时密码，我们第一次登录需要输入这个密码，所以查看该临时密码，然后修改密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看临时密码(&#x2F;var&#x2F;log&#x2F;mysqld.log)</span><br><span class="line">grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line"></span><br><span class="line"># 使用root登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line">#然后输入&#x2F;var&#x2F;log&#x2F;mysqld.log文件中的临时密码</span><br><span class="line"></span><br><span class="line">#登录后；修改密码为Root_123</span><br><span class="line">set password &#x3D; password(&#39;Root_123&#39;);</span><br><span class="line"></span><br><span class="line">注意：密码必须包含大小写字母、数字、特殊符号</span><br></pre></td></tr></table></figure>

<h2 id="五、设置允许远程访问"><a href="#五、设置允许远程访问" class="headerlink" title="五、设置允许远程访问"></a>五、设置允许远程访问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录，密码为新修改的密码Root_123</span><br><span class="line">mysql -uroot –p</span><br><span class="line"></span><br><span class="line">#设置远程访问（使用root密码）：</span><br><span class="line">mysql&gt; grant all privileges on  *.*  to  &#39;root&#39; @&#39;%&#39;  identified by &#39;Root_123&#39; with grant option; </span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>设置3306端口可以被访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 退出mysql</span><br><span class="line"># 防火墙中打开3306端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;3306&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -P 3306 -h 127.0.0.1 -p&#39;password&#39;</span><br></pre></td></tr></table></figure>

<h2 id="七、备份"><a href="#七、备份" class="headerlink" title="七、备份"></a>七、备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份命令mysqldump格式</span><br><span class="line">   格式：mysqldump -h主机名  -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql </span><br><span class="line">还原MySQL数据库的命令</span><br><span class="line">	mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql核心概念</title>
    <url>/2021/04/21/mysql%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、基本架构"><a href="#一、基本架构" class="headerlink" title="一、基本架构"></a>一、基本架构</h2><p><img src="http://yrlzero.gitee.io/images/linux/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<h3 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h3><p>连接器负责跟客户端建立连接，获取权限、维持和管理连接</p>
<ul>
<li><p>用户名、密码校验</p>
</li>
<li><p>查询权限信息，分配对应的权限</p>
</li>
<li><p>可以使用<code>show precesslist</code>查看现在的连接情况</p>
</li>
<li><p>如果太长时间没有动静，就会自动断开，通过<code>wait_timeout</code>控制，默认8小时</p>
</li>
</ul>
<p>连接可以分为两类</p>
<ul>
<li>长连接，推荐使用，但是要周期性的断开长连接</li>
<li>短连接</li>
</ul>
<h3 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h3><p>当执行查询语句的时候，会先去<code>查询缓存</code>中查看结果，之前执行过的sql语句及其结果可能以key-value的形势存储在缓存中，如果能找到则直接返回，找不到，就继续执行后续的阶段</p>
<p>不推荐使用<code>查询缓存</code>：</p>
<ul>
<li><code>查询缓存</code>的失效比较频繁，只要表更新，缓存就会清空</li>
<li>缓存对应新的更新数据命中率比较低</li>
</ul>
<h3 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h3><p>词法分析：mysql需要把输入字符串进行识别每个部分代表什么意思</p>
<ul>
<li>把字符串T识别成表明T</li>
<li>把字符串id识别成列id</li>
</ul>
<p>语法分析：根据语法规则判断这个sql语句是否满足mysql语法，如果不符合就会报错<code>You have an error in your SQL synta</code></p>
<h3 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h3><p>在具体执行sql语句之前，要先经过优化器的处理</p>
<ul>
<li>当表中有多个索引的时候，决定用哪个索引</li>
<li>当sql语句需要做多表关联的时候，决定表的链接，顺序</li>
</ul>
<p>不同的执行方式对sql语句的执行效率影响很大，目前有两种优化策略</p>
<ul>
<li>RBO：基于规则的优化</li>
<li>CBO：基于成本的优化</li>
</ul>
<p><code>show status like &#39;last_query_cost&#39;</code>查询最后一条语句使用的成本，预估的数据页值</p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接器：管理连接，权限校验</span><br><span class="line">分析器：词法分析，语法分析</span><br><span class="line">优化器：执行计划，索引选择</span><br><span class="line">执行器：操作引擎，返回结果</span><br><span class="line">存储引擎：存储数据，提供读写借口哦</span><br></pre></td></tr></table></figure>

<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1、hash"><a href="#1、hash" class="headerlink" title="1、hash"></a>1、hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于哈希表的实现，只有精确匹配索引所有列的查询才有效</span><br><span class="line">在mysql中，只有memory的存储引擎显式支持哈希索引</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash.jpg" alt="HASH"></p>
<h3 id="2、二叉树"><a href="#2、二叉树" class="headerlink" title="2、二叉树"></a>2、二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果数据有序出现单边增长的情况，会单边倾斜出现链表结构</span><br><span class="line">会应为树的深度过深而造成io次数变多，影响数据读取效率</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"></p>
<h3 id="3、红黑树（二叉平衡树）"><a href="#3、红黑树（二叉平衡树）" class="headerlink" title="3、红黑树（二叉平衡树）"></a>3、红黑树（二叉平衡树）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在二叉树的基础上多了树平衡，当出现单边失衡时，会进行转换，形成节点，但是数据量大时，层级会很深</span><br><span class="line">会应为树的深度过深而造成io次数变多，影响数据读取效率</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%91%E7%BA%A2%E6%A0%91.jpg" alt="红黑树"></p>
<h3 id="4、B树"><a href="#4、B树" class="headerlink" title="4、B树"></a>4、B树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对顶级节点进行横向扩展，叶节点具有相同的深度，节点存放数据</span><br><span class="line">特点：</span><br><span class="line">	1、所以键值分布在整棵树中</span><br><span class="line">	2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找</span><br><span class="line">	3、每个节点最多拥有m个子树</span><br><span class="line">	4、根节点至少有2个子树</span><br><span class="line">	5、分支节点至少拥有m&#x2F;2颗子树（除根节点和叶子节点外都是分支节点）</span><br><span class="line">	6、所有叶子数据存储在每个节点上节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</span><br><span class="line">缺点：数据存储在每个节点上，而mysql每次读取16K的数据，每个磁盘区块只有4K，当节点因存储数据而造成数据量变大的情况下，每次可读取的索引值也就变少了</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b%E6%A0%91.jpg" alt="B树"></p>
<h3 id="5、B-树"><a href="#5、B-树" class="headerlink" title="5、B+树"></a>5、B+树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">非叶子结点不存储data，数据只在叶子结点存储，这样mysql每次io读取的记录数能够得到较大提升</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/mysql/数据结构-b+树.jpg" alt="B+树" style="zoom:150%;" />

<h2 id="三、执行引擎"><a href="#三、执行引擎" class="headerlink" title="三、执行引擎"></a>三、执行引擎</h2><p>MyISAM与Innodb对比如下</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>Innodb</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引</td>
<td>即支持聚簇索引又支持非聚簇索引</td>
<td>只支持非聚簇索引</td>
</tr>
<tr>
<td>行锁</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储文件</td>
<td>frm，ibd</td>
<td>frm,myi,myd</td>
</tr>
<tr>
<td>具体行数</td>
<td>每次必须要全表扫描统计行数</td>
<td>通过变量保存行数（查询不能带条件）</td>
</tr>
<tr>
<td>适合操作类型</td>
<td>大量insert、delete、update</td>
<td>大量select</td>
</tr>
</tbody></table>
<p>如何选择？</p>
<p>​        1、是否需要支持事务，如果需要选择innodb，如果不需要选择myisam </p>
<p>​        2、如果表的大部分请求都是读请求，可以考虑myisam，如果既有读也有写，使用innodb</p>
<p>​        现在mysql的默认存储引擎已经变成了Innodb,推荐使用innodb</p>
<h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="1、结构类型"><a href="#1、结构类型" class="headerlink" title="1、结构类型"></a>1、结构类型</h3><h4 id="1-1、聚簇索引"><a href="#1-1、聚簇索引" class="headerlink" title="1.1、聚簇索引"></a>1.1、聚簇索引</h4><p>innodb使用该索引结构，数据文件和索引文件存放在一起</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/innodb-b+%E6%A0%91.jpg" alt=""></p>
<h4 id="1-2、非聚簇索引"><a href="#1-2、非聚簇索引" class="headerlink" title="1.2、非聚簇索引"></a>1.2、非聚簇索引</h4><p>myisam使用该索引结构，数据文件和索引文件分开存放</p>
<p><img src="http://yrlzero.gitee.io/images/linux/mysql/myisamb-b+%E6%A0%91.jpg" alt=""></p>
<h3 id="2、使用类型"><a href="#2、使用类型" class="headerlink" title="2、使用类型"></a>2、使用类型</h3><p>​    主键索引、唯一索引、普通索引、组合索引、全文索引</p>
<h3 id="3、相关概念"><a href="#3、相关概念" class="headerlink" title="3、相关概念"></a>3、相关概念</h3><h4 id="3-1、回表"><a href="#3-1、回表" class="headerlink" title="3.1、回表"></a>3.1、回表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当使用普通索引时，叶子结点查询到主键，根据主键找到主键索引叶子结点的数据</span><br></pre></td></tr></table></figure>

<h4 id="3-2、索引覆盖"><a href="#3-2、索引覆盖" class="headerlink" title="3.2、索引覆盖"></a>3.2、索引覆盖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般在组合索引的使用情况下出现的几率比较大，查询的列与索引的列相对应，可以在索引叶子结点找到匹配的数据，不需要再次回表查询</span><br></pre></td></tr></table></figure>

<h4 id="3-3、索引下推"><a href="#3-3、索引下推" class="headerlink" title="3.3、索引下推"></a>3.3、索引下推</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">高级别版本，如果多个条件进行查询，会一起带到执行引擎进行判断过滤，不需要匹配一个索引之后再回到server层进行判断，减少io交互</span><br></pre></td></tr></table></figure>

<h4 id="3-4、最左匹配"><a href="#3-4、最左匹配" class="headerlink" title="3.4、最左匹配"></a>3.4、最左匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组合索引在使用时，需要注意必须包含该组合最左边的列，否则无法使用该索引</span><br></pre></td></tr></table></figure>

<h3 id="4、常见优化"><a href="#4、常见优化" class="headerlink" title="4、常见优化"></a>4、常见优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、全值匹配</span><br><span class="line">2、最左匹配</span><br><span class="line">3、不在索引条件上做函数操作</span><br><span class="line">4、范围查找条件右边的列不会使用到索引</span><br><span class="line">5、尽量使用覆盖索引</span><br><span class="line">6、‘不等于’操作会导致全表扫描</span><br><span class="line">7、is null或is not null无法使用索引</span><br><span class="line">8、like 全模糊无法使用索引，应使用右模糊</span><br><span class="line">9、参数类型应与数据库类型匹配</span><br><span class="line">10、or会让索引失效</span><br><span class="line">11、join语句的关联条件尽量使用索引</span><br></pre></td></tr></table></figure>

<h3 id="5、order优化"><a href="#5、order优化" class="headerlink" title="5、order优化"></a>5、order优化</h3><h4 id="5-1、双路排序"><a href="#5-1、双路排序" class="headerlink" title="5.1、双路排序"></a>5.1、双路排序</h4><p>​        读取排序字段，在buffer进行排序，再从磁盘读取其他查询字段</p>
<h4 id="5-2、单路排序"><a href="#5-2、单路排序" class="headerlink" title="5.2、单路排序"></a>5.2、单路排序</h4><p>​        4.1之后，一次性读取排序字段和查询字段，在buffer排序之后直接返回，一次性读取两类数据使用更容易超出buffer总大小</p>
<p><code>查询的字段总大小小于max_length_for_sort_data的限制值（1024B），且排序字段不是TEXT|BLOB时，会使用单路排序</code></p>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存在问题：</span><br><span class="line">	sort_buffer的容量有限，如果读取的数据超过了buffer的默认大小262144B（256KB），造成需要多次读取，创建templ文件再进行合并排序，io次数增加，性能下降；</span><br><span class="line">	</span><br><span class="line">优化：</span><br><span class="line">	可以通过调整sort_buffer_size、sort_buffer_size的大小来进行优化</span><br><span class="line">	不管单路还是双路，提高sort_buffer_size都能提高效率，但需要根据系统能力去调整</span><br><span class="line">	提高max_length_for_sort_data的大小会影响使用何种排序算法</span><br></pre></td></tr></table></figure>

<h3 id="6、group优化"><a href="#6、group优化" class="headerlink" title="6、group优化"></a>6、group优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group by 实际上是先排序后分组</span><br><span class="line">无法使用到索引列时，可以考虑增大max_length_for_sort_data和sort_buffer_size参数</span><br><span class="line">where优先级高于having，条件尽量在where进行限制</span><br></pre></td></tr></table></figure>



<h2 id="五、局部性原理和磁盘预读"><a href="#五、局部性原理和磁盘预读" class="headerlink" title="五、局部性原理和磁盘预读"></a>五、局部性原理和磁盘预读</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘 I&#x2F;O。</span><br><span class="line">	为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</span><br><span class="line"></span><br><span class="line">局部性原理：</span><br><span class="line">	当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</span><br><span class="line">	</span><br><span class="line">磁盘预读：</span><br><span class="line">	由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I&#x2F;O 效率。</span><br><span class="line">	预读的长度一般为页（4K）（page）的整倍数。</span><br></pre></td></tr></table></figure>

<h2 id="六、页分裂"><a href="#六、页分裂" class="headerlink" title="六、页分裂"></a>六、页分裂</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页可能填充至100%，在页填满了之后，下一页会继续接管新的记录。但如果下一页也满了，数据又需要按顺序插入，就会产生页分裂。</span><br><span class="line"></span><br><span class="line">InnoDB的做法是（简化版）：</span><br><span class="line">    创建新页</span><br><span class="line">    判断当前页可以从哪里进行分裂（记录行层面）</span><br><span class="line">    移动记录行</span><br><span class="line">    重新定义页之间的关系</span><br><span class="line">    </span><br><span class="line">等于创建了一个新页，并且把当前页的数据迁移部分到新页中，然后插入在当前页和下一页的中间。</span><br></pre></td></tr></table></figure>

<h2 id="七、页合并"><a href="#七、页合并" class="headerlink" title="七、页合并"></a>七、页合并</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</span><br><span class="line"></span><br><span class="line">当页中删除的记录达到MERGE_THRESHOLD（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</span><br></pre></td></tr></table></figure>

<h2 id="八-、Sql-Join"><a href="#八-、Sql-Join" class="headerlink" title="八 、Sql Join"></a>八 、Sql Join</h2><p>​        MySQL是只支持一种Join算法Nested-Loop Join(嵌套循环连接)，并不支持哈希连接和合并连接，不过在mysql中包含了多种变种，能够帮助MySQL提高join执行的效率。</p>
<h3 id="1、Simple-Nested-Loop-Join"><a href="#1、Simple-Nested-Loop-Join" class="headerlink" title="1、Simple Nested-Loop Join"></a><strong>1、Simple Nested-Loop Join</strong></h3><p>​        这个算法相对来说就是很简单了，从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了。</p>
<h3 id="2、Index-Nested-Loop-Join"><a href="#2、Index-Nested-Loop-Join" class="headerlink" title="2、Index Nested-Loop Join"></a><strong>2、Index Nested-Loop Join</strong></h3><p>​        索引嵌套联系由于非驱动表上有索引，所以比较的时候不再需要一条条记录进行比较，而可以通过索引来减少比较，从而加速查询。这也就是平时我们在做关联查询的时候必须要求关联字段有索引的一个主要原因。</p>
<p>​        这种算法在链接查询的时候，驱动表会根据关联字段的索引进行查找，当在索引上找到了符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表。至于驱动表的选择，MySQL优化器一般情况下是会选择记录数少的作为驱动表，但是当SQL特别复杂的时候不排除会出现错误选择。</p>
<p>​        在索引嵌套链接的方式下，如果非驱动表的关联键是主键的话，这样来说性能就会非常的高，如果不是主键的话，关联起来如果返回的行数很多的话，效率就会特别的低，因为要多次的回表操作。先关联索引，然后根据二级索引的主键ID进行回表的操作。这样来说的话性能相对就会很差。</p>
<h3 id="3、Block-Nested-Loop-Join"><a href="#3、Block-Nested-Loop-Join" class="headerlink" title="3、Block Nested-Loop Join"></a><strong>3、Block Nested-Loop Join</strong></h3><p>​        在有索引的情况下，MySQL会尝试去使用Index Nested-Loop Join算法，在有些情况下，可能Join的列就是没有索引，那么这时MySQL的选择绝对不会是最先介绍的Simple Nested-Loop Join算法，而是会优先使用Block Nested-Loop Join的算法。</p>
<p>​        Block Nested-Loop Join对比Simple Nested-Loop Join多了一个中间处理的过程，也就是join buffer，使用join buffer将驱动表的查询JOIN相关列都给缓冲到了JOIN BUFFER当中，然后批量与非驱动表进行比较，这也来实现的话，可以将多次比较合并到一次，降低了非驱动表的访问频率。也就是只需要访问一次S表。这样来说的话，就不会出现多次访问非驱动表的情况了，也只有这种情况下才会访问join buffer。</p>
<p>​        在MySQL当中，我们可以通过参数join_buffer_size来设置join buffer的值，然后再进行操作。默认情况下join_buffer_size=256K，在查找的时候MySQL会将所有的需要的列缓存到join buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join buffer。</p>
<h2 id="九、锁"><a href="#九、锁" class="headerlink" title="九、锁"></a>九、锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁并不是数据库自带的，如果需要使用乐观锁，那么需要自己去实现，一般情况下，我们会在表中新增一个version字段，每次更新数据version+1,在进行提交之前会判断version是否一致。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>mysql中的绝大部分锁都是悲观锁，按照粒度可以分为行锁和表锁</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul>
<li><p>共享锁：当读取一行记录的时候，为了防止别人修改，则需要添加S锁</p>
</li>
<li><p>排它锁：当修改一行记录的时候，为了防止别人同时进行修改，则需要添加X锁</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<ul>
<li>记录锁：添加在行索引上的锁</li>
<li>间隙锁：锁定范围是索引记录之间的间隙，针对可重复读以上隔离级别</li>
<li>临键锁：记录锁+间隙锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li><p>意向锁：在获取某行的锁之前，必须要获取表的锁，分为意向共享锁，意向排它锁</p>
</li>
<li><p>自增锁：对自增字段所采用的特殊表级锁</p>
</li>
</ul>
<h4 id="锁模式的含义"><a href="#锁模式的含义" class="headerlink" title="锁模式的含义"></a>锁模式的含义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IX：意向排它锁</span><br><span class="line"></span><br><span class="line">X：锁定记录本身和记录之前的间隙</span><br><span class="line"></span><br><span class="line">S：锁定记录本身和记录之前的间隙</span><br><span class="line"></span><br><span class="line">X,REC_NOT_GAP：只锁定记录本身</span><br><span class="line"></span><br><span class="line">S，REC_NOT_GAP：只锁定记录本身</span><br><span class="line"></span><br><span class="line">X，GAP：间隙锁，不锁定记录本身</span><br><span class="line"></span><br><span class="line">S，GAP：间隙锁，不锁定记录本身</span><br><span class="line"></span><br><span class="line">X，GAP,INSERT_INTENTION：插入意向锁</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq系列-amqp</title>
    <url>/2020/06/03/rabbitmq%E7%B3%BB%E5%88%97-amqp/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>​         AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。</p>
<a id="more"></a>

<h2 id="二、spring-boot的应用"><a href="#二、spring-boot的应用" class="headerlink" title="二、spring boot的应用"></a><strong>二、spring boot的应用</strong></h2><h4 id="1-消息生产者"><a href="#1-消息生产者" class="headerlink" title="1.消息生产者"></a><strong>1.消息生产者</strong></h4><h5 id="1）导入maven依赖："><a href="#1）导入maven依赖：" class="headerlink" title="1）导入maven依赖："></a><strong>1）导入maven依赖：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2）配置application-yml"><a href="#2）配置application-yml" class="headerlink" title="2）配置application.yml"></a><strong>2）配置application.yml</strong></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">yrl_test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test123</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br></pre></td></tr></table></figure>

<h5 id="3）controller发送消息"><a href="#3）controller发送消息" class="headerlink" title="3）controller发送消息"></a><strong>3）controller发送消息</strong></h5><p>​    实际使用，应抽取rabbitTemplate注入序列化器，不应该每个方法设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange、routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgUser</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(param.get(<span class="string">"msg"</span>));</span><br><span class="line">        user.setBirthday(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不指定exchange，根据routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDefault"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDefault</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"key"</span>),msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange,不指定routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendHeader"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeader</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),<span class="string">""</span>,msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"key-one"</span>, <span class="string">"1"</span>);</span><br><span class="line">            properties.setHeader(<span class="string">"key-two"</span>, <span class="string">"2"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延迟消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDelay"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelay</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"x-delay"</span>, <span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-消息消费者"><a href="#2-消息消费者" class="headerlink" title="2. 消息消费者"></a><strong>2. 消息消费者</strong></h4><h5 id="1-配置"><a href="#1-配置" class="headerlink" title="1) 配置"></a><strong>1) 配置</strong></h5><h6 id="a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"><a href="#a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"></a>a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> *   durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line"><span class="comment"> *   exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line"><span class="comment"> *   autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line"><span class="comment"> *   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">testDirectQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"testDirectQueue"</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建直连交换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">testDirectExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"testDirectExchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将exchange和queue进行绑定，并设置匹配的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(testDirectQueue()).to(testDirectExchange()).with(<span class="string">"testDirectRouting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建监听器容器工厂，设置连接工厂、序列化方式（解决实体序列化问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">	factory.setConnectionFactory(connectionFactory);</span><br><span class="line">	factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">	<span class="comment">//开启手动Ack（后续使用配置消息确认使用）</span></span><br><span class="line">	<span class="comment">//factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span></span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	args.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">"delayExchangeCus"</span>, <span class="string">"x-delayed-message"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">"delayCusQueue"</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">queueBinding</span><span class="params">(Queue delayQueue, CustomExchange delayExchange)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(<span class="string">"cusDelayKey"</span>).noargs();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"><a href="#b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"></a>b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,routingKey为queue的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(<span class="string">"myDefaultQueue"</span>))</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultDirectReceiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"默认交换器，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.2"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue3"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.3"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct3Receiver</span><span class="params">(User param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器3，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.*"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器1</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器2</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，任意匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"any"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-three"</span>,value = <span class="string">"3"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，任意匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，全匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"all"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-two"</span>,value = <span class="string">"2"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，全匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"delayCusQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">		bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">				exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">				value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">				key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">		)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-开启手动应答模式"><a href="#2-开启手动应答模式" class="headerlink" title="2) 开启手动应答模式"></a><strong>2) 开启手动应答模式</strong></h5><h6 id="a-添加application-yml配置"><a href="#a-添加application-yml配置" class="headerlink" title="a. 添加application.yml配置"></a>a. 添加application.yml配置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="b-连接工厂设置参数"><a href="#b-连接工厂设置参数" class="headerlink" title="b. 连接工厂设置参数"></a>b. 连接工厂设置参数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启手动Ack</span></span><br><span class="line"><span class="keyword">new</span> SimpleRabbitListenerContainerFactory().setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br></pre></td></tr></table></figure>

<h6 id="c-监听器"><a href="#c-监听器" class="headerlink" title="c. 监听器"></a>c. 监听器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">           bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                   exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">                   value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">                   key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">           )</span><br><span class="line">   )</span><br><span class="line">   <span class="meta">@RabbitHandler</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">       Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">       System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String message = (String) param.get(<span class="string">"message"</span>);</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">"延迟消息1"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息1拒绝"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"延迟消息2"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">true</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息2拒绝,重新放入队列"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               channel.basicAck(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"正常提交"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>nginx安装</title>
    <url>/2020/11/29/nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><img src="http://yrlzero.gitee.io/images/linux/nginx/nginx版本介绍.jpg" style="zoom: 67%;" />

<a id="more"></a>

<h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><h3 id="1-下载安装包方式"><a href="#1-下载安装包方式" class="headerlink" title="1. 下载安装包方式"></a>1. 下载安装包方式</h3><ul>
<li><p>官网直接下载<code>http://nginx.org/en/download.html</code></p>
</li>
<li><p>使用<code>wget</code>命令下载（推荐）。确保系统已经安装了<code>wget</code>，如果没有安装，执行 <code>yum install wget</code> 安装<code>wget -c https://nginx.org/download/nginx-1.18.0.tar.gz</code></p>
</li>
</ul>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-yum安装依赖项"><a href="#3-yum安装依赖项" class="headerlink" title="3. yum安装依赖项"></a>3. yum安装依赖项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gcc安装，nginx源码编译需要；pcre-devel 安装，nginx 的 http 模块使用 pcre 来解析正则表达式；zlib安装，nginx 使用zlib对http包的内容进行gzip</span><br><span class="line"></span><br><span class="line">yum install gcc pcre-devel zlib-devel</span><br></pre></td></tr></table></figure>

<h3 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx-1.18.0</span><br><span class="line"></span><br><span class="line">#使用默认配置</span><br><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>

<h3 id="5-编译安装"><a href="#5-编译安装" class="headerlink" title="5. 编译安装"></a>5. 编译安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="6-启动、停止nginx"><a href="#6-启动、停止nginx" class="headerlink" title="6. 启动、停止nginx"></a>6. 启动、停止nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx </span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line">.&#x2F;nginx -s quit</span><br><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="Yum安装"><a href="#Yum安装" class="headerlink" title="Yum安装"></a><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener">Yum安装</a></h2><h3 id="安装yum"><a href="#安装yum" class="headerlink" title="安装yum"></a>安装yum</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install yum-utils</span><br></pre></td></tr></table></figure>

<h3 id="添加yum安装源"><a href="#添加yum安装源" class="headerlink" title="添加yum安装源"></a>添加yum安装源</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加以下内容</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nacos集群安装</title>
    <url>/2020/12/06/nacos%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载稳定版本1-3-1（July-10-2020）"><a href="#1-下载稳定版本1-3-1（July-10-2020）" class="headerlink" title="1. 下载稳定版本1.3.1（July 10, 2020）"></a>1. 下载稳定版本<a href="https://github.com/alibaba/nacos/releases/tag/1.3.1" target="_blank" rel="noopener">1.3.1（July 10, 2020）</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他版本参考：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos&#x2F;releases</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-官方文档："><a href="#2-官方文档：" class="headerlink" title="2. 官方文档："></a>2. 官方文档：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;quick-start.html</span><br></pre></td></tr></table></figure>

<h2 id="3-sql脚本导入"><a href="#3-sql脚本导入" class="headerlink" title="3. sql脚本导入"></a>3. sql脚本导入</h2><p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6.jpg" alt=""> <img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E6%89%A7%E8%A1%8Cnaocs%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.jpg" alt=""></p>
<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建安装目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nacos</span><br><span class="line"># 上传压缩包</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf nacos-server-1.3.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="5-修改集群配置"><a href="#5-修改集群配置" class="headerlink" title="5. 修改集群配置"></a>5. 修改集群配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf</span><br><span class="line"># 拷贝集群配置</span><br><span class="line">cp cluster.conf.example  cluster.conf</span><br><span class="line"># 修改配置文件</span><br><span class="line">vi cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.jpg" alt=""> </p>
<h2 id="6-远程拷贝集群配置文件"><a href="#6-远程拷贝集群配置文件" class="headerlink" title="6. 远程拷贝集群配置文件"></a>6. 远程拷贝集群配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从第一台机器拷贝配置文件都其他机器</span><br><span class="line">scp root@192.168.243.131:&#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;cluster.conf &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D.jpg" alt=""></p>
<h2 id="7-修改启动配置"><a href="#7-修改启动配置" class="headerlink" title="7. 修改启动配置"></a>7. 修改启动配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取JAVA_HOME</span><br><span class="line">echo $JAVA_HOME</span><br><span class="line"></span><br><span class="line"># 修改jdk，新增jdk配置，原有的注释</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="8-修改naocs自身配置"><a href="#8-修改naocs自身配置" class="headerlink" title="8. 修改naocs自身配置"></a>8. 修改naocs自身配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;application.properties</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="9-异常情况"><a href="#9-异常情况" class="headerlink" title="9. 异常情况"></a>9. 异常情况</h2><p>如果出现JAVA服务无法连接nacos集群的情况，可以修改nacos.inetutils.ip-address为本机ip(一般情况下不加)</p>
<h2 id="10-开放防火墙"><a href="#10-开放防火墙" class="headerlink" title="10. 开放防火墙"></a>10. 开放防火墙</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开8848端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8848&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>alibaba</tag>
        <tag>配置中心</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq系列-基础篇</title>
    <url>/2020/06/02/rabbitmq%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现</p>
<a id="more"></a>

<h4 id="exchange"><a href="#exchange" class="headerlink" title="exchange:"></a>exchange:</h4><p>​        生产者将消息发送到 Exchange（交换器），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。Exchange 并不存储消息。RabbitMQ 中的 Exchange 有 direct、fanout、topic、headers 四种类型，每种类型对应不同的路由规则。</p>
<h4 id="queue："><a href="#queue：" class="headerlink" title="queue："></a>queue：</h4><p>​        队列是 RabbitMQ 的内部对象，用于存储消息。消息消费者就是通过订阅队列<br>来获取消息的，RabbitMQ 中的消息都只能存储在 Queue 中，生产者生产消息并最终投递到Queue 中，消费者可以从 Queue 中获取消息并消费。多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<h4 id="connection："><a href="#connection：" class="headerlink" title="connection："></a>connection：</h4><p>connection就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。程序的起始处就是建立这个TCP连接。</p>
<h4 id="channels："><a href="#channels：" class="headerlink" title="channels："></a>channels：</h4><p>​        虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p>
<p>那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。</p>
<h4 id="VirtualHost："><a href="#VirtualHost：" class="headerlink" title="VirtualHost："></a>VirtualHost：</h4><p>​        权限控制的基本单位，一个 VirtualHost 里面有若干 Exchange 和MessageQueue，以及指定被哪些 user 使用</p>
<h4 id="routing-key："><a href="#routing-key：" class="headerlink" title="routing key："></a>routing key：</h4><p>​        生产者在将消息发送给exchange的时候，一般会指定一个routing key，来匹配这个消息的路由规则。其实是匹配exchnage与queue绑定的bbinding key</p>
<h4 id="binding-key-："><a href="#binding-key-：" class="headerlink" title="binding key ："></a>binding key ：</h4><p>​        用于绑定exchange与queue之间的关系</p>
<h2 id="二、windows安装"><a href="#二、windows安装" class="headerlink" title="二、windows安装"></a><strong>二、windows安装</strong></h2><p>1）下载安装erlang</p>
<p>2）下载安装rabbitmq</p>
<p>3）安装管理界面（插件）</p>
<p>进入rabbitmq安装目录sbin中，调起cmd界面输入：rabbitmq-plugins enable rabbitmq_management</p>
<p>4）重启rabbitmq服务</p>
<p>5）访问地址127.0.0.1:15672，默认账号密码都为guest</p>
<h2 id="三、docker启动"><a href="#三、docker启动" class="headerlink" title="三、docker启动"></a>三、docker启动</h2><p>1)     搜索镜像：docker search rabbitmq</p>
<p>2)    下载镜像：docker pull rabbitmq:management</p>
<p>3)    创建容器，rabbitmq 需要有映射以下端口: 5671 5672 4369 15671 15672<br>25672</p>
<ul>
<li>15672  management管理端监听端口</li>
<li>5672、5671 AMQP使用端口</li>
<li>4369 epmd代表erlang守护进程的端口</li>
<li>25672 (Erlang distribution)</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -di --name=my_rabbitmq -p 5671:5617 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span></span><br></pre></td></tr></table></figure>

<h2 id="四、exchange-type"><a href="#四、exchange-type" class="headerlink" title="四、exchange type"></a><strong>四、exchange type</strong></h2><h4 id="1）直连模式-direct："><a href="#1）直连模式-direct：" class="headerlink" title="1）直连模式-direct："></a>1）直连模式-direct：</h4><p>​        direct类型的exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的queue中 。</p>
<p>​        默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,binding key为queue的名称。</p>
<img src="http://yrlzero.gitee.io/images/直连模式.jpg" style="zoom:67%;" />

<h4 id="2）主题模式-topic"><a href="#2）主题模式-topic" class="headerlink" title="2）主题模式-topic"></a>2）主题模式-topic</h4><p> topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同， 可以根据某些规则进行匹配，如果 exchange 没有发现能够与 routing Key 匹配的 queue，则会抛弃此消息</p>
<img src="http://yrlzero.gitee.io/images/主题模式.jpg" style="zoom:67%;" />

<p>符号 # 匹配一个或多个词，符号 * 匹配一个词</p>
<h4 id="3）分裂模式-fanout"><a href="#3）分裂模式-fanout" class="headerlink" title="3）分裂模式-fanout"></a><strong>3）分裂模式-fanout</strong></h4><p> fanout类型的exchange路由规则非常简单，它会把所有发送到该exchange的消息路由到所有与它绑定的queue中 </p>
<img src="http://yrlzero.gitee.io/images/分裂模式.jpg" style="zoom:67%;" />



<h4 id="4）头部模式-headers"><a href="#4）头部模式-headers" class="headerlink" title="4）头部模式-headers"></a><strong>4）头部模式-headers</strong></h4><p>​         headers类型的exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定queue与exchange时指定一组键值对；当消息发送到exchange时，rabbitMq会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配queue与exchange绑定时指定的键值对；如果完全匹配则消息会路由到该queue，否则不会路由到该queue </p>
<h4 id="5）延迟消息（特殊模式需要安装插件）"><a href="#5）延迟消息（特殊模式需要安装插件）" class="headerlink" title="5）延迟消息（特殊模式需要安装插件）"></a><strong>5）延迟消息（特殊模式需要安装插件）</strong></h4><p>​         需要在这个页面：<a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">http://www.rabbitmq.com/community-plugins.html</a> 中找到<code>rabbitmq_delayed_message_exchange</code>插件，根据您使用的RabbitMQ版本选择对应的插件版本下载即可 。 在下载好之后，解压得到<code>.ez</code>结尾的插件包，将其复制到RabbitMQ安装目录下的<code>plugins</code>文件夹 。</p>
<pre><code>然后通过命令行启用该插件： </code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>redis-安装</title>
    <url>/2020/12/12/redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="一、下载地址"><a href="#一、下载地址" class="headerlink" title="一、下载地址"></a>一、<a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></h4><p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%8B%E8%BD%BD.jpg" alt=""></p>
<a id="more"></a>

<h4 id="二、安装gcc依赖"><a href="#二、安装gcc依赖" class="headerlink" title="二、安装gcc依赖"></a>二、安装gcc依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看gcc版本是否在9.3以上，centos7.6默认安装4.8.5</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E6%9F%A5%E7%9C%8Bgcc%E7%89%88%E6%9C%AC.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis6以上,gcc版本不能低于5,升级gcc到9.3及以上,如下：</span><br><span class="line">升级到gcc 9.3：</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。</span><br><span class="line">如果要长期使用gcc 9.3的话：</span><br><span class="line"></span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">这样退出shell重新打开就是新版的gcc了</span><br><span class="line">以下其他版本同理，修改devtoolset版本号即可。</span><br></pre></td></tr></table></figure>

<h4 id="三、上传安装"><a href="#三、上传安装" class="headerlink" title="三、上传安装"></a>三、上传安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#上传安装包、解压、编译</span><br><span class="line">tar zxf redis-6.0.9.tar.gz </span><br><span class="line">cd redis-6.0.9</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">#安装并指定安装目录</span><br><span class="line">make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>

<h4 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><h6 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>

<h6 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h6><p>1.从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<p>2.修改 redis.conf 文件，把 daemonize no 改为 daemonize yes</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%AE%88%E6%8A%A4%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<p>3.注释掉 # bind 127.0.0.1，并修改 protected-mode yes 改为 protected-mode no</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<p>4.设置密码</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<p>5.启动命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line"># 停止</span><br><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>1.修改redis环境变量方便之后使用redis命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/redis/redis_etc_profile.jpg" style="zoom: 80%;" />

<p>2.执行安装服务脚本</p>
<p>回到压缩包解压目录的 utils文件夹中，执行install_server.sh脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;utils</span><br><span class="line">.&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>

<p>2.1执行失败</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%AE%89%E8%A3%85redis%E6%9C%8D%E5%8A%A1%E5%A4%B1%E8%B4%A5.jpg" alt=""></p>
<p>进入install_server.sh脚本中，注释图中所示代码</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9install_server%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<p>2.2执行成功</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%AE%89%E8%A3%85redis%E6%9C%8D%E5%8A%A1.jpg" alt=""></p>
<p>3.启动成功</p>
<p>之后可以通过service redis_6379 start/stop/status等命令进行操作</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt=""></p>
<h4 id="五、开放防火墙"><a href="#五、开放防火墙" class="headerlink" title="五、开放防火墙"></a>五、开放防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开6379端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;6379&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h4 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.243.131 -p 6379 -a passsword</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-布隆过滤器</title>
    <url>/2021/04/10/redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="bloom机制"><a href="#bloom机制" class="headerlink" title="bloom机制"></a>bloom机制</h2><p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-01.png" alt=""></p>
<a id="more"></a>

<h2 id="下载BLOOM模块zip包"><a href="#下载BLOOM模块zip包" class="headerlink" title="下载BLOOM模块zip包"></a><a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">下载BLOOM模块zip包</a></h2><h2 id="解压zip包"><a href="#解压zip包" class="headerlink" title="解压zip包"></a>解压zip包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install unzip</span><br><span class="line">unzip RedisBloom-master.zip</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/redis/unzip安装.jpg" style="zoom: 50%;" />

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E7%BC%96%E8%AF%91bloom.jpg" alt=""></p>
<p>将编译后出现的redisbloom.so文件拷贝到/opt/redis/下</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;redis&#x2F;6379.conf</span><br><span class="line"># 添加以下配置</span><br><span class="line">loadmodule &#x2F;opt&#x2F;redis&#x2F;redisbloom.so</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%8A%A0%E8%BD%BD%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%9D%97.jpg" alt=""></p>
<h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service redis_6379 start</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-常见问题</title>
    <url>/2021/04/17/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一、穿透"><a href="#一、穿透" class="headerlink" title="一、穿透"></a>一、穿透</h3><p>数据库不存在，redis不存在</p>
<ul>
<li><p>key设置null值</p>
</li>
<li><p>布隆过滤器（存在一定的误差）</p>
<a id="more"></a>

</li>
</ul>
<h3 id="二、击穿"><a href="#二、击穿" class="headerlink" title="二、击穿"></a>二、击穿</h3><p>某个key，数据库存在，redis不存在（首次请求、key过期），大量（相同key）的请求一次性进来</p>
<ul>
<li>过期时间随机</li>
<li>锁方案（见下文）</li>
</ul>
<h3 id="三、雪崩"><a href="#三、雪崩" class="headerlink" title="三、雪崩"></a>三、雪崩</h3><p>缓存击穿的情况*N，一批key，数据库存在，redis不存在（首次请求、key过期），大量（不同key）的请求一次性进来</p>
<ul>
<li>过期时间随机</li>
<li>锁方案（见下文）</li>
</ul>
<h3 id="四、解决方案"><a href="#四、解决方案" class="headerlink" title="四、解决方案"></a>四、解决方案</h3><h4 id="布隆过滤器方案"><a href="#布隆过滤器方案" class="headerlink" title="布隆过滤器方案"></a>布隆过滤器方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、客户端实现过滤拦截</span><br><span class="line">2、客户端实现布隆算法，映射到redis的bitmap实现</span><br><span class="line">3、使用redis的bloomfilter组件</span><br><span class="line"></span><br><span class="line">问题：	</span><br><span class="line">1、只能key的映射增加不能删除（布谷鸟过滤器可以解决）</span><br><span class="line">2、不存在的key有一定程度可能跟存在的key出现映射重合，存在一定的误差</span><br></pre></td></tr></table></figure>

<h4 id="锁方案"><a href="#锁方案" class="headerlink" title="锁方案"></a>锁方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、请求redis，没有值</span><br><span class="line">2、抢锁setnx px</span><br><span class="line">	2.1、抢到锁的查询DB</span><br><span class="line">	2.2、抢不到锁的sleep（或者服务治理返回）</span><br><span class="line">3、更新redis数据，删除锁</span><br><span class="line">4、sleep苏醒的线程回到第一步</span><br><span class="line"></span><br><span class="line">问题：引入分布式锁，需要解决这个问题</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用SET key value [EX seconds] [PX milliseconds] [NX] 或 setnx + EXPIRE </span><br><span class="line">1.setnx</span><br><span class="line">2.过期时间</span><br><span class="line">3.多线程（守护线程）延长过期</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">1、线程使用setnx抢占之后可能宕机造成锁未释放，出现死锁？</span><br><span class="line">引入过期时间</span><br><span class="line"></span><br><span class="line">2、业务执行时间过久，造成锁已失效，期间其他线程抢占了锁，当前线程执行解锁误删其他线程的锁？</span><br><span class="line">设置value当前线程的操作标识（可以是随机数），删除时取出该值进行判断，看是否为当前线程持有的锁，是的话才进行删除</span><br><span class="line"></span><br><span class="line">3、当前线程取出value值判断锁为本线程持有，到删除之间存在时间差，可能因为锁失效缘故造成其他线程再次期间抢占到了锁？</span><br><span class="line">保证get操作和del操作的原子性，使用lua脚本或者事务</span><br><span class="line"></span><br><span class="line">4、当前业务未执行完，锁已经失效？</span><br><span class="line">多线程监控（守护线程），对key延长失效时间，可以使用redisson解决方案</span><br></pre></td></tr></table></figure>



<h3 id="五、缓存双写一致"><a href="#五、缓存双写一致" class="headerlink" title="五、缓存双写一致"></a>五、缓存双写一致</h3><p>先更新数据库，后更新缓存</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B401.png" alt=""></p>
<p>由图可知：</p>
<ul>
<li>请求A先更新DB</li>
<li>请求B也更新DB</li>
<li>但是因为网络等原因，B却比A更早更新了缓存。</li>
<li>导致数据的不一致，出现脏数据</li>
</ul>
<p>先更新数据库，后删除缓存</p>
<ul>
<li>更新DB成功</li>
<li>删除缓存失败</li>
<li>导致缓存数据为旧数据，出现脏数据</li>
</ul>
<p>先更新缓存，后更新数据库</p>
<ul>
<li>更新缓存成功</li>
<li>更新DB失败</li>
<li>导致数据不一致，出现脏数据</li>
</ul>
<p>先删除缓存，后更新数据库</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B404.png" alt=""></p>
<p>由图可知：</p>
<pre><code>- 如果同时有一个请求A先删除，再进行更新操作
- 中间另一个请求B进行查询发现没有缓存，查询了DB更新了缓存
- 之后A再更新DB
- 导致数据的不一致，出现脏数据</code></pre><p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、消息队列</span><br><span class="line">2、canal</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-过期、淘汰</title>
    <url>/2021/04/11/redis%E8%BF%87%E6%9C%9F%E5%92%8C%E6%B7%98%E6%B1%B0/</url>
    <content><![CDATA[<h2 id="key过期-删除策略"><a href="#key过期-删除策略" class="headerlink" title="key过期-删除策略"></a>key过期-删除策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</span><br><span class="line">优点：</span><br><span class="line">	保证内存被尽快释放</span><br><span class="line">缺点：</span><br><span class="line">	若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除）。</span><br><span class="line">优点：</span><br><span class="line">	删除操作只在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的.</span><br><span class="line">缺点：</span><br><span class="line">	若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</span><br></pre></td></tr></table></figure>

<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">含义：</span><br><span class="line">	每隔一段时间执行一次删除过期key操作</span><br><span class="line">优点：</span><br><span class="line">	通过限制删除操作的时长和频率，该策略是前两者的一个折中方案</span><br><span class="line">缺点：</span><br><span class="line">	在内存友好方面，不如&quot;定时过期&quot;（会造成一定的内存占用，但是没有“惰性过期”那么占用内存）在CPU时间友好方面，不如&quot;惰性过期&quot;（会定期的去进行比较和删除操作，cpu方面不如“惰性过期”，但是比“定时过期”好）</span><br></pre></td></tr></table></figure>

<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h2 id="内存不足-淘汰策略"><a href="#内存不足-淘汰策略" class="headerlink" title="内存不足-淘汰策略"></a>内存不足-淘汰策略</h2><p>redis内存满了使用的淘汰策略</p>
<p>​        设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。<br>当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。</p>
<p>​        当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。</p>
<!-- more -->

<p>以下的策略是可用的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># volatile-lru -&gt; </span><br><span class="line">	Evict using approximated LRU, only keys with an expire set.</span><br><span class="line">	在过期集合的键中，尝试回收最久未被访问的键（LRU）,使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-lru -&gt; </span><br><span class="line">	Evict any key using approximated LRU.</span><br><span class="line">	在所有的键中，尝试回收最久未被访问的键（LRU），使得新添加的数据有空间存放。</span><br><span class="line"># volatile-lfu -&gt; </span><br><span class="line">	Evict using approximated LFU, only keys with an expire set.</span><br><span class="line">	在过期集合的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-lfu -&gt; </span><br><span class="line">	Evict any key using approximated LFU.</span><br><span class="line">	在所有的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</span><br><span class="line"># volatile-random -&gt; </span><br><span class="line">	Remove a random key having an expire set.</span><br><span class="line">	在过期集合的键中，随机回收键，使得新添加的数据有空间存放。</span><br><span class="line"># allkeys-random -&gt; </span><br><span class="line">	Remove a random key, any key.</span><br><span class="line">	在所有的键中，随机回收键，使得新添加的数据有空间存放。</span><br><span class="line"># volatile-ttl -&gt; </span><br><span class="line">	Remove the key with the nearest expire time (minor TTL)</span><br><span class="line">	在过期集合的键，优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</span><br><span class="line"># noeviction -&gt; </span><br><span class="line">	Don&#39;t evict anything, just return an error on write operations.</span><br><span class="line">	不淘汰，返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</span><br></pre></td></tr></table></figure>

<p>一般的经验规则:</p>
<ul>
<li>使用<strong>allkeys-lru</strong>策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.</li>
<li>使用<strong>allkeys-random</strong>：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。</li>
<li>使用<strong>volatile-ttl</strong>：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。</li>
</ul>
<p>当想要单一的实例实现缓存及持久化一些键时，allkeys-lru 和 volatile-random策略很有用。不过一般运行两个实例是解决这个问题的更好方法。<br>当内存有压力时，没有必要为键取设置过期时间，因为为了键设置过期时间也是需要消耗内存的。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-持久化</title>
    <url>/2021/04/11/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-02.png" alt=""></p>
<a id="more"></a>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认开启rdb</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.只有一个文件 dump.rdb，方便持久化。 </span><br><span class="line">2.性能大化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 ，使用fork()创建子进程来进行RDB备份操作，子进程拥有父进程数据的指针，不需要全部数据拷贝一份，当有主进程有新数据进行修改时，触发系统内核的copy on write写时复制的机制，新数据写入新的内存位置，之后再操作旧数据的指针，而子进程的指针仍指向旧数据，因此两个进程的数据是隔离的，也保证了数据备份的时点性，</span><br><span class="line">3.二进制文件，相比于aof恢复比较快</span><br><span class="line">4.存在数据丢失的可能性</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发 生故障，会发生数据丢失。</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#RDB触发规则，多少秒触发了多少次则执行RDB，“”表示不开启RDB，可以多个save规则同时配置</span></span><br><span class="line"><span class="comment">#   save ""</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># bgsave快照出错时是否停止数据写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否设置检查点</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># rdb文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否同步删除rdb文件</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持久化文件存放的目录（RDB和AOF问备份文件都会放在这里）</span></span><br><span class="line">dir /var/lib/redis/6379</span><br></pre></td></tr></table></figure>



<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-03.png" alt=""></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.满足条件时触发重写</span><br><span class="line">	4.0以前，重写时，删除抵消命令，合并重复命令</span><br><span class="line">	4.0后，重写时，将旧数据RDB到aof文件中，之后将增量数据append到aof中</span><br><span class="line">2.redis是内存数据库，写操作触发io，造成性能下降</span><br><span class="line">3.aof可以修改触发级别：no、always、everysec</span><br><span class="line">4.如果RDB、AOF两个都配了优先加载AOF</span><br></pre></td></tr></table></figure>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一 次 命令操作就记录到aof文件中一次。 </span><br><span class="line">2.AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命 令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</span><br></pre></td></tr></table></figure>

<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.AOF 文件比 RDB 文件大，且恢复速度慢。</span><br></pre></td></tr></table></figure>



<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof触发策略</span></span><br><span class="line">appendfsync always <span class="comment">#每个动作都追加</span></span><br><span class="line">appendfsync everysec <span class="comment">#默认配置，每秒都追加</span></span><br><span class="line">appendfsync no <span class="comment">#等待内核缓冲区满了在一起追加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当有其他子进程在对磁盘进行写操作（rdb）或者重写操作时，no表示不参与争抢，此时不进行aof操作</span></span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100   </span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#aof达到64MB时触发重写</span></span><br><span class="line"></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#是否混合使用RDB和AOF备份，重写时会将旧数据以RDB形势放入aof文件前面，新数据以追加日志方式写入，[RDB file][AOF tail]，当打开aof文件时前面出现"REDIS"证明是开启RDB前置的新AOF混合文件，4.0之后才有的新功能</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h2 id="持久化选择"><a href="#持久化选择" class="headerlink" title="持久化选择"></a>持久化选择</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 </span><br><span class="line">- 如果非常关心数据，但仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。 </span><br><span class="line">- 有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 </span><br><span class="line">- 如果只希望数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>restTemplate常见操作</title>
    <url>/2020/11/29/restTemplate%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>常见的restTemplate操作</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种方式 xxForObject、xxForEntity、exchange</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装请求头</span></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);<span class="comment">//封装请求类型</span></span><br><span class="line">headers.add(<span class="string">"Accept"</span>, MediaType.APPLICATION_JSON.toString());<span class="comment">//封装可接收类型,"Accept", MediaType.APPLICATION_JSON_VALUE</span></span><br><span class="line"><span class="comment">//封装请求参数</span></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map); </span><br><span class="line"><span class="comment">//封装请求实体（请求参数、请求头）</span></span><br><span class="line">HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(jsonStr, headers);</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">Map result = restTemplate.postForObject(expressUrl, entity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送携带query参数的uri，使用此api进行编码生成uri</span></span><br><span class="line">UriComponentsBuilder builder = UriComponentsBuilder</span><br><span class="line">                .fromUriString(getUsersUrl)</span><br><span class="line">                .queryParam(<span class="string">"nameOrEmail"</span>, nameOrEmail);</span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(builder.build().encode().toUri(), HttpMethod.PUT, <span class="keyword">new</span> HttpEntity&lt;&gt;(headers), String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送文件</span></span><br><span class="line">httpHeaders.setAccept(Arrays.asList(MediaType.MULTIPART_FORM_DATA));</span><br><span class="line">httpHeaders.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line"><span class="comment">//设置请求体，注意是LinkedMultiValueMap</span></span><br><span class="line">FileSystemResource fileSystemResource = <span class="keyword">new</span> FileSystemResource(filePath+<span class="string">"/"</span>+fileName);<span class="comment">//获取文件资源</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; form = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();<span class="comment">//一个key可以存多个value</span></span><br><span class="line">form.add(<span class="string">"file"</span>, fileSystemResource);<span class="comment">//封装资源文件 </span></span><br><span class="line">form.add(<span class="string">"filename"</span>,fileName);<span class="comment">//封装文件名称</span></span><br><span class="line"><span class="comment">//用HttpEntity封装整个请求报文</span></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = <span class="keyword">new</span> HttpEntity&lt;&gt;(form, headers);</span><br><span class="line">String s = restTemplate.postForObject(url, files, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>https请求报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.web.client.ResourceAccessException: I/O error on GET request <span class="keyword">for</span> <span class="string">"https://ecs.gac.com.cn:3351/ecs-console/api/bill/searchBillCount"</span>: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; nested exception is javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">    </span><br><span class="line">cn.kjjk.kjpayservice.KjPayServiceApplicationTests.main(KjPayServiceApplicationTests.java:<span class="number">58</span>)</span><br><span class="line">Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	</span><br><span class="line">Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure>

<p>处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate  = <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> HttpsClientRequestFactory());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsClientRequestFactory</span> <span class="keyword">extends</span> <span class="title">SimpleClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareConnection</span><span class="params">(HttpURLConnection connection, String httpMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(connection <span class="keyword">instanceof</span> HttpsURLConnection)) &#123;<span class="comment">// http协议</span></span><br><span class="line">                <span class="comment">//throw new RuntimeException("An instance of HttpsURLConnection is expected");</span></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(connection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;<span class="comment">// https协议，修改协议版本</span></span><br><span class="line">                SSLContext ctx = SSLContext.getInstance(<span class="string">"TLSv1.2"</span>);</span><br><span class="line">                X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line">                org.apache.http.conn.ssl.SSLSocketFactory ssf = <span class="keyword">new</span> org.apache.http.conn.ssl.SSLSocketFactory(ctx, org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line">                ((HttpsURLConnection) connection).setSSLSocketFactory(ctx.getSocketFactory());</span><br><span class="line">                HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(httpsConnection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>redis-命令</title>
    <url>/2021/04/10/redis%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli #链接客户端</span><br><span class="line">select dbnum #选择数据库</span><br><span class="line">flushdb #清除当前数据库数据</span><br><span class="line">flushall #清除所有数据库数据</span><br><span class="line">scan #游标扫描匹配的key</span><br><span class="line">KEYS  # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">dbsize #返回当前数据库的 key 的数量</span><br><span class="line">del # 删除给定的一个或多个 key</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">      summary: Append a value to a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。</span><br><span class="line">      # 如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。</span><br><span class="line">      # 返回追加 value 之后， 键 key 的值的长度。</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">      summary: Count set bits in a string</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 对指定的bit索引位置区间的bit值进行统计</span><br><span class="line">  </span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">      summary: Perform bitwise operations between strings</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 在多个键（包含字符串值）之间执行按位操作并将结果存储在目标键中，operation支持四个按位运算：AND，OR，XOR和NOT</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">      summary: Find first bit set or clear in a string</span><br><span class="line">      since: 2.8.7</span><br><span class="line">      # 查找字符串中第一个设置为1或0的bit的索引位，从指定索引的左边开始寻找</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">      summary: Decrement the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值减去一。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行减一操作之后的值。</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">      summary: Decrement the integer value of a key by the given number</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 储存的整数值减去减量 decrement 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键在执行减法操作之后的值。</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">      summary: Get the value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值</span><br><span class="line">      # 如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">      summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回指定bit索引偏移量的值</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">      summary: Get a substring of the string stored at a key</span><br><span class="line">      since: 2.4.0</span><br><span class="line">      # 返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。</span><br><span class="line">      # 负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</span><br><span class="line">      # GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">      summary: Set the string value of a key and return its old value</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。</span><br><span class="line">      # 返回给定键 key 的旧值。</span><br><span class="line">      # 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil </span><br><span class="line">      # 当键 key 存在但不是字符串类型时， 命令返回一个错误。</span><br><span class="line">      </span><br><span class="line">  INCR key</span><br><span class="line">      summary: Increment the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上一。</span><br><span class="line">      # 如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行加一操作之后的值。</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">      summary: Increment the integer value of a key by the given amount</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回在加上增量 increment 之后， 键 key 当前的值。</span><br><span class="line">      </span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">      summary: Increment the float value of a key by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为键 key 储存的值加上浮点数增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么 INCRBYFLOAT 会先将键 key 的值设为 0 ， 然后再执行加法操作。</span><br><span class="line">      # 如果命令执行成功， 那么键 key 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</span><br><span class="line">      # 无论是键 key 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</span><br><span class="line">      # 此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</span><br><span class="line">      # 当以下任意一个条件发生时， 命令返回一个错误：1）键 key 的值不是字符串类型。 2）键 key 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</span><br><span class="line">      </span><br><span class="line">  MGET key [key ...]</span><br><span class="line">      summary: Get the values of all the given keys</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回给定的一个或多个字符串键的值</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 同时为多个键设置值。</span><br><span class="line">      # 如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</span><br><span class="line">      # MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</span><br><span class="line">      # MSET 命令总是返回 OK </span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 当且仅当所有给定键都不存在时， 为所有给定键设置值。</span><br><span class="line">      # 即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</span><br><span class="line">      # MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</span><br><span class="line">      # 当所有给定键都设置成功时， 命令返回 1 ； 如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">      summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</span><br><span class="line">      # 命令在设置成功时返回 OK </span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">      summary: Set the string value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将字符串值 value 关联到 key 。</span><br><span class="line">      # 如果 key 已经持有其他值， SET 就覆写旧值， 无视类型</span><br><span class="line">      # 当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</span><br><span class="line">      #从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</span><br><span class="line">            EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</span><br><span class="line">            PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</span><br><span class="line">            NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</span><br><span class="line">            XX ： 只在键已经存在时， 才对键进行设置操作。</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">      summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">      summary: Set the value and expiration of a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。</span><br><span class="line">      # 如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。</span><br><span class="line">      # SETEX 和SET EXPIRE这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">      summary: Set the value of a key, only if the key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。</span><br><span class="line">      # 若键 key 已经存在， 则 SETNX 命令不做任何动作</span><br><span class="line">      # SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</span><br><span class="line">      # 设置成功时返回 1 ， 设置失败时返回 0 。</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">      summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。</span><br><span class="line">      # 不存在的键 key 当作空白字符串处理。</span><br><span class="line">      # SETRANGE 命令会确保字符串足够长以便将 value 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, &quot;\x00&quot; )进行填充。</span><br><span class="line">      # 因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。</span><br><span class="line">      </span><br><span class="line">  STRLEN key</span><br><span class="line">      summary: Get the length of the value stored in a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回键 key 储存的字符串值的长度。</span><br><span class="line">      # 当键 key 不存在时， 命令返回 0 。</span><br><span class="line">      # 当 key 储存的不是字符串值时， 返回一个错误。</span><br></pre></td></tr></table></figure>

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">      summary: Delete one or more hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</span><br><span class="line">      # 被成功移除的域的数量，不包括被忽略的域。</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">      summary: Determine if a hash field exists</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 检查给定域 field 是否存在于哈希表 hash 当中。</span><br><span class="line">      # 在给定field存在时返回 1 ， 在给定field不存在时返回 0 。</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">      summary: Get the value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表中给定域的值。</span><br><span class="line">      # 如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">      summary: Get all the fields and values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，所有的域和值</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">      summary: Increment the integer value of a hash field by the given number</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 为哈希表 key 中的域 field 的值加上增量 increment 。</span><br><span class="line">      # 增量也可以为负数，相当于对给定域进行减法操作。</span><br><span class="line">      # 如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</span><br><span class="line">      # 如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</span><br><span class="line">      # 对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</span><br><span class="line">      # 本操作的值被限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      </span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">      summary: Increment the float value of a hash field by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为哈希表 key 中的域 field 加上浮点数增量 increment </span><br><span class="line">      # 如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</span><br><span class="line">      # 如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</span><br><span class="line">      # 当以下任意一个条件发生时，返回一个错误：1)域 field 的值不是字符串类型 2)域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数</span><br><span class="line">      </span><br><span class="line">  HKEYS key</span><br><span class="line">      summary: Get all the fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中的所有域。</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">      summary: Get the number of fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中域的数量。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">      summary: Get the values of all the given hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，一个或多个给定域的值。</span><br><span class="line">      # 如果给定的域不存在于哈希表，那么返回一个 nil 值。</span><br><span class="line">      # 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">      summary: Set multiple hash fields to multiple values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 同时将多个 field-value (域-值)对设置到哈希表 key 中</span><br><span class="line">      # 此命令会覆盖哈希表中已存在的域。</span><br><span class="line">      # 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate hash fields and associated values</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代哈希键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line">      # 返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">      summary: Set the string value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将哈希表 hash 中域 field 的值设置为 value 。</span><br><span class="line">      # 如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</span><br><span class="line">      # 如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。</span><br><span class="line">      # 当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 </span><br><span class="line">      </span><br><span class="line">  HSETNX key field value</span><br><span class="line">      summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。</span><br><span class="line">      # 如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</span><br><span class="line">      # 如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</span><br><span class="line">      # 在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">      summary: Get the length of the value of a hash field</span><br><span class="line">      since: 3.2.0</span><br><span class="line">      # 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</span><br><span class="line">      # 如果给定的键或者域不存在， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">      summary: Get all the values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中所有域的值。</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BLPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</span><br><span class="line">      # 如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值</span><br><span class="line">      </span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BRPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">      summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</span><br><span class="line">      # 当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</span><br><span class="line">      # 超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">      summary: Get an element from a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中，下标为 index 的元素。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">      summary: Insert an element before or after another element in a list</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后 。</span><br><span class="line">      # 当 pivot 不存在于列表 key 时，不执行任何操作，返回 -1 。</span><br><span class="line">      # 当 key 不存在时， key 被视为空列表，不执行任何操作，返回 0 。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">      summary: Get the length of a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 的长度。</span><br><span class="line">      # 如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">      summary: Remove and get the first element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的头元素。</span><br><span class="line">      # 列表的头元素。 当 key 不存在时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">      summary: Prepend one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表头</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">      summary: Prepend a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">      summary: Get a range of elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表</span><br><span class="line">      # 如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">      summary: Remove elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 根据参数 count 的值，移除列表中与参数 value 相等的元素。</span><br><span class="line">      # count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</span><br><span class="line">      # count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</span><br><span class="line">      # count &#x3D; 0 : 移除表中所有与 value 相等的值。</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">      summary: Set the value of an element in a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将列表 key 下标为 index 的元素的值设置为 value 。</span><br><span class="line">      # 当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">      summary: Trim a list to the specified range</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">      summary: Remove and get the last element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的尾元素。</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">      summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</span><br><span class="line">      #     将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</span><br><span class="line">      #     将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</span><br><span class="line">      # 如果 source 不存在，值 nil 被返回，并且不执行其他动作。</span><br><span class="line">      # 如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">      summary: Append one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表尾(最右边)。</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">      summary: Append a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">      summary: Add one or more members to a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</span><br><span class="line">      # 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</span><br><span class="line">      # 当 key 不是集合类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">      summary: Get the number of members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 的基数(集合中元素的数量)。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">      summary: Subtract multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合之间的差集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">      summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">      summary: Intersect multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的交集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line">      # 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">      summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">      summary: Determine if a given value is a member of a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 判断 member 元素是否集合 key 的成员。</span><br><span class="line">      # 如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">      summary: Get all the members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 中的所有成员。</span><br><span class="line">      # 不存在的 key 被视为空集合。</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">      summary: Move a member from one set to another</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 member 元素从 source 集合移动到 destination 集合。</span><br><span class="line">      # 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</span><br><span class="line">      # 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</span><br><span class="line">      # 当 source 或 destination 不是集合类型时，返回一个错误。</span><br><span class="line">      # 如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</span><br><span class="line"></span><br><span class="line">  SPOP key</span><br><span class="line">      summary: Remove and return a random member from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回集合中的一个随机元素。</span><br><span class="line">      # 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</span><br><span class="line">      # 被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">      summary: Get one or multiple random members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</span><br><span class="line">      # 从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</span><br><span class="line">      #     如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</span><br><span class="line">      #     如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</span><br><span class="line">      # 该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</span><br><span class="line">      # 当 key 不是集合类型，返回一个错误。</span><br><span class="line">      # 被成功移除的元素的数量，不包括被忽略的元素。</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate Set elements</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代set键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">      summary: Add multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的并集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">      summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line">      # 结果集中的元素数量。</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">      summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 将一个或多个 member 元素及其 score 值加入到有序集 key 当中</span><br><span class="line">      # 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数。</span><br><span class="line">      # 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">      summary: Get the number of members in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">      summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">      summary: Increment the score of a member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 为有序集 key 的成员 member 的 score 值加上增量 increment 。</span><br><span class="line">      # 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</span><br><span class="line">      # 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</span><br><span class="line">      # 当 key 不是有序集类型时，返回一个错误。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数</span><br><span class="line">      # member 成员的新 score 值，以字符串形式表示。</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</span><br><span class="line">      # WEIGHTS指定对应key的权重，redis该key对应值得分值乘上权重系数，再根据AGGREGATE聚合函数统计，默认相加</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">      summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递增(从小到大)来排序。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order )来排列。</span><br><span class="line">      # 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</span><br><span class="line">      # 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</span><br><span class="line">      # 如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</span><br><span class="line">      # 命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</span><br><span class="line">      # 可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</span><br><span class="line">      # 合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</span><br><span class="line">      # 特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX &lt;zset&gt; - + ， 命令将返回有序集合中的所有元素。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score</span><br><span class="line">      since: 1.0.5</span><br><span class="line">      # 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</span><br><span class="line">      # 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</span><br><span class="line">      # 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</span><br><span class="line">      # min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</span><br><span class="line">      # 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</span><br><span class="line">      # 使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</span><br><span class="line">      # 如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">      summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">      summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 移除有序集 key 中，指定排名(rank)区间内的所有成员。</span><br><span class="line">      # 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">      summary: Remove all members in a sorted set within the given scores</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</span><br><span class="line">      # 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      #参见ZRANGEBYLEX，列表排列从大到小</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</span><br><span class="line">      # 使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代zset键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">      summary: Get the score associated with the given member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，成员 member 的 score 值。</span><br><span class="line">      # 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</span><br><span class="line">      # 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</span><br><span class="line">      # 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</span><br><span class="line">      #     默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br></pre></td></tr></table></figure>

<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @generic</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">      summary: Delete a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 删除给定的一个或多个 key 。</span><br><span class="line">      # 不存在的 key 会被忽略。</span><br><span class="line">      # 被删除 key 的数量。</span><br><span class="line">   </span><br><span class="line">  DUMP key</span><br><span class="line">      summary: Return a serialized version of the value stored at the specified key.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</span><br><span class="line">      # 序列化生成的值有以下几个特点：</span><br><span class="line">      #     它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</span><br><span class="line">      #     值的编码格式和 RDB 文件保持一致。</span><br><span class="line">      #     RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</span><br><span class="line">      # 序列化的值不包括任何生存时间信息。</span><br><span class="line">      # 如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">      summary: Determine if a key exists</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 检查给定 key 是否存在。</span><br><span class="line">      # 若 key 存在，返回 1 ，否则返回 0 。</span><br><span class="line"></span><br><span class="line">  EXPIRE key seconds</span><br><span class="line">      summary: Set a key&#39;s time to live in seconds</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</span><br><span class="line">      # 在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</span><br><span class="line">      # 可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</span><br><span class="line">      # 在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</span><br><span class="line">      # 使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</span><br><span class="line"></span><br><span class="line">  EXPIREAT key timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</span><br><span class="line">      # 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</span><br><span class="line">      # 如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</span><br><span class="line"></span><br><span class="line">  KEYS pattern</span><br><span class="line">      summary: Find all keys matching the given pattern</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">      #     KEYS * 匹配数据库中所有 key 。</span><br><span class="line">      #     KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span><br><span class="line">      #     KEYS h*llo 匹配 hllo 和 heeeeello 等。</span><br><span class="line">      #     KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</span><br><span class="line">      # KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</span><br><span class="line"></span><br><span class="line">  MIGRATE host port key destination-db timeout [COPY] [REPLACE]</span><br><span class="line">      summary: Atomically transfer a key from a Redis instance to another one.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</span><br><span class="line">      # 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</span><br><span class="line">      # 命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</span><br><span class="line">      # timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</span><br><span class="line">      # MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。当 IOERR 出现时，有以下两种可能：</span><br><span class="line">      #     key 可能存在于两个实例</span><br><span class="line">      #     key 可能只存在于当前实例</span><br><span class="line">      # 唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</span><br><span class="line">      # 如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）</span><br><span class="line"></span><br><span class="line">  MOVE key db</span><br><span class="line">      summary: Move a key to another database</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将当前数据库的 key 移动到给定的数据库 db 当中。</span><br><span class="line">      # 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</span><br><span class="line">      # 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</span><br><span class="line">      # 移动成功返回 1 ，失败则返回 0 。</span><br><span class="line">      </span><br><span class="line">  OBJECT subcommand [arguments [arguments ...]]</span><br><span class="line">      summary: Inspect the internals of Redis objects</span><br><span class="line">      since: 2.2.3</span><br><span class="line">      # OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</span><br><span class="line">      # OBJECT 命令有多个子命令：</span><br><span class="line">      #     OBJECT REFCOUNT &lt;key&gt; 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</span><br><span class="line">      #     OBJECT ENCODING &lt;key&gt; 返回给定 key 锁储存的值所使用的内部表示(representation)。</span><br><span class="line">      #     OBJECT IDLETIME &lt;key&gt; 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。</span><br><span class="line">      # 对象可以以多种方式编码：</span><br><span class="line">      #     字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</span><br><span class="line">      #     列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</span><br><span class="line">      #     集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</span><br><span class="line">      #     哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</span><br><span class="line">      #     有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</span><br><span class="line">      # 假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</span><br><span class="line">      # REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</span><br><span class="line"></span><br><span class="line">  PERSIST key</span><br><span class="line">      summary: Remove the expiration from a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</span><br><span class="line">      # 当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 </span><br><span class="line"></span><br><span class="line">  PEXPIRE key milliseconds</span><br><span class="line">      summary: Set a key&#39;s time to live in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PEXPIREAT key milliseconds-timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp specified in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PTTL key</span><br><span class="line">      summary: Get the time to live for a key in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</span><br><span class="line">      #     当 key 不存在时，返回 -2 。</span><br><span class="line">      #     当 key 存在但没有设置剩余生存时间时，返回 -1 。</span><br><span class="line">      #     否则，以毫秒为单位，返回 key 的剩余生存时间。</span><br><span class="line">      # 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</span><br><span class="line"></span><br><span class="line">  RANDOMKEY -</span><br><span class="line">      summary: Return a random key from the keyspace</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 从当前数据库中随机返回(不删除)一个 key 。</span><br><span class="line">      # 当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  RENAME key newkey</span><br><span class="line">      summary: Rename a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</span><br><span class="line">      # 当 newkey 已经存在时， RENAME 命令将覆盖旧值。</span><br><span class="line">      # 改名成功时提示 OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line">  RENAMENX key newkey</span><br><span class="line">      summary: Rename a key, only if the new key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 当且仅当 newkey 不存在时，将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 不存在时，返回一个错误。</span><br><span class="line">      # 修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</span><br><span class="line">     </span><br><span class="line">  RESTORE key ttl serialized-value [REPLACE]</span><br><span class="line">      summary: Create a key using the provided serialized value, previously obtained using DUMP.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 反序列化给定的序列化值，并将它和给定的 key 关联。</span><br><span class="line">      # 参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</span><br><span class="line">      # RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</span><br><span class="line">      # 如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate the keys space</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</span><br><span class="line">      #     SCAN 命令用于迭代当前数据库中的数据库键。</span><br><span class="line">      #     SSCAN 命令用于迭代集合键中的元素。</span><br><span class="line">      #     HSCAN 命令用于迭代哈希键中的键值对。</span><br><span class="line">      #     ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]</span><br><span class="line">      summary: Sort the elements in a list, set or sorted set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</span><br><span class="line">      # 排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</span><br><span class="line">      # 最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</span><br><span class="line">      #     SORT key 返回键值从小到大排序的结果。</span><br><span class="line">      #     SORT key DESC 返回键值从大到小排序的结果。</span><br><span class="line">      # 因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符。</span><br><span class="line">      # 如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</span><br><span class="line">      # 排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</span><br><span class="line">      #     offset 指定要跳过的元素数量。</span><br><span class="line">      #     count 指定跳过 offset 个指定的元素之后，要返回多少个对象。</span><br><span class="line">      # 其他玩法请自行查阅资料</span><br><span class="line"></span><br><span class="line">  TTL key</span><br><span class="line">      summary: Get the time to live for a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</span><br><span class="line">      # 当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</span><br><span class="line"></span><br><span class="line">  TYPE key</span><br><span class="line">      summary: Determine the type stored at key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回 key 所储存的值的类型。</span><br><span class="line"></span><br><span class="line">  WAIT numslaves timeout</span><br><span class="line">      summary: Wait for the synchronous replication of all the write commands sent in the context of the current connection</span><br><span class="line">      since: 3.0.0</span><br><span class="line">      # 等待在当前连接上下文中发送的所有写命令的同步复制</span><br></pre></td></tr></table></figure>

<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">      summary: Discard all commands issued after MULTI</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 取消事务，放弃执行事务块内的所有命令。</span><br><span class="line">      # 如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">      summary: Execute all commands issued after MULTI</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 执行所有事务块内的命令。</span><br><span class="line">      # 假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">      summary: Mark the start of a transaction block</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 标记一个事务块的开始。</span><br><span class="line">      # 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">      summary: Forget about all watched keys</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 取消 WATCH 命令对所有 key 的监视。</span><br><span class="line">      # 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</span><br><span class="line">      # 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">      summary: Watch the given keys to determine execution of the MULTI&#x2F;EXEC block</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br></pre></td></tr></table></figure>

<h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BF.ADD key ...options...</span><br><span class="line">    # 添加key到bloom中</span><br><span class="line"></span><br><span class="line">BF.EXISTS key ...options...</span><br><span class="line">	# 判断是否存在对应的key</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-集群</title>
    <url>/2021/04/13/redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="一、主从复制"><a href="#一、主从复制" class="headerlink" title="一、主从复制"></a>一、<code>主从复制</code></h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><ul>
<li>一个master可以拥有多个slave。</li>
<li>master的复制是异步非阻塞的。</li>
<li>客户端可以使用wait命令请求同步复制某些特定数据。</li>
<li>正常连接情况下，master通过命令流来保持对slave的数据更新。</li>
<li>master与slave之间得到连接断开，slave在尝试与master重连后，会尝试获取与master断开期间丢失的命令流</li>
<li>当断开期间的数据无法重新同步时，slave会请求全量更新，master将以rdb快照方式将全量数据推送给slave，之后再进行增量更新。</li>
</ul>
<a id="more"></a>

<h3 id="2、复制原理"><a href="#2、复制原理" class="headerlink" title="2、复制原理"></a>2、复制原理</h3><ul>
<li>每个master都有一个replicationId用来表示与slave处于同一个主从复制中；<br>同时存在一个偏移量，用来记录上次发送给slave的数据，每次复制数据后该偏移量都会增加，即使没有slave链接master，它的offset也会增加。一对Replication ID, offset表示一个版本的数据</li>
<li>当slave连接到master后，会使用psync命令发送自己存储的旧replicationId和offset，master从积压的缓冲区找到对应版本的数据，开始增量复制推送给slave，如果缓冲区没有的话，master会进行全量RBD复制</li>
<li>全量复制，master后台fork一个进行产生一个rdb文件在本地磁盘，将rdb文件传输给slave保存在本地磁盘，slave加载到内存执行，无磁盘复制可以使用repl-diskless-sync 配置参数</li>
</ul>
<h3 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建文件夹，拷贝redis配置，方便后续测试</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis</span><br><span class="line">cp /etc/redis/* /</span><br><span class="line"></span><br><span class="line"><span class="comment">#注释日志输出，以便控制台观看</span></span><br><span class="line">vi 6379.conf</span><br><span class="line"><span class="comment">#logfile /var/log/redis_6379.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭aof值测试rdb</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭后台启动，前台启动方便查看</span></span><br><span class="line">daemonize no</span><br></pre></td></tr></table></figure>

<h3 id="4、启动redis"><a href="#4、启动redis" class="headerlink" title="4、启动redis"></a>4、启动redis</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server ./6379.conf </span><br><span class="line">redis-server ./6380.conf </span><br><span class="line">redis-server ./6380.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8redis-01.jpg" alt=""></p>
<h3 id="5、slave追随master"><a href="#5、slave追随master" class="headerlink" title="5、slave追随master"></a>5、slave追随master</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">方式一：在进入6380、6381客户端，使用`replicaof host port`命令（5.0之前命令为`slaveof host port`），让从节点追随主节点</span><br><span class="line"></span><br><span class="line">方式二：在启动服务端时，使用`redis-server ./6380.conf --replicaof host port`命令，让从节点追随主节点</span><br><span class="line"></span><br><span class="line">方式三：在配置文件指定 <span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<p>从节点控制台日志</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E4%B8%BB%E8%8A%82%E7%82%B9-%E4%BB%8E%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97-03.jpg" alt=""></p>
<p>主节点控制台日志</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E4%B8%BB%E8%8A%82%E7%82%B9-%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97-04.jpg" alt=""></p>
<h3 id="6、错误"><a href="#6、错误" class="headerlink" title="6、错误"></a>6、错误</h3><p>此时发现客户端宕机，重新启动客户端报如下错误</p>
<h4 id="6-1、问题1："><a href="#6-1、问题1：" class="headerlink" title="6.1、问题1："></a>6.1、问题1：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING overcommit_memory is <span class="built_in">set</span> to 0! Background save may fail under low memory condition. To fix this issue add <span class="string">'vm.overcommit_memory = 1'</span> to /etc/sysctl.conf and <span class="keyword">then</span> reboot or run the <span class="built_in">command</span> <span class="string">'sysctl vm.overcommit_memory=1'</span> <span class="keyword">for</span> this to take effect.</span><br><span class="line">4562:M 13 Apr 2021 21:45:46.588 <span class="comment"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').</span></span><br><span class="line"></span><br><span class="line">警告:overcommit_memory设置为0!在内存不足的情况下，后台保存可能失败。要解决这个问题，添加‘vm’。overcommit_memory = 1<span class="string">' /etc/sysctl.conf，然后重启或执行'</span>sysctl vm. conf <span class="string">'命令。overcommit_memory=1'</span>让它生效。</span><br><span class="line"><span class="comment">#警告:你的内核已经启用了透明的大页面(THP)支持。这会造成Redis的延迟和内存使用问题。要解决这个问题，以root权限运行'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'命令，并将其添加到/etc/rc.本地，以便在重新启动后保留设置。禁用THP后必须重新启动Redis(设置为'madvise'或'never')。</span></span><br></pre></td></tr></table></figure>

<p>执行<code>sysctl vm.overcommit_memory=1</code>解决以上问题</p>
<h4 id="6-2、问题2："><a href="#6-2、问题2：" class="headerlink" title="6.2、问题2："></a>6.2、问题2：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING you have Transparent Huge Pages (THP) support enabled <span class="keyword">in</span> your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the <span class="built_in">command</span> <span class="string">'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'</span> as root, and add it to your /etc/rc.local <span class="keyword">in</span> order to retain the setting after a reboot. Redis must be restarted after THP is disabled (<span class="built_in">set</span> to <span class="string">'madvise'</span> or <span class="string">'never'</span>).</span><br><span class="line"></span><br><span class="line">您的内核中启用了透明的大页面(THP)支持。这会造成Redis的延迟和内存使用问题。要解决这个问题，以root权限运行<span class="string">'echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled'</span>命令，并将其添加到/etc/rc.本地，以便在重新启动后保留设置。禁用THP后必须重新启动Redis(设置为<span class="string">'madvise'</span>或<span class="string">'never'</span>)。</span><br></pre></td></tr></table></figure>

<p>执行<code>echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>解决以上问题</p>
<h4 id="6-3、问题3："><a href="#6-3、问题3：" class="headerlink" title="6.3、问题3："></a>6.3、问题3：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is <span class="built_in">set</span> to the lower value of 128.</span><br><span class="line"></span><br><span class="line">由于/proc/sys/net/core/somaxconn被设置为较低的值128,TCP backlog设置511无法执行。</span><br></pre></td></tr></table></figure>

<p>执行<code>echo 511 &gt; /proc/sys/net/core/somaxconn</code>解决以上问题</p>
<h4 id="6-4、问题4："><a href="#6-4、问题4：" class="headerlink" title="6.4、问题4："></a>6.4、问题4：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">5499:M 13 Apr 2021 21:58:45.198 <span class="comment"># Server initialized</span></span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * Loading RDB produced by version 6.0.9</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * RDB age 1191 seconds</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 * RDB memory usage when created 1.85 Mb</span><br><span class="line">5499:M 13 Apr 2021 21:58:45.198 <span class="comment"># The RDB file contains module data I can't load: no matching module 'MBbloom--'</span></span><br></pre></td></tr></table></figure>

<p>此时仍无法启动，需要到持久化目录<code>/var/lib/redis/6381</code>下处理rdb文件<code>mv dump.rdb dump.rdb.bak</code>，此时可以正常启动</p>
<h3 id="7、slave升级为master"><a href="#7、slave升级为master" class="headerlink" title="7、slave升级为master"></a>7、slave升级为master</h3><p>当主节点宕机时，我们需要手动进行故障转移，将从节点升级为主节点</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7%E5%88%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA-05.jpg" alt="从节点监控到主节点宕机"></p>
<p>从节点客户端执行<code>replicaof no one</code>指令，将自己从slave升级为master</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E5%B0%86%E8%87%AA%E5%B7%B1%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%BB%E8%8A%82%E7%82%B9-06.jpg" alt="从节点升级为主节点"></p>
<h3 id="8、配置"><a href="#8、配置" class="headerlink" title="8、配置"></a>8、配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slave在首次接收master数据时，可以在slave中配置同步期间是否接收旧数据的访问，在首次同步之后，旧数据会被删除，然后再主线程加载新数据，此时slave会阻塞</span></span><br><span class="line">replica-serve-stale-data yes  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从节点是否开启只读模式</span></span><br><span class="line">replica-read-only yes </span><br><span class="line"></span><br><span class="line"><span class="comment">#是否采用无磁盘模式传输，no表示走磁盘，yes走网络传输</span></span><br><span class="line">repl-diskless-sync no </span><br><span class="line"></span><br><span class="line"><span class="comment">#增量复制，当redis挂掉之后又恢复，主节点可以增量传输数据过来，但是增量的数据与当前的数据存在偏差，从节点可以通过传送offset从主节点再次拉回数据，此配置大小会关系到redis内存维护的队列大小，此操作的成功与否，数据量大于这个值会造成溢出</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果至少有 3 个 slave ，并且滞后小于 10 秒，则写入将被接受,如果条件不满足master的写操作将被拒绝。</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果master节点设置了密码，需要在此处进行配置对应表的访问密码</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置追随的master节点</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p>1、从节点追随主节点之后，旧数据会被删除，同时非阻塞方式同步主节点数据</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%BD%E9%9A%8F%E5%89%8D%E5%90%8E%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96-05.jpg" alt=""></p>
<p>2、从节点只能读，不能写（可修改配置改变）</p>
<p>3、主节点出现故障时，需要人工维护升级新的主节点</p>
<h2 id="二、哨兵模式"><a href="#二、哨兵模式" class="headerlink" title="二、哨兵模式"></a>二、<code>哨兵模式</code></h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过连接master获取slave的信息</span><br><span class="line">2.通过psubscribe正则方式订阅发布的信息,从而发现其他哨兵节点</span><br><span class="line">3.监控主从节点是否正常</span><br><span class="line">3.自动故障转移</span><br><span class="line">4.使用投票机制选举master</span><br></pre></td></tr></table></figure>

<h3 id="2、Sentinel相互发现"><a href="#2、Sentinel相互发现" class="headerlink" title="2、Sentinel相互发现"></a>2、Sentinel相互发现</h3><ul>
<li>每个Sentinel会以每两秒一次的频率，通过发布与订阅功能，向被它监视的所有master和slave的 sentinel:hello 频道发送一条信息，信息中包含了该Sentinel的IP 地址、端口号和运行ID （runid）。</li>
<li>每个Sentinel都订阅了被它监视的所有master和slave的sentinel:hello 频道,查找之前未出现过的sentinel（looking for unknown sentinels）。当一个Sentinel 发现一个新的Sentinel时，它会将新的Sentinel添加到一个列表中，这个列表保存了Sentinel已知的，监视同一个主服务器的所有其他Sentinel。</li>
<li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li>
<li>在将一个新Sentinel添加到监视主服务器的列表上面之前，Sentinel会先检查列表中是否已经包含了和要添加的Sentinel拥有相同运行ID或者相同地址（包括IP地址和端口号）的 Sentinel ，如果是的话，Sentinel会先移除列表中已有的那些拥有相同运行ID或者相同地址的Sentinel， 然后再添加新Sentinel。</li>
</ul>
<h3 id="3、Sentinel对master的故障判定"><a href="#3、Sentinel对master的故障判定" class="headerlink" title="3、Sentinel对master的故障判定"></a>3、Sentinel对master的故障判定</h3><p>1)、 Sentinel以每秒钟一次的频率向它所知的master、slave以及其他 Sentinel 实例发送一个 PING 命令,如果距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，那么这个实例会被 Sentinel 标记为主观下线。一个有效回复可以是：+PONG 、-LOADING 或者 -MASTERDOWN ，其余回复或者没有回复都算是无效回复。<br>2)、当master标记为ODOWN(主观下线)后，用通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。<br>        2.1)、当有足够数量的 Sentinel（至少要达到配置文件指定的数量quorum）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。<br>        2.2)、当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主观下线状态就会被移除<br>3)、在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有master和slave发送 INFO 命令。 当一个master被 Sentinel 标记为客观下线时， Sentinel 向下线master的所有slave发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>
<h3 id="4、选举新的master"><a href="#4、选举新的master" class="headerlink" title="4、选举新的master"></a>4、选举新的master</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先标记master为ODOWN状态的Sentinel使用以下规则从slave中来选取新的master：</span><br><span class="line">1、被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</span><br><span class="line">2、与失效主服务器连接断开的时长超过 down-after-milliseconds 选项指定的时长十倍的从服务器都会被淘汰。</span><br><span class="line">3、在经历了以上两轮淘汰之后剩下来的从服务器中， 选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； </span><br><span class="line">4、如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</span><br></pre></td></tr></table></figure>

<h3 id="5、准备"><a href="#5、准备" class="headerlink" title="5、准备"></a>5、准备</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件参考源码目录下/usr/local/redis-6.0.9/sentinel.conf</span></span><br><span class="line"></span><br><span class="line">创建配置文件</span><br><span class="line">vi 26379.conf</span><br><span class="line"></span><br><span class="line">port 26379 <span class="comment"># 指定当前哨兵端口号</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 <span class="comment"># 指定哨兵需要监控的主节点ip port 投票达成一致数量</span></span><br></pre></td></tr></table></figure>

<h3 id="6、配置"><a href="#6、配置" class="headerlink" title="6、配置"></a>6、配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果需要监控监控的master设置了密码，需要在此处设置</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、启动哨兵节点"><a href="#7、启动哨兵节点" class="headerlink" title="7、启动哨兵节点"></a>7、启动哨兵节点</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">启动方式一：redis-server ./26379.conf --sentinel</span><br><span class="line">启动方式二：redis-sentinel ./26381.conf</span><br></pre></td></tr></table></figure>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%90%AF%E5%8A%A8-01.jpg" alt=""></p>
<h3 id="8、选举新master节点"><a href="#8、选举新master节点" class="headerlink" title="8、选举新master节点"></a>8、选举新master节点</h3><p>当master节点宕机，哨兵节点过半以上检测到之后会重新选举新的master节点</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8C%82%E4%BA%86%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE-01.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E6%8C%82%E4%BA%86%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE.jpg" alt=""></p>
<p>slave节点升级为master节点</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9-6380%E8%A2%AB%E9%80%89%E4%B8%BE-6380%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<p>另一个slave检测到新的master主节点产生并追随</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9-6380%E8%A2%AB%E9%80%89%E4%B8%BE-6381%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、哨兵通过主节点获取从节点信息，同时发布订阅方式发现其他哨兵节点信息</p>
<p>2、主节点宕机后，哨兵节点重新选举新的主节点，做到故障转移，不需要人工处理</p>
<p>3、master节点存在已经过期的key，复制到了slave，那当master的“访问过期”和“定期过期”机制没有被触发时，该key没有被删除，客户端链接slave查询该key时出现什么情况？推测：判断过期返回不存在，过期的key不处理，等待master处理后同步del指令</p>
<h2 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h2><h3 id="1、概念-2"><a href="#1、概念-2" class="headerlink" title="1、概念"></a>1、概念</h3><h4 id="1-1、不同端的分区"><a href="#1-1、不同端的分区" class="headerlink" title="1.1、不同端的分区"></a>1.1、不同端的分区</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端分区:</span><br><span class="line">	由客户端根据一定的算法逻辑计算出该key应该与哪一个redis实例交互</span><br><span class="line">	用户客户端自己实现逻辑</span><br><span class="line">代理分区:</span><br><span class="line">	客户端不需要理会如何分区，请求发送给代理，有代理觉得链接哪一个redis实例</span><br><span class="line">	twemproxy、predixy</span><br><span class="line">查询路由:</span><br><span class="line">	客户端随机请求任意的redis实例，redis将请求转发给正确的redis节点处理</span><br><span class="line">	redis cluster</span><br></pre></td></tr></table></figure>

<h4 id="1-2、优缺点"><a href="#1-2、优缺点" class="headerlink" title="1.2、优缺点"></a>1.2、优缺点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区优点</span><br><span class="line">	可以让redis管理更大的内存</span><br><span class="line">	分布在不同的计算机利用不同计算机的计算能力，使redis的计算能力得到提升</span><br><span class="line">分区的缺点：</span><br><span class="line">	多个key不在统一分区无法使用聚合、事务等操作</span><br><span class="line">	动态扩容和收缩需要对数据进行再平衡（预分片可以解决这个问题）</span><br></pre></td></tr></table></figure>

<h4 id="1-3、预分片"><a href="#1-3、预分片" class="headerlink" title="1.3、预分片"></a>1.3、预分片</h4><p>​    因为redis实例占用的内存很小，在一台机子提前启用多台redis以分布式方式运行，随着数据不断增加，需要做的只是将redis实例迁移到另外的计算机中，不需要考虑重新分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.新的服务器启动新的redis实例</span><br><span class="line">2.配置为需要迁移的旧redis的slave（此操作可以同步数据）</span><br><span class="line">3.更新分片映射的旧实例ip为新实例ip</span><br><span class="line">4.客户端连接新的redis实例执行SLAVEOF NO ONE命令，将新实例升级为master</span><br><span class="line">5.停止旧的redis实例</span><br></pre></td></tr></table></figure>

<h3 id="2、分区算法"><a href="#2、分区算法" class="headerlink" title="2、分区算法"></a>2、分区算法</h3><h4 id="2-1、普通Hash算法（modula）"><a href="#2-1、普通Hash算法（modula）" class="headerlink" title="2.1、普通Hash算法（modula）"></a>2.1、普通Hash算法（modula）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如你有 N 个 &#96;redis&#96;实例，那么如何将一个&#96;key&#96;映射到&#96;redis&#96;上呢，你很可能会采用类似下面的通用方法计算 key的 hash 值，然后均匀的映射到到 N 个 &#96;redis&#96;上：</span><br><span class="line">　　&#96;hash(key)%N&#96;</span><br><span class="line">　　如果增加一个&#96;redis&#96;，映射公式变成了 &#96;hash(key)%(N+1)&#96;</span><br><span class="line">　　如果一个&#96;redis&#96;宕机了，映射公式变成了 &#96;hash(key)%(N-1)&#96;</span><br><span class="line">　　在这两种情况下，每一个&#96;redis&#96;管理的数据全部要重新计算移动，几乎所有的缓存都失效了。会导致数据库访问的压力陡增，严重情况，还可能导致数据库宕机。</span><br></pre></td></tr></table></figure>

<h4 id="2-2、随机分配算法-random"><a href="#2-2、随机分配算法-random" class="headerlink" title="2.2、随机分配算法(random)"></a>2.2、随机分配算法(random)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机将数据分发到Redis集群中，Client无法准确地从某台机器获取相对的数据，该做法常用于消息队列中。</span><br></pre></td></tr></table></figure>

<h4 id="2-3、一致性Hash算法-ketama"><a href="#2-3、一致性Hash算法-ketama" class="headerlink" title="2.3、一致性Hash算法(ketama)"></a>2.3、一致性Hash算法(ketama)</h4><ol>
<li>将内存想象成一个环，由于hash值有32位，因此将内存分出2 ^32（0~2 ^32-1）个地址</li>
<li>将节点的IP+算法确定唯一的哈希值，之后在内存中确定节点的位置</li>
<li>当保存数据时，根据key进行哈希运算，确定唯一的一个位置</li>
<li>根据当前<code>key</code>位置<strong>顺时针</strong>查找最近的<code>node</code>节点进行挂载（在内存中，加法计算快于减法运算，因此采用顺时针查找）</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-38.png" alt=""></p>
<p>将各个服务器使用<code>Hash</code>进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p>
<p>假设将中四台服务器使用ip地址哈希后在环空间的位置如下：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-39.png" alt=""></p>
<p>将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<p>假设4个存储对象 Object A、B、C、D，经过对 Key 的哈希计算后，它们的位置如下：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-40.png" alt=""></p>
<p>根据一致性哈希算法，数据A会被定为到<code>Node A</code>上，B被定为到<code>Node B</code>上，C被定为到<code>Node C</code>上，D被定为到<code>Node D</code>上。</p>
<h5 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h5><p>假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到<code>Node D</code>。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>如果在系统中增加一台服务器Node X，如下图所示：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-41.png" alt=""></p>
<p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<p>如果这时候新增了一个结点，对原来缓存的一部分数据的访问将会落到新增的结点上，但是这时候结点并没有数据缓存，<strong>它将去数据库中查找并缓存，原先已经缓存数据的结点需要通过淘汰算法（LRU）淘汰数据，它并没有从原缓存结点复制数据到新节点中。</strong></p>
<h5 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h5><p><strong>但一致性哈希算法也有一个严重的问题，就是数据倾斜</strong>。如果在分片的集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少。也就是说无法控制节点存储数据的分配。如下图，大部分数据都在 A 上了，B 的数据比较少。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-42.png" alt=""></p>
<p>节点数越少，越容易出现节点在哈希环上的分布不均匀，导致各节点映射的对象数量严重不均衡(数据倾斜)；相反，节点数越多越密集，数据在哈希环上的分布就越均匀。</p>
<p>以删除节点为例，假设删除了<code>Node B</code>节点，原来<code>Node B</code>节点的数据将转移到<code>Node C</code>上，这样<code>Node C</code>的内存使用率会骤增，如果<code>Node B</code>上存在热点数据，<code>Node C</code>会扛不住甚至会可能挂掉，挂掉之后数据又转移给<code>Node D</code>,如此循环会造成所有节点崩溃，也就是<strong>缓存雪崩</strong>。</p>
<p>为了解决雪崩现象和数据倾斜现象，提出了虚拟节点这个概念。就是将真实节点计算多个哈希形成多个虚拟节点并放置到哈希环上，<strong>定位算法不变，只是多了一步虚拟节点到真实节点映射的过程</strong></p>
<p>但实际部署的物理节点有限，我们可以用有限的物理节点，虚拟出足够多的虚拟节点(<code>Virtual Node</code>)，最终达到数据在哈希环上均匀分布的效果。</p>
<p>如下图，实际只部署了2个节点 Node A/B，每个节点都复制成3倍，结果看上去是部署了6个节点。可以想象，当复制倍数为 2^32 时，就达到绝对的均匀，通常可取复制倍数为32或更高。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-43.png" alt=""></p>
<p><strong>这就解决了雪崩的问题，当某个节点宕机后，其数据并没有全部分配给某一个节点，而是被分到了多个节点，数据倾斜的问题也随之解决</strong>。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>一致性哈希算法，既可以在客户端实现，也可以在中间件上实现（如 proxy）。在客户端实现中，当客户端初始化的时候，需要初始化一张预备的 Redis 节点的映射表：hash(key)=&gt; . 这有一个缺点，假设有多个客户端，当映射表发生变化的时候，多个客户端需要同时拉取新的映射表。</p>
<p>另一个种是中间件（proxy）的实现方法，即在客户端和 Redis 节点之间加多一个代理，代理经过哈希计算后将对应某个 key 的请求分发到对应的节点，一致性哈希算法就在中间件里面实现。可以发现，twemproxy 就是这么做的。</p>
<h4 id="2-4、哈希槽"><a href="#2-4、哈希槽" class="headerlink" title="2.4、哈希槽"></a>2.4、哈希槽</h4><p><strong><code>redis</code> 集群（<code>cluster</code>）并没有选用上面一致性哈希，而是采用了哈希槽（<code>slot</code>）的这种概念</strong>。主要的原因就是上面所说的，<strong>一致性哈希算法对于数据分布、节点位置的控制并不是很友好</strong>。</p>
<p>首先哈希槽其实是两个概念，第一个是哈希算法。<code>redis cluster</code> 的 <code>hash</code> 算法不是简单的<code>hash</code>()，而是 <code>crc16</code> 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。</p>
<p>其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 <code>redis cluster</code> 的槽位空间是自定义分配的，类似于 <code>windows</code> 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p>
<p><code>redis cluster</code> 包含了16384个哈希槽，每个 <code>key</code> 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。<strong>所以哈希槽这种概念很好地解决了一致性哈希的弊端</strong>。</p>
<p><strong>当有新节点加入时，它不再需要像一致性Hash算法那样把每个<code>key</code>取出来重新计算<code>hash</code>值，只需要从旧节点中将新节点应该缓存的槽位数据拷贝到新节点中即可。</strong></p>
<p>另外在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-28.png" alt=""></p>
<p><strong>弊端是聚合操作很难实现，并且不支持跨机器事务，但是提供了Hash Tag让用户控制需要计算的Key都集中在一个Redis中。</strong></p>
<h3 id="3、代理分区-TwemProxy"><a href="#3、代理分区-TwemProxy" class="headerlink" title="3、代理分区-TwemProxy"></a>3、代理分区-<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener"><code>TwemProxy</code></a></h3><h4 id="3-1、安装"><a href="#3-1、安装" class="headerlink" title="3.1、安装"></a>3.1、安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:twitter/twemproxy.git</span><br><span class="line"><span class="built_in">cd</span> twemproxy</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --<span class="built_in">enable</span>-debug=full</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#此操作是为了之后可以使用service twemproxy start/stop等命令操作</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/scripts</span><br><span class="line">cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">chmod +x twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看到需要在这个目录下创建此配置 OPTIONS="-d -c /etc/nutcracker/.yml"</span></span><br><span class="line">more twemproxy </span><br><span class="line"></span><br><span class="line">进入源码目录</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/conf</span><br><span class="line">cp ./* /etc/nutcracker</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/src</span><br><span class="line">cp nutcracker /usr/bin <span class="comment">#之后再操作系统任意地方可以使用nutcracker命令</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/nutcracker</span><br><span class="line">cp nutcracker.yml nutcracker.yml.bak</span><br></pre></td></tr></table></figure>

<h4 id="3-2、配置"><a href="#3-2、配置" class="headerlink" title="3.2、配置"></a>3.2、配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">nutcracker.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">alpha:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:22121</span></span><br><span class="line">  <span class="attr">hash:</span> <span class="string">fnv1a_64</span></span><br><span class="line">  <span class="attr">distribution:</span> <span class="string">ketama</span></span><br><span class="line">  <span class="attr">auto_eject_hosts:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">redis:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">server_retry_timeout:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">server_failure_limit:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379:1</span> <span class="comment">#1指的是权重</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9380:1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3、手动启动redis"><a href="#3-3、手动启动redis" class="headerlink" title="3.3、手动启动redis"></a>3.3、手动启动redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接指定端口启动的话，会将当前目录作为持久目录</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis/6379_data</span><br><span class="line">redis-server --port 6379</span><br><span class="line"></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/<span class="built_in">test</span>-redis/6380_data</span><br><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure>

<h4 id="3-4、启动twemproxy"><a href="#3-4、启动twemproxy" class="headerlink" title="3.4、启动twemproxy"></a>3.4、启动twemproxy</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service twemproxy start</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/twemproxy-%E5%90%AF%E5%8A%A803.jpg" alt=""></p>
<h4 id="3-5、通过代理连接redis"><a href="#3-5、通过代理连接redis" class="headerlink" title="3.5、通过代理连接redis"></a>3.5、通过代理连接redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据分区，不支持keys、watch、MULTI等命令</span></span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure>

<h3 id="4、代理分区-Predixy"><a href="#4、代理分区-Predixy" class="headerlink" title="4、代理分区-Predixy"></a>4、代理分区-<a href="https://github.com/joyieldInc/predixy/releases" target="_blank" rel="noopener"><code>Predixy</code></a></h3><p><a href="https://github.com/joyieldInc/predixy/blob/master/README_CN.md" target="_blank" rel="noopener">中文文档</a></p>
<h4 id="4-1、安装"><a href="#4-1、安装" class="headerlink" title="4.1、安装"></a>4.1、安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line">tar xf predixy-1.0.5-bin-amd64-linux.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="4-2、predixy相关配置"><a href="#4-2、predixy相关配置" class="headerlink" title="4.2、predixy相关配置"></a>4.2、predixy相关配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改predixy配置</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy/predixy-1.0.5/conf</span><br><span class="line">vi predixy.conf </span><br><span class="line"></span><br><span class="line"><span class="comment">################################### GENERAL ####################################</span></span><br><span class="line"><span class="comment"># 开放predixy绑定的ip端口</span></span><br><span class="line">Bind 127.0.0.1:7617</span><br><span class="line"><span class="comment"># Bind 0.0.0.0:7617</span></span><br><span class="line"><span class="comment"># Bind /tmp/predixy</span></span><br><span class="line"><span class="comment">################################### SERVERS ####################################</span></span><br><span class="line"><span class="comment"># Include cluster.conf</span></span><br><span class="line"><span class="comment">#加载sentinel相关配置</span></span><br><span class="line">Include sentinel.conf</span><br><span class="line"><span class="comment"># Include try.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改predixy的sentinel配置</span></span><br><span class="line">vim sentinel.conf</span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">"&#123;&#125;"</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 127.0.0.1:26379  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26380  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26381  <span class="comment">#配置哨兵节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel001 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel002 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3、sentinel配置"><a href="#4-3、sentinel配置" class="headerlink" title="4.3、sentinel配置"></a>4.3、sentinel配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line"></span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line"></span><br><span class="line">port 26381</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br></pre></td></tr></table></figure>

<h4 id="4-4、启动sentinel"><a href="#4-4、启动sentinel" class="headerlink" title="4.4、启动sentinel"></a>4.4、启动sentinel</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server 26379.conf --sentinel</span><br><span class="line">redis-server 26380.conf --sentinel</span><br><span class="line">redis-server 26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<h4 id="4-5、启动redis主从"><a href="#4-5、启动redis主从" class="headerlink" title="4.5、启动redis主从"></a>4.5、启动redis主从</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir 36379</span><br><span class="line">mkdir 36380</span><br><span class="line">mkdir 46379</span><br><span class="line">mkdir 46380</span><br><span class="line">redis-sever --port 36379</span><br><span class="line">redis-server --port 36380 --replicaof 127.0.0.1 36379</span><br><span class="line">redis-sever --port 46379</span><br><span class="line">redis-server --port 46380 --replicaof 127.0.0.1 46379</span><br></pre></td></tr></table></figure>

<h4 id="4-6、启动predixy"><a href="#4-6、启动predixy" class="headerlink" title="4.6、启动predixy"></a>4.6、启动predixy</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy/predixy-1.0.5/bin</span><br><span class="line">./predixy ../conf/predixy.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E5%90%AF%E5%8A%A8predixy-01jpg.jpg" alt=""></p>
<h4 id="4-7、通过代理连接redis"><a href="#4-7、通过代理连接redis" class="headerlink" title="4.7、通过代理连接redis"></a>4.7、通过代理连接redis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代理分区，因为sentinel监控了两套主从，不支持keys、watch、MULTI等命令，使用单套主从则可以</span></span><br><span class="line">redis-cli -p 7167</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/predixy%E4%BD%BF%E7%94%A8.jpg" alt=""></p>
<h3 id="5、查询路由分区-Redis-Cluster"><a href="#5、查询路由分区-Redis-Cluster" class="headerlink" title="5、查询路由分区-Redis-Cluster"></a>5、查询路由分区-<code>Redis-Cluster</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无需&#96;proxy&#96;代理，客户端直接与&#96;redis&#96;集群的每个节点连接，根据同样的&#96;hash&#96;算法计算出&#96;key&#96;对应的&#96;slot&#96;，然后直接在&#96;slot&#96;对应的&#96;redis&#96;节点上执行命令。</span><br><span class="line"></span><br><span class="line">在&#96;redis&#96;看来，响应时间是最苛刻的条件，增加一层带来的开销是&#96;redis&#96;不能接受的。因此，&#96;redis&#96;实现了客户端对节点的直接访问，**为了去中心化，节点之间通过&#96;gossip&#96;协议交换互相的状态，以及探测新加入的节点信息**。&#96;redis&#96;集群支持动态加入节点，动态迁移&#96;slot&#96;，以及自动故障转移。</span><br></pre></td></tr></table></figure>

<h4 id="5-1、slot分配"><a href="#5-1、slot分配" class="headerlink" title="5.1、slot分配"></a>5.1、slot分配</h4><p><strong>redis集群模式使用公式 <code>CRC16(key) % 16384</code> 来计算键<code>key</code>属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC16</code> 校验和 。集群中的每个节点负责处理一部分哈希槽。</strong></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-28.png" alt=""></p>
<p> 举个例子， 一个集群可以有三个节点， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5500 号哈希槽。</li>
<li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li>
<li>节点 C 负责处理 11001 号至 16383 号哈希槽。</li>
<li>此时 <code>Redis Client</code> 需要根据一个<code>Key</code>获取对应的 <code>Value</code> 的数据，首先通过 <code>CRC16(key)%16384</code> 计算出 Slot 的值，假设计算的结果是 5000，将这个数据传送给 <code>Redis Cluster</code>，集群接收到以后会到一个对照表中查找这个 <code>Slot=5000</code> 属于那个缓存节点。发现属于“节点 A ”负责，于是顺着红线的方向调用节点 A中存放的 <code>Key-Value</code> 的内容并且返回给 <code>Redis Client</code>。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p><strong>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，且成本很低， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线</strong>。</p>
<h4 id="5-2、数据结构"><a href="#5-2、数据结构" class="headerlink" title="5.2、数据结构"></a>5.2、数据结构</h4><p><code>Redis Cluster</code>中的每个节点都保存了集群的配置信息，并且存储在<code>clusterState</code>中，结构如下：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-30.png" alt=""></p>
<p>上图的各个变量语义如下:</p>
<ul>
<li><code>clusterState</code> 记录了从集群中某个节点视角，来看集群配置状态；</li>
<li><code>currentEpoch</code> 表示整个集群中最大的版本号，集群信息每变更一次，改版本号都会自增。</li>
<li><code>nodes</code> 是一个列表，包含了本节点所感知的，集群所有节点的信息（<code>clusterNode</code>），也包含自身的信息。</li>
<li><code>clusterNode</code> 记录了每个节点的信息，其中包含了节点本身的版本 <code>Epoch</code>；自身的信息描述：节点对应的数据分片范围（<code>slot</code>）、为<code>master</code>时的<code>slave</code>列表、为<code>slave</code>时的<code>master</code>等。</li>
</ul>
<p><strong>每个节点包含一个全局唯一的<code>NodeId</code></strong>。</p>
<p>当集群的数据分片信息发生变更（数据在节点间迁移时），<code>Redis Cluster</code>仍然保持对外服务。</p>
<p>当集群中某个master出现宕机时，<code>Redis Cluster</code> 会自动发现，并触发故障转移的操作。会将<code>master</code>的某个<code>slave</code>晋升为新的 <code>master</code>。</p>
<p>由此可见，每个节点都保存着<code>Node</code>视角的集群结构。它描述了数据的分片方式，节点主备关系，并通过<code>Epoch</code>作为版本号实现集群结构信息的一致性，同时也控制着数据迁移和故障转移的过程。</p>
<h4 id="5-3、节点通信"><a href="#5-3、节点通信" class="headerlink" title="5.3、节点通信"></a>5.3、节点通信</h4><p>在<code>Redis Cluster</code>中，这个配置信息交互通过<code>Redis Cluster Bus</code>来完成（<code>独立端口</code>）。<code>Redis Cluster Bus</code>上交互的信息结构如下：</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-31.png" alt=""></p>
<p><code>clusterMsg</code> 中的<code>type</code>指明了消息的类型，配置信息的一致性主要依靠<code>PING/PONG</code>。每个节点向其他节点频繁的周期性的发送<code>PING/PONG</code>消息。对于消息体中的<code>Gossip</code>部分，包含了<code>sender/receiver</code> 所感知的其他节点信息，接受者根据这些<code>Gossip</code> 跟新对集群的认识。</p>
<p>对于大规模的集群，如果每次<code>PING/PONG</code> 都携带着所有节点的信息，则网络开销会很大。此时<code>Redis Cluster</code> 在每次<code>PING/PONG</code>，只包含了随机的一部分节点信息。由于交互比较频繁，短时间的几次交互之后，集群的状态也会达成一致。</p>
<h4 id="5-4、一致性"><a href="#5-4、一致性" class="headerlink" title="5.4、一致性"></a>5.4、一致性</h4><p>当<code>Cluster</code> 结构不发生变化时，各个节点通过<code>gossip</code> 协议在几轮交互之后，便可以得知<code>Cluster</code>的结构信息，达到一致性的状态。但是当集群结构发生变化时（故障转移/分片迁移等），优先得知变更的节点通过Epoch变量，将自己的最新信息扩散到<code>Cluster</code>，并最终达到一致。</p>
<p><code>clusterNode</code> 的<code>Epoch</code>描述的单个节点的信息版本；<br><code>clusterState</code> 的<code>currentEpoch</code> 描述的是集群信息的版本，它可以辅助<code>Epoch</code> 的自增生成。因为<code>currentEpoch</code> 是维护在每个节点上的，在集群结构发生变更时，<code>Cluster</code> 在一定的时间窗口控制更新规则，来保证每个节点的<code>currentEpoch</code>都是最新的。<br>更新规则如下：</p>
<p>当某个节点率先知道了变更时，将自身的<code>currentEpoch</code> 自增，并使之成为集群中的最大值。再用自增后的<code>currentEpoch</code> 作为新的<code>Epoch</code> 版本；</p>
<ul>
<li>当某个节点收到了比自己大的<code>currentEpoch</code>时，更新自己的<code>currentEpoch</code>；</li>
<li>当收到的<code>Redis Cluster Bus</code> 消息中的某个节点的<code>Epoch</code> &gt; 自身的时，将更新自身的内容；</li>
<li>当<code>Redis Cluster Bus</code> 消息中，包含了自己没有的节点时，将其加入到自身的配置中。</li>
</ul>
<p>上述的规则保证了信息的更新都是单向的，最终朝着<code>Epoch</code>更大的信息收敛。同时<code>Epoch</code>也随着<code>currentEpoch</code>的增加而增加，最终将各节点信息趋于稳定。</p>
<p>为了使得集群在一部分节点下线或者无法与集群的大多数（<code>majority</code>）节点进行通讯的情况下， 仍然可以正常运作， <code>Redis</code> 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（<code>replica</code>）， 其中一个复制品为主节点（<code>master</code>）， 而其余的 N-1 个复制品为从节点（<code>slave</code>）。</p>
<p><strong>集群间节点支持主从关系</strong>，复制的逻辑基本复用了单机版的实现。不过还是有些地方需要注意。</p>
<ul>
<li>首先集群间节点建立主从关系不再使用原有的<code>SLAVEOF</code>命令和<code>SLAVEOF</code>配置，而是通过<code>cluster replicate</code>命令，这保证了主从节点需要先完成握手，才能建立主从关系。</li>
<li>集群是不能组成链式主从关系的，也就是说从节点不能有自己的从节点。不过对于集群外的没开启集群功能的节点，<code>redis</code>并不干预这些节点去复制集群内的节点，但是在集群故障转移时，这些集群外的节点，集群不会处理。</li>
<li>集群内节点想要复制另一个节点，需要保证本节点不再负责任何<code>slot</code>，不然<code>redis</code>也是不允许的。</li>
<li>集群内的从节点在与其他节点通信的时候，传递的消息中数据分布表和<code>epoch</code>是<code>master</code>的值。</li>
</ul>
<p><strong>集群主节点出现故障，发生故障转移，其他主节点会把故障主节点的从节点自动提为主节点，原来的主节点恢复后，自动成为新主节点的从节点</strong>。</p>
<p>这里先说明，把一个<code>master</code>和它的全部<code>slave</code>描述为一个<code>group</code>，故障转移是以<code>group</code>为单位的，集群故障转移的方式跟sentinel的实现很类似。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-32.png" alt=""></p>
<h4 id="5-5、均衡集群"><a href="#5-5、均衡集群" class="headerlink" title="5.5、均衡集群"></a>5.5、均衡集群</h4><p>在集群运行过程中，有的<code>master</code>的<code>slave</code>宕机，导致了该<code>master</code>成为孤儿<code>master</code>（<code>orphaned masters</code>），而有的<code>master</code>有很多<code>slave</code>。</p>
<p>此处孤儿<code>master</code>的定义是那些本来有<code>slave</code>，但是全部离线的<code>master</code>，对于那些原来就没有<code>slave</code>的<code>master</code>不能认为是孤儿<code>master</code>。</p>
<p><code>redis</code>集群支持均衡<code>slave</code>功能，官方称为<code>Replica migration</code>，而我觉得均衡集群的<code>slave</code>更好理解该概念。集群能把某个<code>slave</code>较多的<code>group</code>上的<code>slave</code>迁移到那些孤儿<code>master</code>上，该功能通过<code>cluster-migration-barrier</code>参数配置，默认为1。</p>
<p><code>slave</code>在每次定时任务都会检查是否需要迁移<code>slave</code>，即把自己变成孤儿<code>master</code>的<code>slave</code>。 满足以下条件，<code>slave</code>就会成为孤儿<code>master</code>的<code>slave</code>：</p>
<ul>
<li>自己所在的<code>group</code>是<code>slave</code>最多的<code>group</code>。</li>
<li>目前存在孤儿<code>master</code>。</li>
<li>自己所在的<code>group</code>的<code>slave</code>数目至少超过2个，只有自己一个的话迁移到其他<code>group</code>，自己原来的<code>group</code>的<code>master</code>又成了孤儿<code>master</code>。</li>
<li>自己所在的<code>group</code>的<code>slave</code>数量大于<code>cluster-migration-barrier</code>配置。</li>
<li>与<code>group</code>内的其他<code>slave</code>基于<code>memcmp</code>比较<code>node id</code>，自己的<code>node id</code>最小。这个可以防止多个<code>slave</code>并发复制孤儿<code>master</code>，从而原来的<code>group</code>失去过多的<code>slave</code>。</li>
</ul>
<h5 id="5-5-1、优势"><a href="#5-5-1、优势" class="headerlink" title="5.5.1、优势"></a>5.5.1、优势</h5><ol start="2">
<li>去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。</li>
<li>解耦 <strong>数据</strong> 和 <strong>节点</strong> 之间的关系，简化了节点 <strong>扩容</strong> 和 <strong>收缩</strong> 难度。</li>
<li><strong>节点自身</strong> 维护槽的 <strong>映射关系</strong>，不需要 <strong>客户端</strong> 或者 <strong>代理服务</strong> 维护 <strong>槽分区元数据</strong>。</li>
</ol>
<h5 id="5-5-2、劣势"><a href="#5-5-2、劣势" class="headerlink" title="5.5.2、劣势"></a>5.5.2、劣势</h5><ol>
<li><code>key</code> <strong>批量操作</strong> 支持有限。类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的<code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的<code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</li>
<li>只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</li>
<li><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</li>
<li>不支持<strong>多数据库空间</strong>，<strong>单机</strong>下的<code>Redis</code>可以支持 16 个数据库（db0 ~ db15），<strong>集群模式</strong>下只能使用<strong>一个</strong> 数据库空间，即 db0。</li>
<li><strong>复制结构</strong> 只支持一层，<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</li>
</ol>
<h4 id="5-6、集群搭建"><a href="#5-6、集群搭建" class="headerlink" title="5.6、集群搭建"></a>5.6、集群搭建</h4><h5 id="5-6-1、脚本启动"><a href="#5-6-1、脚本启动" class="headerlink" title="5.6.1、脚本启动"></a>5.6.1、脚本启动</h5><p>​    进入redis源码目录下/utils/create-cluster中执行create-cluster脚本</p>
<p>​    <code>cd /usr/local/redis-6.0.9/utils/create-cluster</code></p>
<h5 id="5-6-2、配置"><a href="#5-6-2、配置" class="headerlink" title="5.6.2、配置"></a>5.6.2、配置</h5><p>​    <code>vim create-cluster</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Settings</span></span><br><span class="line">BIN_PATH=<span class="string">"../../src/"</span></span><br><span class="line">CLUSTER_HOST=127.0.0.1</span><br><span class="line">PORT=30000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6 <span class="comment">#总的节点数量</span></span><br><span class="line">REPLICAS=1 <span class="comment">#每个master对应的slave数量</span></span><br><span class="line">PROTECTED_MODE=yes</span><br><span class="line">ADDITIONAL_OPTIONS=<span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>​        由以上配置可以看出，总节点数为6，每个master对应的slave数量为1，因此根据此配置启动后集群为三主三从模式；后续如果有需要可以修改此配置</p>
<h5 id="5-6-3、启动集群实例"><a href="#5-6-3、启动集群实例" class="headerlink" title="5.6.3、启动集群实例"></a>5.6.3、启动集群实例</h5><p>​    <code>./create-cluster start</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8-01.jpg" alt=""></p>
<h5 id="5-6-4、脚本分配slot（hash槽位）"><a href="#5-6-4、脚本分配slot（hash槽位）" class="headerlink" title="5.6.4、脚本分配slot（hash槽位）"></a>5.6.4、脚本分配slot（hash槽位）</h5><p>​     <code>./create-cluster create</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8-02.jpg" alt=""></p>
<h5 id="5-6-5、客户端-连接"><a href="#5-6-5、客户端-连接" class="headerlink" title="5.6.5、客户端-连接"></a>5.6.5、客户端-连接</h5><p>客户端在初始化的时候只需要知道一个节点的地址即可，客户端会先尝试向这个节点执行命令，比如<code>“get key”</code>，如果key所在的<code>slot</code>刚好在该节点上，则能够直接执行成功。如果<code>slot</code>不在该节点，则节点会返回MOVED错误，同时把该slot对应的节点告诉客户端。客户端可以去该节点执行命令。</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/redis-29.png" alt=""></p>
<h6 id="普通客户端模式-连接"><a href="#普通客户端模式-连接" class="headerlink" title="普通客户端模式-连接"></a>普通客户端模式-连接</h6><p>​    <code>redis-cli -p 30001</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E6%99%AE%E9%80%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BF%9E%E6%8E%A5-01.jpg" alt=""></p>
<p>​    key分配的slot不在当前连接的redis server时，服务端返回错误提示，让客户端自己进行跳转 <code>(error) MOVED 12706 127.0.0.1:30003</code></p>
<h6 id="集群客户端模式-连接"><a href="#集群客户端模式-连接" class="headerlink" title="集群客户端模式-连接"></a>集群客户端模式-连接</h6><p>​    <code>redis-cli -c -p 30001</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E8%BF%9E%E6%8E%A5.jpg" alt=""></p>
<p>​    key分配的slot不在当前连接的redis server时，集群模式客户端会帮助我们进行重定向跳转 <code>Redirected to slot [12706] located at 127.0.0.1:30003</code></p>
<h5 id="5-6-6、注意"><a href="#5-6-6、注意" class="headerlink" title="5.6.6、注意"></a>5.6.6、注意</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	不管是&#96;普通客户端模式&#96;还是&#96;集群客户端模式&#96;去连接服务，如果key不在一个slot仍无法使用事务等指令</span><br><span class="line">​	解决同类业务数据不在同个 redis哈希槽的问题，在key上加上&#123;tag&#125;来标识某个key，会计算第一次出现&#39;&#123;&#39;到第一次出现&#39;&#125;&#39;之间的subString内容的hash值，如果该内容为空，则计算整个key;这种方式是解决分区key不同分区的通用解决方案</span><br></pre></td></tr></table></figure>

<h5 id="5-6-7、停止实例"><a href="#5-6-7、停止实例" class="headerlink" title="5.6.7、停止实例"></a>5.6.7、停止实例</h5><p>​    停止所有正在运行的redis-cluster实例 <code>./create-cluster stop</code></p>
<h5 id="5-6-7、还原实例"><a href="#5-6-7、还原实例" class="headerlink" title="5.6.7、还原实例"></a>5.6.7、还原实例</h5><p>​    清除配置、日志、持久化文件 <code>./create-cluster clean</code></p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E6%B8%85%E9%99%A4%E9%85%8D%E7%BD%AE%E8%BF%98%E5%8E%9F.jpg" alt=""></p>
<h5 id="5-6-8、手动启动"><a href="#5-6-8、手动启动" class="headerlink" title="5.6.8、手动启动"></a>5.6.8、手动启动</h5><p>修改redis配置，之后启动redis时加载此配置 <code>redis-server ./6379.conf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"><span class="comment">#redis.conf相关集群配置</span></span><br><span class="line"><span class="comment">#配置为cluster模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群节点配置信息，包括nodeid，集群信息。此文件非常关键，要确保故障转移或者重启的时候此文件还在，所以如果在docker环境下要外挂到外部存储</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点连接超时，如果集群规模小，都在同一个网络环境下，可以配置的短些，更快的做故障转移</span></span><br><span class="line">cluster-node-timeout 2000</span><br><span class="line"></span><br><span class="line"><span class="comment">#慢查询日志，用于性能分析，生产环境可设置为1000（毫秒）</span></span><br><span class="line">slowlog-log-slower-than 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存慢查询的队列长度 ，设置为1000</span></span><br><span class="line">slowlog-max-len 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为0，默认为10如果master slave都挂掉，slave跟master失联又超过这个数值*timeout的数值，就不会发起选举了。</span></span><br><span class="line"><span class="comment">#如果设置为0，就是永远都会尝试发起选举，尝试从slave变为mater</span></span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为no，默认为yes，故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况</span></span><br><span class="line"><span class="comment">#因此要设置为no，当主节点故障时只影 响它负责槽的相关命令执行，不会影响其他主节点的可用性</span></span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>



<h5 id="5-6-9、手动分配slot（hash槽）"><a href="#5-6-9、手动分配slot（hash槽）" class="headerlink" title="5.6.9、手动分配slot（hash槽）"></a>5.6.9、手动分配slot（hash槽）</h5><p>​    使用此方式可以自己指定参与集群的redis节点，设置slave节点数，适合真实环境下多服务器实例的集群搭建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<h5 id="5-6-10、移动slot"><a href="#5-6-10、移动slot" class="headerlink" title="5.6.10、移动slot"></a>5.6.10、移动slot</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实行重新分片命令，可任意连接一个redis实例进行操作</span></span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:30001</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span><br><span class="line">M: 1ba79d08eacd99fa3791d1824907a3e3e136cf06 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: d23ba04b97a59fa4bf3400510feb128ef0694520 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">S: 40b2868d28ac09031df1caa9847066eadebfa4f7 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e5bb13b4ea84f4fd5f23a944ae59a6768a34be28</span><br><span class="line">S: ddeb75d4235f26ce86fe30d3aa9edffde92d5a31 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">M: e3e285582cabc5360d74e99c778867526cecb2a1 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e5bb13b4ea84f4fd5f23a944ae59a6768a34be28 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="comment">#想要移动多少槽位？这里指定了2000</span></span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 2000</span><br><span class="line"><span class="comment"># 想要移动到哪个节点？这里指定了30002的节点id</span></span><br><span class="line">What is the receiving node ID? e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">    Moving slot 1998 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">    Moving slot 1999 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line"><span class="comment"># 是否执行表重新分片计划？yes</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">Moving slot 1997 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1998 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1999 from 127.0.0.1:30001 to 127.0.0.1:30002:</span><br></pre></td></tr></table></figure>

<p>如下图所示，有2000个槽位从30001的实例迁移到了30002的实例中</p>
<p><img src="http://yrlzero.gitee.io/images/linux/redis/cluster-%E7%A7%BB%E5%8A%A8%E6%A7%BD%E4%BD%8D-02.jpg" alt=""></p>
<h5 id="5-6-11、集群客户端-帮助"><a href="#5-6-11、集群客户端-帮助" class="headerlink" title="5.6.11、集群客户端-帮助"></a>5.6.11、集群客户端-帮助</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos-3 create-cluster]<span class="comment"># redis-cli --cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  <span class="built_in">set</span>-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  <span class="built_in">help</span>           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, <span class="built_in">set</span>-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 认证</title>
    <url>/2021/02/08/spring%20security%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h3 id="认证流程图"><a href="#认证流程图" class="headerlink" title="认证流程图"></a>认证流程图</h3><p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<a id="more"></a>

<h3 id="认证解析"><a href="#认证解析" class="headerlink" title="认证解析"></a>认证解析</h3><h4 id="用户发起认证"><a href="#用户发起认证" class="headerlink" title="用户发起认证"></a>用户发起认证</h4><p>​        经过<code>UsernamePasswordAuthenticationFilter</code>，调用其父类<code>AbstractAuthenticationProcessingFilter</code>的doFilter()方法</p>
<p>​        调用<code>UsernamePasswordAuthenticationFilter</code>的attemptAuthentication()方法尝试进行认证</p>
<p>​        将新构建的未认证的token（Authentication）交给AuthenticationManager接口的子类进行认证</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/1-attemptAuthentication.jpg" alt=""></p>
<h4 id="认证管理器处理认证"><a href="#认证管理器处理认证" class="headerlink" title="认证管理器处理认证"></a>认证管理器处理认证</h4><p>​    <code>AuthenticationManager</code>本身不包含任何的认证逻辑，其核心是管理所有的<code>AuthenticationProvider</code>，本质上认证是由<code>AuthenticationProvider</code>来实现认证。</p>
<p>​    用户认证调用了<code>AuthenticationManager</code>的authenticate()方法，由此进入 AbstractUserDetailsAuthenticationProvider（AuthenticationManager的实现类）的authenticate()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.根据自定义方式获取数据库用户信息</span><br><span class="line">	1.根据用户名从缓存寻找用户信息</span><br><span class="line">	2.没有缓存，调用子类DaoAuthenticationProvider.retrieveUser()-&gt;调用userDetailService的loadUserByUsername()走我们自定义的查询用户方法返回用户信息</span><br><span class="line">	</span><br><span class="line">b.校验用户状态(前置校验、额外校验、后置校验)</span><br><span class="line">	3.preAuthenticationChecks.check(user)对账号状态（isAccountNonLocked、isEnabled、isAccountNonExpired）进行校验	</span><br><span class="line">	4.additionalAuthenticationChecks(user,authenticationToken) 对其他认证信息进行检查（密码校验）</span><br><span class="line">	5.postAuthenticationChecks.check(user)对账号状态（isCredentialsNonExpired）进行校验</span><br><span class="line">	6.存在用户缓存信息的情况下需要更新缓存</span><br><span class="line">	</span><br><span class="line">c.生成用户认证信息authentication</span><br><span class="line">	7.createSuccessAuthentication()返回Authentication</span><br></pre></td></tr></table></figure>

<p>​        a.根据自定义方式获取数据库用户信息，如下图：</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/4-authenticate.jpg" alt=""></p>
<p>​        b.校验用户状态(前置校验、额外校验、后置校验)</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/5-authencation.jpg" alt=""></p>
<p>c.生成用户认证信息authentication</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/6-authencation.jpg" alt=""></p>
<h4 id="认证成功、失败handler"><a href="#认证成功、失败handler" class="headerlink" title="认证成功、失败handler"></a>认证成功、失败handler</h4><p>最后认证信息会传回<code>UsernamePasswordAuthenticationFilter</code>，并在其父类<code>AbstractAuthenticationProcessingFilter</code>的<code>doFilter()</code>中，根据认证成功设置SecurityContextHolder安全上下文用户信息，失败清除上下文用户信息，并设置调用相应的<code>handler</code>。</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/7-handler.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.自定义登录过滤器</span><br><span class="line">​	不同的登录形式我们可以继承AbstractAuthenticationProcessingFilter定义自己的登录过滤器（默认UsernamePasswordAuthenticationFilter）</span><br><span class="line">​	根据指定的url匹配到该过滤器，目的是生成自定义继承AbstractAuthenticationToken的子类token(默认UsernamePasswordAuthenticationToken)</span><br><span class="line"></span><br><span class="line">2.认证管理器</span><br><span class="line">​	调用环境指定的认证管理器对未认真的Authentication进行认证处理（默认ProviderManager）</span><br><span class="line"></span><br><span class="line">3.覆写provider、abstractAuthenticationToken、userDetailServicec</span><br><span class="line">​	实现AuthenticationProvider自定义自己的provider（默认DaoAuthenticationProvider），认证管理器根据我们重写的public boolean supports(Class&lt;?&gt; authentication)方法对当前环境的authentication进行判断，选取合适我的provider进行认证处理</span><br><span class="line">​	provider会调用自定义的userDerailService查询用户信息进行校验</span><br><span class="line"></span><br><span class="line">4.覆写成功、失败的handler</span><br><span class="line">​	认证期间，失败，会抛出对应的异常；成功，则生成已认证的Authentication返回</span><br><span class="line">​	覆写AuthenticationFailureHandler、AuthenticationSuccessHandler可以在认证成功或失败时进行自定义处理</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖一（图解）</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%80%EF%BC%88%E5%9B%BE%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>指的是DefaultSingletonBeanRegistry类中的三个Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存，存放初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存，存放已经被实例化，但是未初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三级缓存，存储创建Bean的匿名内部类工厂对象ObjectFactory&lt;?&gt;，通过存储lambda表达式（() -&gt; getEarlyBeanReference(beanName, mbd, bean)），解决创建动态代理逻辑性能，解耦 bean动态代理问题</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>spring通过三级缓存来解决循环依赖问题</p>
<a id="more"></a>

<h2 id="不含aop的流程图"><a href="#不含aop的流程图" class="headerlink" title="不含aop的流程图"></a>不含aop的流程图</h2><p><img src="http://yrlzero.gitee.io/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg" alt=""></p>
<h2 id="含aop的流程图"><a href="#含aop的流程图" class="headerlink" title="含aop的流程图"></a>含aop的流程图</h2><p><img src="http://yrlzero.gitee.io/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%ABaop2.jpg" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1：使用三级缓存的作用？"><a href="#1：使用三级缓存的作用？" class="headerlink" title="1：使用三级缓存的作用？"></a>1：使用三级缓存的作用？</h3><p>在三个级别的缓存中防止的对象是有区别的<br>    一级缓存存放的是：实例化和初始化都完成的对象<br>    二级缓存存放的是：实例化完成、初始化未完成的对象<br>    三级缓存存放的是：实例化和初始化都未完成，存放的是创建bean的匿名内部类（函数是接口ObjectFactory传入）</p>
<h3 id="2：只使用一级缓存？"><a href="#2：只使用一级缓存？" class="headerlink" title="2：只使用一级缓存？"></a>2：只使用一级缓存？</h3><p>​    在并发的情况下，可能取到实例化但是未初始化的对象</p>
<h3 id="3：只使用二级缓存？"><a href="#3：只使用二级缓存？" class="headerlink" title="3：只使用二级缓存？"></a>3：只使用二级缓存？</h3><p>​    三级缓存存放的是生成具体对象的一个匿名内部类，这个类可能是代理类，也可能是普通的实例对象，使用三级缓存就保证了不管是否需要代理，用的都是一个对象</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 鉴权</title>
    <url>/2021/02/08/spring%20security%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>FilterSecurityInterceptor</code>是过滤链的最后一环，一个请求完成了认证，且没有抛出异常之后就会到达<code>FilterSecurityInterceptor</code>所负责的鉴权部分，也就是说鉴权的入口就在<code>FilterSecurityInterceptor</code>。</p>
<p>​        它实现了<code>Filter</code>接口，我们一般直接继承这个过滤器或者继承他的父类，目的是为了注入自定义的授权管理器<code>AccessDecisionManager</code>、和权限元数据<code>FilterInvocationSecurityMetadataSource</code></p>
<p>​        它是在<code>WebSecurityConfigurerAdapter</code>的<code>init()</code>里配置的。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="进入FilterSecurityInterceptor的doFilter-、invoke-方法"><a href="#进入FilterSecurityInterceptor的doFilter-、invoke-方法" class="headerlink" title="进入FilterSecurityInterceptor的doFilter()、invoke()方法"></a>进入<code>FilterSecurityInterceptor</code>的doFilter()、invoke()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个FilterInvocation对象，这个FilterInvocation对象你可以当作它封装了request，它的主要工作就是拿请求里面的信息，比如请求的URI。</span></span><br><span class="line">		FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">		<span class="comment">//调用了自身的invoke方法，并将FilterInvocation对象传入。</span></span><br><span class="line">		invoke(fi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((fi.getRequest() != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">			<span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line">			<span class="comment">// once-per-request handling, so don't re-do security checking</span></span><br><span class="line">			fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">			<span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">				fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//根据资源权限配置来判断当前请求是否有权限访问对应的资源。</span></span><br><span class="line">			<span class="comment">//如果不能访问，则抛出相应的异常</span></span><br><span class="line">			InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//访问相关资源，通过SpringMvc的核心组件DispatcherServlet进行访问</span></span><br><span class="line">				fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用父类AbstractSecurityInterceptor的beforeInvocation-方法"><a href="#调用父类AbstractSecurityInterceptor的beforeInvocation-方法" class="headerlink" title="调用父类AbstractSecurityInterceptor的beforeInvocation()方法"></a>调用父类<code>AbstractSecurityInterceptor</code>的beforeInvocation()方法</h4><p>​                1、获取当前资源权限（我们自己定义的规则权限）</p>
<p>​                2、获取认证的authentication身份信息</p>
<p>​                3、调用决策器尝试进行认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationEventPublisherAware</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">					<span class="string">"Security invocation attempted for object "</span></span><br><span class="line">							+ object.getClass().getName()</span><br><span class="line">							+ <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">							+ getSecureObjectClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用子类的FilterInvocationSecurityMetadataSource.getAttributes(object)获取当前资源所需权限</span></span><br><span class="line">		Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">				.getAttributes(object);</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果Authentication.isAuthenticated()返回false或属性alwaysReauthenticate已设置为true，则检查当前身份验证令牌并将其传递给AuthenticationManager进行认证</span></span><br><span class="line">		<span class="comment">//返回认证的authentication身份信息，并放入安全上下文</span></span><br><span class="line">		Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Attempt authorization</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用访问决策器进行决策，尝试进行鉴权</span></span><br><span class="line">			<span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">			publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">					accessDeniedException));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>AccessDecisionManager</code>访问决策管理器是一个接口，它声明了三个方法，除了第一个鉴权方法以外，还有两个是辅助性的方法，其作用都是甄别 decide方法中参数的有效性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 解决传递参数的访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">            InsufficientAuthenticationException</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//指示此AccessDecisionManager是否能够处理通过传递的ConfigAttribute提出的授权请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//指示AccessDecisionManager实现是否能够为指示的安全对象类型提供访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/security/%E9%89%B4%E6%9D%83/%E5%86%B3%E7%AD%96%E5%99%A8.jpg" alt=""></p>
<p>​    从图中我们可以看到它主要有三个实现类，分别代表了三种不同的鉴权逻辑：</p>
<ul>
<li>AffirmativeBased：一票通过，只要有一票通过就算通过，默认是它。</li>
<li>UnanimousBased：一票反对，只要有一票反对就不能通过。</li>
<li>ConsensusBased：少数票服从多数票。</li>
</ul>
<p><code>这三个实现类，其实还不是真正判断请求能不能通过的类，真正判断请求是否通过的是投票器，然后实现类把投票器的结果综合起来来决定到底能不能通过。</code></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>以<code>AffirmativeBased</code>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="keyword">extends</span> <span class="title">AbstractAccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AffirmativeBased</span><span class="params">(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(decisionVoters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException </span>&#123;</span><br><span class="line">		<span class="comment">//拒绝数量</span></span><br><span class="line">		<span class="keyword">int</span> deny = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//遍历从构造传入的决策投票器集合</span></span><br><span class="line">		<span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">			<span class="comment">//调用该投票器的投票逻辑方法进行判断（AffirmativeBased默认传入WebExpressionVoter）</span></span><br><span class="line">			<span class="keyword">int</span> result = voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (result) &#123;</span><br><span class="line">				<span class="comment">//赞成</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//拒绝</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">                    deny++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拒绝数量大于0，抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(messages.getMessage(</span><br><span class="line">					<span class="string">"AbstractAccessDecisionManager.accessDenied"</span>, <span class="string">"Access is denied"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果全部都弃权，进入此方法，判断此决策器是否允许全部弃权，不允许则抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">		checkAllowIfAllAbstainDecisions();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当走完决策流程没有抛出<code>AccessDeniedException</code>异常，则权限校验通过</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>通过实现<code>AccessDeniedHandler</code>接口的handle()可以对<code>AccessDeniedException</code>异常抛出的权限被拒信息作出友好提示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line"><span class="comment">//WebSecurityConfigurerAdapter配置</span></span><br><span class="line">http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br></pre></td></tr></table></figure>



<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="http://yrlzero.gitee.io/images/security/%E9%89%B4%E6%9D%83/%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt=""></p>
<h2 id="自定义鉴权"><a href="#自定义鉴权" class="headerlink" title="自定义鉴权"></a>自定义鉴权</h2><h3 id="方式一-访问决策管理器实现鉴权"><a href="#方式一-访问决策管理器实现鉴权" class="headerlink" title="方式一 访问决策管理器实现鉴权"></a>方式一 访问决策管理器实现鉴权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionManager访问决策管理器实现类，直接在决策器decide()方法实现鉴权逻辑，空参构造，不注入投票器</span><br><span class="line">2、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">3、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​        总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>走自定义的鉴权规则</p>
<h3 id="方式二-投票器实现鉴权逻辑"><a href="#方式二-投票器实现鉴权逻辑" class="headerlink" title="方式二 投票器实现鉴权逻辑"></a>方式二 投票器实现鉴权逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionVoter&lt;FilterInvocation&gt;投票器实现类，vote()方法中实现鉴权逻辑</span><br><span class="line">2、自定义AccessDecisionManager访问决策管理器实现类，有参构造，注入自定义投票器</span><br><span class="line">3、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">4、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​    总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>调用<code>自定义投票器</code>走自定义的投票鉴权逻辑；这种方式较完整的仿照security流程</p>
<h3 id="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"><a href="#以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态" class="headerlink" title="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"></a>以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 UsernamePasswordAuthenticationFilter之前添加自定义OncePerRequestFilter过滤器实现类，目的是检查token状态是否正常(过期、系统已清除等)</span></span><br><span class="line">http.addFilterBefore(myJwtAuthenticationTokenRequestFilter,UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 过滤器链</title>
    <url>/2021/02/08/spring%20security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/</url>
    <content><![CDATA[<h3 id="过滤器链介绍"><a href="#过滤器链介绍" class="headerlink" title="过滤器链介绍"></a>过滤器链介绍</h3><p>spring security采用的是责任链的设计模式，它有一条很长的过滤器链。</p>
<p>客户端向服务端发送请求，然后应用根据请求的 <strong>URI</strong> 的路径来确定该请求的过滤器链（<strong>Filter</strong>）以及最终的具体 <strong>Servlet</strong> 控制器（<strong>Controller</strong>）</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E5%9F%BA%E7%A1%80%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<p>从上图我们可以看出 <strong>Spring Security</strong> 以一个单 <strong>Filter（FilterChainProxy）</strong> 存在于整个过滤器链中，而这个 <code>FilterChainProxy</code> 实际内部代理着众多的 <strong>Spring Security Filter（过滤器链）</strong> ，过滤器链的每个元素都是一组URL对应一组过滤器</p>
<h3 id="过滤器链形成"><a href="#过滤器链形成" class="headerlink" title="过滤器链形成"></a>过滤器链形成</h3><p>首先 众多的<strong>Filter</strong> 按照一定的顺序被 <code>SecurityBuilder</code> 的实现来组装为 <code>SecurityFilterChain</code> ，然后通过 <code>WebSecurity</code> 注入到 <code>FilterChainProxy</code> 中去，接着 <code>FilterChainProxy</code> 又在 <code>WebSecurityConfiguration</code> 中以 <code>springSecurityFilterChain</code> 的名称注册为 <strong>Spring Bean</strong> 。实际上还有一个隐藏层 <code>DelegatingFilterProxy</code> 代理了 <code>springSecurityFilterChain</code> 注入到最后整个 <strong>Servlet</strong> 过滤器链中，如下图</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<p><strong>Spring Security</strong> 允许有多条过滤器链并行，<strong>Spring Security</strong> 的 <code>FilterChainProxy</code> 可以代理多条过滤器链并根据不同的 <strong>URI</strong> 匹配策略进行分发。但是每个请求每次只能被分发到一条过滤器链，实际每条过滤链就是一个 <code>SecurityFilterChain</code>。如下图所示：</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/url%E5%8C%B9%E9%85%8D%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<h3 id="过滤器链中的过滤器"><a href="#过滤器链中的过滤器" class="headerlink" title="过滤器链中的过滤器"></a>过滤器链中的过滤器</h3><p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%9B%BE.jpg" alt=""></p>
<p>过滤器说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1） WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</span><br><span class="line"></span><br><span class="line">（2） SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder 中，然后在该次请求处理完成之后，将SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder 中的信息清除，例如在 Session 中维护一个用户的安全信息就是这个过滤器处理的。</span><br><span class="line"></span><br><span class="line">（3） HeaderWriterFilter：用于将头信息加入响应中。</span><br><span class="line"></span><br><span class="line">（4） CsrfFilter：用于处理跨站请求伪造。</span><br><span class="line"></span><br><span class="line">（5）LogoutFilter：用于处理退出登录。</span><br><span class="line"></span><br><span class="line">（6）UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 &#x2F;login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。</span><br><span class="line"></span><br><span class="line">（7）DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</span><br><span class="line"></span><br><span class="line">（8）BasicAuthenticationFilter：检测和处理 http basic 认证。</span><br><span class="line"></span><br><span class="line">（9）RequestCacheAwareFilter：用来处理请求的缓存。</span><br><span class="line"></span><br><span class="line">（10）SecurityContextHolderAwareRequestFilter：主要是包装请求对象 request。 </span><br><span class="line"></span><br><span class="line">（11）AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在Authentication 对象，如果不存在为其提供一个匿名 Authentication。 </span><br><span class="line"></span><br><span class="line">（12）SessionManagementFilter：管理 session 的过滤器</span><br><span class="line"></span><br><span class="line">（13）ExceptionTranslationFilter：处理 AccessDeniedException 和AuthenticationException 异常。</span><br><span class="line"></span><br><span class="line">（14）FilterSecurityInterceptor：可以看做过滤器链的出口。</span><br><span class="line"></span><br><span class="line">（15）RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安全框架</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security oauth2搭建</title>
    <url>/2020/11/29/spring%20security%20oauth2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>OAuth2是一套开放标准，Spring Cloud Security Oauth2是对它的一种实现。</p>
<a id="more"></a>

<h3 id="1-1-角色定义"><a href="#1-1-角色定义" class="headerlink" title="1.1 角色定义"></a>1.1 角色定义</h3><h4 id="1-1-1-客户端"><a href="#1-1-1-客户端" class="headerlink" title="1.1.1 客户端"></a>1.1.1 客户端</h4><p>​        本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，如：移动端、pc端等。</p>
<h4 id="1-1-2-资源拥有者"><a href="#1-1-2-资源拥有者" class="headerlink" title="1.1.2 资源拥有者"></a>1.1.2 资源拥有者</h4><p>​        通常为用户、也可为应用程序，即资源的拥有者。</p>
<h4 id="1-1-3-资源服务器"><a href="#1-1-3-资源服务器" class="headerlink" title="1.1.3  资源服务器"></a>1.1.3  资源服务器</h4><p>​        存储资源的服务器，一般为提供业务接口服务的程序。</p>
<h4 id="1-1-4-授权服务器"><a href="#1-1-4-授权服务器" class="headerlink" title="1.1.4 授权服务器"></a>1.1.4 授权服务器</h4><p>​        用于对资源拥有者的身份进行认证、对访问资源进行授权，认证成功发放令牌（access_token）给客户端，作为客户端访问资源服务器的凭证；授权服务器就是对客户端和资源拥有着进行认证授权，使其可以访问资源服务器获取资源。</p>
<h3 id="1-2-四种模式"><a href="#1-2-四种模式" class="headerlink" title="1.2 四种模式"></a>1.2 四种模式</h3><h4 id="1-2-1-授权码模式"><a href="#1-2-1-授权码模式" class="headerlink" title="1.2.1 授权码模式"></a>1.2.1 授权码模式</h4><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式，code保证了token的安全性，即使code被拦截，由于没有app_secret，也是无法通过code获得token的。</p>
<h4 id="1-2-2-隐式授权模式-简化模式"><a href="#1-2-2-隐式授权模式-简化模式" class="headerlink" title="1.2.2 隐式授权模式/简化模式"></a>1.2.2 隐式授权模式/简化模式</h4><p>和授权码模式类似，少了获取code的步骤，是直接获取令牌token的，适用于公开的浏览器单页应用，令牌直接从授权服务器返回，不支持刷新令牌，且没有code安全保证，令牌容易因为被拦截窃听而泄露。</p>
<h4 id="1-2-3-密码模式"><a href="#1-2-3-密码模式" class="headerlink" title="1.2.3 密码模式"></a>1.2.3 密码模式</h4><p>使用用户名/密码作为授权方式从授权服务器上获取令牌，一般不支持刷新令牌。</p>
<h4 id="1-2-4-客户端凭证模式"><a href="#1-2-4-客户端凭证模式" class="headerlink" title="1.2.4 客户端凭证模式"></a>1.2.4 客户端凭证模式</h4><p>一般用于资源服务器是应用的一个后端模块，客户端向认证服务器验证身份来获取令牌。</p>
<h2 id="二、授权服务搭建"><a href="#二、授权服务搭建" class="headerlink" title="二、授权服务搭建"></a>二、授权服务搭建</h2><h3 id="2-1-maven依赖"><a href="#2-1-maven依赖" class="headerlink" title="2.1 maven依赖"></a>2.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-配置类"><a href="#2-2-配置类" class="headerlink" title="2.2 配置类"></a>2.2 配置类</h3><h4 id="2-2-1-鉴权服务配置"><a href="#2-2-1-鉴权服务配置" class="headerlink" title="2.2.1 鉴权服务配置"></a>2.2.1 鉴权服务配置</h4><p>配置类添加@EnableAuthorizationServer，继承org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter类</p>
<p>需重写以下三个方法</p>
<h5 id="2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-："><a href="#2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-：" class="headerlink" title="2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ："></a>2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ：</h5><p>客户端详情信息服务配置，能够使用内存、jdbc方式来实现clientDetailsService（客户端详情服务），负责查找clientDetails。clientDetails能够在应用程序运行时进行更新，通过访问存储服务（如jdbcClientDetailsService）或自己实现ClientRegistrationService接口进行管理</p>
<p>关于clientDetails的几个属性如下：</p>
<ul>
<li>clientId:用来表示客户的id</li>
<li>secret：用来限制客户端的访问访问，如果为空（默认为空）的话，客户端拥有全部的访问范围</li>
<li>authorizedGrantType：客户端可以使用的授权类型，默认为空（client_credentials,password,authorization_code,implicit,refresh_token）</li>
<li>authorities：客户端可以使用的权限</li>
</ul>
<h5 id="2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-："><a href="#2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-：" class="headerlink" title="2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)："></a>2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)：</h5><p>令牌访问端点，用来配置令牌的访问端点和令牌服务</p>
<h5 id="2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-："><a href="#2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-：" class="headerlink" title="2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)："></a>2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)：</h5><p>令牌访问端点安全策略，用来配置令牌端点的安全约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfiguration</span>  <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizationCodeServices authorizationCodeServices;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.客户端详情信息服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂时使用内存方式</span></span><br><span class="line"><span class="comment">/*        clients.inMemory()</span></span><br><span class="line"><span class="comment">                //client_id</span></span><br><span class="line"><span class="comment">                .withClient("c1")</span></span><br><span class="line"><span class="comment">                //客户端秘钥</span></span><br><span class="line"><span class="comment">                .secret(passwordEncoder.encode("secret"))</span></span><br><span class="line"><span class="comment">                //可访问资源列表</span></span><br><span class="line"><span class="comment">                .resourceIds("r1")</span></span><br><span class="line"><span class="comment">                //允许该client授权的类型</span></span><br><span class="line"><span class="comment">                .authorizedGrantTypes("authorization_code","password","client_credentials","implicit","refresh_token")</span></span><br><span class="line"><span class="comment">                //允许授权范围</span></span><br><span class="line"><span class="comment">                .scopes("all")</span></span><br><span class="line"><span class="comment">                //如果使用授权码模式，false跳转到授权页面让用户进行授权，true直接发放令牌</span></span><br><span class="line"><span class="comment">                .autoApprove(false)</span></span><br><span class="line"><span class="comment">                //验证回调地址</span></span><br><span class="line"><span class="comment">                .redirectUris("http://baidu.com");*/</span></span><br><span class="line">        <span class="comment">//使用数据库方式</span></span><br><span class="line">        clients.withClientDetails(clientDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.1令牌管理服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices defaultTokenServices = <span class="keyword">new</span> DefaultTokenServices();</span><br><span class="line">        <span class="comment">//客户端信息服务</span></span><br><span class="line">        defaultTokenServices.setClientDetailsService(clientDetailsService);</span><br><span class="line">        <span class="comment">//是否产生刷新令牌</span></span><br><span class="line">        defaultTokenServices.setSupportRefreshToken(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//令牌存储策略</span></span><br><span class="line">        defaultTokenServices.setTokenStore(tokenStore);</span><br><span class="line">        <span class="comment">//令牌增强</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        defaultTokenServices.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">        <span class="comment">//令牌默认有效时间2小时</span></span><br><span class="line">        defaultTokenServices.setAccessTokenValiditySeconds(<span class="number">7200</span>);</span><br><span class="line">        <span class="comment">//刷新令牌默认有效时间</span></span><br><span class="line">        defaultTokenServices.setRefreshTokenValiditySeconds(<span class="number">259200</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultTokenServices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.2令牌访问端点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                <span class="comment">//密码模式需要(此处注入的管理类为security所配置)</span></span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                <span class="comment">//授权码模式需要</span></span><br><span class="line">                .authorizationCodeServices(authorizationCodeServices)</span><br><span class="line">                <span class="comment">//令牌管理服务</span></span><br><span class="line">                .tokenServices(tokenService())</span><br><span class="line">            	<span class="comment">//注入自己重写的userDetailsService进行自定义用户信息查询</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                <span class="comment">//允许post提交访问服务</span></span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.令牌访问端点安全策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> </span>&#123;</span><br><span class="line">        security</span><br><span class="line">                <span class="comment">//提供公有秘钥端点，用于jwt令牌 公开/oauth/token_key</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">// /oauth/check_token端点公开</span></span><br><span class="line">                .checkTokenAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">//允许表单认证</span></span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置授权码模式的授权码存储，暂时使用内存方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*    @Bean</span></span><br><span class="line"><span class="comment">    public AuthorizationCodeServices authorizationCodeServices()&#123;</span></span><br><span class="line"><span class="comment">        //设置授权码模式，暂时使用内存方式</span></span><br><span class="line"><span class="comment">        return new InMemoryAuthorizationCodeServices();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置授权码模式，暂时使用数据库方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDetailsService <span class="title">clientDetailsService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        JdbcClientDetailsService clientDetailsService = <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">        clientDetailsService.setPasswordEncoder(passwordEncoder);</span><br><span class="line">        <span class="keyword">return</span> clientDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-令牌存储策略配置"><a href="#2-2-2-令牌存储策略配置" class="headerlink" title="2.2.2 令牌存储策略配置"></a>2.2.2 令牌存储策略配置</h4><p>这里编写了三种令牌生成后的存储方式，根据自己的需求进行修改，后面的配置以jwt策略为准，在AuthorizationServerConfiguration类中的tokenService()进行令牌注入配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 令牌存储策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储时使用</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/*@Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore()&#123;</span></span><br><span class="line"><span class="comment">        //内存方式生成普通令牌</span></span><br><span class="line"><span class="comment">        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String SIGNING_KEY = <span class="string">"uaa123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jwt存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">accessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">//对称秘钥，资源服务器使用此秘钥来校验</span></span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">        RedisTokenStore tokenStore = new RedisTokenStore(redisConnectionFactory);</span></span><br><span class="line"><span class="comment">        //配置redis存储的key前缀</span></span><br><span class="line"><span class="comment">        tokenStore.setPrefix("myOauth2:");</span></span><br><span class="line"><span class="comment">        return tokenStore;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-security配置"><a href="#2-2-3-security配置" class="headerlink" title="2.2.3 security配置"></a>2.2.3 security配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">                .and().csrf().disable()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(web);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">       <span class="comment">/* BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();</span></span><br><span class="line"><span class="comment">        auth.inMemoryAuthentication().withUser("111").password(bCryptPasswordEncoder.encode("222")).authorities("user")</span></span><br><span class="line"><span class="comment">                .and().withUser("admin").password(bCryptPasswordEncoder.encode("admin")).authorities("admin");*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * oauth2 的密码模式需要在令牌访问端点注入此配置，管理security操作的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不使用加密方式的编码器，字符串比较</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="comment">//使用加密密码编码器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-四种模式的认证请求"><a href="#2-2-4-四种模式的认证请求" class="headerlink" title="2.2.4 四种模式的认证请求"></a>2.2.4 四种模式的认证请求</h4><h5 id="2-2-4-1-授权码模式（较安全模式）："><a href="#2-2-4-1-授权码模式（较安全模式）：" class="headerlink" title="2.2.4.1 授权码模式（较安全模式）："></a>2.2.4.1 授权码模式（较安全模式）：</h5><ul>
<li><p>申请授权码-GET：</p>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="http://yrlzero.gitee.io/images/oauth2/用户登录授权.jpg" alt="授权码模式 用户登录授权" style="zoom: 50%;" />



</li>
</ul>
<p>客户端进行授权请求（此处授权的客户端信息为oauth2表格维护的客户端信息），用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，通过回调url返回code（授权码）<a href="https://www.baidu.com/?code=m4aOtl" target="_blank" rel="noopener">https://www.baidu.com/?code=m4aOtl</a></p>
<ul>
<li><p>申请token-POST:</p>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl</a></p>
</li>
</ul>
<p>根据授权码和客户端secret等信息获取token(此处的token使用的是jwt)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2MjY0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiMDQ1N2ZiNTgtMmY0Ny00NGJmLTk0NzMtMTRiNWU2ZmI4M2ZmIiwiY2xpZW50X2lkIjoiYzEifQ.EjYisjGOtqrTJQc7nqWBtaStphF1PxTe07_pC0oireM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiIwNDU3ZmI1OC0yZjQ3LTQ0YmYtOTQ3My0xNGI1ZTZmYjgzZmYiLCJleHAiOjE2MDY4Nzg0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNGQ4NjMxM2YtYjI3Zi00NTZiLWJlYzItMjc1NDY2N2UwMjIwIiwiY2xpZW50X2lkIjoiYzEifQ.1qItJNh8cGEiTEGJY1b2gBeeGq904lx8sZB7GaRMPmk"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"0457fb58-2f47-44bf-9473-14b5e6fb83ff"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-2-隐式授权模式-简化模式"><a href="#2-2-4-2-隐式授权模式-简化模式" class="headerlink" title="2.2.4.2 隐式授权模式/简化模式"></a>2.2.4.2 隐式授权模式/简化模式</h5><ul>
<li>申请token-GET：</li>
</ul>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="http://yrlzero.gitee.io/images/oauth2/用户登录授权.jpg" style="zoom:50%;" />

<p>此模式不需要获取授权码，用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，回调url返回token</p>
<p><a href="https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906" target="_blank" rel="noopener">https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906</a></p>
<h5 id="2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险"><a href="#2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险" class="headerlink" title="2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)"></a>2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)</h5><ul>
<li>申请token-POST:</li>
</ul>
<p><a href="http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret" target="_blank" rel="noopener">http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjg0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNDRjZjNlN2QtNjIwYi00M2FhLThjMWItMGZkMWVkZjE3YTMwIiwiY2xpZW50X2lkIjoiYzEifQ.N_Wd2DKyEpzGBmnvnDrP-vx4lSzIjiInQRNTsJtxMkM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiI0NGNmM2U3ZC02MjBiLTQzYWEtOGMxYi0wZmQxZWRmMTdhMzAiLCJleHAiOjE2MDY4ODA0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNmJiOWQ5YTAtYzhiYi00ZDk4LTgwMGYtMzY1NGY5ZjU1MDgxIiwiY2xpZW50X2lkIjoiYzEifQ.AL2ODdEhSKwuzrkYCvikY6UBrljFBroPtFiI9UT5xs4"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"44cf3e7d-620b-43aa-8c1b-0fd1edf17a30"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token"><a href="#2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token" class="headerlink" title="2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)"></a>2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)</h5><ul>
<li>申请token-POST</li>
</ul>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwic2NvcGUiOlsiUk9MRV9BRE1JTiIsIlJPTEVfVVNFUiIsIlJPTEVfQVBJIl0sImV4cCI6MTYwNjYyODU2MSwianRpIjoiZDBmODBjNTEtMWU5Ny00ODA5LThjNmEtYmEzYjYzNTZhMGE5IiwiY2xpZW50X2lkIjoiYzEifQ.I7KIvzQLYqlkzMQqw2hOPZ-ev8cV4ehoDU9LsP4qAAM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_ADMIN ROLE_USER ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"d0f80c51-1e97-4809-8c6a-ba3b6356a0a9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"><a href="#三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）" class="headerlink" title="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"></a>三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）</h2><h3 id="3-1-maven依赖（同鉴权服务）"><a href="#3-1-maven依赖（同鉴权服务）" class="headerlink" title="3.1 maven依赖（同鉴权服务）"></a>3.1 maven依赖（同鉴权服务）</h3><h3 id="3-2-配置类"><a href="#3-2-配置类" class="headerlink" title="3.2 配置类"></a>3.2 配置类</h3><h4 id="3-2-1-资源服务配置"><a href="#3-2-1-资源服务配置" class="headerlink" title="3.2.1 资源服务配置"></a>3.2.1 资源服务配置</h4><p>对于token的校验可以请求远程auth服务，也可以使用其他tokenStore进行自我校验，本次使用jwt方式进行自我校验，不请求远程资源服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源服务配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//符合对应的scope才能访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不用记录session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//资源id</span></span><br><span class="line">        resources.resourceId(RESOURCE_ID)</span><br><span class="line">                <span class="comment">//验证令牌服务(远程校验)</span></span><br><span class="line"><span class="comment">//                .tokenServices(tokenService())</span></span><br><span class="line">                <span class="comment">//本服务自身校验jwt令牌</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .stateless(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//权限不足处理类</span></span><br><span class="line">                .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程请求校验令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResourceServerTokenServices <span class="title">tokenService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="string">"http://localhost:9305/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="string">"c1"</span>);</span><br><span class="line">        services.setClientSecret(<span class="string">"secret"</span>);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-令牌存储策略（同鉴权服务2-2-2）"><a href="#3-2-2-令牌存储策略（同鉴权服务2-2-2）" class="headerlink" title="3.2.2 令牌存储策略（同鉴权服务2.2.2）"></a>3.2.2 令牌存储策略（同鉴权服务2.2.2）</h4><h4 id="3-2-3-security配置"><a href="#3-2-3-security配置" class="headerlink" title="3.2.3 security配置"></a>3.2.3 security配置</h4><p>将方法权限的控制交给security</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/order/r1"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"order/r2"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                <span class="comment">//所有/order/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/order/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/order/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、网关资源校验服务"><a href="#四、网关资源校验服务" class="headerlink" title="四、网关资源校验服务"></a>四、网关资源校验服务</h2><p>网关进行token校验，合法后对用户和权限信息封装，再下发下游服务，下游服务可以不再集成oauth2依赖，获取网关封装的权限信息，再次封装入security的上下文中，通过security完成权限校验</p>
<ul>
<li>网关对鉴权服务的认证请求放行</li>
<li>网关的资源服务会对用户的请求进行合法性校验</li>
<li>网关过滤器对token进行封装自定义用户信息json格式下发下游服务</li>
<li>下游服务过滤器对自定义用户权限信息封装的security安全上下文中</li>
<li>security接管下游服务的权限控制</li>
</ul>
<h3 id="4-1-maven依赖"><a href="#4-1-maven依赖" class="headerlink" title="4.1 maven依赖"></a>4.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网关依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-配置类"><a href="#4-2-配置类" class="headerlink" title="4.2 配置类"></a>4.2 配置类</h3><h4 id="4-2-1-资源服务配置"><a href="#4-2-1-资源服务配置" class="headerlink" title="4.2.1 资源服务配置"></a>4.2.1 资源服务配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oauth2资源服务配置类</span></span><br><span class="line"><span class="comment"> *      网关整合都有的微服务资源拦截</span></span><br><span class="line"><span class="comment"> *      此类用于配置每个微服务的资源配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源id(实际使用时，每个服务对应自己的资源id)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * auth微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//权限不足处理类</span></span><br><span class="line">                    .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                    <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                    .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                	<span class="comment">//需要放行，否则用户无法获取token</span></span><br><span class="line">                    .antMatchers(<span class="string">"/auth/**"</span>).permitAll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pay微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">"/api/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-令牌存储策略配置（同鉴权服务2-2-2）"><a href="#4-2-2-令牌存储策略配置（同鉴权服务2-2-2）" class="headerlink" title="4.2.2 令牌存储策略配置（同鉴权服务2.2.2）"></a>4.2.2 令牌存储策略配置（同鉴权服务2.2.2）</h3><h3 id="4-2-3-security配置"><a href="#4-2-3-security配置" class="headerlink" title="4.2.3 security配置"></a>4.2.3 security配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * security拦截配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-过滤器封装token用户及权限信息"><a href="#4-2-4-过滤器封装token用户及权限信息" class="headerlink" title="4.2.4 过滤器封装token用户及权限信息"></a>4.2.4 过滤器封装token用户及权限信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该过滤器进行权限信息解析，封装到header路由转发都下级微服务</span></span><br><span class="line"><span class="comment"> *      下级微服务将权限信息放入security上下文中，从而可以使用security的权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取令牌内容</span></span><br><span class="line">        RequestContext currentContext = RequestContext.getCurrentContext();</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是oauth认证信息，无法访问</span></span><br><span class="line">        <span class="keyword">if</span> (!(authentication <span class="keyword">instanceof</span> OAuth2Authentication)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication;</span><br><span class="line">        Authentication userAuthentication = oAuth2Authentication.getUserAuthentication();</span><br><span class="line">        Object principal = userAuthentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装明文token，转发给微服务，放入header，名称为json-token</span></span><br><span class="line">        List&lt;String&gt; authList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        userAuthentication.getAuthorities().forEach(auth-&gt; authList.add(auth.getAuthority()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        OAuth2Request oAuth2Request = oAuth2Authentication.getOAuth2Request();</span><br><span class="line">        Map&lt;String, String&gt; requestParameters = oAuth2Request.getRequestParameters();</span><br><span class="line">        Map&lt;String,Object&gt; jsonToken = <span class="keyword">new</span> HashMap&lt;&gt;(requestParameters);</span><br><span class="line">        jsonToken.put(<span class="string">"principal"</span>,principal);</span><br><span class="line">        jsonToken.put(<span class="string">"authorities"</span>,authList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String jsonTokenStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonTokenStr = objectMapper.writeValueAsString(jsonToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将身份信息和权限信息放在json中，加入header中，转发给下级微服务</span></span><br><span class="line">        currentContext.addZuulRequestHeader(<span class="string">"json-token"</span>, Base64.getEncoder().encodeToString(jsonTokenStr.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-自定义处理类"><a href="#4-2-5-自定义处理类" class="headerlink" title="4.2.5 自定义处理类"></a>4.2.5 自定义处理类</h3><h4 id="4-2-5-1-权限不足处理类"><a href="#4-2-5-1-权限不足处理类" class="headerlink" title="4.2.5.1 权限不足处理类"></a>4.2.5.1 权限不足处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权拒绝处理器，覆盖默认的OAuth2AccessDeniedHandler</span></span><br><span class="line"><span class="comment"> * 当权限不足时走此类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">extends</span> <span class="title">OAuth2AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 授权拒绝处理，使用R包装</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request       request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response      response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> authException authException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException authException)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"授权失败，禁止访问 &#123;&#125;"</span>, request.getRequestURI());</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		response.setStatus(HttpStatus.FORBIDDEN.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(<span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足，禁止访问"</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-2-各种AuthenticationException细化处理"><a href="#4-2-5-2-各种AuthenticationException细化处理" class="headerlink" title="4.2.5.2 各种AuthenticationException细化处理"></a>4.2.5.2 各种AuthenticationException细化处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以根据 AuthenticationException 不同细化异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceAuthExceptionEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResourceAuthExceptionEntryPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		Result result = <span class="keyword">new</span> Result();</span><br><span class="line">		result.setCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		<span class="keyword">if</span> (authException != <span class="keyword">null</span>) &#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			result.setData(authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(authException.getCause() == <span class="keyword">null</span>)&#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			logger.error(<span class="string">"no right to access or token invalid!,msg:&#123;&#125;"</span>,authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			String exceptionStr = authException.getCause().toString();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"unauthorized"</span>)) &#123;<span class="comment">//oauth2.0认证,用户不存在</span></span><br><span class="line">				result.setCode(<span class="number">11</span>);</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_grant"</span>)) &#123;<span class="comment">//oauth2.0认证,密码错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_token"</span>)) &#123;<span class="comment">//oauth2.0认证,token无效</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">		 	&#125;  <span class="keyword">else</span> &#123;<span class="comment">//其他错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_ERROR.getIndex());</span><br><span class="line"></span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_ERROR.getText(),authException);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、下游资源微服务"><a href="#五、下游资源微服务" class="headerlink" title="五、下游资源微服务"></a>五、下游资源微服务</h2><h3 id="5-1-maven依赖"><a href="#5-1-maven依赖" class="headerlink" title="5.1 maven依赖"></a>5.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2 配置"></a>5.2 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限不足处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来解决匿名用户访问无权限资源时的异常处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/pay/r1"</span>).hasAuthority(<span class="string">"p3"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"pay/r2"</span>).hasAuthority(<span class="string">"p1"</span>)</span><br><span class="line">                <span class="comment">//所有/pay/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/pay/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/pay/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">        http.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line">    http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-自定义异常处理"><a href="#5-3-自定义异常处理" class="headerlink" title="5.3 自定义异常处理"></a>5.3 自定义异常处理</h3><h4 id="5-3-1-权限不足"><a href="#5-3-1-权限不足" class="headerlink" title="5.3.1 权限不足"></a>5.3.1 权限不足</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 权限不足效验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足"</span>);</span><br><span class="line">        HttpResponseUtil.responseJsonWriter(httpServletResponse,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-匿名用户无权限处理"><a href="#5-3-2-匿名用户无权限处理" class="headerlink" title="5.3.2 匿名用户无权限处理"></a>5.3.2 匿名用户无权限处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationEntryPoint</span>  <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"超过登录有效期，请重新登录！"</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        HttpResponseUtil.responseJsonWriter(response, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-封装自定义权限到security安全上下文"><a href="#5-4-封装自定义权限到security安全上下文" class="headerlink" title="5.4 封装自定义权限到security安全上下文"></a>5.4 封装自定义权限到security安全上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将网关下发的权限信息放入security上下文中，交由security进行权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析header中的token</span></span><br><span class="line">        String token = httpServletRequest.getHeader(<span class="string">"json-token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(token))&#123;</span><br><span class="line">            String jsonTokenStr = <span class="keyword">new</span> String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8);</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            JsonNode jsonNode = objectMapper.readTree(jsonTokenStr);</span><br><span class="line">            String principal = jsonNode.get(<span class="string">"principal"</span>).asText();</span><br><span class="line">            UserPo userPo = <span class="keyword">new</span> UserPo();</span><br><span class="line">            userPo.setUsername(principal);</span><br><span class="line">            Iterator&lt;JsonNode&gt; authorities = jsonNode.get(<span class="string">"authorities"</span>).iterator();</span><br><span class="line">            List&lt;String&gt; authList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (authorities.hasNext())&#123;</span><br><span class="line">                authList.add(authorities.next().asText());</span><br><span class="line">            &#125;</span><br><span class="line">            String[] authArr = authList.toArray(<span class="keyword">new</span> String[authList.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装新的权限token</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken =</span><br><span class="line">                    <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userPo,<span class="keyword">null</span>, AuthorityUtils.createAuthorityList(authArr));</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(httpServletRequest));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入security上下文</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-自定义security权限注解校验"><a href="#5-5-自定义security权限注解校验" class="headerlink" title="5.5 自定义security权限注解校验"></a>5.5 自定义security权限注解校验</h3><h4 id="5-5-1-处理类"><a href="#5-5-1-处理类" class="headerlink" title="5.5.1 处理类"></a>5.5.1 处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限判断工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"pms"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断接口是否有xxx:xxx权限</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> permission 权限</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isEmpty(permission))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> (authentication == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		UserPo userPo = (UserPo) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">		<span class="keyword">return</span> authorities.stream()</span><br><span class="line">			.map(GrantedAuthority::getAuthority)</span><br><span class="line">			.filter(StringUtils::hasText)</span><br><span class="line">			.anyMatch(x -&gt; PatternMatchUtils.simpleMatch(permission, x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-注解"><a href="#5-5-2-注解" class="headerlink" title="5.5.2 注解"></a>5.5.2 注解</h4><p>方法上添加注解进行权限控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"@pms.hasPermission('p1')"</span> )</span><br></pre></td></tr></table></figure>

<h2 id="六、数据库表格"><a href="#六、数据库表格" class="headerlink" title="六、数据库表格"></a>六、数据库表格</h2><p><a href="https://www.cnblogs.com/zxy-come-on/p/14047791.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxy-come-on/p/14047791.html</a></p>
]]></content>
      <categories>
        <category>安全框架</category>
        <category>ouath2</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>oauth2 - cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码登录</title>
    <url>/2021/04/17/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://yrlzero.gitee.io/images/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png" alt="二维码扫码登录"></p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC端</span><br><span class="line">	1、&#96;pc端&#96;请求&#96;服务端&#96;生成二维码，获取二维码id</span><br><span class="line">	4、&quot;未扫描&quot;状态下，&#96;pc端&#96;轮询&#96;服务端&#96;二维码状态，返回&quot;已扫描&quot;状态，显示等待用户在&#96;移动端&#96;确认</span><br><span class="line">	9、&quot;已扫描&quot;状态下，&#96;pc端&#96;轮询&#96;服务端&#96;二维码状态&quot;已确认&quot;状态，获取&#96;服务端&#96;返回的登录token，完成扫码登录</span><br><span class="line">	</span><br><span class="line">移动端</span><br><span class="line">	3、&#96;移动端&#96;扫描二维码获取&#96;PC端&#96;保存的二维码id</span><br><span class="line">	5、&#96;移动端&#96;调用服务端扫码接口传送&#96;移动端&#96;用户身份信息和二维码id</span><br><span class="line">	7、&#96;移动端&#96;调用服务端用户确认接口，传送临时token</span><br><span class="line">	</span><br><span class="line">服务端</span><br><span class="line">	2、接收pc端生成二维码的请求，绑定该pc终端信息并生成二维码id，状态“未扫描”</span><br><span class="line">	6、接收移动端扫码请求（app身份信息和二维码id），更改二维码状态为“已扫描”，返回临时token（保证之后的确认操作与扫描操作是同一设备）</span><br><span class="line">	8、接收移动端用户确认请求（临时token），修改二维码状态为“已确认”，根据&#96;PC&#96;的设备信息和&#96;移动端&#96;的用户信息生成用户的pc登录token</span><br><span class="line">	</span><br><span class="line">服务端接口</span><br><span class="line">	生成二维码接口，</span><br><span class="line">		入参：pc终端信息</span><br><span class="line">		返参：生成二维码id</span><br><span class="line">	扫码接口</span><br><span class="line">		入参：移动端身份信息、二维码id</span><br><span class="line">		返参：临时token（保证之后的确认操作与扫描操作是同一设备）</span><br><span class="line">	确认接口</span><br><span class="line">		入参：临时token、二维码id</span><br><span class="line">		返参：成功、失败</span><br><span class="line">	轮询状态接口</span><br><span class="line">		入参：二维码id</span><br><span class="line">		返参：二维码状态、</span><br><span class="line">			  登录token（已确认状态返回）</span><br><span class="line">			  </span><br><span class="line">前端二维码内容：二维码id或二维码id的一个url地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池-基本概念</title>
    <url>/2020/12/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="一、常见线程池"><a href="#一、常见线程池" class="headerlink" title="一、常见线程池"></a>一、常见线程池</h2><h3 id="1-Executors-newFixedThreadPool"><a href="#1-Executors-newFixedThreadPool" class="headerlink" title="1.Executors.newFixedThreadPool()"></a>1.Executors.newFixedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值是相等的，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造方法</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-Executors-newSingleThreadExecutor"><a href="#2-Executors-newSingleThreadExecutor" class="headerlink" title="2.Executors.newSingleThreadExecutor()"></a>2.Executors.newSingleThreadExecutor()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值为1，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造</span><br><span class="line">	return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure>

<h3 id="3-Executors-newCachedThreadPool"><a href="#3-Executors-newCachedThreadPool" class="headerlink" title="3.Executors.newCachedThreadPool()"></a>3.Executors.newCachedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程corePoolSize的值为0，maximumPoolSize的值为Integer,MAX_VALUE，使用的队列是SynchronousQueue。有任务时就创建线程运行，当线程空闲60s就销毁线程</span><br><span class="line">构造</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="二、线程池底层调用"><a href="#二、线程池底层调用" class="headerlink" title="二、线程池底层调用"></a>二、线程池底层调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line">--&gt; 调用自身七参构造方法public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br><span class="line">	 int corePoolSize:线程池中常驻核心线程数</span><br><span class="line">	 int maximumPoolSize：线程池能够容纳同时执行你的最大线程数，此值必须大于等于1</span><br><span class="line">	 long keepAliveTime：多余的空闲线程存活时间，当前线程池超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止</span><br><span class="line">	 TimeUnit unit：keepAliveTime的单位</span><br><span class="line">	 BlockingQueue&lt;Runnable&gt; workQueue：任务队列，被提交但尚未被执行的任务</span><br><span class="line">	 ThreadFactory threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认即可</span><br><span class="line">	 RejectedExecutionHandler handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize）时如何来拒绝</span><br></pre></td></tr></table></figure>

<h2 id="三、线程池底层原理"><a href="#三、线程池底层原理" class="headerlink" title="三、线程池底层原理"></a>三、<a href="https://yrlzero.gitee.io/2021/05/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/#1%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">线程池底层原理</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）在创建了线程池后，等待提交过来的任务请求</span><br><span class="line">2）当调用execute()方法添加一个请求任务时，线程会做如下判断</span><br><span class="line">	2.1）如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</span><br><span class="line">	2.2）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</span><br><span class="line">	2.3）如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</span><br><span class="line">	2.4）如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</span><br><span class="line">3）当一个线程完成任务时，它会从队列中取下一个任务来执行</span><br><span class="line">4）当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</span><br><span class="line">	4.1) 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</span><br><span class="line">	4.2）所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小</span><br></pre></td></tr></table></figure>

<h2 id="四、线程池拒绝策略"><a href="#四、线程池拒绝策略" class="headerlink" title="四、线程池拒绝策略"></a>四、线程池拒绝策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行</span><br><span class="line"></span><br><span class="line">CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低任务流量</span><br><span class="line"></span><br><span class="line">DiscardOldestPolicy:抛弃任务中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</span><br><span class="line"></span><br><span class="line">DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案</span><br></pre></td></tr></table></figure>

<h2 id="五、自定义创建线程"><a href="#五、自定义创建线程" class="headerlink" title="五、自定义创建线程"></a>五、自定义创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">		<span class="number">2</span>,</span><br><span class="line">		<span class="number">5</span>,</span><br><span class="line">		<span class="number">1L</span>,</span><br><span class="line">		TimeUnit.SECONDS,</span><br><span class="line">		<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">		Executors.defaultThreadFactory(),</span><br><span class="line">		<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么不能使用常见的这三个线程池？</span><br><span class="line">因为newFixedThreadPool和newSingleThreadExecutor允许创建的队列长度Integer.MAX_VALUE，长度为21亿，可能会堆积大量请求，容易造成OOM；</span><br><span class="line">而newCachedThreadPool 和 newScheduledThreadPool允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，容易造成OOM</span><br><span class="line"></span><br><span class="line">如何设置线程数？</span><br><span class="line">CPU密集型，该任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量，CPU核数+1个线程</span><br><span class="line">IO密集型 该任务需要大量的IO，即大量的阻塞，</span><br><span class="line">	由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，</span><br><span class="line">	1.常见公式：CPU核数*2</span><br><span class="line">	2. CPU核数 &#x2F; （1 - 阻塞系数）  阻塞系数0.8-09之间</span><br><span class="line"></span><br><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</span><br><span class="line">的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line">说明： Executors 返回的线程池对象的弊端如下：</span><br><span class="line">	1） FixedThreadPool 和 SingleThreadPool :</span><br><span class="line">			允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。</span><br><span class="line">	2） CachedThreadPool 和 ScheduledThreadPool :</span><br><span class="line">			允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>不同版本HashMap和ConcurrentHashMap区分</title>
    <url>/2021/03/31/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACHashMap-ConcurrentHashMap%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="HashMap区别"><a href="#HashMap区别" class="headerlink" title="HashMap区别"></a>HashMap区别</h2><p>JDK7和JDK8中的HashMap底层数据结构有什么区别?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK7:数组 + 链表</span><br><span class="line">JDK8:数组 + 链表 + 红黑树</span><br><span class="line">     链表包括单向链表和双向链表，双线链表主要是为了链表操作方便，在插入、扩容链表转红黑树的过程中使用</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>JDK8中的HashMap为什么要使用红黑树？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当元素个数小于一个阈值时，链表在整体效率上要高于红黑树，当元素个数大于此阈值时，链表整体的查询效率要低于红黑树，此阈值在HashMap中为8。转换成红黑树可以平衡插入和查询效率。</span><br><span class="line"></span><br><span class="line">链表查询效率：O(N)</span><br><span class="line">链表插入效率：O(1)</span><br><span class="line"></span><br><span class="line">红黑树查询效率：O(logN)</span><br><span class="line">红黑树插入效率：O(logN)</span><br></pre></td></tr></table></figure>

<p>JDK8中的HashMap什么时候将链表转化成红黑树？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当链表中的元素大于8，并且数组的长度大于等于64时，才会将链表转化成红黑树。</span><br><span class="line">当数组的长度低于64时，通过扩容数组大小来缩小链表的长度。</span><br></pre></td></tr></table></figure>

<p>JDK8中的HashMap的put方法的实现过程？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.根据Key生成HashCode</span><br><span class="line">2.判断当前HashMap对象中的数组是否为空，如果为空则初始化数组</span><br><span class="line">3.根据逻辑与运算，算出HashCode基于当前数组对应的数组下标i</span><br><span class="line">4.判断数组的第i个位置的元素(tab[i])是否为空</span><br><span class="line">   a.如果为空，则将key,value封装为Node对象赋值给tab[i]</span><br><span class="line">   b.如果不为空：</span><br><span class="line">     I.如果put方法传入进来的key等于tab[i].key，那么存在相同的key</span><br><span class="line">     II.如果不等于tab[i].key，则:</span><br><span class="line">       1.如果tab[i]的类型是TreeNode，插入红黑树之前判断树中是否存在相同的key,然后Key和Value插入到红黑树中</span><br><span class="line">       2.如果tab[i]的类型不是TreeNode，则表示当前是个链表，遍历寻找相同的key，找不到则插入，然后判断是否Size大于8，大于则树化。</span><br><span class="line">     III.如果上诉步骤发现相同的key，则更新value值，返回oldValue</span><br><span class="line">5.modCount++</span><br><span class="line">6.HashMap的元素个数size + 1</span><br><span class="line">7.如果size大于扩容阈值，则进行扩容</span><br></pre></td></tr></table></figure>

<p>JDK8中HashMap的get方法的实现过程?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.根据Key生成HashCode</span><br><span class="line">2.如果数组为空，则直接返回空</span><br><span class="line">3.如果数组不为空，则利用HashCode和数组长度通过逻辑与操作是厒Key所对应的数组下标i</span><br><span class="line">4.如果数组的第i个位置上没有元素，则直接返回空</span><br><span class="line">5.如果数组的第1个位置上的元素key等于get方法传进来的key，则返回该元素，并取该元素的value</span><br><span class="line">6.如果不等于则判断该元素有没有下一个元素，如果没有，返回空</span><br><span class="line">7.如果有则判断该元素的类型是链表节点还是红黑树节点</span><br><span class="line">  a.如果是链表则遍历链表</span><br><span class="line">  b.如果是红黑树则遍历红黑树</span><br><span class="line">8.找到则返回元素，没找到则返回空</span><br></pre></td></tr></table></figure>

<p>JDK7与JDK8中HashMap的不同点?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.JDK8使用了红黑树</span><br><span class="line">2.JDK7中链表插入使用的头插法，但是会造成循环链表CPU100%的问题，JDK8使用尾插法</span><br><span class="line">3.JDK7的Hash算法比JDK8复杂，散列性更好能提高链表查询效率，而JDK8增加红黑树查询性能得到保障，所以简化了Hash算法</span><br><span class="line">4.扩容的过程JDK7可能会对Key进行reHash(和Hash种子有关)，而JDK8&#x3D;的Key没有reHash的过程</span><br><span class="line">5.JDK8中的扩容条件和JDK7不同，在JDK7中，若tab[i]为空，则不进行扩容，而JDK8移除了该条件</span><br><span class="line">6.JDK8增加了API：putIfAbsent(Key,Value)</span><br><span class="line">7.扩容过程转移元素的逻辑不同，JDK7是一次转移一个元素，JDK8是算出尾部同一个位置的数组直接头结点迁移</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap区别"><a href="#ConcurrentHashMap区别" class="headerlink" title="ConcurrentHashMap区别"></a>ConcurrentHashMap区别</h2><p>JDK7中的ConcurrentHashMap是怎么保证并发安全的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用 Unsafe操作 + ReentrantLock + 分段思想</span><br><span class="line">Unsafe操作：</span><br><span class="line">1.compareAndSwapObject : CAS方式修改对象的属性</span><br><span class="line">2.putOrderedObject : 并发安全的给数组的某个位置赋值</span><br><span class="line">3.getObjectVolatile ： 并发安全的获取数组某个位置的元素</span><br><span class="line"></span><br><span class="line">分段思想是为了提高ConcurrentHashMap的并发量，分段越高则支持的最大并发量越高。</span><br><span class="line">并发量根据concurrencyLevel参数指定，内部类Segment表示一个段。</span><br><span class="line"></span><br><span class="line">每个Segment是一个小型的HashMap，Segment类继承ReentrantLock，所以自带重入锁，put方法时加锁，再插入值，然后解锁。</span><br></pre></td></tr></table></figure>

<p>JDK7中的ConcurrentHashMap的底层原理?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap底层是由两层嵌套数组实现的：</span><br><span class="line">1.ConcurrentHashMap对象中有一个属性segments，类型Segment[]</span><br><span class="line">2.Segment对象中有一个属性table,类型HashEntry[]</span><br><span class="line"></span><br><span class="line">当调用put方法时，根据Key计算出Segment[]数组下标，若为空，则初始化Segment对象，然后调用Segment对象的put方法.</span><br><span class="line">Segment对象的put方法会先加锁，然后根据Key计算出HashEntry[]数组下标，并放到链表中。</span><br><span class="line"></span><br><span class="line">加锁过程是通过CAS加锁，超过一定次数就会阻塞等待加锁。</span><br></pre></td></tr></table></figure>

<p>JDK8中的ConcurrentHashMap是怎么保证并发安全的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用 Unsafe操作 + synchronized关键字</span><br><span class="line">Unsave操作的使用和JDK7中的类似，主要负责并发安全的修改对象的属性活数组某个位置的值。</span><br><span class="line"></span><br><span class="line">synchronized主要负责对tab[i]元素时进行加锁(该位置不为空)，若该位置为空，则采用CAS赋值tab[i]</span><br><span class="line">tab[i]若是链表，则是链表头结点，若是红黑树，则是TreeBin对象。</span><br><span class="line"></span><br><span class="line">JDK8中也有分段锁的思想，只不过JDK7中段数是可以控制的，而JDK8中针对数组的每一个位置(tab[i]元素)</span><br></pre></td></tr></table></figure>

<p>JDK8中的ConcurrentHashMap的put方法的实现流程？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当向ConcurrentHashMap中put一个Key,Value时：</span><br><span class="line">1.首先根据Key计算对应的数组下标，如果该位置没有元素，则通过CAS去赋值该位置</span><br><span class="line">2.如果该位置有元素，则synchronized加锁</span><br><span class="line">3.加锁成功后，判断该元素的类型</span><br><span class="line">  a.如果是链表，则将新节点添加到链表中</span><br><span class="line">  b.如果是红黑树，则将新节点添加到红黑树中</span><br><span class="line">4.添加成功后，判断是否需要进行树化</span><br><span class="line">5.addCount，并发安全地对ConcurrentHashMap元素个数 + 1(采用了LongAdder思想)，然后判断是否需要扩容</span><br><span class="line">6.同时线程在put时如果发现当前ConcurrentHashMap正在进行扩容(tab[i]&#x3D;FWD类型的对象)，则会去帮助扩容(并发扩容)。</span><br></pre></td></tr></table></figure>

<p>JDK7和JDK8中，统计元素个数的实现逻辑有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK7:</span><br><span class="line">1.第一次遍历累加Segment[]数组中的count属性</span><br><span class="line">2.第二次遍历累加Segmeng[]数组中的count属性</span><br><span class="line">3.如果在两次遍历过程中，结果不相等，则再遍历第三次累加，和第二次的结果对比，若相等则返回</span><br><span class="line">4.若还是不等，则对Segment数组的上的所有元素加锁，然后计算</span><br><span class="line"></span><br><span class="line">JDK8：</span><br><span class="line">1.有一个baseCount的属性，供以CAS操作，并借鉴了LongAdder的设计思想</span><br><span class="line">2.当baseCount在CAS竞争激烈时，使用CounterCell[]数组提供多个篮子进行资源分散</span><br><span class="line">3.只要能对篮子中的值CAS成功后，即可</span><br><span class="line">4.最终统计时，通过累加baseCount + CounterCell[] 得到结果。</span><br></pre></td></tr></table></figure>

<p>JDK7和JDK8中，都支持多线程并发扩容吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">都支持多线程扩容。</span><br><span class="line">在JDK7中，扩容只是针对一个Segment对象中的HashEntry[]对象，所以能够达到多个线程同时扩容不同的Segment对象。</span><br><span class="line">在JDK8中，每个线程迁移指定步长下标的元素，并发操作，达到多线程同时扩容一个tab数组。</span><br><span class="line"></span><br><span class="line">JDK8的扩容性能更高，因为JDK8对任意一个线程都可以帮助扩容，而JDK7一个线程扩容一个Segment。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>四种引用-强软弱虚</title>
    <url>/2020/12/12/%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A/</url>
    <content><![CDATA[<h2 id="一、强引用"><a href="#一、强引用" class="headerlink" title="一、强引用"></a>一、强引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</span><br><span class="line">在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。</span><br><span class="line">当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，及时该对象以后永远都不会被用到jvm也不会回收。</span><br><span class="line">因此强引用时造成java内存泄露的主要原因之一。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="二、软引用"><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一种相对强引用弱化了一些的引用，需要java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</span><br><span class="line">当系统内存充足时，它不会被回收，当系统内存不足时，会被回收。</span><br><span class="line">通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用时候就保留，不够用就回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如有一个应用需要读取大量的本地图片,如果每次读取图片都从硬盘读取则会严重影响性能,如果一次性全部加载到内存中有可能造成内存溢出</span><br><span class="line"></span><br><span class="line">此时可以使用软引用解决这个问题。</span><br><span class="line">思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，</span><br><span class="line">在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM的问题。</span><br><span class="line">Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="三、弱引用"><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.WeakReference类来实现。</span><br><span class="line">它比软引用的生存期更短，只要垃圾回收机制一运行，不管内存空间是否充足，都会被回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;M&gt; tl &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">tl.set(new M());</span><br><span class="line">tl.remove();</span><br><span class="line"></span><br><span class="line">ThreadLocal的应用中，每个线程有自己的ThreadLocalMap，根据ThreadLocal对象找到其对应的值。</span><br><span class="line">ThreadLocalMap里面存放的Entry继承了WeakReference，当创建Entry是会调用super(key)方法进行创建，key指向tl对象，也就是说这个key是一个弱引用。</span><br><span class="line">若是强引用，即使tl&#x3D;null,但是key的引用依然指向ThreadLocal对象，只要ThreadLocalMap在就不会被回收，所以会有内存泄漏，而是用弱引用则不会。</span><br><span class="line">当tl没有额外的强引用指向时，即使key引用了tl，因为key是弱引用，遇到GC时tl也会开始回收。</span><br><span class="line"></span><br><span class="line">注意：当key被回收时，无法根据key找到对应的value，只要ThreadLocalMap在就不会被回收，也会存在泄漏，所以必须使用tl.remove()进行移除</span><br></pre></td></tr></table></figure>

<h2 id="四、虚引用"><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.PhantomRefrnce类来实现，如果一个对象仅持有虚引用，那么它和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</span><br><span class="line">它不能单独使用，也不能单独访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</span><br><span class="line">主要作用是跟踪对象被垃圾回收的状态，提供一种确保对象被finalize以后做某些事情的机制，一般是来管理堆外内存的。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NIO有个DirectByteBuffer是用来操作堆外内存的，堆外内存由操作系统管理，gc无法回收，当DirectByteBuffer为null时，可以通过虚引用的方式检测到，此时Reference&lt;? extends M&gt; poll &#x3D; QUEUE.poll();可以获得GC回收的通知，进而去执行自定义的逻辑清理堆外内存。</span><br><span class="line"></span><br><span class="line">堆外内存操作：</span><br><span class="line">Unsafe类</span><br><span class="line">	&#x2F;&#x2F;分配内存</span><br><span class="line">	public long allocateMemory(long bytes)&#123;</span><br><span class="line">		return theInternalUnsafe.allocateMemory(bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;回收内存</span><br><span class="line">	public void freeMemory(long address)&#123;</span><br><span class="line">		theInternalUnsafe.freeMemory(address);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>强软弱虚</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖二-源码跟踪</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%8C%EF%BC%88%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="第一步：最初的入口"><a href="#第一步：最初的入口" class="headerlink" title="第一步：最初的入口"></a>第一步：最初的入口</h3><p>ClassPathXmlApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//第一步，最初的入口</span></span><br><span class="line"><span class="number">144</span>			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="第二步：实例化所有剩余的-非延迟-init-单例"><a href="#第二步：实例化所有剩余的-非延迟-init-单例" class="headerlink" title="第二步：实例化所有剩余的(非延迟-init)单例"></a>第二步：实例化所有剩余的(非延迟-init)单例</h3><p>AbstractApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// 第二步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">517</span>				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>AbstractApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">879</span>		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：调用子类的doGetBean"><a href="#第四步：调用子类的doGetBean" class="headerlink" title="第四步：调用子类的doGetBean"></a>第四步：调用子类的doGetBean</h3><p>DefaultListableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 触发所有非惰性单例bean的初始化...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 略</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第四步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">897</span>					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"><a href="#第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）" class="headerlink" title="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"></a>第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）</h3><p>AbstractBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    	<span class="comment">// 第五步 获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="number">250</span>		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">                <span class="comment">//标记当前bean处于正在创建状态</span></span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// Create bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 第七步 创建实例</span></span><br><span class="line"><span class="number">322</span>					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//第九步，在第八步调用singletonFactory.getObject()执行此lambda方法</span></span><br><span class="line"><span class="number">324</span>							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							<span class="keyword">throw</span> ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No scope name defined for bean ´"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">								<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">								<span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"><a href="#第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）" class="headerlink" title="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"></a>第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第六步，获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">	    <span class="comment">//1.先从一级缓存中获取对象，若存在则返回</span></span><br><span class="line"><span class="number">182</span>		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">//2.若对象不存在，则从二级缓存中查找该对象</span></span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="comment">//3.若对象不存在一级、二级缓存中时，并且存在于三级缓存中时</span></span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//4.调用工厂对象的getObject()方法【() -&gt; getEarlyBeanReference(beanName, mbd, bean)】</span></span><br><span class="line">                            	<span class="comment">// 提前，实际上是调用了【AnnotationAwareAspectJAutoProxyCreator】</span></span><br><span class="line">                            	<span class="comment">// 第十八步，最终返回一个动态代理对象Proxy</span></span><br><span class="line"><span class="number">194</span>								singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//将该动态代理对象存放到二级缓存中</span></span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">//把该bean的函数接口从三级缓存中移除</span></span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"><a href="#第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）" class="headerlink" title="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"></a>第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//1.从缓存中获取bean实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//2.如果bean实例不存在缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 省略部分源码 */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//第八步，调用第七步传入的lambda表达式() -&gt; &#123; return createBean(beanName, mbd, args);&#125;</span></span><br><span class="line"><span class="number">234</span>             singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            	<span class="comment">/* 省略部分源码 */</span>    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//第二十步，添加到一级缓存中，然后调用链将回到初始化实例的函数</span></span><br><span class="line"><span class="number">260</span>             addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十步：创建一个bean实"><a href="#第十步：创建一个bean实" class="headerlink" title="第十步：创建一个bean实"></a>第十步：创建一个bean实</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="comment">// 略</span></span></span><br><span class="line"><span class="function">		<span class="keyword">try</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第十步，创建一个bean实例，填充bean实例、应用前置处理器等</span></span><br><span class="line"><span class="number">516</span>			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"><a href="#第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）" class="headerlink" title="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"></a>第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate the bean.</span></span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//第十一步,实例化对象，开辟内存空间</span></span><br><span class="line"><span class="number">556</span>			instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">//快速缓存单例，以便能够解决循环引用</span></span><br><span class="line">		<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    	<span class="comment">// 实例化完成后，判断是否需要提前暴露该对象，结果为true</span></span><br><span class="line">    	<span class="comment">// 满足条件：单例、开启允许循环依赖的配置、并且该Bean处于正在创建状态</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//第十二步，添加Bean的工厂对象到三级缓存中</span></span><br><span class="line"><span class="number">587</span>			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第十三步，填充属性，即给A的属性赋值（也就是属性B）</span></span><br><span class="line"><span class="number">593</span>			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">//第十九步，获取到二级缓存中提前暴露的A</span></span><br><span class="line"><span class="number">607</span>			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十三步：给给Bean的属性赋值"><a href="#第十三步：给给Bean的属性赋值" class="headerlink" title="第十三步：给给Bean的属性赋值"></a>第十三步：给给Bean的属性赋值</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">		<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">		<span class="comment">// to support styles of field injection.</span></span><br><span class="line">	    <span class="comment">//当像BeanFactoryAware这样的生命周期接口触发时，任何实例化的awarebeanpostprocessor都有机会在属性设置之前修改bean的状态</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">		PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">						&#125;</span><br><span class="line">						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					pvs = pvsToUse;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">			<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			&#125;</span><br><span class="line">			checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            <span class="comment">//第十三步，给Bean的属性赋值</span></span><br><span class="line"><span class="number">1442</span>			applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"><a href="#第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）" class="headerlink" title="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"></a>第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取属性名称</span></span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">				<span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">					Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">					<span class="keyword">if</span> (writeMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Autowire marker for property without write method: "</span> + pv);</span><br><span class="line">					&#125;</span><br><span class="line">					originalValue = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">new</span> MethodParameter(writeMethod, <span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">                	<span class="comment">//第十四步 使用解析器解析不同类型的值</span></span><br><span class="line"><span class="number">1697</span>				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				Object convertedValue = resolvedValue;</span><br><span class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">        <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第二十步，真正的属性赋值</span></span><br><span class="line"><span class="number">1730</span>		bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十五步："><a href="#第十五步：" class="headerlink" title="第十五步："></a>第十五步：</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">		<span class="comment">// to another bean to be resolved.</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">			RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">            <span class="comment">//第十五步</span></span><br><span class="line"><span class="number">113</span>			<span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十六步：调用子类的doGetBean"><a href="#第十六步：调用子类的doGetBean" class="headerlink" title="第十六步：调用子类的doGetBean"></a>第十六步：调用子类的doGetBean</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object bean;</span><br><span class="line">			Class&lt;?&gt; beanType = ref.getBeanType();</span><br><span class="line">			<span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String resolvedName;</span><br><span class="line">				<span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					NamedBeanHolder&lt;?&gt; namedBean = <span class="keyword">this</span>.beanFactory.resolveNamedBean(beanType);</span><br><span class="line">					bean = namedBean.getBeanInstance();</span><br><span class="line">					resolvedName = namedBean.getBeanName();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolvedName = String.valueOf(doEvaluate(ref.getBeanName()));</span><br><span class="line">                    <span class="comment">//第十六步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">330</span>					bean = <span class="keyword">this</span>.beanFactory.getBean(resolvedName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory.registerDependentBean(resolvedName, <span class="keyword">this</span>.beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				bean = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十七步-循环第五步创建B"><a href="#第十七步-循环第五步创建B" class="headerlink" title="第十七步:循环第五步创建B"></a>第十七步:循环第五步创建B</h3><p>AbstractBeanFactory</p>
<h2 id="归纳步骤："><a href="#归纳步骤：" class="headerlink" title="归纳步骤："></a>归纳步骤：</h2><h4 id="实例化A"><a href="#实例化A" class="headerlink" title="实例化A"></a>实例化A</h4><p>1.<code>第五步</code>getSingleton(beanName)从缓存获取<code>A</code>；</p>
<p>2.获取不到时，走<code>第七步</code>准备开始创建；</p>
<p>3.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>4.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>A</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取A的属性B"><a href="#获取A的属性B" class="headerlink" title="获取A的属性B"></a>获取A的属性B</h4><p>5.<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>；</p>
<p>6.走<code>第五步</code>获取<code>B</code>，返现<code>B</code>没有，继续重复流程创建<code>B</code>；</p>
<h4 id="实例化B"><a href="#实例化B" class="headerlink" title="实例化B"></a>实例化B</h4><p>7.走<code>第七步</code>准备开始创建B；</p>
<p>8.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>9.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>B</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取B的属性A"><a href="#获取B的属性A" class="headerlink" title="获取B的属性A"></a>获取B的属性A</h4><p>10.再次来到<code>第十三步</code>给<code>B</code>的赋值<code>属性A</code>时；</p>
<p>11.<code>第十六步</code>,调用子类的doGetBean(name, null, null, false)</p>
<p>11.再次走<code>第五步</code>获取<code>A</code></p>
<p>12.<code>十八步</code>获取到A的三级缓存生成对象放入<code>二级缓存</code>，如果有aop最终返回一个动态代理对象Proxy，移除三级缓存A的工厂；</p>
<p>13.<code>第二十步</code> 真正的属性赋值,将A赋值给B</p>
<p>14.<code>第二十一步</code>将<code>B</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<p>15.回到<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>时，走类似<code>10</code>之后的流程；</p>
<p>16.最终<code>A</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="getSingleton：获取各级缓存"><a href="#getSingleton：获取各级缓存" class="headerlink" title="getSingleton：获取各级缓存"></a>getSingleton：获取各级缓存</h3><h3 id="doCreateBean：创建bean主要方法"><a href="#doCreateBean：创建bean主要方法" class="headerlink" title="doCreateBean：创建bean主要方法"></a>doCreateBean：创建bean主要方法</h3><h3 id="populateBean：填充属性方法"><a href="#populateBean：填充属性方法" class="headerlink" title="populateBean：填充属性方法"></a>populateBean：填充属性方法</h3><h3 id="addSingleton：添加一级缓存方法"><a href="#addSingleton：添加一级缓存方法" class="headerlink" title="addSingleton：添加一级缓存方法"></a>addSingleton：添加一级缓存方法</h3><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>结合上面四个方法做个简单的总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.调用doGetBean()方法，想要获取A，于是调用getSingleton()方法，从缓存中查找A</span><br><span class="line">2.在getSingleton()方法中，从一级缓存中查找，没有，返回null</span><br><span class="line">3.doGet】Bean()方法中获取的A为null，于是走对应的处理逻辑，调用getSingleton()的重载方法(参数为ObjectFactory)</span><br><span class="line">4.在getSingleton()方法中，现将A的name添加到一个集合中，用于标记该bean正常创建中；然后回调匿名内部类的createBean方法</span><br><span class="line">5.进入AbstractAutowireCapableBeanFactory#doCreateBean，先反射调用构造器创建出A的实例，然后判断是否为单例、是否允许提前曝光引用（单例一般为true）、是否正在创建中（第四步的集合）；判断为true则将A添加到三级缓存中</span><br><span class="line">6.对A进行属性填充，此时检测到A依赖于B，于是开始查找B</span><br><span class="line">7.调用doGetBean()方法和上面A的过程一样，到缓存中查找B，没有则创建，然后给B填充属性</span><br><span class="line">8.此时B依赖于A，调用getSingle()获取A，依次从缓存中茶渣，此时从三级缓存中获取到A的工厂，通过公办工厂获取singletonObject，此时这个singleton指向就是上面在doCreate()方法中实例化的A（第七步）</span><br><span class="line">9.这样B就获取到了A的依赖，于是B顺利完成实例化，并将A从三级缓存移动到二级缓存中</span><br><span class="line">10.随后A继续它的属性填充工作，此时也获取到B，A也随之完成创建，回到getSingleton()方法中继续向下执行，将A从二级缓存移动到一级缓存中</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>配置centos固定ip</title>
    <url>/2020/11/29/%E9%85%8D%E7%BD%AEcentos%E5%9B%BA%E5%AE%9Aip/</url>
    <content><![CDATA[<h2 id="a-修改-etc-sysconfig-network配置文件："><a href="#a-修改-etc-sysconfig-network配置文件：" class="headerlink" title="a. 修改/etc/sysconfig/network配置文件："></a>a. 修改/etc/sysconfig/network配置文件：</h2><p>vi /etc/sysconfig/network</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Created by anaconda</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件："><a href="#b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件：" class="headerlink" title="b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件："></a>b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件：</h2><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line"></span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">IPADDR&#x3D;192.168.243.131</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line"></span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">UUID&#x3D;193e7f5e-e25b-40ef-b292-0fe5c8970af5</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">ZONE&#x3D;public</span><br><span class="line"></span><br><span class="line">DNS1&#x3D;8.8.8.8</span><br><span class="line">DNS2&#x3D;4.2.2.2</span><br></pre></td></tr></table></figure>

<h2 id="c-重启网关"><a href="#c-重启网关" class="headerlink" title="c. 重启网关:"></a>c. 重启网关:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>线程池-执行原理</title>
    <url>/2021/05/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>Java中的线程池核心实现类是<code>ThreadPoolExecutor</code>。</p>
<img src="http://yrlzero.gitee.io/images/多线程/接口父类.jpg" style="zoom: 80%;" />

<a id="more"></a>

<h3 id="顶级接口Executor"><a href="#顶级接口Executor" class="headerlink" title="顶级接口Executor"></a>顶级接口<code>Executor</code></h3><ul>
<li>顶层接口<code>Executor</code>提供了一种思想：将任务提交和任务执行进行解耦。</li>
<li>用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到<code>执行器(Executor)</code>中，由<code>Executor</code>框架完成线程的调配和任务的执行部分。</li>
</ul>
<h3 id="接口ExecutorService"><a href="#接口ExecutorService" class="headerlink" title="接口ExecutorService"></a>接口<code>ExecutorService</code></h3><p>​    接口增加了一些能力：</p>
<ul>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法。</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ul>
<h3 id="抽象类AbstractExecutorService"><a href="#抽象类AbstractExecutorService" class="headerlink" title="抽象类AbstractExecutorService"></a>抽象类<code>AbstractExecutorService</code></h3><p>​        上层的抽象类：</p>
<ul>
<li>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</li>
</ul>
<h3 id="实现类ThreadPoolExecutor"><a href="#实现类ThreadPoolExecutor" class="headerlink" title="实现类ThreadPoolExecutor"></a>实现类<code>ThreadPoolExecutor</code></h3><p>​        实现最复杂的运行部分：</p>
<ul>
<li>ThreadPoolExecutor将会一方面维护自身的生命周期。</li>
<li>另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>​        线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadpoolexecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>​        线程池的运行主要分成两部分：任务管理、线程管理。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p>
<ul>
<li>（1）直接申请线程执行该任务；</li>
<li>（2）缓冲到队列中等待线程执行；</li>
<li>（3）拒绝该任务。</li>
</ul>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<hr>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><p>​        线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。</p>
<p>线程池内部使用变量<code>ctl</code>来维护两个值：<code>runState</code>(运行状态，使用ctl的高3位来维护)、<code>workerCount</code>(线程数量，使用ctl的低29位来维护)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量，<code>ThreadPoolExecutor</code>提供了如下变量和方法以供操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer.SIZE = 32</span></span><br><span class="line"><span class="comment">//29，基础操作位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; </span><br><span class="line"><span class="comment">// 工作线程容量大小</span></span><br><span class="line"><span class="comment">// 左位移29位再减一，保证高3位为0，低29位为1，</span></span><br><span class="line"><span class="comment">// 二进制：0001 1111 1111 1111 1111 1111 1111 1111; 十进制：536870911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// runState存储在高位的状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"><span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//通过状态和线程数生成ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="runState"><a href="#runState" class="headerlink" title="runState"></a><code>runState</code></h3><p>标识线程池运行状态，使用<code>ctl</code>变量的高3位来保存。</p>
<p>runState提供主要的生命周期控制，主要状态如下：</p>
<table>
<thead>
<tr>
<th align="left">运行状态</th>
<th align="left">数值</th>
<th align="left">状态描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行（RUNNING）</td>
<td align="left">-1 &lt;&lt; 29</td>
<td align="left">能接受新任务，并处理排队的任务</td>
</tr>
<tr>
<td align="left">关机（SHUTDOWN）</td>
<td align="left">0 &lt;&lt; 29</td>
<td align="left">不接受新任务，但可以继续处理队列中的任务</td>
</tr>
<tr>
<td align="left">停止（STOP）</td>
<td align="left">1 &lt;&lt; 29</td>
<td align="left">不接受新任务，也不会处理排队的任务，并且中断正在进行的任务</td>
</tr>
<tr>
<td align="left">整理（TIDYING）</td>
<td align="left">2 &lt;&lt; 29</td>
<td align="left">所有任务已终止，workerCount为零，线程转换为TIDYING状态之后将运行terminate（）方法(钩子方法)</td>
</tr>
<tr>
<td align="left">终止（TERMINATED）</td>
<td align="left">3 &lt;&lt; 29</td>
<td align="left">在terminated（）方法执行，进入此状态，在awaitTermination（）中等待的线程将返回</td>
</tr>
</tbody></table>
<p>以上的状态是数值有序的，可以进行有序的比较，RUNNING最小，TERMINATED最大，但不必达到每个状态，变化如下图：</p>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/runState%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpg" alt=""></p>
<blockquote>
<p>1、RUNNING -&gt; SHUTDOWN：在调用shutdown（）时，可能隐式在finalize（）中使用</p>
<p>2、(RUNNING or SHUTDOWN) -&gt; STOP：在调用shutdownNow（）时</p>
<p>3、SHUTDOWN -&gt; TIDYING：当队列和有效工作线程都为空时</p>
<p>4、STOP -&gt; TIDYING：有效工作线程都为空时</p>
<p>5、TIDYING -&gt; TERMINATED：当terminate（）调用完成时</p>
</blockquote>
<h3 id="workerCount"><a href="#workerCount" class="headerlink" title="workerCount"></a><code>workerCount</code></h3><p>指线程池当前工作的有效线程数，使用<code>ctl</code>变量的低29位保存。所以workerCount限制约为5亿（2 ^ 29-1）个线程。</p>
<h2 id="三、执行流程"><a href="#三、执行流程" class="headerlink" title="三、执行流程"></a>三、执行流程</h2><h3 id="1、任务调度"><a href="#1、任务调度" class="headerlink" title="1、任务调度"></a>1、任务调度</h3><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-01.jpg" alt=""></p>
<h3 id="2、任务申请"><a href="#2、任务申请" class="headerlink" title="2、任务申请"></a>2、任务申请</h3><p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h4 id="execute-提交Runnable任务"><a href="#execute-提交Runnable任务" class="headerlink" title="execute-提交Runnable任务"></a>execute-提交Runnable任务</h4><p>调用<code>ThreadPoolExecutor</code>的<code>execute(Runnable command)</code>方法提交任务到线程池，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池当前ctl数值（该值保存了线程池状态、有效工作线程数量）</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过以下三步进行任务提交</span></span><br><span class="line">    <span class="comment">//1、当前工作线程数 &lt; 核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//创建核心线程并执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、工作线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="comment">//线程池处于运行状态 &amp;&amp; 任务放入队列成功（当队列满时，调用offer()会返回false）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.1、 线程池不是运行状态并且队列移除任务成功，执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//2.2、 线程池为运行状态 且 线程池不是运行状态但队列移除任务失败</span></span><br><span class="line">        <span class="comment">// 当前工作线程数量为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//创建当前任务为空的非核心线程，空任务的work会去队列获取任务并执行</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//2.3、 如果2.1和2.2都不执行，那么任务会被放入队列中等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、工作线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="comment">// 线程池非运行状态 || 队列满了</span></span><br><span class="line">    <span class="comment">// 尝试创建非核心线程并执行任务，失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前工作线程数 &lt; 核心线程数<br>    创建<code>核心线程并执行任务</code><br>工作线程数 &gt;= 核心线程数<br>    线程池处于运行状态 &amp;&amp; 任务放入队列成功<br>        线程池不是运行状态并且队列移除任务成功<br>            执行<code>拒绝策略</code><br>        线程池为运行状态 且 线程池不是运行状态但队列移除任务失败 且 当前工作线程数量为空<br>            创建当前<code>任务为空的非核心线程</code>，空任务的work会去队列获取任务并执行<br>    线程池非运行状态 || 队列满了<br>        尝试创建<code>非核心线程并执行任务</code>，失败则执行<code>拒绝策略</code></p>
</blockquote>
<h4 id="submit-提交Callable任务"><a href="#submit-提交Callable任务" class="headerlink" title="submit-提交Callable任务"></a>submit-提交Callable任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法为抽象父类AbstractExecutorService的实现方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取Runnable实现类</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>submit可以提交callable任务，callable任务可以获取线程执行的返回结果</p>
<p>通过newTaskFor(task)方法创建FutureTask（Runnable实现类）交给execute(ftask)方法执行</p>
<p>​    FutureTask<V>实现RunnableFuture<V>接口，RunnableFuture<V>接口继承了Runnable,和Future<V>；因此给交给execute执行</p>
</blockquote>
<h4 id="addWorker-创建线程执行任务"><a href="#addWorker-创建线程执行任务" class="headerlink" title="addWorker-创建线程执行任务"></a>addWorker-创建线程执行任务</h4><table>
<thead>
<tr>
<th>重载方法</th>
<th>描述</th>
<th>execute()方法中触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>addWorker(command, true)</td>
<td>创建核心线程，执行任务</td>
<td>1.当前工作线程数 &lt; 核心线程数</td>
</tr>
<tr>
<td>addWorker(command, false)</td>
<td>创建非核心线程，执行任务</td>
<td>1.工作线程数 &gt;= 核心线程数<br/>2.且 线程池非运行状态 || 队列满了</td>
</tr>
<tr>
<td>addWorker(null, false)</td>
<td>创建非核心线程，当前任务为空</td>
<td>1.线程池为运行状态 或者 (线程池不是运行状态但队列移除任务失败)<br/>2.当前工作线程数量为空</td>
</tr>
</tbody></table>
<p>此方法较长需要分成两部分来分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//########### 第一部分 ############</span></span><br><span class="line">    <span class="comment">//循环使用CAS、重读ctl等操作，判断是否可以创建worker </span></span><br><span class="line">    <span class="comment">// 失败则返回false跳出此方法，成功则跳出循环执行第二部分代码</span></span><br><span class="line">    retry:</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池运行状态</span></span><br><span class="line">		<span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 以下三种条件满足任一一种，返回false，退出方法</span></span><br><span class="line">        <span class="comment">// 1.运行状态非RUNNING，且不为SHUTDOWN，返回false</span></span><br><span class="line">		<span class="comment">// 2.运行状态等于SHUTDOWN，firstTask不为null，返回false</span></span><br><span class="line">		<span class="comment">// 3.运行状态等于SHUTDOWN，firstTask为null,队列为空，返回false</span></span><br><span class="line">		<span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">			! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">			   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			   ! workQueue.isEmpty()))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取工作线程数量</span></span><br><span class="line">			<span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 工作线程数 &gt;= 最大线程数，返回false，退出方法</span></span><br><span class="line">			<span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                <span class="comment">//core为true，判断工作线程数 &gt;= 核心线程数，返回false，退出方法</span></span><br><span class="line">                <span class="comment">//core为false，判断工作线程数 &gt;= 最大线程数，返回false，退出方法</span></span><br><span class="line">				wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// CAS增长workerCount，成功则跳出内外层循环，执行第二部分代码</span></span><br><span class="line">			<span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">				<span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// Re-read ctl 重新获取ctl</span></span><br><span class="line">			c = ctl.get();  </span><br><span class="line">             <span class="comment">// 运行状态改变，跳过此次内层循环剩余的操作，继续外层循环（检查运行状态）</span></span><br><span class="line">			<span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">				<span class="keyword">continue</span> retry;</span><br><span class="line">			<span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// cas失败、工作线程数量改变则重新内循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//###########第二部分############</span></span><br><span class="line">    <span class="comment">// 线程启动标志位</span></span><br><span class="line">	<span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 线程是否加入workers标志位</span></span><br><span class="line">	<span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">	Worker w = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建worker</span></span><br><span class="line">		w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">		<span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">		<span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">			mainLock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取到锁以后仍需检查ctl，可能在上一个获取到锁处理的线程可能会改变runState</span></span><br><span class="line">                <span class="comment">// 如 ThreadFactory 创建失败 或线程池被 shut down等</span></span><br><span class="line">				<span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//当前状态为RUNNING || （当前状态为SHUTDOWN &amp;&amp; 任务为null）</span></span><br><span class="line">				<span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">					(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查线程是否活跃（已经启动则抛出异常）</span></span><br><span class="line">					<span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//加入工作线程集合中</span></span><br><span class="line">					workers.add(w);</span><br><span class="line">					<span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//工作线程集合数量 &gt; 线程池最大大小</span></span><br><span class="line">					<span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">						largestPoolSize = s;</span><br><span class="line">					<span class="comment">//workers标志位</span></span><br><span class="line">					workerAdded = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">				mainLock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//加入works成功</span></span><br><span class="line">			<span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">//启动线程</span></span><br><span class="line">				t.start();</span><br><span class="line">                <span class="comment">//线程启动标志位</span></span><br><span class="line">				workerStarted = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//启动失败</span></span><br><span class="line">		<span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">//回滚创建的工作线程 </span></span><br><span class="line">            <span class="comment">// 加锁，1.从workers移除w、2.cas回减ctl的sorkCount数量化、3.重新检查线程池状态是否终止</span></span><br><span class="line">			addWorkerFailed(w);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//返回线程启动标志位</span></span><br><span class="line">	<span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一部分：循环使用CAS、重读ctl等操作，判断是否可以<code>创建worker</code>，失败则返回false跳出此方法，成功则跳出循环执行第二部分代码</p>
<p>第二部分：加锁同步<code>创建work</code>并<code>启动执行任务</code></p>
</blockquote>
<h4 id="work-工作线程"><a href="#work-工作线程" class="headerlink" title="work-工作线程"></a>work-工作线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程<code>Worker</code>，其为<code>ThreadPoolExecutor</code>的私有内部类。</p>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/work%E7%B1%BBuml%E5%9B%BE.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//此工作程序正在其中运行的线程，如果ThreadFactory创建失败，则为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//要运行的初始任务，可能为null</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//每个worker的完成任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//有参构造</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程在启动前被打断</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程启动调用runWorker(this)执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state. 值0代表解锁状态。</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state. 值1表示锁定状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否锁锁定状态，true：是、false：否</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//aqs-尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//aqs-尝试释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断已启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">// 初始化是 state = -1，不会被interrupt</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Worker</code>实现了<code>Runnable</code>接口，并持有一个线程<code>thread</code>，一个初始化的任务<code>firstTask</code>。</p>
<ol>
<li><code>thread</code>是在调用构造方法时通过<code>ThreadFactory</code>来创建的线程，可以用来执行任务；</li>
<li><code>firstTask</code>用它来保存传入的第一个任务，这个任务可以有，也可以为null。<ul>
<li><code>firstTask</code>非空，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；</li>
<li><code>firstTask</code>为null，那么就需要创建一个线程去执行任务队列（workQueue）中的任务，也就是非核心线程的创建。</li>
</ul>
</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/work%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt=""></p>
<h4 id="runWorker-真正执行任务"><a href="#runWorker-真正执行任务" class="headerlink" title="runWorker-真正执行任务"></a>runWorker-真正执行任务</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>当 <code>worker.thread.start()</code>调用work的<code>run()</code>，该方法调用了<code>runWorker(this)</code>去真正执行任务</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务。</li>
<li>getTask()方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li>
<li>执行任务。 </li>
<li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/runWorker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt=""></p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//异常标识，true：异常、false：非异常</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先尝试执行firstTask，若没有的话，则调用getTask()从队列中获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用aqs的acquire(1)方法获取锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//（线程池是否停止 || （当前线程是否被中断 &amp;&amp; 线程池是否停止 ））</span></span><br><span class="line">            <span class="comment">// &amp;&amp; 当前线程没有被中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                <span class="comment">//中断当前线程</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 运行run之前的扩展方法，不执行任何操作，但可以在子类中对其进行自定义，子类通常应在此方法的末尾调用super.beforeExecute()</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 真正执行run方法</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 运行run之后的扩展方法</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//累加该worker的完成任务数</span></span><br><span class="line">                <span class="comment">//这里加了锁，因此没有线程安全的问题，volatile修饰保证其他线程的可见性</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//使用aqs的acquire(1)方法获取锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常执行修改完成异常标识为false</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//异常或者获取不到任务时,处理线程退出工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.首先尝试执行<code>firstTask</code>，若没有的话，则调用<code>getTask()</code>从队列中获取任务<br>2.加锁<br>3.如果线程池非运行状态，中断当前线程<br>4.调用<code>beforeExecute(wt, task)</code>前置处理方法<br>5.执行任务调用<code>task.run()</code><br>6.调用<code>afterExecute(task, thrown)</code>后置处理方法<br>7.累加该<code>worker</code>的<code>completedTasks</code>(完成任务数)<br>8.解锁<br>9.异常或者获取不到任务时,调用<code>processWorkerExit(w, completedAbruptly)</code>处理<code>worker</code></p>
</blockquote>
<h4 id="getTask-从队列中获取任务"><a href="#getTask-从队列中获取任务" class="headerlink" title="getTask()-从队列中获取任务"></a>getTask()-从队列中获取任务</h4><p><code>runWorker()</code>的主要任务就是一直loop循环，来一个任务处理一个任务，没有任务就去<code>getTask()</code>，<code>getTask()</code>可能会阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上一次队列的poll()方法是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下两个条件满足任一，cas减少工作线程数，返回退出方法</span></span><br><span class="line">        <span class="comment">//1、线程池关闭了，运行状态非RUNNING &amp;&amp; 运行状态为（STOP、TIDYING、TERMINATED）</span></span><br><span class="line">		<span class="comment">//2、运行状态非RUNNING &amp;&amp; 工作队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//减少ctl的workerCount字段。仅在线程突然终止时调用此方法</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 是否允许核心线程超时 || 工作线程数量 &gt; 核心线程数</span></span><br><span class="line">        <span class="comment">// 是否允许超时标识，true：调用workQueue.poll()；false：调用workQueue.take()</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（ 工作线程数量 &gt; 最大线程数 || （是否超时 &amp;&amp; 超时未获取任务）） </span></span><br><span class="line">        <span class="comment">//		&amp;&amp; （工作线程数量大于1 || 工作队列为空）</span></span><br><span class="line">        <span class="comment">//满足条件则减少工作线程后退出方法，否则重试</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//使用超时等待方法，移除获取，没有值为null</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            <span class="comment">//当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span></span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//队列的poll()方法超时返回null，才会来到此处</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断线程池是否为运行状态，不是的话cas减少工作线程数，返回退出方法<br>判断满足以下任一条件则减少工作线程后退出方法，否则重试<br>    工作线程数量 &gt; 最大线程数 并且 工作线程数量大于1<br>    工作线程数量 &gt; 最大线程数 并且  工作队列为空<br>    允许核心线程超时 并且 上一次队列的poll()方法超时 并且 工作线程数量大于1<br>    允许核心线程超时 并且 上一次队列的poll()方法超时 并且  工作队列为空</p>
<p>（允许核心线程超时 || 工作线程数量 &gt; 核心线程数）使用超时等待方法workQueue.poll()，移除获取，没有值为null；否则使用workQueue.take()为空时阻塞等待获取</p>
</blockquote>
<h4 id="processWorkerExit-处理异常或者无任务执行的worker"><a href="#processWorkerExit-处理异常或者无任务执行的worker" class="headerlink" title="processWorkerExit()-处理异常或者无任务执行的worker"></a>processWorkerExit()-处理异常或者无任务执行的worker</h4><p>当<code>runWorker()</code>的获取不到任务或者出现异常时，会调用<code>processWorkerExit(w, completedAbruptly)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//completedAbruptly为异常调用标识，true：异常调用、false：非异常调用（获取不到任务）</span></span><br><span class="line">    <span class="comment">//如果是异常终止的，那么减少worker的数量</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//累加当前worker的完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//从线程池worker集合中移除该worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果满足条件的话，那么将线程池转换为TERMINATED状态</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前线程池仍然是运行中的状态，那么就看一下是否需要新增另外一个worker替换此worker</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//非异常（任务为null）调用进入此判断</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//是否允许核心线程超时 ? 0 : 核心线程数</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 允许线程超时 &amp;&amp; 队列不为空</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当允许核心线程超时时，worker(工作线程)数量 &gt;= 1时，直接返回，无需创建新的worker</span></span><br><span class="line">            <span class="comment">// 当核心线程不允许超时时，worker(工作线程)数量 &gt;= 核心线程数，直接返回，无需创建新的worker</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试新增work</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>减少工作线程数量，移除该worker，如果当前线程池仍然是运行中的状态<br>    1。当此方法为非异常调用时<br>        当允许核心线程超时时，worker(工作线程)数量 &gt;= 1时，直接返回，无需创建新的worker<br>        当核心线程不允许超时时，worker(工作线程)数量 &gt;= 核心线程数，直接返回，无需创建新的worker<br>        其余情况创建新worker替代旧worker<br>    2.当此方法为异常调用时<br>        创建新worker替代旧worker</p>
</blockquote>
<h3 id="3、线程管理"><a href="#3、线程管理" class="headerlink" title="3、线程管理"></a>3、线程管理</h3><p>​        线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用<code>HashSet</code>来维持对线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>​        <code>Worker</code>是通过继承<code>AQS</code>，使用<code>AQS</code>来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用<code>AQS</code>，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。</li>
<li>如果正在执行任务，则不应该中断线程。 </li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 </li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/worker%E8%8E%B7%E5%8F%96%E9%94%81.png" alt=""></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>链路追踪</title>
    <url>/2020/12/06/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>sleuth收集跟踪信息通过http请求发送给zipkin server，zipkin将跟踪信息存储，以及提供RESTful API接口，zipkin ui通过调用api进行数据展示。默认内存存储，可以用mysql，ES等存储。</p>
<a id="more"></a>

<h2 id="二、Sleuth"><a href="#二、Sleuth" class="headerlink" title="二、Sleuth"></a>二、Sleuth</h2><p>Sleuth是Spring cloud的分布式跟踪解决方案。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>span(跨度)，基本工作单元。一次链路调用，创建一个span，</p>
<p>span用一个64位id唯一标识。包括：id，描述，时间戳事件，spanId,span父id。</p>
<p>span被启动和停止时，记录了时间信息，初始化span叫：root span，它的span id和trace id相等。</p>
</li>
<li><p>trace(跟踪)，一组共享“root span”的span组成的树状结构 称为 trace，trace也有一个64位ID，trace中所有span共享一个trace id。类似于一颗 span 树。</p>
</li>
<li><p>annotation（标签），annotation用来记录事件的存在，其中，核心annotation用来定义请求的开始和结束。</p>
<ul>
<li>CS(Client Send客户端发起请求)。客户端发起请求描述了span开始。</li>
<li>SR(Server Received服务端接到请求)。服务端获得请求并准备处理它。SR-CS=网络延迟。</li>
<li>SS（Server Send服务器端处理完成，并将结果发送给客户端）。表示服务器完成请求处理，响应客户端时。SS-SR=服务器处理请求的时间。</li>
<li>CR（Client Received 客户端接受服务端信息）。span结束的标识。客户端接收到服务器的响应。CR-CS=客户端发出请求到服务器响应的总时间。</li>
</ul>
</li>
</ol>
<p>taceId标识是同一条链路<br>spanId标识是一个服务的一次请求<br>parentId将当前请求与上一请求串联，被调用方的parentId是调用方的spanId</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg" alt=""></p>
<h2 id="三、zipkin"><a href="#三、zipkin" class="headerlink" title="三、zipkin"></a>三、zipkin</h2><p>zipkin是twitter开源的分布式跟踪系统</p>
<p>下载最新的稳定版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;search.maven.org&#x2F;remote_content?g&#x3D;io.zipkin&amp;a&#x3D;zipkin-server&amp;v&#x3D;LATEST&amp;c&#x3D;exec</span><br></pre></td></tr></table></figure>

<p>命令下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;zipkin.io&#x2F;quickstart.sh | bash -s</span><br></pre></td></tr></table></figure>

<p>启动 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.22</span><span class="number">.2</span>-exec.jar</span><br></pre></td></tr></table></figure>

<h2 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--链路追踪--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- zipkin --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#链路跟踪</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://admin:admin@localhost:9411/</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">rate:</span> <span class="number">1</span> <span class="comment">#采样比例1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、服务调用"><a href="#五、服务调用" class="headerlink" title="五、服务调用"></a>五、服务调用</h2><p>通过user服务调用pay服务</p>
<p>调用情况：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8.jpg" alt=""></p>
<p>调用详情：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt=""></p>
<p>依赖情况：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E4%BE%9D%E8%B5%96%E6%83%85%E5%86%B5.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>链路追踪</tag>
        <tag>sleuth</tag>
        <tag>zipkin</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（queue）</title>
    <url>/2020/12/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="各种队列介绍"><a href="#各种队列介绍" class="headerlink" title="各种队列介绍"></a>各种队列介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue 由数组结构组成的有界阻塞队列</span><br><span class="line">LinkedBlockingQueue 由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE 21亿）阻塞队列</span><br><span class="line">PriorityBlockingQueue 支持优先级排序的无界阻塞队列</span><br><span class="line">DelayQueue 使用时间优先级队列实现的延迟无界阻塞队列</span><br><span class="line">SynchronousQueue 不存储、匀速的阻塞队列，容量为零的队列（用于一个线程给另一个线程下达任务）</span><br><span class="line">LinkedTransferQueue 由链表结构组成的无界阻塞队列 transfer将元素放入队列之后会阻塞，等待元素被拿走</span><br><span class="line">LinkedBlockingDeque 由链表结构组成的双向阻塞队列</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><h4 id="操作失败会抛出异常的方法（add、remove、element）"><a href="#操作失败会抛出异常的方法（add、remove、element）" class="headerlink" title="操作失败会抛出异常的方法（add、remove、element）"></a>操作失败会抛出异常的方法（add、remove、element）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean add(E e)：添加元素，当阻塞队列满的时候再进行add会抛Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line"></span><br><span class="line">E remove()：移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line"></span><br><span class="line">E element()：获取队列排头的元素，没有值时Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br></pre></td></tr></table></figure>

<h4 id="操作失败返回false-null的方法（offer、poll、peek）"><a href="#操作失败返回false-null的方法（offer、poll、peek）" class="headerlink" title="操作失败返回false null的方法（offer、poll、peek）"></a>操作失败返回false null的方法（offer、poll、peek）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean offer(E e)：当阻塞队列满的时候再进行offer会返回false</span><br><span class="line"></span><br><span class="line">boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException：当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span><br><span class="line"></span><br><span class="line">E poll()：移除值并返回，当阻塞队列空的时候再进行poll会返回null</span><br><span class="line"></span><br><span class="line">E peek()：获取队列排头的元素，没有值时为null</span><br></pre></td></tr></table></figure>

<h4 id="一直阻塞的方法（put、take）"><a href="#一直阻塞的方法（put、take）" class="headerlink" title="一直阻塞的方法（put、take）"></a>一直阻塞的方法（put、take）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put(E e) throws InterruptedException：当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span><br><span class="line"></span><br><span class="line">E take() throws InterruptedException：当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span><br></pre></td></tr></table></figure>

<h4 id="以ArrayBlockingQueue为例"><a href="#以ArrayBlockingQueue为例" class="headerlink" title="以ArrayBlockingQueue为例"></a>以ArrayBlockingQueue为例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockIngQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞队列，先进先出</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会抛异常的方法：add、element、remove</span></span><br><span class="line">        exceptionBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//会阻塞的方法：put、take</span></span><br><span class="line">        block(blockingQueue);</span><br><span class="line">		<span class="comment">//返回true、false、null的方法：offer、peek、poll</span></span><br><span class="line">        booleanBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//超时返回true、false的方法：offer</span></span><br><span class="line">        timeout(blockingQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作d失败等待超时返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">block</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span></span><br><span class="line">        <span class="comment">//blockingQueue.put("d");</span></span><br><span class="line">        <span class="comment">//获取并移除队列的值</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.take());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">booleanBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"d"</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时为null</span></span><br><span class="line">        System.out.println(blockingQueue.peek());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行poll会返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败会抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//######### 抛异常方法 ###########</span></span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行add会抛Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.element());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">// Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(一)-基本概念</title>
    <url>/2021/05/24/elasticsearch%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>ES是基于Lucene分布式搜索服务，可以存储整个对象或文档，分布式的实时文件存储，每个字段都被索引并可被搜索，分布式的实时分析搜索引擎，可以扩展到上百台服务器，处理PB级结构化或非结构化数据。</p>
<h3 id="与传统数据库的对比"><a href="#与传统数据库的对比" class="headerlink" title="与传统数据库的对比"></a>与传统数据库的对比</h3><p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-01.png" alt=""></p>
<a id="more"></a>

<h3 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h3><p>索引是ES的一个逻辑存储，对应关系型数据库中的库，ES可以把索引数据存放到服务器中，也可以sharding(分片)后存储到多台服务器上。每个索引有一个或多个分片，每个分片可以有多个副本。</p>
<h3 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h3><p>ES中，一个索引可以存储多个用于不同用途的对象，可以通过类型来区分索引中的不同对象，对应关系型数据库中表的概念。但是在ES6.0开始，类型的概念被废弃，ES7中将它完全删除。删除type的原因：</p>
<p>我们一直认为ES中的“index”类似于关系型数据库的“database”，而“type”相当于一个数据表。ES的开发者们认为这是一个糟糕的认识。例如：关系型数据库中两个数据表示是独立的，即使他们里面有相同名称的列也不影响使用，但ES中不是这样的。</p>
<p>我们都知道elasticsearch是基于Lucene开发的搜索引擎，而ES中不同type下名称相同的filed最终在Lucene中的处理方式是一样的。举个例子，两个不同type下的两个user_name，在ES同一个索引下其实被认为是同一个filed，你必须在两个不同的type中定义相同的filed映射。否则，不同type中的相同字段名称就会在处理中出现冲突的情况，导致Lucene处理效率下降。</p>
<p>去掉type能够使数据存储在独立的index中，这样即使有相同的字段名称也不会出现冲突，就像ElasticSearch出现的第一句话一样“你知道的，为了搜索····”，去掉type就是为了提高ES处理数据的效率。</p>
<p>除此之外，在同一个索引的不同type下存储字段数不一样的实体会导致存储中出现稀疏数据，影响Lucene压缩文档的能力，导致ES查询效率的降低。</p>
<h3 id="文档（document）"><a href="#文档（document）" class="headerlink" title="文档（document）"></a>文档（document）</h3><p>存储在ES中的主要实体叫文档，可以理解为关系型数据库中表的一行数据记录。每个文档由多个<strong>字段（field）</strong>组成。区别于关系型数据库的是，ES是一个非结构化的数据库，每个文档可以有不同的字段，并且有一个唯一标识。</p>
<h3 id="映射（mapping）"><a href="#映射（mapping）" class="headerlink" title="映射（mapping）"></a>映射（mapping）</h3><p>mapping是对索引库中的索引字段及其数据类型进行定义，类似于关系型数据库中的表结构。ES默认动态创建索引和索引类型的mapping，这就像是关系型数据中的，无需定义表机构，更不用指定字段的数据类型。当然也可以手动指定mapping类型。</p>
<h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><h3 id="分片（shard）"><a href="#分片（shard）" class="headerlink" title="分片（shard）"></a>分片（shard）</h3><p>如果我们的索引数据量很大，超过硬件存放单个文件的限制，就会影响查询请求的速度，Es引入了分片技术。一个分片本身就是一个完成的搜索引擎，文档存储在分片中，而分片会被分配到集群中的各个节点中，随着集群的扩大和缩小，ES会自动的将分片在节点之间进行迁移，以保证集群能保持一种平衡。分片有以下特点：</p>
<ol>
<li>ES的一个索引可以包含多个分片（shard）；</li>
<li>每一个分片（shard）都是一个最小的工作单元，承载部分数据；</li>
<li>每个shard都是一个lucene实例，有完整的简历索引和处理请求的能力；</li>
<li>增减节点时，shard会自动在nodes中负载均衡；</li>
<li>一个文档只能完整的存放在一个shard上（主节点）</li>
<li>一个索引中含有shard的数量，默认值为5，在索引创建后这个值是不能被更改的。</li>
<li>优点：水平分割和扩展我们存放的内容索引；分发和并行跨碎片操作提高性能/吞吐量；</li>
<li>每一个shard关联的副本分片（replica shard）的数量，默认值为1，这个设置在任何时候都可以修改。</li>
<li>primary shard和对应的replica shard<strong>不能同时存在于同一个节点</strong>，所以最低的可用配置是两个节点，互为主备。</li>
<li><strong>primary shard是可读可写的，而replica shard是只读的。</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分片的好处：</span><br><span class="line">1.当某一台服务器宕机，可以保证其他数据的完整性（非最优方案）</span><br><span class="line">2.横向扩容：当数据量增大时，只需要添加一个新的结点，然后创建新的索引，操作非常简单</span><br><span class="line">3.看似占用了更多的服务器资源，实际上replica shard带来了性能和集群吞吐量的提升，这点和横向扩容是相同的。</span><br><span class="line">不同的是，横向扩容是可以承载更多的数据，而replica shard是单纯的增加数据的副本，带来的是性能和高可用。</span><br></pre></td></tr></table></figure>

<h3 id="副本（replica）"><a href="#副本（replica）" class="headerlink" title="副本（replica）"></a>副本（replica）</h3><p>副本（replica shard）就是shard的冗余备份，它的主要作用：</p>
<ol>
<li>冗余备份，防止数据丢失；</li>
<li>shard异常时负责容错和负载均衡；</li>
</ol>
<h2 id="ES的特性"><a href="#ES的特性" class="headerlink" title="ES的特性"></a>ES的特性</h2><p>分布式、高性能、高可用、可伸缩、易维护、速度快、弹性、灵活、操作简单、多语言客户端、X-Pack、hadoop/spark强强联手、开箱即用。</p>
<ul>
<li><strong>分布式：</strong>横向扩展非常灵活</li>
<li><strong>全文检索：</strong>基于lucene的强大的全文检索能力；</li>
<li><strong>近实时搜索和分析：</strong>数据进入ES，可达到近实时搜索，还可进行聚合分析</li>
<li><strong>高可用：</strong>容错机制，自动发现新的或失败的节点，重组和重新平衡数据</li>
<li><strong>模式自由：</strong>ES的动态mapping机制可以自动检测数据的结构和类型，创建索引并使数据可搜索。</li>
<li><strong>RESTful API：</strong>JSON + HTTP</li>
</ul>
<p><strong>应用领域：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.百度（全文检索、高亮、搜索推荐）</span><br><span class="line">2.各大网站的用户行为日志（用户点击、浏览、收藏、评论）</span><br><span class="line">3.BI（Business Intelligence商业智能），数据分析：数据挖掘统计。</span><br><span class="line">4.Github：代码托管平台，几千亿行代码</span><br><span class="line">5.ELK：Elasticsearch（数据存储）、Logstash（日志采集）、Kibana（可视化）</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.面向开发者友好，屏蔽了Lucene的复杂特性，集群自动发现（cluster discovery）</span><br><span class="line">2.自动维护数据在多个节点上的建立</span><br><span class="line">3.会帮我做搜索请求的负载均衡</span><br><span class="line">4.自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</span><br><span class="line">5.ES基于Lucene提供了很多高级功能：复合查询、聚合分析、基于地理位置等。</span><br><span class="line">6.对于大公司，可以构建几百台服务器的大型分布式集群，处理PB级别数据；对于小公司，开箱即用，门槛低上手简单。</span><br><span class="line">7.相遇传统数据库，提供了全文检索，同义词处理（美丽的cls&gt;漂亮的cls），相关度排名。聚合分析以及海量数据的近实时（NTR）处理，这些传统数据库完全做不到。</span><br></pre></td></tr></table></figure>

<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引（Inverted Index）也叫反向索引，有反向索引必有正向索引。通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据结构：</span><br><span class="line">1、包含这个关键词的document list</span><br><span class="line">2、关键词在每个doc中出现的次数 TF term frequency</span><br><span class="line">3、关键词在整个索引中出现的次数 IDF inverse doc frequency</span><br><span class="line">4、关键词在当前doc中出现的次数</span><br><span class="line">5、每个doc的长度，越长相关度越低</span><br><span class="line">6、包含这个关键词的所有doc的平均长度</span><br></pre></td></tr></table></figure>

<p><strong>Term（单词）</strong>：一段文本经过分析器分析以后就会输出一串单词，这一个一个的就叫做Term（直译为：单词）</p>
<p><strong>Term Dictionary（单词字典）</strong>：顾名思义，它里面维护的是Term，可以理解为Term的集合</p>
<p><strong>Term Index（单词索引）</strong>：为了更快的找到某个单词，我们为单词建立索引</p>
<p><strong>Posting List（倒排列表）</strong>：倒排列表记录了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。（PS：实际的倒排列表中并不只是存了文档ID这么简单，还有一些其它的信息，比如：词频（Term出现的次数）、偏移量（offset）等，可以想象成是Python中的元组，或者Java中的对象）</p>
<p>（PS：如果类比现代汉语词典的话，那么Term就相当于词语，Term Dictionary相当于汉语词典本身，Term Index相当于词典的目录索引）</p>
<p>每个文档都有一个ID，如果插入的时候没有指定的话，Elasticsearch会自动生成一个。</p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-02.png" alt="es"></p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上。但是，实际情况取决于集群拥有的分片和索引的数量以及它们的大小，不一定总是能均匀地分布。</p>
<p>ES不允许Primary和它的Replica放在同一个节点中，并且同一个节点不接受完全相同的两个Replica</p>
<p>同一个节点允许多个索引的分片同时存在。</p>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>在局部出错异常的情况下，保证服务正常运行并且有自行恢复能力。</p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-03-01.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-03-02.jpg" alt=""></p>
<p><strong>Master节点会尝试重启故障机，故障机启动后将作为Slave节点</strong></p>
<p>数据同步，Master会将宕机期间丢失的数据<strong>增量同步</strong>到重启机器对应的分片上去。</p>
<p><strong>主节点的Shard分片和副本shard分片不能同时存在于同一个节点，横向扩容新节点时，ES会自动进行分片重新均衡。</strong></p>
<blockquote>
<p>如何提高ES分布式系统的可用性以及性能最大化？</p>
</blockquote>
<p>（1）每台节点的Shard数量越少，每个shard分配的CPU、内存和IO资源越多，单个Shard的性能越好，当一台机器一个Shard时，单个Shard性能最好。</p>
<p>（2）<strong>稳定的Master节点对于群集健康非常重要</strong>！理论上讲，应该尽可能的减轻Master节点的压力，分片数量越多，Master节点维护管理shard的任务越重，并且节点可能就要承担更多的数据转发任务，可增加“仅协调”节点来缓解Master节点和Data节点的压力，但是在集群中添加过多的仅协调节点会增加整个集群的负担，因为选择的主节点必须等待每个节点的集群状态更新确认。</p>
<p>（3）反过来说，如果相同资源分配相同的前提下，shard数量越少，单个shard的体积越大，查询性能越低，速度越慢，这个取舍应根据实际集群状况和结合应用场景等因素综合考虑。</p>
<p>（4）数据节点和Master节点一定要分开，集群规模越大，这样做的意义也就越大。</p>
<p>（5）数据节点处理与数据相关的操作，例如CRUD，搜索和聚合。这些操作是I / O，内存和CPU密集型的，所以他们需要更高配置的服务器以及更高的带宽，并且集群的性能冗余非常重要。</p>
<p>（6）由于仅投票节不参与Master竞选，所以和真正的Master节点相比，它需要的内存和CPU较少。但是，所有候选节点以及仅投票节点都可能是数据节点，所以他们都需要快速稳定低延迟的网络。</p>
<p>（7）高可用性（HA）群集至少需要三个主节点，其中<strong>至少两个不是仅投票</strong>节点。即使其中一个节点发生故障，这样的群集也将能够选举一个主节点。生产环境最好设置3台仅Master候选节点（node.master = true     node.data = true）</p>
<p> （8）为确保群集仍然可用，集群<strong>不能同时停止投票配置中的一半或更多节点</strong>。只要有一半以上的投票节点可用，群集仍可以正常工作。这意味着，如果存在三个或四个主节点合格的节点，则群集可以容忍其中一个节点不可用。如果有两个或更少的主机资格节点，则它们必须都保持可用</p>
<h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p>每个节点都会不定期的在集群做广播，ping所有节点</p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-06.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-07.png" alt="es"></p>
<img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-08.jpg" alt="es" style="zoom:67%;" />

<p><strong>如果是偶数节点，Elasticsearch会将其中一个排除在投票配置之外，确保其大小为奇数。</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">下载地址</a> ES的启动需要JDK环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window版本启动：</span><br><span class="line">  elasticsearch.bat</span><br><span class="line"></span><br><span class="line">linux版本启动：</span><br><span class="line">  .&#x2F;elasticsearch -d</span><br><span class="line">  </span><br><span class="line">验证：</span><br><span class="line">  http:&#x2F;&#x2F;localhost:9200&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，可以进行各种操作，从跟踪查询负载，到理解请求如何流经整个应用，都能轻松完成。</p>
<p><a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINUX启动：</span><br><span class="line">.&#x2F;kibana</span><br><span class="line"></span><br><span class="line">WINDOW启动</span><br><span class="line">kibana.bat</span><br><span class="line"></span><br><span class="line">验证：</span><br><span class="line">http:&#x2F;&#x2F;localhost:5601</span><br></pre></td></tr></table></figure>

<h3 id="Head插件"><a href="#Head插件" class="headerlink" title="Head插件"></a>Head插件</h3><p>提供可视化的操作页面对<code>ElasticSearch</code>搜索引擎进行各种设置和数据检索功能，可以很直观的查看集群的健康状况，索引分配情况，还可以管理索引和集群以及提供方便快捷的搜索功能等等。</p>
<p>依赖于node 和 grunt管理工具    <a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">下载地址</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">安装grunt环境：</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install -g grunt-cli</span></span><br><span class="line"><span class="attr">检查：</span></span><br><span class="line"><span class="attr">grunt</span> <span class="string">-version</span></span><br></pre></td></tr></table></figure>

<p>解压下载的压缩包，打开<code>glasticsearch-head-master</code>文件夹，修改<code>Gruntfile.js</code>文件，添加<code>hostname:&#39;*&#39;</code></p>
<p><img src="http://yrlzero.gitee.io/images/elk/elastic-search/es-05.png" alt="es"></p>
<p>在当前目录输入<code>npm install</code>，     <code>npm run start</code>启动</p>
<p>验证：<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a> 安装成功</p>
<p>如果无法发现ES节点，尝试在ES配置文件中设置允许跨域</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<h3 id="ES节点"><a href="#ES节点" class="headerlink" title="ES节点"></a>ES节点</h3><p><code>Master：主节点</code></p>
<p>每个集群都有且只有一个，尽量避免Master节点中配置node.data ＝ true； Master节点的主要职责是和集群操作相关的内容，例如创建或删除索引、跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点。</p>
<p><code>voting：投票节点</code></p>
<p>需配置 Node.voting_only = true（仅投票节点，即使配置了node.master = true，也不会参选, 但是仍然可以作为数据节点）</p>
<p><code>coordinating：协调节点</code></p>
<p>每一个节点都隐式的是一个协调节点，如果同时设置了node.master = false和node.data=false，那么此节点将成为仅协调节点，该节点只能处理路由请求，处理搜索，分发索引操作</p>
<p><code>Master-eligible node：候选节点</code></p>
<p>设置node.master = true即是候选节点，具备竞选master的资格。</p>
<p><code>Data node：数据节点</code></p>
<p>数据节点主要是存储索引数据的节点，<strong>主要对文档进行增删改查操作，聚合操作</strong>等。</p>
<p><code>Ingest node：</code><br><code>Machine learning node：机器学习节点</code></p>
<p>相关配置参数如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.node.master</span> = <span class="string">true	 node.data = true</span></span><br><span class="line"><span class="attr">这是ES节点默认配置，既作为候选节点又作为数据节点，这样的节点一旦被选举为Master，压力是比较大的</span></span><br><span class="line"><span class="attr">通常来说Master节点应该只承担较为轻量级的任务，比如创建删除索引，分片均衡等。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.node.master</span> = <span class="string">true	 node.data = false</span></span><br><span class="line"><span class="attr">只作为候选节点，不作为数据节点，可参选Master节点，当选后成为真正的Master节点。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.node.master</span> = <span class="string">false	 node.data = false</span></span><br><span class="line"><span class="attr">既不当候选节点，也不作为数据节点，那就是仅协调节点，负责负载均衡</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.node.master</span>=<span class="string">false		node.data=true</span></span><br><span class="line"><span class="attr">不作为候选节点，但是作为数据节点，这样的节点主要负责数据存储和查询服务。</span></span><br></pre></td></tr></table></figure>

<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL:</span><br><span class="line">  _cat&#x2F;health</span><br><span class="line">  _cluster&#x2F;health</span><br></pre></td></tr></table></figure>

<blockquote>
<p>健康值状态</p>
</blockquote>
<p>① <strong>Green</strong>：所有Primary shard和Replica shard均为active，集群健康</p>
<p>② <strong>Yellow</strong>：至少一个Replica shard不可用，但是所有Primary shard均为active，数据仍然是可以保证完整性的。</p>
<p>③ <strong>Red</strong>：至少有一个Primary shard为不可用状态，数据不完整，集群不可用。</p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><strong>elasticearch.yml配置</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">my-application</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#集群名字 同一个集群的节点要设置在同一个集群名称</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">csdemo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#节点名字 同一集群的节点名称不能相同</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#指定节点的部落属性，这是一个比集群更大的范围。</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment"># 数据存放目录</span></span><br><span class="line"><span class="comment">#path.data: /path/to/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#path.logs: /path/to/logs</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#锁定物理内存地址，防止elasticsearch内存被交换出去,也就是避免es使用swap交换分区</span></span><br><span class="line"><span class="meta">bootstrap.memory_lock</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#当系统进行内存交换的时候，es的性能很差</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#设置ip绑定</span></span><br><span class="line"><span class="meta">network.host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#自定义端口号</span></span><br><span class="line"><span class="meta">http.port</span>: <span class="string">9202</span></span><br><span class="line"><span class="meta">transport.tcp.port</span>: <span class="string">9302</span></span><br><span class="line"><span class="comment"># 是否启用TCP保持活动状态，默认为true</span></span><br><span class="line"><span class="meta">network.tcp.keep_alive</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#是否启用tcp无延迟，true为启用tcp不延迟，默认为false启用tcp延迟</span></span><br><span class="line"><span class="meta">network.tcp.no_delay</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#设置是否压缩tcp传输时的数据，默认为false，不压缩。</span></span><br><span class="line"><span class="meta">transport.tcp.compress</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#设置成主服务</span></span><br><span class="line"><span class="meta">node.master</span>: <span class="string">false</span></span><br><span class="line"><span class="comment"># 时候进行数据存贮</span></span><br><span class="line"><span class="meta">node.data</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#集群节点列表</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is ["127.0.0.1", "[::1]"]</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="meta">discovery.seed_hosts</span>: <span class="string">["127.0.0.1:9301", "127.0.0.1:9302", "127.0.0.1:9303"]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="meta">cluster.initial_master_nodes</span>: <span class="string">["node-1", "node-2", "node-3"]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#每个节点在选中的主节点的检查之间等待的时间。默认为1秒</span></span><br><span class="line"><span class="meta">cluster.fault_detection.leader_check.interval</span>: <span class="string">15s </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置主节点等待每个集群状态完全更新后发布到所有节点的时间，默认为30秒</span></span><br><span class="line"><span class="meta">cluster.publish.timeout</span>: <span class="string">90s</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#集群内同时启动的数据任务个数，默认是2个</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.cluster_concurrent_rebalance: 2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#添加或删除节点及负载均衡时并发恢复的线程个数，默认4个</span></span><br><span class="line"><span class="comment">#cluster.routing.allocation.node_concurrent_recoveries: 4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#集群中的N个节点启动后,才允许进行数据恢复处理</span></span><br><span class="line"><span class="meta">gateway.recover_after_nodes</span>: <span class="string">3</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">gateway.expected_nodes</span>: <span class="string">3</span></span><br><span class="line"><span class="comment">#配置限制了单节点上可以开启的ES存储实例的个数</span></span><br><span class="line"><span class="meta">node.max_local_storage_nodes</span>: <span class="string">3</span></span><br><span class="line"><span class="meta">gateway.auto_import_dangling_indices</span>: <span class="string">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#删除索引必须要索引名称</span></span><br><span class="line"><span class="meta">action.destructive_requires_name</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许跨域</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#master 和 data 的四种组合</span></span><br><span class="line"><span class="comment">#1.master=true &amp; data = true 生产环境不推荐使用</span></span><br><span class="line"><span class="comment">#2.master=true &amp; data = false 生产环境推荐使用，master不进行数据存储</span></span><br><span class="line"><span class="comment">#3.master=false &amp; data = true 备机存储数据</span></span><br><span class="line"><span class="comment">#4.master = false &amp; data = false 充当协调节点，类似nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="meta">node.master</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="meta">node.data</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记投票节点</span></span><br><span class="line"><span class="meta">Node.voting_only</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>切记，如果拷贝了单点程序做集群节点，一定要把原有的data数据清除，否则多分Master节点数据会导致集群搭建失败。</strong></p>
</blockquote>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建索引  index是索引名称</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">/index?pretty</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">/product?pretty</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询所有索引</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">_cat/indices?v</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除索引  index是索引名称</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/index?pretty</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/product?pretty</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入数据 /index/type/id   若无索引会自动创建,   type被弱化，统一使用 "_doc" </span></span><br><span class="line">PUT /index/type/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">3999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新数据---全量更新---再次执行插入数据即可</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">13999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据---增量更新</span></span><br><span class="line">PUT /index/type/id/_update</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">       <span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增量更新案例</span></span><br><span class="line">PUT /product/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"price"</span> :  <span class="number">3999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除数据</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/index/type/id</span></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">/product/_doc/1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(二)-查询语法</title>
    <url>/2021/05/24/elasticsearch%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><h3 id="Searchtimeout："><a href="#Searchtimeout：" class="headerlink" title="Searchtimeout："></a>Searchtimeout：</h3><p>①   设置：默认没有timeout，如果设置了timeout，那么会执行timeout机制。</p>
<p>②   Timeout机制：假设用户查询结果有1W条数据，但是需要10″才能查询完毕，但是用户设置了1″的timeout，那么不管当前一共查询到了多少数据，都会在1″后ES讲停止查询，并返回当前数据。</p>
<p>③  用法：GET /_search?timeout=1s/ms/m</p>
<a id="more"></a>

<h3 id="Query-String"><a href="#Query-String" class="headerlink" title="Query_String"></a>Query_String</h3><p>①  查询所有：GET /product/_search</p>
<p>②  带参数：GET /product/_search?q=name:xiaomi</p>
<p>③  分页：GET /product/_search?from=0&amp;size=2&amp;sort=price:asc</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据：</span></span><br><span class="line">PUT /product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de zhandouji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">3999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"buka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line">PUT /product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi nfc phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"zhichi quangongneng nfc,shouji zhong de jianjiji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">4999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"gongjiaoka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /product/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"nfc phone"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"shouji zhong de hongzhaji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">2999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"xingjiabi"</span>, <span class="string">"fashao"</span>, <span class="string">"menjinka"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /product/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"xiaomi erji"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"erji zhong de huangmenji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">999</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"low"</span>, <span class="string">"bufangshui"</span>, <span class="string">"yinzhicha"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /product/_doc/5</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"hongmi erji"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"erji zhong de kendeji"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">399</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"lowbee"</span>, <span class="string">"xuhangduan"</span>, <span class="string">"zhiliangx"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以后语句将忽略type的其他类型直接使用 _doc，以后 _doc也会移除</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询product索引下的所有type/doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置时限查询</span></span><br><span class="line"><span class="attr">timeout：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">(1)</span> <span class="string">设置：默认没有timeout，如果设置了timeout，那么会执行timeout机制。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">(2)</span> <span class="string">Timeout机制：假设用户查询结果有1W条数据，但是需要10s才能查询完毕</span></span><br><span class="line">    <span class="attr">但是用户设置了1s的timeout，那么不管当前一共查询到了多少数据，都会在1s后ES将停止查询，并返回当前数据。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">/_search?timeout=1s</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询doc中包含xiaomi的所有doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?q=xiaomi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询name中包含xiaomi的所有doc</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?q=name:xiaomi</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两者的区别：</p>
<p>q=xiaomi  ：将所有字段拼接成一个长字符串进行匹配</p>
<p>q=name:xiaomi   ：直接按照name进行匹配</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分页查询 每页2条数据 取第一页</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?from=0&amp;size=2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#排序 使用排序的话，相关度分数将_score = null</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_search?sort=price:asc</span></span><br></pre></td></tr></table></figure>

<h3 id="Query-DQL"><a href="#Query-DQL" class="headerlink" title="Query DQL"></a>Query DQL</h3><blockquote>
<p>match_all：匹配所有<br>multi_match：根据多个字段分词查询<br>match :对指定的关键词进行分词检索<br>match_phrase:对指定的关键词进行短语分词检索，如“xiaomi nfc”将按照此短语顺序匹配<br>match_phrase_prefix:对指定的关键词进行短语前缀分词检索，如“xiaomi nf”将按照此短语顺序匹配，最后一个term进行前缀匹配<br>term:对指定的此进行term匹配，不分词<br>keyword:对该值进行精确匹配，不分词<br>bool：可以组合多个查询条件<br>    must：相当于and<br>    must_not：相当于not<br>    should：相当于or</p>
</blockquote>
<h4 id="match-all"><a href="#match-all" class="headerlink" title="match_all"></a>match_all</h4><p>查询所有</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><blockquote>
<p> 分词查询</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><blockquote>
<p> 搜索排序</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"nfc"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"desc"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h4><blockquote>
<p> 据多个字段查询一个关键词</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ，name和desc中包含"nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"nfc"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [<span class="string">"name"</span>,<span class="string">"desc"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h4><blockquote>
<p>元数据：指定查询的字段</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子中为只查询“name”和“price”字段</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"nfc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>,<span class="string">"price"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deep-paging"><a href="#deep-paging" class="headerlink" title="deep-paging"></a>deep-paging</h4><blockquote>
<p>分页查询（性能低）</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页（deep-paging）：查询第一页（每页两条数据）</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"asc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ], </span><br><span class="line">    <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><blockquote>
<p>不会分词，直接与term匹配</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//query-term：查询条件 "nfc phone" 不会被分词，不会分成多个单词</span></span><br><span class="line"><span class="comment">//term和match的区别是match 会对查询条件进行分词</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合查询</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"nfc"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"phone"</span>&#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含查询  类似于 SQL: where xxx in ();</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>:[<span class="string">"nfc"</span>,<span class="string">"phone"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全文检索，一个单词进行分词，常用语句！！！</span></span><br><span class="line"><span class="comment">//等价SQL: name in (xiaomi,nfc,zhineng,phone)</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"xiaomi nfc zhineng phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证这个字符串的分词结果</span></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="attr">"text"</span>:<span class="string">"xiaomi nfc zhineng phone"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h4><blockquote>
<p>短语匹配，匹配合适的短语，可能是匹配到多个顺序的term</p>
<p>“nfc phone”短语匹配到了“nfc ”、“phone”两个顺序的term文档</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//短语搜索，和全文检索相反，会将给定的短语（phrase）当成一个完整的查询条件</span></span><br><span class="line"><span class="comment">//等价SQL: name contains("nfc phone")</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="match-phrase-prefix"><a href="#match-phrase-prefix" class="headerlink" title="match_phrase_prefix"></a>match_phrase_prefix</h4><blockquote>
<p>与match_phrase类似，但是允许与最后一个term前缀匹配</p>
</blockquote>
<h4 id="Query-and-filter"><a href="#Query-and-filter" class="headerlink" title="Query and filter"></a>Query and filter</h4><blockquote>
<p>bool：可以组合多个查询条件，bool查询也是采用more_matches_is_better的机制，因此满足must和should子句的文档将会合并起来计算分值。</p>
</blockquote>
<p><strong>must</strong>：必须满足</p>
<p>​            子句（查询）必须出现在匹配的文档中，并将有助于得分。</p>
<p><strong>filter</strong>：过滤器 <strong>不计算相关度分数</strong>，cache☆</p>
<p>​            子句（查询）必须出现在匹配的文档中。但是不像 must查询的分数将被忽略。Filter子句在filter上下文中执行，这意味着计分被忽略，并且子句被考虑用于缓存。</p>
<p><strong>should</strong>：可能满足 or</p>
<p>​            子句（查询）应出现在匹配的文档中。</p>
<p><strong>must_not</strong>：必须不满足 <strong>不计算相关度分数</strong>  not</p>
<p>​            子句（查询）不得出现在匹配的文档中。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。由于忽略计分，0因此将返回所有文档的分数。</p>
<p><strong>minimum_should_match</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先筛选name包含“xiaomi phone”并且价格大于1999的数据（不排序）   先执行filter筛选数据</span></span><br><span class="line"><span class="comment">//然后搜索name包含“xiaomi”and desc 包含“shouji”</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"xiaomi"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"desc"</span>: <span class="string">"shouji"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match_phrase"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi phone"</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"gt"</span>: <span class="number">1999</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bool多条件 name包含xiaomi 不包含erji 描述里包不包含nfc都可以，价钱要大于等于4999</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">			<span class="comment">//name中必须不能包含“erji”</span></span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"xiaomi"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">			<span class="comment">//name中必须包含“xiaomi”</span></span><br><span class="line">            <span class="attr">"must_not"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"erji"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">			<span class="comment">//should中至少满足0个条件，参见下面的minimum_should_match的解释</span></span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123;</span><br><span class="line">                    <span class="attr">"desc"</span>: <span class="string">"nfc"</span></span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ], </span><br><span class="line">			<span class="comment">//筛选价格大于4999的doc</span></span><br><span class="line">            <span class="attr">"filter"</span>: [		</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"gt"</span>: <span class="number">4999</span>   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minimum_should_match：参数指定should返回的文档必须匹配的子句的数量或百分比。<br>如果bool查询包含至少一个should子句，而没有must或 filter子句，则默认值为1。否则，默认值为0</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询 name必须包含 "nfc" 且should中必须满足一个条件</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>:&#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>:<span class="number">1999</span>&#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123;<span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>:<span class="number">3999</span>&#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">//表示should里的条件至少满足一个</span></span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种情况下，should至少满足0个条件</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                    <span class="comment">//价格必须大于1999或者大于3999</span></span><br><span class="line">                    <span class="attr">"should"</span>: [</span><br><span class="line">                        &#123; <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">1999</span>&#125;&#125;&#125;,</span><br><span class="line">                        &#123; <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">3999</span>&#125;&#125;&#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"must"</span>: [</span><br><span class="line">                        &#123; <span class="attr">"match"</span>: &#123;<span class="attr">"name"</span>: <span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"my good"</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"or"</span>,   <span class="comment">//可选：or、and  默认是or</span></span><br><span class="line">                <span class="attr">"minimum_should_match"</span>: <span class="number">2</span>, <span class="comment">//最少匹配2个此项</span></span><br><span class="line">                "boost"：1   //相关度算法权重</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有相关查询，ES底层会转换成bool操作</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;    </span><br><span class="line">            <span class="attr">"should"</span>: [  <span class="comment">//and的话，这里就是must, 可选：must/must not/should</span></span><br><span class="line">              &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"my"</span>&#125;&#125;,</span><br><span class="line">              &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"good"</span>&#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Compound-queries"><a href="#Compound-queries" class="headerlink" title="Compound queries"></a>Compound queries</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合查询</span></span><br><span class="line"><span class="comment">//想要一台带NFC功能的 或者 小米的手机 但是不要耳机</span></span><br><span class="line"><span class="comment">//等价于SQL:</span></span><br><span class="line"><span class="comment">//  SELECT * from product </span></span><br><span class="line"><span class="comment">//  where (`name` like "%xiaomi%" or `name` like '%nfc%')</span></span><br><span class="line"><span class="comment">//  AND `name` not LIKE '%erji%'</span></span><br><span class="line"></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>:&#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                    <span class="attr">"should"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi"</span>&#125;&#125;,</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"nfc"</span>&#125;&#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"must_not"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"erji"</span>&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//给他的分数赋值 1.2  没什么 意义</span></span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">1.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//搜索一台xiaomi nfc phone或者一台满足 是一台手机 并且 价格小于等于2999</span></span><br><span class="line"><span class="comment">//等价于SQL：</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123; </span><br><span class="line">                <span class="attr">"bool"</span>:&#123;</span><br><span class="line">                    <span class="attr">"should"</span>:[</span><br><span class="line">                        &#123;<span class="attr">"match_phrase"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"xiaomi nfc phone"</span>&#125;&#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"bool"</span>:&#123;</span><br><span class="line">                                <span class="attr">"must"</span>:[</span><br><span class="line">                                    &#123;<span class="attr">"term"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"phone"</span>&#125;&#125;,</span><br><span class="line">                                    &#123;<span class="attr">"range"</span>:&#123;<span class="attr">"price"</span>:&#123;<span class="attr">"lte"</span>:<span class="string">"2999"</span>&#125;&#125;&#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Highlight-search"><a href="#Highlight-search" class="headerlink" title="Highlight search"></a>Highlight search</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高亮查询</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"nfc phone"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span>:&#123;</span><br><span class="line">        <span class="attr">"fields"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果：会多返回一段高亮信息</span></span><br><span class="line">"highlight" : &#123;</span><br><span class="line">    "name" : [</span><br><span class="line">        <span class="string">"&lt;em&gt;nfc&lt;/em&gt; &lt;em&gt;phone&lt;/em&gt;"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deep-paging问题"><a href="#Deep-paging问题" class="headerlink" title="Deep paging问题"></a>Deep paging问题</h4><p>![](<a href="http://yrlzero.gitee.io/images/elk/elasticsearch-dql/deep">http://yrlzero.gitee.io/images/elk/elasticsearch-dql/deep</a> paging问题.png)</p>
<p>假设我要分页获取第5001~5050条数据时，由于数据是无序散落在各个<code>shard</code>分片中的，所以进行分页排序的时候，需要将各个<code>shard</code>分片进行排序，获取每个分片的【0 - 5050】条数据，然后进行合并，最后取出合适的50条数据，然后丢弃其他数据。</p>
<p><strong>这种操作是十分损耗性能的，尽量避免深度分页查询，当你的数据超过1W，不要使用，返回结果不要超过1000个，500以下为宜。</strong></p>
<h4 id="Scroll-search"><a href="#Scroll-search" class="headerlink" title="Scroll search"></a>Scroll search</h4><p>通过使用<code>Scroll search</code>来避免部分分页查询，在查询中添加<code>?scroll</code>参数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中  1m 表示当前的scroll窗口有效期是1分钟</span></span><br><span class="line">GET /product/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>:[&#123;<span class="attr">"price"</span>:<span class="string">"asc"</span>&#125;],</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这样查询，返回值会带上一个<code>_scroll_id</code>结果</p>
<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-dql/es-02.png" alt="es"></p>
<p>当进行下一页时，直接通过上一次返回的<code>scroll_id</code>进行查询即可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//给scroll进行续命</span></span><br><span class="line">    <span class="attr">"scroll"</span> :<span class="string">"1m"</span>,</span><br><span class="line">    scroll_id:"xxxxxxxxxxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>他的缺点是只能下一页，没办法上一页，不适合实时查询</strong></p>
<h4 id="Filter缓存原理"><a href="#Filter缓存原理" class="headerlink" title="Filter缓存原理"></a>Filter缓存原理</h4><p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-dql/Filter%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png" alt=""></p>
<p><strong>当使用 term词项去倒排索引表进行搜索时，返回的一条条数据，filter会通过一个Bit数组存储，每个词项term对应一个bit数组，1表示匹配成功，0表示匹配失败。</strong></p>
<p>计算多个filter条件的组合时，直接进行bit数组的与运算就能得出相应的结果，在一定条件下，filter会将查询的bit数组进行缓存。</p>
<h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/_mget</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/&lt;index&gt;/_mget</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量查询 查询id =2 和id = 3 的数据</span></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_index"</span>: <span class="string">"product"</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装,把索引名(product提取出来)</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//再封装</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ids"</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include包含哪些字段  exclude排除哪些字段</span></span><br><span class="line">GET /product/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"docs"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: <span class="literal">false</span> <span class="comment">//不显示字段数据</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: [  <span class="comment">//指定字段数据</span></span><br><span class="line">                <span class="string">"name"</span>,</span><br><span class="line">                <span class="string">"price"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"include"</span>: [</span><br><span class="line">                    <span class="string">"name"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"exclude"</span>:[</span><br><span class="line">                    <span class="string">"price"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operate：</span><br><span class="line">  create：PUT &#x2F;index&#x2F;_create&#x2F;id&#x2F;，强制创建（是否制定id）</span><br><span class="line">  delete：删除（lazy delete原理）</span><br><span class="line">  index：可以是创建，也可以是全量替换</span><br><span class="line">  update：执行partial update（全量替换，部分替换）</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动指定id和自动生成</span></span><br><span class="line">PUT /test_index/_doc/1/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强制执行创建 如果数据存在则报错</span></span><br><span class="line">PUT /test_index/_doc/1/_create</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">PUT /test_index/_create/1/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生产id(guid)</span></span><br><span class="line">POST /test_index/_doc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"test"</span>:<span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用PUT进行数据覆盖的时候，Version版本号会上升，旧的Version数据会被删除，不会马上删除，会有一个懒删除的机制。</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">bulk：批量增删改  no-query</span><br><span class="line">语法格式：</span><br><span class="line">POST /_bulk</span><br><span class="line">POST /&lt;index&gt;/_bulk</span><br><span class="line">&#123;<span class="attr">"action"</span>: &#123;<span class="attr">"metadata"</span>&#125;&#125;   <span class="comment">//操作和索引</span></span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;   <span class="comment">//数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"1"</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"_bulk create 2"</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"12"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"_bulk create 12"</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"3"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"index product2 "</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"13"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>:    <span class="string">"index product2"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当出现冲突时尝试三次，三次失败后就放弃</span></span><br><span class="line">&#123; <span class="attr">"update"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"4"</span>,<span class="attr">"retry_on_conflict"</span> : <span class="string">"3"</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123;<span class="attr">"test_field2"</span> : <span class="string">"bulk test1"</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<p><code>bulk</code>批处理操作要求数据分两行编写，不可以将<code>{}</code>进行换行操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加?filter_path=items.*.error  只显示失败的，返回从操作失败的数据信息</span></span><br><span class="line">POST /_bulk?filter_path=items.*.error</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"1"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"product2"</span>,  <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//version=2&amp;&amp;version_type=external 通过版本更新数据，避免并发覆盖---CAS</span></span><br><span class="line">PUT /version_index/_doc/1?version=2&amp;&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"窈窕淑女,君子好逑"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新版本使用者两个</span></span><br><span class="line"><span class="comment">//if_seq_no` and `if_primary_term`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ES是通过CAS+Version解决并发的问题！！！</strong></p>
</blockquote>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>概念：mapping就是ES数据字段field的type元数据，ES在创建索引的时候，dynamic mapping会自动为不同的数据指定相应mapping，mapping中包含了字段的类型、搜索方式（exact value或者full text）、分词器等。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">查看mapping</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/product/_mappings</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Dynamic</span> <span class="string">mapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">“Elasticsearch”：text/keyword</span>		<span class="string"></span></span><br><span class="line"><span class="attr">123456</span>			=<span class="string">&gt;	long			？为什么不是integer</span></span><br><span class="line"><span class="meta">123.123</span>			=<span class="string">&gt;	double		</span></span><br><span class="line"><span class="attr">true</span> <span class="string">false		=&gt;	boolean</span></span><br><span class="line"><span class="meta">2020-05-20</span>		=<span class="string">&gt;	date</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为啥price是long类型而不是integer？因为es的mapping_type是由JSON分析器检测数据类型，而Json没有隐式类型转换（integer=&gt;long or float=&gt; double）,所以dynamic mapping会选择一个比较宽的数据类型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索方式：</span><br><span class="line">exact value 精确匹配：在倒排索引过程中，分词器会将field作为一个整体创建到索引中，</span><br><span class="line">full text全文检索：分词、近义词同义词、混淆词、大小写、词性、过滤、时态转换等（normaliztion）</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【核心类型】：</span><br><span class="line">数字类型：</span><br><span class="line">  long, integer, short, byte, double, float, half_float, scaled_float</span><br><span class="line">  在满足需求的情况下，尽可能选择范围小的数据类型。</span><br><span class="line"></span><br><span class="line">2.字符串：string：</span><br><span class="line">  2.1 keyword：适用于索引结构化的字段，可以用于过滤、排序、聚合。</span><br><span class="line">      keyword类型的字段只能通过精确值（exact value）搜索到。</span><br><span class="line">      Id应该用keyword。</span><br><span class="line"></span><br><span class="line">  2.2 text：</span><br><span class="line">  当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型。</span><br><span class="line">  设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。</span><br><span class="line">  text类型的字段不用于排序，很少用于聚合。</span><br><span class="line">  （解释一下为啥不会为text创建索引：字段数据会占用大量堆空间，尤其是在加载高基数text字段时。</span><br><span class="line">  字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。</span><br><span class="line">  同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问题。这就是默认情况下禁用字段数据的原因）</span><br><span class="line">  </span><br><span class="line">  2.3 有时，在同一字段中同时具有全文本（text）和关键字（keyword）版本会很有用：一个用于全文本搜索，另一个用于聚合和排序。</span><br><span class="line">  </span><br><span class="line">3.date（时间类型）：exact value（精确匹配）</span><br><span class="line">4.布尔类型：boolean</span><br><span class="line">5.binary（二进制）：binary</span><br><span class="line">6.range（区间类型）：integer_range、float_range、long_range、double_range、date_range</span><br><span class="line"></span><br><span class="line">【复杂类型】：</span><br><span class="line">1.Object：用于单个JSON对象</span><br><span class="line">2.Nested：用于JSON对象数组</span><br><span class="line"></span><br><span class="line">【地理位置】：</span><br><span class="line">1.Geo-point：纬度&#x2F;经度积分</span><br><span class="line">2.Geo-shape：用于多边形等复杂形状</span><br><span class="line"></span><br><span class="line">【特有类型】：</span><br><span class="line">1.IP地址：ip 用于IPv4和IPv6地址</span><br><span class="line">2.Completion：提供自动完成建议</span><br><span class="line">3.Tocken_count：计算字符串中令牌的数量</span><br><span class="line">4.Murmur3：在索引时计算值的哈希并将其存储在索引中</span><br><span class="line">5.Annotated-text：索引包含特殊标记的文本（通常用于标识命名实体）</span><br><span class="line">6.Percolator：接受来自query-dsl的查询</span><br><span class="line">7.Join：为同一索引内的文档定义父&#x2F;子关系</span><br><span class="line">8.Rank features：记录数字功能以提高查询时的点击率。</span><br><span class="line">9.Dense vector：记录浮点值的密集向量。</span><br><span class="line">10.Sparse vector：记录浮点值的稀疏向量。</span><br><span class="line">11.Search-as-you-type：针对查询优化的文本字段，以实现按需输入的完成</span><br><span class="line">12.Alias：为现有字段定义别名。</span><br><span class="line">13.Flattened：允许将整个JSON对象索引为单个字段。</span><br><span class="line">14.Shape：shape 对于任意笛卡尔几何。</span><br><span class="line">15.Histogram：histogram 用于百分位数聚合的预聚合数值。</span><br><span class="line">16.Constant keyword：keyword当所有文档都具有相同值时的情况的 专业化。</span><br><span class="line"></span><br><span class="line">【Array（数组）】：在Elasticsearch中，数组不需要专用的字段数据类型。</span><br><span class="line">默认情况下，任何字段都可以包含零个或多个值，但是，数组中的所有值都必须具有相同的数据类型。</span><br><span class="line"></span><br><span class="line">【ES 7新增】：</span><br><span class="line">1.Date_nanos：date plus 纳秒</span><br><span class="line">2.Features：</span><br><span class="line">3.Vector：as</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手工创建mapping fields的mapping只能创建，无法修改</span></span><br><span class="line">PUT /product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: &#123;</span><br><span class="line">                <span class="attr">"mapping_parameter"</span>: <span class="string">"parameter_value"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapping-parameters"><a href="#Mapping-parameters" class="headerlink" title="Mapping parameters"></a>Mapping parameters</h3><p><strong>index</strong>：是否对创建对当前字段创建索引，默认true，如果不创建索引，该字段不会通过索引被搜索到,但是仍然会在source元数据中展示</p>
<p><strong>analyzer</strong>:指定分析器（character filter、tokenizer、Token filters）。</p>
<p><strong>boost</strong>：对当前字段相关度的评分权重，默认1</p>
<p><strong>coerce</strong>：是否允许强制类型转换  true “1”=&gt; 1  false “1”=&lt; 1</p>
<p><strong>copy_to</strong>：拷贝字段值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本案例</span></span><br><span class="line">PUT /product3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"date"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"false"</span>,</span><br><span class="line">                <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"Integer"</span>,</span><br><span class="line">                <span class="attr">"coerce"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tags"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"true"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"parts"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"object"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"partlist"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"nested"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy_to案例</span></span><br><span class="line">PUT copy_to</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"field1"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"copy_to"</span>: <span class="string">"field_all"</span> </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"field2"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"copy_to"</span>: <span class="string">"field_all"</span> </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"field_all"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doc_values</strong>：为了提升排序和聚合效率，默认true，如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，则可以禁用doc值以节省磁盘空间（不支持text和annotated_text）</p>
<p><strong>dynamic</strong>：控制是否可以动态添加新字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true 新检测到的字段将添加到映射中。（默认）</span><br><span class="line"></span><br><span class="line">false 新检测到的字段将被忽略。这些字段将不会被索引，因此将无法搜索，但仍会出现在_source返回的匹配项中。</span><br><span class="line">这些字段不会添加到映射中，必须显式添加新字段。</span><br><span class="line"></span><br><span class="line">strict 如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显式添加到映射中</span><br></pre></td></tr></table></figure>

<p><strong>eager_global_ordinals：用于聚合的字段上，优化聚合性能。</strong></p>
<p>Frozen indices（冻结索引）：有些索引使用率很高，会被保存在内存中，有些使用率特别低，宁愿在使用的时候重新创建，在使用完毕后丢弃数据，Frozen indices的数据命中频率小，不适用于高搜索负载，数据不会被保存在内存中，堆空间占用比普通索引少得多，Frozen indices是只读的，请求可能是秒级或者分钟级。<strong>eager_global_ordinals不适用于Frozen indices</strong></p>
<p><strong>enable</strong>：<strong>只用于mapping中的object字段类型</strong>。当设置为false时，其作用是使es不去解析该字段，并且该字段<strong>不能被查询和store</strong>，只有在_source中才能看到（即查询结果中会显示的_source数据）。设置enabled为false，可以不设置字段类型，默认为object。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "enabled": false </span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "session_data": &#123;</span><br><span class="line">                "type": "object",</span><br><span class="line">                "enabled": false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fielddata</strong>：查询时<strong>内存</strong>数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，需要字段为fielddata数据结构，并且创建正排索引保存到堆中。</p>
<p> <strong>fields：</strong>给field创建多字段，用于不同目的（全文检索或者聚合分析排序）</p>
<p><strong>format</strong>：格式化</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"date": &#123;</span><br><span class="line">    "type":  "date",</span><br><span class="line">    "format": "yyyy-MM-dd"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ignore_above</strong>：<strong>text中的keyword长度，超过长度将被截断</strong></p>
<p><strong>ignore_malformed</strong>：忽略类型错误</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "number_one": &#123;</span><br><span class="line">                "type": "integer",</span><br><span class="line">                "ignore_malformed": true</span><br><span class="line">            &#125;,</span><br><span class="line">            "number_two": &#123;</span><br><span class="line">                "type": "integer"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虽然有异常 但是不抛出</span></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Some text value"</span>,</span><br><span class="line">    <span class="attr">"number_one"</span>:<span class="string">"foo"</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据格式不对</span></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Some text value"</span>,</span><br><span class="line">    <span class="attr">"number_two"</span>: <span class="string">"foo"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index_options</strong>：控制将哪些信息添加到反向索引中以进行搜索和突出显示。仅用于text字段</p>
<p><strong>Index_phrases</strong>：提升exact_value查询速度，但是要消耗更多磁盘空间</p>
<p><strong>Index_prefixes</strong>：前缀搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_chars：前缀最小长度，&gt;0，默认2（包含）</span><br><span class="line">max_chars：前缀最大长度，&lt;20，默认5（包含）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"index_prefixes"</span>: &#123;</span><br><span class="line">    <span class="string">"min_chars"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"max_chars"</span> : <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>meta</strong>：附加元数据</p>
<p><strong>norms</strong>：是否禁用评分（在filter和聚合字段上应该禁用）。</p>
<p><strong>null_value</strong>：为null值设置默认值</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"null_value": "NULL"</span><br></pre></td></tr></table></figure>

<p><strong>proterties</strong>：除了mapping还可用于object的属性设置</p>
<p><strong>search_analyzer</strong>：设置单独的查询时分析</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT my_index&#123;</span><br><span class="line">    "settings": &#123;</span><br><span class="line">        "analysis": &#123;</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "autocomplete_filter": &#123;</span><br><span class="line">                    "type": "edge_ngram",</span><br><span class="line">                    "min_gram": 1,</span><br><span class="line">                    "max_gram": 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "analyzer": &#123;</span><br><span class="line">                "autocomplete": &#123; </span><br><span class="line">                    "type": "custom",</span><br><span class="line">                    <span class="comment">//倒排索引的分词器 默认 standard</span></span><br><span class="line">                    "tokenizer": "standard",</span><br><span class="line">                    "filter": [</span><br><span class="line">                        "lowercase",</span><br><span class="line">                        <span class="string">"autocomplete_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "text": &#123;</span><br><span class="line">                "type": "text",</span><br><span class="line">                "analyzer": "autocomplete",</span><br><span class="line">                <span class="comment">//搜索时的分词器 默认 standard</span></span><br><span class="line">                "search_analyzer": "standard" </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Quick Brown Fox"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET my_index/_search&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match": &#123;</span><br><span class="line">            "text": &#123;</span><br><span class="line">                "query": "Quick Br", </span><br><span class="line">                "operator": "and"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>similarity</strong>：为字段设置相关度算法，支持BM25、claassic（默认TF-IDF）、boolean</p>
<p><strong>store</strong>：设置字段是否仅查询</p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>语法：<code>&quot;aggs&quot;:{}</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个tag产品的数量   "size":0, 不显示原始结果  </span></span><br><span class="line"><span class="comment">//使用text类型.keyword，提高效率</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"your_group_name"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//text默认不支持聚合，若想要支持，需要修改mapping的key属性：fielddata</span></span><br><span class="line"><span class="comment">//text直接做聚合，效率极低，不推荐！！！</span></span><br><span class="line">PUT /product/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//价格大于1999的每个tag产品的数量</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;<span class="attr">"price"</span>: &#123;<span class="attr">"gt"</span>: <span class="number">1999</span>&#125;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平均值语法</span></span><br><span class="line">"avg": &#123;</span><br><span class="line">    "field": "your_avg_key"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//价格大于1999的每个tag产品的平均价格</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_avg"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span>,</span><br><span class="line">                <span class="attr">"order"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg_price"</span>: <span class="string">"desc"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照千元机 1000以下  中端机[2000-3000) 高端机 [3000,∞）</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"range"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"ranges"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">100</span>,</span><br><span class="line">                        <span class="attr">"to"</span>: <span class="number">1000</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">1000</span>,</span><br><span class="line">                        <span class="attr">"to"</span>: <span class="number">3000</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"from"</span>: <span class="number">3000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"price_agg"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(三)-倒排索引和写入原理</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%B8%89%EF%BC%89%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><blockquote>
<p>正排索引（doc values ）VS 倒排索引</p>
</blockquote>
<p><strong>概念</strong>：从广义来说，<code>正排索引（doc values ）</code> 本质上是一个序列化的列式存储。列式存储 适用于聚合、排序、脚本等操作，所有的数字、地理坐标、日期、IP 和不分析（ not_analyzed ）字符类型都会默认开启。</p>
<p>而<code>倒排索引</code>的优势在于查找包含某个项的文档，相反，也可以用它确定哪些项是否存在单个文档里。</p>
<p><strong>优化</strong>：es官方是建议，es大量是基于os cache来进行缓存和提升性能的，不建议用jvm内存来进行缓存，那样会导致一定的gc开销和oom问题，给jvm更少的内存，给os cache更大的内存。比如64g服务器，给jvm最多4 ~ 16g（1/16 ~ 1/4），os cache可以提升doc value和倒排索引的缓存和查询效率。</p>
<p><strong>总结：全文搜索需要用倒排索引，而排序和聚合则需要使用 正排索引。</strong></p>
<a id="more"></a>



<p><strong>在Mappings中有两个相关配置</strong></p>
<p><code>doc_values：true/false</code><br>为该字段创建正排索引，默认true，不支持text类型（不分词的field默认true，text类型为false）<br>提升聚合统计性能，为false时可以节省磁盘空间，但当需要使用聚合操作，需要将fielddata设置为true，可以在内存中创建临时的正排索引</p>
<p><code>index:true/false</code><br>为该字段创建倒排索引，默认为true</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;  </span><br><span class="line">            <span class="attr">"tags"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"true"</span></span><br><span class="line">                <span class="comment">//"doc_values": "true" text类型不支持</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用es自带的keyword时，它字段值是一个整体的精确匹配，并不会对字段值的内容进行分词</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而<code>doc_values</code>正排索引不支持<code>text</code>字段，那<code>text</code>字段怎么进行聚合操作呢？</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当直接使用tags进行聚合操作，想要聚合tags中的分词后的terms词项，会报错</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"tags"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text fields are not optimised for operations that require per-document field data like aggregations and sorting, </span><br><span class="line">so these operations are disabled by default. Please use a keyword field instead. </span><br><span class="line">Alternatively, set fielddata&#x3D;true on [tags] in order to load field data by uninverting the inverted index. </span><br><span class="line">Note that this can use significant memory.</span><br></pre></td></tr></table></figure>

<p>大概的意思是，必须要打开<code>fielddata=true</code>，然后将正排索引数据加载到内存中，才可以对分词的field执行聚合操作，而且会消耗很大的内存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改Mapping结构：开启tags字段 在使用聚合操作时使用 正排索引进行计算</span></span><br><span class="line">PUT /product/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再次执行上文的tags的聚合操作，就不会报错了，<strong>那么<code>fielddata</code>和<code>doc_values</code>都是开启正排索引，他们之间有什么区别呢？</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>doc_values</th>
<th>fielddata</th>
</tr>
</thead>
<tbody><tr>
<td>创建时间</td>
<td>index时创建</td>
<td>使用时动态创建</td>
</tr>
<tr>
<td>创建位置</td>
<td>磁盘</td>
<td>内存(jvm heap)</td>
</tr>
<tr>
<td>优点</td>
<td>不占用内存空间</td>
<td>不占用磁盘空间</td>
</tr>
<tr>
<td>缺点</td>
<td>索引速度稍低</td>
<td>文档很多时，动态创建开销比较大，而且占内存</td>
</tr>
<tr>
<td>默认值</td>
<td><strong>true</strong></td>
<td><strong>false</strong></td>
</tr>
</tbody></table>
<p><code>doc_values</code>速度稍低，这个是相对于fielddata方案的，其实仔细想想也可以理解。拿排序举例，相对于一个在磁盘排序，一个在内存排序。谁的速度快自然不用多说。</p>
<p>与 doc values 不同，fielddata 构建和管理 100% 在内存中，常驻于 JVM 内存堆。这意味着它本质上是不可扩展的。</p>
<p>fielddata可能会消耗大量的堆空间，尤其是在加载高基数（high cardinality）text字段时。一旦fielddata已加载到堆中，它将在该段的生命周期内保留。此外，加载fielddata是一个昂贵的过程，可能会导致用户遇到延迟命中。这就是默认情况下禁用fielddata的原因。</p>
<p><code>doc_values</code>虽然速度稍慢，但doc_values的优势还是非常明显的。一个很显著的点就是他不会随着文档的增多引起<code>OOM</code>问题。正如前面说的，doc_values在磁盘创建排序和聚合所需的正排索引。这样我们就避免了在生产环境给ES设置一个很大的<code>HEAP_SIZE</code>，也使得JVM的GC更加高效，这个又为其它的操作带来了间接的好处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.当没有文档的value字段需要聚合，而doc_values为false时，需要打开fielddata，然后临时在内存中建立正排索引，fielddata的构建和管理发生在JVM heap中。</span><br><span class="line"></span><br><span class="line">2.Fielddata默认是不启用的，因为text字段比较长，一般只做关键字分词和搜索，很少拿来进行全文匹配和聚合还有排序。</span><br><span class="line"></span><br><span class="line">3.ES采用了circuit breaker(熔断)机制避免fielddata一次性超过物理内存大小而导致内存溢出，如果发生熔断，查询会被终止并返回异常。</span><br><span class="line"></span><br><span class="line">4.fielddata使用的是jvm内存，doc value在内存不足时会静静的待在磁盘中，而当内存充足时，会蹦到内存里提升性能。</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-index/es-01.png" alt="es"></p>
<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-index/es-02.png" alt="es"></p>
<blockquote>
<p>为什么不可以用倒排索引计算聚合？</p>
<p>对于聚合部分，我们需要找到匹配的doc里所有唯一的词项（term）。需要遍历每个doc获取所有trem词项，然后再一个个去倒排索引表中进行查找，是一个 n x m 的操作，做这件事情性能很低，很有可能会造成全表遍历。</p>
<p><strong>因此通过正排索引来解决聚合问题</strong>。</p>
</blockquote>
<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-index/es-03.png" alt="es"></p>
<hr>
<h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-painless/es-01.jpg" alt="es"></p>
<p>当有写入请求时，数据会先写到内存的Buffer中（Buffer专门用于写入操作），每间隔1S会创建一个<code>index segment</code>的<code>file</code>，然后<code>segment</code>会同步到<code>OS cache</code>中，<code>OS cache</code>会返回一个<code>status = Open</code>，<strong>这时候的<code>segment</code>就能对外提供搜索操作。</strong></p>
<p><strong>读写操作进行了异步分离操作，segment对外提供读搜索操作，OS cache后台异步写入数据。</strong></p>
<blockquote>
<p>在这种方式下，如果宕机会造成少部分数据的丢失，ES是怎么避免的？</p>
</blockquote>
<p>ES在写入索引时，并没有实时落盘到索引文件，而是先双写到内存和translog文件，假如节点挂了，重启节点时就会重放日志，这样相当于把用户的操作模拟了一遍。保证了数据的不丢失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当OS cache中的数据达到一定大小之后或者一定时间后，触发Flush：</span><br><span class="line">1.执行 commit操作，把内存中的Buffer、Segment数据同步到OS cache</span><br><span class="line">2.把OS cache的数据fsync到 磁盘中</span><br><span class="line">3.清空translog</span><br></pre></td></tr></table></figure>

<p><code>Commit Point</code>用于存储可用的segment，每当创建一个segment时，都会往<code>Commit point</code>中做登记，<code>segment</code>文件并不是无限制地创建的，当达到一定的操作/大小时，会执行segment合并操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.选择一些体积小的segment，然后将其合并成一个更大的segment</span><br><span class="line">2.执行flush操作，讲OS cache的数据落地到磁盘中</span><br><span class="line">3.创建新的commit point，并且登记新的segment，然后将旧的segment标记成删除状态</span><br><span class="line">4.将新的segment搜索状态&#96;status&#x3D;open&#96;打开</span><br><span class="line">5.将删除状态的segment文件删除</span><br></pre></td></tr></table></figure>

<p><code>segment</code>维护了一个<code>.del</code>的文件，当有数据执行删除/更新操作时，它会先将数据在segment中标记成删除的状态，这时候没有物理删除，然后在查询的时候，会将删除状态的数据进行过滤。</p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(四)-painless</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E5%9B%9B%EF%BC%89painless/</url>
    <content><![CDATA[<h2 id="Painless"><a href="#Painless" class="headerlink" title="Painless"></a>Painless</h2><p>Painless是一种专门用于Elasticsearch的简单,用于内联和存储脚本，类似于Java,也有注释、关键字、类型、变量、函数等，安全的脚本语言。它是Elasticsearch的默认脚本语言，可以安全地用于内联和存储脚本。</p>
<a id="more"></a>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将price的价格减少1</span></span><br><span class="line"><span class="comment">//ctx._source 拿取上下文的source对象，固定写法</span></span><br><span class="line">POST index/_update/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: <span class="string">"ctx._source.price -=1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略的写法</span></span><br><span class="line">POST index/_update/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.price -=1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用方法添加tags里的数据</span></span><br><span class="line">POST product2/_update/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="comment">//标识这是一个painless语言</span></span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.tags.add('无线充电')"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传参调用</span></span><br><span class="line">POST product2/_update/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.tags.add(params.tag_name)"</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"tag_name"</span>: <span class="string">"无线充电"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete  id=15的数据</span></span><br><span class="line">POST product2/_update/15</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx.op='delete'"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="upsert"><a href="#upsert" class="headerlink" title="upsert"></a>upsert</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果数据存在,执行script语句进行更新操作,如果数据不存在,那么执行upsert进行插入操作</span></span><br><span class="line">GET /product2/_doc/15</span><br><span class="line">POST product2/_update/15</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"ctx._source.price += params.param1"</span>,</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"param1"</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"小米10"</span>,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="number">1999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><blockquote>
<p>Elasticsearch首次执行脚本时，将对其进行编译并将编译后的版本存储在缓存中。编译过程比较消耗性能。<br>如果需要将变量传递到脚本中，则应以命名形式传递变量，params而不是将值硬编码到脚本本身中。例如，如果您希望能够将字段值乘以不同的乘数，请不要将乘数硬编码到脚本中</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看took消耗</span></span><br><span class="line"><span class="comment">//doc['price'].value 获取doc对象里的price列的值</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//由于是查询字段经过了script计算，返回的结果需要定义一个名称，使用script_fields接收结果</span></span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_field"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value * 9"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更换num的值 对比took消耗   </span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_field"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"expression"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value * num"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"num"</span>: <span class="number">9</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doc[&#39;price&#39;] * num</code>只编译一次，而<code>doc[&#39;price&#39;] * 9</code> 会随着数字改变而一直编译，效率没有传参的方式高效。ES默认每分钟支持15次编译。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持查原数据 + 计算数据 ，如原始价格 和 多个打折价格</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['price'].value"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"discount_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="comment">//这里要使用数据，因为有多个参数</span></span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"[doc['price'].value * params.p1,doc['price'].value * params.p2]"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"p1"</span>: <span class="number">0.8</span>,</span><br><span class="line">                    <span class="attr">"p2"</span>: <span class="number">0.7</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stored-scripts"><a href="#Stored-scripts" class="headerlink" title="Stored scripts"></a>Stored scripts</h3><p><strong>Stored scripts</strong> :可以理解为script模板  缓存在集群的cache中，默认缓存大小是100MB  没有过期时间 可以手工设置过期时间script.cache.expire 通过script.cache.max_size设置缓存大小 脚本最大64MB 通过<code>script.max_size_in_bytes</code>配置 只有发生变更时重新编译。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法：/_scripts/&#123;id&#125;  类似存储过程  计算折扣 作用域为整个集群 &#123;id&#125;是scripts的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">POST _scripts/calculate-discount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"doc['price'].value * params.discount"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看</span></span><br><span class="line">GET _scripts/calculate-discount</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">DELETE _scripts/calculate-discount</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"discount_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="comment">//调用名称为calculate-discount的srcipt</span></span><br><span class="line">                <span class="attr">"id"</span>:<span class="string">"calculate-discount"</span>,</span><br><span class="line">                <span class="attr">"params"</span>: &#123;</span><br><span class="line">                    <span class="attr">"discount"</span>: <span class="number">0.8</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dates"><a href="#Dates" class="headerlink" title="Dates"></a>Dates</h3><p><strong>Dates</strong>：ZonedDateTime类型，因此它们支持诸如之类的方法getYear，getDayOfWeek 或例如从历元开始到毫秒getMillis。要在脚本中使用它们，请省略get前缀并继续使用小写的方法名其余部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getYear()</span></span><br><span class="line"><span class="comment">//getMonth()</span></span><br><span class="line"><span class="comment">//getDayOfMonth()</span></span><br><span class="line"><span class="comment">//getDayOfWeek()</span></span><br><span class="line"><span class="comment">//getDayOfYear()</span></span><br><span class="line"><span class="comment">//getHour()</span></span><br><span class="line"><span class="comment">//getMinute()</span></span><br><span class="line"><span class="comment">//getSecond()</span></span><br><span class="line"><span class="comment">//getNano()</span></span><br><span class="line">GET product2/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"test_year"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc.createtime.value.year"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><p>通过两个<code>&quot;&quot;&quot;</code>括起来，在里面能够把它当做java代码进行编写，每个语句分隔使用<code>;</code>，支持使用条件语句。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            ctx._source.name += params.name;</span></span><br><span class="line"><span class="string">            ctx._source.price -= 1</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"无线充电"</span>,</span><br><span class="line">            <span class="attr">"price"</span>: <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则部分匹配phone</span></span><br><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            // =~ 部分匹配 name中包含phone   [\s\S]表示任意符号 </span></span><br><span class="line"><span class="string">            if (ctx._source.name =~ /[\s\S]*phone[\s\S]*/) &#123;</span></span><br><span class="line"><span class="string">                ctx._source.name += "</span>***|<span class="string">";</span></span><br><span class="line"><span class="string">            &#125; else &#123;</span></span><br><span class="line"><span class="string">                //什么都不做</span></span><br><span class="line"><span class="string">                ctx.op = "</span>noop<span class="string">";</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则匹配日期 yyyy-MM-dd</span></span><br><span class="line">POST product2/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            // ==~ 全匹配 日期</span></span><br><span class="line"><span class="string">            if (ctx._source.createtime ==~ /[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;/) &#123;</span></span><br><span class="line"><span class="string">                ctx._source.name += "</span>|***<span class="string">";</span></span><br><span class="line"><span class="string">            &#125; else &#123;</span></span><br><span class="line"><span class="string">                ctx.op = "</span>noop<span class="string">";</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式默认情况下处于禁用状态，因为他们绕过了<code>Painless</code>的针对长时间运行和占用内存的脚本保护措施，而且有深度堆栈行为，若想要开启，则需要在<code>elasticsearch.yml</code>增加配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">script.painless.regex.enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算价格小于1000的tags数量</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"range"</span>: &#123;</span><br><span class="line">                        <span class="attr">"price"</span>: &#123;</span><br><span class="line">                            <span class="attr">"lt"</span>: <span class="number">1000</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"tag_agg_group"</span>: &#123;</span><br><span class="line">            <span class="attr">"sum"</span>: &#123;</span><br><span class="line">                <span class="attr">"script"</span>: &#123;</span><br><span class="line">                    <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                    <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                        int total = 0;</span></span><br><span class="line"><span class="string">                    for (int i = 0; i &lt; doc['tags.keyword'].length; i++)</span></span><br><span class="line"><span class="string">                    &#123;</span></span><br><span class="line"><span class="string">                        total++</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                    return total;</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doc[‘field’].value和params[‘_source’] [‘field’] 的区别：</p>
</blockquote>
<p>理解之间的区别是很重要的，首先，使用doc关键字，将导致该字段的条件被加载到内存（缓存），这将导致更快的执行，但更多的内存消耗。</p>
<p>此外，<strong>doc[…]符号只允许简单类型</strong>（不能返回一个复杂类型(JSON对象或者nested类型)），只有在非分析或单个词条的基础上有意义。</p>
<p>但是，doc如果可能，使用仍然是从文档访问值的推荐方式，因为_source每次使用时都必须加载并解析。使用_source非常缓慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询一批数据中，字段people：[&#123;"SF":男&#125;,&#123;"SF":女&#125;]，有多少个男性</span></span><br><span class="line">GET /test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aggs"</span>: &#123;</span><br><span class="line">        <span class="string">"sum_person"</span>: &#123;</span><br><span class="line">            <span class="string">"sum"</span>: &#123;</span><br><span class="line">                <span class="string">"script"</span>: &#123;</span><br><span class="line">                    <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                    <span class="string">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                        int total = 0;</span></span><br><span class="line"><span class="string">                    for (int i = 0; i &lt; params['_source']['people'].length; i++)</span></span><br><span class="line"><span class="string">                    &#123;</span></span><br><span class="line"><span class="string">                        if (params['_source']['people'][i]['SF'] == '男') &#123;</span></span><br><span class="line"><span class="string">                            total += 1;</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                    return total;</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(五)-分词器</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">分析器：</span></span><br><span class="line"><span class="meta">1.character</span> <span class="string">filter（mapping）：分词之前预处理（过滤无用字符、标签等，转换一些&amp;=&gt;and 《es》=&gt; es</span></span><br><span class="line">   <span class="attr">HTML</span> <span class="string">Strip Character Filter：html_strip  自动过滤html标签</span></span><br><span class="line">   <span class="meta">参数：escaped_tags</span>   <span class="string">需要保留的html标签</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">Mapping</span> <span class="string">Character Filter：type mapping</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">Pattern</span> <span class="string">Replace Character Filter：type pattern_replace</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.tokenizer（分词器）：分词</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.token</span> <span class="string">filter：停用词、时态转换、大小写转换、同义词转换、语气词处理等。如：has=&gt;have  him=&gt;he  apples=&gt;apple</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="normalization"><a href="#normalization" class="headerlink" title="normalization"></a>normalization</h3><p>标准化处理是用于完善分词器结果的，提升recall召回率。</p>
<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-analysis/es-01.png" alt="es"></p>
<p><img src="http://yrlzero.gitee.io/images/elk/elasticsearch-analysis/es-02.png" alt="es"></p>
<h3 id="character-filter"><a href="#character-filter" class="headerlink" title="character filter"></a>character filter</h3><h4 id="HTML-Strip-Character-Filter"><a href="#HTML-Strip-Character-Filter" class="headerlink" title="HTML Strip Character Filter"></a>HTML Strip Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTML Strip Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="comment">//分析器</span></span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;         <span class="comment">//设置html字符过滤器，并保留&lt;a&gt;标签</span></span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"html_strip"</span>,   </span><br><span class="line">                    <span class="attr">"escaped_tags"</span>: [<span class="string">"a"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//分词器</span></span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [<span class="string">"my_char_filter"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试分词</span></span><br><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"&lt;p&gt;I&amp;apos;m so &lt;a&gt;happy&lt;/a&gt;!&lt;/p&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : """</span><br><span class="line">          I'm so &lt;a&gt;happy&lt;/a&gt;!</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapping-Character-Filter"><a href="#Mapping-Character-Filter" class="headerlink" title="Mapping Character Filter"></a>Mapping Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Mapping Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [</span><br><span class="line">                        <span class="string">"my_char_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"mapping"</span>,   <span class="comment">//为指定的字符制定映射规则</span></span><br><span class="line">                    <span class="attr">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"٠ =&gt; 0"</span>,</span><br><span class="line">                        <span class="string">"١ =&gt; 1"</span>,</span><br><span class="line">                        <span class="string">"٢ =&gt; 2"</span>,</span><br><span class="line">                        <span class="string">"٣ =&gt; 3"</span>,</span><br><span class="line">                        <span class="string">"٤ =&gt; 4"</span>,</span><br><span class="line">                        <span class="string">"٥ =&gt; 5"</span>,</span><br><span class="line">                        <span class="string">"٦ =&gt; 6"</span>,</span><br><span class="line">                        <span class="string">"٧ =&gt; 7"</span>,</span><br><span class="line">                        <span class="string">"٨ =&gt; 8"</span>,</span><br><span class="line">                        <span class="string">"٩ =&gt; 9"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"My license plate is ٢٥٠١٥"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : "My license plate is 25015"</span><br></pre></td></tr></table></figure>

<h4 id="Pattern-Replace-Character-Filter"><a href="#Pattern-Replace-Character-Filter" class="headerlink" title="Pattern Replace Character Filter"></a>Pattern Replace Character Filter</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pattern Replace Character Filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [<span class="string">"my_char_filter"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"pattern_replace"</span>,   <span class="comment">//通过正则匹配，把-替换成_</span></span><br><span class="line">                    <span class="attr">"pattern"</span>: <span class="string">"(\\d+)-(?=\\d)"</span>,</span><br><span class="line">                    <span class="attr">"replacement"</span>: <span class="string">"$1_"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"My credit card is 123-456-789"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">"token" : "My credit card is 123_456_789"</span><br></pre></td></tr></table></figure>

<h3 id="token-filter"><a href="#token-filter" class="headerlink" title="token filter"></a>token filter</h3><h4 id="lowercase-token-filter"><a href="#lowercase-token-filter" class="headerlink" title="lowercase token filter"></a>lowercase token filter</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大小写 lowercase token filter</span></span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokenizer"</span> : <span class="string">"standard"</span>,</span><br><span class="line">  <span class="attr">"filter"</span> : [<span class="string">"lowercase"</span>],</span><br><span class="line">  <span class="attr">"text"</span> : <span class="string">"THE Quick FoX JUMPs"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">the、quick、fox、jumps</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当分词后的词项长度满足 &lt; 5 时，执行 filter配置</span></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"condition"</span>,</span><br><span class="line">            <span class="attr">"filter"</span>: [ <span class="string">"lowercase"</span> ],</span><br><span class="line">            <span class="attr">"script"</span>: &#123;</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"token.getTerm().length() &lt; 5"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"THE QUICK BROWN FOX"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">the、QUICK、BROWN、fox</span><br></pre></td></tr></table></figure>

<h4 id="stopwords-token-filter"><a href="#stopwords-token-filter" class="headerlink" title="stopwords token filter"></a>stopwords token filter</h4><p>在信息检索中，停用词是为节省存储空间和提高搜索效率，处理文本时自动过滤掉某些字或词，这些字或词即被称为Stop Words（停用词）。</p>
<p>停用词大致分为两类。一类是语言中的功能词，这些词极其普遍而无实际含义，如“the”、“is“、“which“、“on”等。另一类是词汇词，比如’want’等，这些词应用广泛，但搜索引擎无法保证能够给出真正相关的搜索结果，难以缩小搜索范围，还会降低搜索效率。</p>
<p>实践中，<strong>通过配置<code>stopwords</code>使得这些词汇不添加进倒排索引中</strong>，从而节省索引的存储空间、提高搜索性能。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>:&#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"stopwords"</span>:<span class="string">"_english_"</span>  <span class="comment">//启动英语停用词</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Teacher Ma is in the restroom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">未启用英语停用词结果：</span><br><span class="line">Teacher、Ma、is、in、the、restroom</span><br><span class="line"></span><br><span class="line">启用英语停用词结果：</span><br><span class="line">Teacher、Ma、restroom</span><br></pre></td></tr></table></figure>

<h3 id="tokenizer"><a href="#tokenizer" class="headerlink" title="tokenizer"></a>tokenizer</h3><p>基于ES 7.6版本，支持的内置分词器有15种。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/analysis-tokenizers.html" target="_blank" rel="noopener">官网介绍</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.standard</span> <span class="string">analyzer：默认分词器，中文支持的不理想，会逐字拆分。</span></span><br><span class="line">   <span class="attr">max_token_length：最大令牌长度。如果看到令牌超过此长度，则将其max_token_length间隔分割。默认为255。</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">2.Pattern</span> <span class="string">Tokenizer：以正则匹配分隔符，把文本拆分成若干词项。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.Simple</span> <span class="string">Pattern Tokenizer：以正则匹配词项，速度比Pattern Tokenizer快。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.whitespace</span> <span class="string">analyzer：以空白符分隔	Tim_cookie</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置内置分词器</span></span><br><span class="line">PUT /test_analysis/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;  <span class="comment">//自定义分词器名称</span></span><br><span class="line">                    <span class="attr">"tokenizer"</span>:<span class="string">"whitespace"</span>   <span class="comment">//指定使用的分词器 standard、pattern、simple</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证分词器</span></span><br><span class="line">GET /test_analysis/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"ooo is bbbb!!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-analysis"><a href="#自定义-analysis" class="headerlink" title="自定义 analysis"></a>自定义 analysis</h4><p>设置<code>&quot;type&quot;: &quot;custom&quot;</code>告诉Elasticsearch我们正在定义一个定制分析器。将此与配置内置分析器的方式进行比较： type将设置为内置分析器的名称，如 standard或simple</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_analysis</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;   <span class="comment">//自定义字符过滤器，设置映射规则</span></span><br><span class="line">                <span class="attr">"test_char_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="attr">"mappings"</span>: [</span><br><span class="line">                        <span class="string">"&amp; =&gt; and"</span>,</span><br><span class="line">                        <span class="string">"| =&gt; or"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;         <span class="comment">//过滤器，过滤指定字符</span></span><br><span class="line">                <span class="attr">"test_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="attr">"stopwords"</span>: [<span class="string">"is"</span>,<span class="string">"in"</span>,<span class="string">"at"</span>,<span class="string">"the"</span>,<span class="string">"a"</span>,<span class="string">"for"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tokenizer"</span>: &#123;     <span class="comment">//正则分析器</span></span><br><span class="line">                <span class="attr">"punctuation"</span>: &#123; </span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"pattern"</span>,</span><br><span class="line">                    <span class="attr">"pattern"</span>: <span class="string">"[ .,!?]"</span>  <span class="comment">//以正则匹配到的字符做分词</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;      <span class="comment">//自定义分词器</span></span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"custom"</span>,    <span class="comment">//告诉ES这是一个自定义分词器</span></span><br><span class="line">                    <span class="attr">"char_filter"</span>: [     <span class="comment">//设置两个字符过滤器</span></span><br><span class="line">                        <span class="string">"html_strip"</span>,</span><br><span class="line">                        <span class="string">"test_char_filter"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,  <span class="comment">//设置内置分词器</span></span><br><span class="line">                    <span class="attr">"filter"</span>: [<span class="string">"lowercase"</span>,<span class="string">"test_stopwords"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /test_analysis/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Teacher ma &amp; zhang also thinks [mother's friends] is good | nice!!!"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"my_analyzer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分词结果：</span><br><span class="line">teacher、ma、and、zhang、also、thinks、mother's、friends、good、or、nice</span><br></pre></td></tr></table></figure>

<h4 id="IK中文分词器"><a href="#IK中文分词器" class="headerlink" title="IK中文分词器"></a>IK中文分词器</h4><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">IK分词器下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IK分词器安装步骤：</span><br><span class="line">1.上Github下载IK分词器</span><br><span class="line">2.解压分词器，使用maven进行package打包</span><br><span class="line">3.从releases中获取打好的zip包，放到es安装目录&#x2F;plugins&#x2F;ik&#x2F; 目录下解压</span><br><span class="line">4.重启ES</span><br></pre></td></tr></table></figure>

<p>如果ES版本比IK分词器版本高，启动ES时可能会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin [analysis-ik] was built for Elasticsearch version 7.4.0 but version 7.10.1 is running</span><br></pre></td></tr></table></figure>

<p>需要修改IK分词器的配置文件<code>plugin-descriptor.properties</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改成自己使用的ES版本号</span></span><br><span class="line"><span class="meta">elasticsearch.version</span>=<span class="string">7.10.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IK分词器提供两种analyzer</span><br><span class="line">  ik_max_word：细粒度</span><br><span class="line">  ik_smart：粗粒度</span><br><span class="line"></span><br><span class="line">2.IK文件描述</span><br><span class="line">  IKAnalyzer.cfg.xml：IK分词配置文件</span><br><span class="line">  主词库：main.dic</span><br><span class="line">  英文停用词：stopword.dic，不会建立在倒排索引中</span><br><span class="line">  特殊词库：</span><br><span class="line">    quantifier.dic：特殊词库：计量单位等</span><br><span class="line">    suffix.dic：特殊词库：后缀名</span><br><span class="line">    surname.dic：特殊词库：百家姓</span><br><span class="line">    preposition：特殊词库：语气词</span><br><span class="line">  </span><br><span class="line">  自定义词库：比如当下流行词：857、emmm...、996</span><br><span class="line">  热更新：</span><br><span class="line">    修改ik分词器源码</span><br><span class="line">    基于ik分词器原生支持的热更新方案，部署web服务器，提供http接口，通过modified和tag两个http响应头，来提供词语的热更新</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"你的衣服真好看"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">你、的、衣服、真好、好看</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"你的衣服真好看"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"ik_smart"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">你、的、衣服、真、好看</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(六)-前缀、通配符、正则、模糊查询</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="prefix-前缀"><a href="#prefix-前缀" class="headerlink" title="prefix-前缀"></a>prefix-前缀</h2><p>前缀查询：以xx开头的搜索，不计算相关度评分，和filter比，没有bitcache。前缀搜索，尽量把前缀长度设置的更长，<strong>性能差，因为它会扫描倒排索引整张表，匹配每个term是否包含xx。</strong></p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">index_prefixes: 默认   "min_chars" : 2,   "max_chars" : 5</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于SQL的左Like查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"myword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>index_prefixes</code>映射，ES会额外建立一个长度在2和5之间索引，在进行前缀匹配的时候效率会有很大的提高</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置默认的 启动索引 加快前缀搜索速度</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"index_prefixes"</span>: &#123;</span><br><span class="line">                    <span class="attr">"min_chars"</span>:<span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"max_chars"</span>:<span class="number">4</span></span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wildcard-通配符"><a href="#wildcard-通配符" class="headerlink" title="wildcard-通配符"></a>wildcard-通配符</h2><p>通配符：通配符运算符是匹配一个或多个字符的占位符。例如，*通配符运算符匹配零个或多个字符。可以将通配符运算符与其他字符结合使用以创建通配符模式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  "name" : "xiaomi nfc phone"</span></span><br><span class="line"><span class="comment">//通配符匹配</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;     <span class="comment">//匹配倒排索引表中的term词项</span></span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xia?mi"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">能查出  "name" : "xiaomi nfc phone" 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="attr">"name.keyword"</span>: &#123;     <span class="comment">//全量匹配内容</span></span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xia?mi"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">不能查出数据</span><br></pre></td></tr></table></figure>

<h2 id="regexp-正则"><a href="#regexp-正则" class="headerlink" title="regexp-正则"></a>regexp-正则</h2><p>正则：regexp查询的性能可以根据提供的正则表达式而有所不同。为了提高性能，应避免使用通配符模式，如.<em>或 .</em>?+未经前缀或后缀</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"name" : "xiaomi nfc phone"  正则匹配</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"[\\s\\S]*nfc[\\s\\S]*"</span>,  <span class="comment">//  \\s\\S表示任意字符</span></span><br><span class="line">                <span class="attr">"flags"</span>: <span class="string">"ALL"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"desc" : "xiaomi nfc 2020-05-20 phone"</span></span><br><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">".*2020-05-20.*"</span>,</span><br><span class="line">                <span class="attr">"flags"</span>: <span class="string">"ALL"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 无法匹配到上文中的注释数据，原因在于默认使用了<code>standard</code>，会将日期拆成【2020】、【05】、【20】三个词汇，如果想要匹配，需要使用<code>desc.keyword</code>进行全文匹配，但是这样性能十分低下。</p>
<p>而IK分词器很好的对日期进行了分词词项【2020-05-20】，对该索引指定IK分词器（需重建索引），即可查询到结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"ik_max_word"</span>,   <span class="comment">//倒排索引分词</span></span><br><span class="line">                <span class="attr">"search_analyzer"</span>: <span class="string">"ik_max_word"</span>  <span class="comment">//搜索分词</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fuzzy-混淆模糊查询"><a href="#fuzzy-混淆模糊查询" class="headerlink" title="fuzzy-混淆模糊查询"></a>fuzzy-混淆模糊查询</h2><p>混淆字符 (<strong>b</strong>ox → <strong>f</strong>ox)                缺少字符 (<strong>b</strong>lack → lack)</p>
<p>多出字符 (sic → sic<strong>k</strong>)                颠倒次序 (<strong>ac</strong>t → <strong>ca</strong>t)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">value：（必需，字符串）</span><br><span class="line">fuzziness：（可选，字符串）最大误差(距离)  并非越大越好, 召回率高 但是结果不准确</span><br></pre></td></tr></table></figure>

<p>距离：两段文本之间的Damerau-Levenshtein距离是指一个字符串需要经过多少次操作之后才能变成另一个字符串。</p>
<p>距离公式：Levenshtein是lucene的，es改进版：Damerau-Levenshtein，<code>axe=&gt;aex  Levenshtein=2</code> ，而<code>Damerau-Levenshtein=1</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 使用fuzzy</span></span><br><span class="line">GET /product/_search </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"xioami"</span>,  <span class="comment">//匹配 xiaomi</span></span><br><span class="line">                <span class="attr">"fuzziness"</span>: <span class="number">5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 使用match</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"quangengneng nfc"</span>,</span><br><span class="line">                <span class="attr">"fuzziness"</span>: <span class="string">"AUTO"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="match-phrase-prefix-短语前缀"><a href="#match-phrase-prefix-短语前缀" class="headerlink" title="match_phrase_prefix-短语前缀"></a>match_phrase_prefix-短语前缀</h2><p>match_phrase_prefix与match_phrase相同,但是它多了一个特性,就是它允许在文本的最后一个词项(term)上的前缀匹配。</p>
<p>如果 是一个单词,比如a,它会匹配文档字段所有以a开头的文档,如果是一个短语,比如 “this is ma” ,<strong>他会先在倒排索引中做以ma做前缀搜索,然后在匹配到的doc中做match_phrase查询</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">GET /index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"fieldName"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"text"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">analyzer 指定何种分析器来对该短语进行分词处理</span><br><span class="line">max_expansions 限制匹配到的最大词项，每个分片中匹配的结果达到max_expansions值后停止遍历倒排索引表</span><br><span class="line">boost 用于设置该查询的权重</span><br><span class="line">slop：允许短语间的词项(term)间隔，指为了让查询和文档匹配需要移动term多少(slop)次</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例  匹配 "desc" : "zhichi nfc"   注意！无法匹配 "zhichi aaa nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"zhichi nf"</span>,  <span class="comment">//先进行nf 前缀匹配，再进行match_phrase(zhichi)词项匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例 可以匹配到："zhichi aaa nfc"</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase_prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"desc"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"zhichi nf"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"whitespace"</span>,</span><br><span class="line">                <span class="attr">"max_expansions"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"slop"</span>: <span class="number">1</span>,   <span class="comment">//配置slop，允许移动一次term匹配结果</span></span><br><span class="line">                <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N-gram：token-filter"><a href="#N-gram：token-filter" class="headerlink" title="N-gram：token filter"></a>N-gram：token filter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edge_ngram：是从第一个字符开始,按照步长,进行分词,适合前缀匹配场景,比如:订单号,手机号,邮政编码的检索</span><br><span class="line">ngram：是从每一个字符开始,按照步长,进行分词,适合前缀中缀检索</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">min_gram &#x3D;1 最小步长 默认值 1</span><br><span class="line">max_gram &#x3D;1 最大步长 默认值 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【edge_ngram】 拆词： &quot;reba always loves me&quot;</span><br><span class="line">min_gram &#x3D;1   max_gram &#x3D;1</span><br><span class="line">#r a l m</span><br><span class="line"></span><br><span class="line">min_gram &#x3D;1   max_gram &#x3D;2</span><br><span class="line">#r a l m</span><br><span class="line">#re al lo me</span><br><span class="line"></span><br><span class="line">min_gram &#x3D;2   max_gram &#x3D;3</span><br><span class="line">#re al lo me</span><br><span class="line">#reb alw lov me</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引，设置分词器和token filter</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"2_3_edge_ngram"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"edge_ngram"</span>,</span><br><span class="line">                    <span class="attr">"min_gram"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"max_gram"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_edge_ngram"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>: [ <span class="string">"2_3_edge_ngram"</span> ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>:<span class="string">"my_edge_ngram"</span>,</span><br><span class="line">                <span class="attr">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>: <span class="string">"my_edge_ngram"</span></span><br><span class="line">  , <span class="attr">"text"</span>: [<span class="string">"my english"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">my、en、eng</span><br><span class="line"></span><br><span class="line">如果分词器把edge_ngram换成ngram，则输出结果如下：</span><br><span class="line">my、en、ng、gl、li、is、sh、eng、ngl、gli、lis、ish</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配 "text": "my english is good"</span></span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"my eng is goo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(七)-JAVA API</title>
    <url>/2021/05/25/elasticsearch%EF%BC%88%E4%B8%83%EF%BC%89JAVA%20API/</url>
    <content><![CDATA[<h2 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a>JAVA API</h2><p><strong>Transport Client</strong>：TransportClient不推荐使用，而推荐使用Java High Level REST Client，并将在Elasticsearch 8.0中删除。<br><strong>Java Low Level REST Client</strong>：低级别的REST客户端，通过http与集群交互，用户需自己编组请求JSON串，及解析响应JSON串。兼容所有ES版本<br><strong>Java High Level REST Client</strong>：高级别的REST客户端，基于低级别的REST客户端，增加了编组请求JSON串、解析响应JSON串等相关api。使用的版本需要保持和ES服务端的版本一致，否则会有版本问题。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--ES transport client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--high-level-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置集群名称</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="comment">//TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</span></span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>))<span class="comment">//通讯端口  而不是服务端口</span></span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9301</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据</span></span><br><span class="line">    create(client);</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    List&lt;Product&gt; list = service.list();</span><br><span class="line">    <span class="keyword">for</span> (Product item : list) &#123;</span><br><span class="line">       	<span class="comment">//固定语法</span></span><br><span class="line">        IndexResponse response = client.prepareIndex(<span class="string">"product2"</span>, <span class="string">"_doc"</span>, item.getId().toString())</span><br><span class="line">            .setSource(XContentFactory.jsonBuilder()</span><br><span class="line">                       .startObject()</span><br><span class="line">                       .field(<span class="string">"name"</span>, item.getName())</span><br><span class="line">                       .field(<span class="string">"desc"</span>, item.getDesc())</span><br><span class="line">                       .field(<span class="string">"price"</span>, item.getPrice())</span><br><span class="line">                       .field(<span class="string">"date"</span>, item.getCreateTime().toLocalDateTime().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>)))</span><br><span class="line">                       .field(<span class="string">"tags"</span>, item.getTags().split(<span class="string">","</span>))</span><br><span class="line">                       .endObject())</span><br><span class="line">            .get();</span><br><span class="line">        System.out.println(response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询一条数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    GetResponse response = client.prepareGet(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"1"</span>).get();</span><br><span class="line">    String index = response.getIndex();<span class="comment">//获取索引名称</span></span><br><span class="line">    String type = response.getType();<span class="comment">//获取索引类型</span></span><br><span class="line">    String id = response.getId();<span class="comment">//获取索引id</span></span><br><span class="line">    System.out.println(<span class="string">"index:"</span> + index);</span><br><span class="line">    System.out.println(<span class="string">"type:"</span> + type);</span><br><span class="line">    System.out.println(<span class="string">"id:"</span> + id);</span><br><span class="line">    System.out.println(response.getSourceAsString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量查询</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product"</span>)</span><br><span class="line">        .get();</span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        String res = hit.getSourceAsString();</span><br><span class="line">        System.out.println(<span class="string">"res"</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增量更新</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    UpdateResponse response = client.prepareUpdate(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"2"</span>)</span><br><span class="line">        .setDoc(XContentFactory.jsonBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                .field(<span class="string">"name"</span>, <span class="string">"update name"</span>)</span><br><span class="line">                .endObject())</span><br><span class="line">        .get();</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    DeleteResponse response = client.prepareDelete(<span class="string">"product"</span>, <span class="string">"_doc"</span>, <span class="string">"2"</span>).get();</span><br><span class="line">    System.out.println(response.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多条件查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSearch</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SearchResponse：返回的结果集</span></span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product2"</span>)</span><br><span class="line">        .setQuery(QueryBuilders.termQuery(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>))                 <span class="comment">// Query</span></span><br><span class="line">        .setPostFilter(QueryBuilders.rangeQuery(<span class="string">"price"</span>).from(<span class="number">0</span>).to(<span class="number">4000</span>))</span><br><span class="line">        .setFrom(<span class="number">1</span>).setSize(<span class="number">3</span>)</span><br><span class="line">        .get();</span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        String res = hit.getSourceAsString();</span><br><span class="line">        System.out.println(<span class="string">"res"</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个月份的tags中每个词项term的平均价格</span></span><br><span class="line">GET /product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_by_month"</span>: &#123;</span><br><span class="line">            <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"date"</span>,</span><br><span class="line">                <span class="attr">"calendar_interval"</span>: <span class="string">"month"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"by_tags"</span>: &#123;</span><br><span class="line">                    <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                        <span class="attr">"field"</span>: <span class="string">"tags.keyword"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                        <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                            <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                                <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggregations"</span> : &#123;</span><br><span class="line">        <span class="attr">"group_by_month"</span> : &#123;</span><br><span class="line">            <span class="attr">"buckets"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span> : <span class="string">"2020-04-01T00:00:00.000Z"</span>,</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="number">1585699200000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"by_tags"</span> : &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span> : [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"bufangshui"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">999.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"fashao"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">2999.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key_as_string"</span> : <span class="string">"2020-05-01T00:00:00.000Z"</span>,</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="number">1588291200000</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"by_tags"</span> : &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span> : [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"fashao"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">4499.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span> : <span class="string">"xingjiabi"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span> : <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                                    <span class="attr">"value"</span> : <span class="number">4499.0</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Java代码实现上面案例的聚合查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggSearch</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//region 1-&gt;计算并返回聚合分析response对象</span></span><br><span class="line">    SearchResponse response = client.prepareSearch(<span class="string">"product"</span>)</span><br><span class="line">        .addAggregation(</span><br><span class="line">        AggregationBuilders.dateHistogram(<span class="string">"group_by_month"</span>)</span><br><span class="line">        .field(<span class="string">"date"</span>)</span><br><span class="line">        .calendarInterval(DateHistogramInterval.MONTH)</span><br><span class="line">        <span class="comment">//.dateHistogramInterval(DateHistogramInterval.MONTH)</span></span><br><span class="line">        .subAggregation(</span><br><span class="line">            AggregationBuilders</span><br><span class="line">            .terms(<span class="string">"by_tag"</span>)</span><br><span class="line">            .field(<span class="string">"tags.keyword"</span>)</span><br><span class="line">            .subAggregation(</span><br><span class="line">                AggregationBuilders</span><br><span class="line">                .avg(<span class="string">"avg_price"</span>)</span><br><span class="line">                .field(<span class="string">"price"</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">        .execute().actionGet();  <span class="comment">//执行查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//region 2-&gt;输出结果信息</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="comment">//获取aggregations结果</span></span><br><span class="line">    Map&lt;String, Aggregation&gt; map = response.getAggregations().asMap();</span><br><span class="line">    <span class="comment">//获取group_by_month结果</span></span><br><span class="line">    Aggregation group_by_month = map.get(<span class="string">"group_by_month"</span>);</span><br><span class="line">    Histogram dates = (Histogram) group_by_month;</span><br><span class="line">    <span class="comment">//转换成分组的桶</span></span><br><span class="line">    Iterator&lt;Histogram.Bucket&gt; buckets = (Iterator&lt;Histogram.Bucket&gt;) dates.getBuckets().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buckets.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//遍历桶中的数据</span></span><br><span class="line">        Histogram.Bucket dateBucket = buckets.next();</span><br><span class="line">        System.out.println(<span class="string">"\n\n月份："</span> + dateBucket.getKeyAsString() + <span class="string">"\n计数："</span> + dateBucket.getDocCount());</span><br><span class="line">        <span class="comment">//获取桶里面的桶by_tag</span></span><br><span class="line">        Aggregation group_by_tag = dateBucket.getAggregations().asMap().get(<span class="string">"by_tag"</span>);</span><br><span class="line">        StringTerms terms = (StringTerms) group_by_tag;</span><br><span class="line">        Iterator&lt;StringTerms.Bucket&gt; tagsBucket = terms.getBuckets().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tagsBucket.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历by_tag桶，获取桶中的平均价格</span></span><br><span class="line">            StringTerms.Bucket tagBucket = tagsBucket.next();</span><br><span class="line">            System.out.println(<span class="string">"\t标签名称："</span> + tagBucket.getKey() + <span class="string">"\n\t数量："</span> + tagBucket.getDocCount());</span><br><span class="line">            Aggregation avg_price = tagBucket.getAggregations().get(<span class="string">"avg_price"</span>);</span><br><span class="line">            Avg avg = (Avg) avg_price;</span><br><span class="line">            System.out.println(<span class="string">"\t平均价格："</span> + avg.getValue() + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="High-Level-REST-Client"><a href="#High-Level-REST-Client" class="headerlink" title="High Level REST Client"></a>High Level REST Client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常见步骤：</span><br><span class="line">1.创建对应的Request对象</span><br><span class="line">2.创建对应的Builder对象&#x2F;编写对应操作</span><br><span class="line">3.Client执行对应的方法</span><br></pre></td></tr></table></figure>



<h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 RestHighLevelClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> createConnection &#123;</span><br><span class="line">    RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">            <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>),</span><br><span class="line">            <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9201</span>, <span class="string">"http"</span>)));  <span class="comment">//使用的是9200服务端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line"></span><br><span class="line">    request.settings(Settings.builder()</span><br><span class="line">                     .put(<span class="string">"index.number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                     .put(<span class="string">"index.number_of_replicas"</span>, <span class="number">2</span>)</span><br><span class="line">                    );</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (createIndexResponse.isAcknowledged()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"创建index成功!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"创建index失败!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">"test_index*"</span>);</span><br><span class="line">    GetIndexResponse response = client.indices().get(request, RequestOptions.DEFAULT);</span><br><span class="line">    String[] indices = response.getIndices();</span><br><span class="line">    <span class="keyword">for</span> (String indexName : indices) &#123;</span><br><span class="line">        System.out.println(<span class="string">"index name:"</span> + indexName);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delIndex</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    AcknowledgedResponse response = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (response.isAcknowledged()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"删除index成功!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"删除index失败!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertData</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    List&lt;Product&gt; list = service.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据，index不存在则自动根据匹配到的template创建。index没必要每天创建一个，如果是为了灵活管理，最低建议每月一个 yyyyMM。</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    <span class="comment">//最好不要自定义id 会影响插入速度。</span></span><br><span class="line">    Product product = list.get(<span class="number">0</span>);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    request.id(product.getId().toString());</span><br><span class="line">    request.source(gson.toJson(product), XContentType.JSON);</span><br><span class="line">    IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertData</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//批量插入数据，更新和删除同理</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    product.setPrice(<span class="number">3999.00</span>);</span><br><span class="line">    product.setDesc(<span class="string">"xioami"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        product.setName(<span class="string">"name"</span> + i);</span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest().source(gson.toJson(product), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse response = client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(<span class="string">"数量:"</span> + response.getItems().length);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ID查询数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getById</span><span class="params">(RestHighLevelClient client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意 这里查询使用的是别名。</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">"test_index"</span>, <span class="string">"PPWhwnIBRwX67j4bTmV1"</span>);</span><br><span class="line">    String[] includes = &#123;<span class="string">"name"</span>, <span class="string">"price"</span>&#125;;</span><br><span class="line">    String[] excludes = &#123;<span class="string">"desc"</span>&#125;;</span><br><span class="line">    FetchSourceContext fetchSourceContext = <span class="keyword">new</span> FetchSourceContext(<span class="keyword">true</span>, includes, excludes);</span><br><span class="line">    <span class="comment">//只查询特定字段。如果需要查询所有字段则不设置该项。</span></span><br><span class="line">    request.fetchSourceContext(fetchSourceContext);</span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ID删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delById</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">"test_index"</span>, <span class="string">"1"</span>);</span><br><span class="line">    DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiGetById</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//多个根据id查询</span></span><br><span class="line">    MultiGetRequest request = <span class="keyword">new</span> MultiGetRequest();</span><br><span class="line">    request.add(<span class="string">"test_index"</span>, <span class="string">"PPWhwnIBRwX67j4bTmV1"</span>);</span><br><span class="line">    <span class="comment">//两种写法</span></span><br><span class="line">    request.add(<span class="keyword">new</span> MultiGetRequest.Item(</span><br><span class="line">        <span class="string">"test_index"</span>,</span><br><span class="line">        <span class="string">"PfWhwnIBRwX67j4bTmV1"</span>));</span><br><span class="line">    MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">for</span> (MultiGetItemResponse itemResponse : response) &#123;</span><br><span class="line">        System.out.println(itemResponse.getResponse().getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateByQuery</span><span class="params">(RestHighLevelClient client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateByQueryRequest request = <span class="keyword">new</span> UpdateByQueryRequest(<span class="string">"test_index"</span>);</span><br><span class="line">    <span class="comment">//默认情况下，版本冲突会中止 UpdateByQueryRequest 进程，但是你可以用以下命令来代替</span></span><br><span class="line">    <span class="comment">//设置版本冲突继续</span></span><br><span class="line">    <span class="comment">//        request.setConflicts("proceed");</span></span><br><span class="line">    <span class="comment">//设置更新条件</span></span><br><span class="line">    request.setQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"name1 name3"</span>));</span><br><span class="line">    <span class="comment">//        //限制更新条数</span></span><br><span class="line">    <span class="comment">//        request.setMaxDocs(10);</span></span><br><span class="line">    request.setScript(</span><br><span class="line">        <span class="keyword">new</span> Script(ScriptType.INLINE, <span class="string">"painless"</span>, <span class="string">"ctx._source.desc+='#';"</span>, Collections.emptyMap()));</span><br><span class="line">    BulkByScrollResponse response = client.updateByQuery(request,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">carInfo</span><span class="params">(String keyword,Integer from,Integer size)</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    </span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"name"</span>, keyword));</span><br><span class="line">    searchSourceBuilder.from(from);</span><br><span class="line">    searchSourceBuilder.size(size);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//ESClient.getInstance().closeClient();</span></span><br><span class="line">    </span><br><span class="line">    ResultDto res = <span class="keyword">new</span> ResultDto();</span><br><span class="line">    res.setData(searchResponse.getHits().getHits());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Scroll查询"><a href="#Scroll查询" class="headerlink" title="Scroll查询"></a>Scroll查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">scroll</span><span class="params">(String scrollId)</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.size(<span class="number">2</span>); <span class="comment">//每页两条</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    searchRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));  <span class="comment">//scrollID的有效期1分钟</span></span><br><span class="line"></span><br><span class="line">    SearchResponse searchResponse = scrollId == <span class="keyword">null</span></span><br><span class="line">        ? client.search(searchRequest, RequestOptions.DEFAULT)</span><br><span class="line">        : client.scroll(<span class="keyword">new</span> SearchScrollRequest(scrollId), RequestOptions.DEFAULT);</span><br><span class="line">    scrollId = searchResponse.getScrollId();</span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    </span><br><span class="line">    ResultDto res = <span class="keyword">new</span> ResultDto();</span><br><span class="line">    res.setTag(scrollId);</span><br><span class="line">    res.setData(hits.getHits());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">bulk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"msb_auto"</span>);</span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    request.add(<span class="keyword">new</span> DeleteRequest(<span class="string">"product"</span>, <span class="string">"13"</span>));  <span class="comment">//删除doc</span></span><br><span class="line">    request.add(<span class="keyword">new</span> UpdateRequest(<span class="string">"product"</span>, <span class="string">"22"</span>)</span><br><span class="line">                .doc(XContentType.JSON, <span class="string">"name"</span>, <span class="string">"天籁之音"</span>));  <span class="comment">//修改doc一个字段</span></span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(<span class="string">"product"</span>).id(<span class="string">"4"</span>)</span><br><span class="line">                .source(XContentType.JSON, <span class="string">"myname"</span>, <span class="string">"天津一汽"</span>)); <span class="comment">//修改整doc</span></span><br><span class="line">    BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索模板"><a href="#搜索模板" class="headerlink" title="搜索模板"></a>搜索模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">templateSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//region 创建模板并缓存 作用域为整个集群</span></span><br><span class="line">    Request scriptRequest = <span class="keyword">new</span> Request(<span class="string">"POST"</span>, <span class="string">"_scripts/test_template_search"</span>);</span><br><span class="line">    scriptRequest.setJsonEntity(</span><br><span class="line">        <span class="string">"&#123;"</span> +</span><br><span class="line">        <span class="string">"  \"script\": &#123;"</span> +</span><br><span class="line">        <span class="string">"    \"lang\": \"mustache\","</span> +</span><br><span class="line">        <span class="string">"    \"source\": &#123;"</span> +</span><br><span class="line">        <span class="string">"      \"query\": &#123; \"match\" : &#123; \"&#123;&#123;field&#125;&#125;\" : \"&#123;&#123;value&#125;&#125;\" &#125; &#125;,"</span> +</span><br><span class="line">        <span class="string">"      \"size\" : \"&#123;&#123;size&#125;&#125;\""</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span> +</span><br><span class="line">        <span class="string">"  &#125;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>);</span><br><span class="line">    Response scriptResponse = client.getLowLevelClient().performRequest(scriptRequest);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">    request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"msb_auto"</span>));</span><br><span class="line">    <span class="comment">//STORED 保存到内存模板</span></span><br><span class="line">    request.setScriptType(ScriptType.STORED);</span><br><span class="line">    request.setScript(<span class="string">"test_template_search"</span>);</span><br><span class="line">    <span class="comment">// 本地模板</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//request.setScriptType(ScriptType.INLINE);</span></span><br><span class="line">    <span class="comment">//    request.setScript(</span></span><br><span class="line">    <span class="comment">//                    "&#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"from\": &#123;&#123;from&#125;&#125;,\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"size\": &#123;&#123;size&#125;&#125;,\n" +</span></span><br><span class="line">    <span class="comment">//                    "  \"query\": &#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "    \"match\": &#123;\n" +</span></span><br><span class="line">    <span class="comment">//                    "      \"master_brand_name\": \"&#123;&#123;master_brand_name&#125;&#125;\"\n" +</span></span><br><span class="line">    <span class="comment">//                    "    &#125;\n" +</span></span><br><span class="line">    <span class="comment">//                    "  &#125;\n" +</span></span><br><span class="line">    <span class="comment">//                    "&#125;");</span></span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Object&gt; scriptParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    scriptParams.put(<span class="string">"field"</span>, <span class="string">"master_brand_name"</span>);</span><br><span class="line">    scriptParams.put(<span class="string">"value"</span>, <span class="string">"一汽"</span>);</span><br><span class="line">    scriptParams.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">    request.setScriptParams(scriptParams);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    SearchTemplateResponse response = client.searchTemplate(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchHit[] fuzzy(String name) &#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.fuzzyQuery(<span class="string">"brand_name.keyword"</span>, name).fuzziness(Fuzziness.AUTO));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> response.getHits().getHits();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多语句查询"><a href="#多语句查询" class="headerlink" title="多语句查询"></a>多语句查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">multiSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个空的MultiSearchRequest</span></span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.创建SearchRequest,并填充查询条件</span></span><br><span class="line">    SearchRequest firstSearchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"series_name"</span>, <span class="string">"朗动"</span>));</span><br><span class="line">    firstSearchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//3.将SearchRequest装配到MultiSearchRequest中</span></span><br><span class="line">    request.add(firstSearchRequest);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//4.创建第二个SearchRequest并重复第三步</span></span><br><span class="line">    SearchRequest secondSearchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">"series_name"</span>, <span class="string">"揽胜运动"</span>));</span><br><span class="line">    secondSearchRequest.source(searchSourceBuilder);</span><br><span class="line">    request.add(secondSearchRequest);</span><br><span class="line"></span><br><span class="line">    MultiSearchResponse response = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bool查询"><a href="#Bool查询" class="headerlink" title="Bool查询"></a>Bool查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultDto <span class="title">boolSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line"></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"product"</span>);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query</span><br><span class="line">        (</span><br><span class="line">        QueryBuilders.boolQuery()</span><br><span class="line">        .must(matchPhraseQuery(<span class="string">"sale_name"</span>, <span class="string">"2018款"</span>))</span><br><span class="line">        .filter(matchQuery(<span class="string">"master_brand_name"</span>, <span class="string">"大众"</span>).analyzer(<span class="string">"ik_max_word"</span>))</span><br><span class="line">        .mustNot(matchQuery(<span class="string">"series_name"</span>, <span class="string">"速腾"</span>))</span><br><span class="line">    );</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    request.add(searchRequest);</span><br><span class="line">    MultiSearchResponse response = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sniffer-嗅探器"><a href="#Sniffer-嗅探器" class="headerlink" title="Sniffer 嗅探器"></a>Sniffer 嗅探器</h2><p>概念：从运行中的Elasticsearch集群自动发现节点并将它们设置为现有RestClient实例（low实例）。</p>
<p>版本：从ES 2.X开始及更高版本支持。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client-sniffer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">1.创建RestClient：RestClientBuilder</span><br><span class="line">2.HTTPS支持：NodesSniffer</span><br><span class="line">3.绑定：Sniffer.builder(RestClient)</span><br><span class="line">4.监听：SniffOnFailureListener</span><br><span class="line"></span><br><span class="line">相关设置参数：</span><br><span class="line">1.setSniffIntervalMillis：每隔多久触发一次嗅探，单位毫秒，默认30000（5分钟）。</span><br><span class="line">2.setSniffAfterFailureDelayMillis：嗅探失败时触发嗅探一次,经过设置的时间（默认1min）之后再次嗅探直至正常。若无绑定监听器则无效。</span><br><span class="line">3.setFailureListener：设置用于监听嗅探失败的监听器，当监听到普通嗅探失败，则通知Sniffer实例进行新一轮的嗅探，并更新节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ESClient ESClient;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost:9200,localhost:9201"</span>;</span><br><span class="line">    <span class="keyword">private</span> RestClientBuilder builder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sniffer sniffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestHighLevelClient highClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ESClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ESClient <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ESClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ESClient<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ESClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ESClient = <span class="keyword">new</span> ESClient();</span><br><span class="line">                    ESClient.initBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ESClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClientBuilder <span class="title">initBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] hosts = host.split(<span class="string">","</span>);</span><br><span class="line">        HttpHost[] httpHosts = <span class="keyword">new</span> HttpHost[hosts.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hosts.length; i++) &#123;</span><br><span class="line">            String[] host = hosts[i].split(<span class="string">":"</span>);</span><br><span class="line">            httpHosts[i] = <span class="keyword">new</span> HttpHost(host[<span class="number">0</span>], Integer.parseInt(host[<span class="number">1</span>]), <span class="string">"http"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder = RestClient.builder(httpHosts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//region 在Builder中设置请求头</span></span><br><span class="line">        <span class="comment">//  1.设置请求头</span></span><br><span class="line">        Header[] defaultHeaders = <span class="keyword">new</span> Header[]&#123;</span><br><span class="line">            <span class="keyword">new</span> BasicHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        builder.setDefaultHeaders(defaultHeaders);</span><br><span class="line">        <span class="comment">//endregion</span></span><br><span class="line">        <span class="comment">//RestClient restClient = builder.build();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启用嗅探器</span></span><br><span class="line">        <span class="comment">//SniffOnFailureListener sniffOnFailureListener = new SniffOnFailureListener();</span></span><br><span class="line">        <span class="comment">//builder.setFailureListener(sniffOnFailureListener);</span></span><br><span class="line">        <span class="comment">//sniffer = Sniffer.builder(restClient)</span></span><br><span class="line">        <span class="comment">//        .setSniffIntervalMillis(5000)</span></span><br><span class="line">        <span class="comment">//        .setSniffAfterFailureDelayMillis(10000)</span></span><br><span class="line">        <span class="comment">//        .build();</span></span><br><span class="line">        <span class="comment">//sniffOnFailureListener.setSniffer(sniffer);</span></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (highClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ESClient<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (highClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//gighClient是通过lowClient包装产生的</span></span><br><span class="line">                    highClient = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">                    <span class="comment">//设置嗅探器</span></span><br><span class="line">                    <span class="comment">//十秒刷新并更新一次节点</span></span><br><span class="line">                    sniffer = Sniffer.builder(highClient.getLowLevelClient())</span><br><span class="line">                        .setSniffIntervalMillis(<span class="number">5000</span>)</span><br><span class="line">                        .setSniffAfterFailureDelayMillis(<span class="number">15000</span>)</span><br><span class="line">                        .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> highClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 关闭sniffer client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != highClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sniffer.close();    <span class="comment">//需要在highClient close之前操作</span></span><br><span class="line">                highClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snifferTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client = ESClient.getInstance().getHighLevelClient();</span><br><span class="line">    Iterator&lt;Node&gt; nodes = client.getLowLevelClient().getNodes().iterator();</span><br><span class="line">    <span class="keyword">while</span> (nodes.hasNext()) &#123;</span><br><span class="line">        Node node = nodes.next();</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">"5秒后:"</span>);</span><br><span class="line">    nodes = client.getLowLevelClient().getNodes().iterator();</span><br><span class="line">    <span class="keyword">while</span> (nodes.hasNext()) &#123;</span><br><span class="line">        Node node = nodes.next();</span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ESClient.getInstance().closeClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有5台机器，IP分别是【9200 - 9204】最后嗅探造成的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先输出:</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9200]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9201]</span><br><span class="line">间隔五秒后输出：</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9200]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9201]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9202]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9203]</span><br><span class="line">host&#x3D;[http:&#x2F;&#x2F;localhost:9204]</span><br></pre></td></tr></table></figure>

<p><strong>嗅探器它能够给我们监控动态更新集群的节点数量，避免了程序因节点过多或增加/减少节点造成的切换问题。</strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(八)-集群</title>
    <url>/2021/05/26/elasticsearch%EF%BC%88%E5%85%AB%EF%BC%89%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener">下载</a></h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxf  elasticsearch-7.12.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><a id="more"></a>

<h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p>​    ES为了安全，不允许直接使用root用户启动，需要创建普通用户来运行程序：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">############# 方式一 ###############</span></span><br><span class="line"><span class="comment">#创建用户：elasticsearch</span></span><br><span class="line">adduser elasticsearch</span><br><span class="line"><span class="comment">#创建用户密码，需要输入两次</span></span><br><span class="line">passwd elasticsearch</span><br><span class="line"><span class="comment">#切换到es文件夹上，将对应的文件夹权限赋给该用户</span></span><br><span class="line">chown -R elasticsearch elasticsearch-7.10.1</span><br><span class="line"><span class="comment">############# 方式二 ###############</span></span><br><span class="line"><span class="comment">#创建用户组   </span></span><br><span class="line">groupadd esgroup</span><br><span class="line"><span class="comment">#创建用户     </span></span><br><span class="line">useradd -g esgroup elasticsearch</span><br><span class="line"><span class="comment">#设置权限     </span></span><br><span class="line">chown -R elasticsearch:esgroup elasticsearch-7.10.1</span><br><span class="line"><span class="comment">#设置密码     </span></span><br><span class="line">passwd elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换至elasticsearch用户</span></span><br><span class="line">su elasticsearch</span><br></pre></td></tr></table></figure>

<h3 id="创建data和logs目录"><a href="#创建data和logs目录" class="headerlink" title="创建data和logs目录"></a>创建data和logs目录</h3><p>​    为了以后elasticsearch更新升级不影响到数据和日志，需要创建独立存放数据和日志的文件目录，并为用户授权</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/elasticsearch/data</span><br><span class="line">mkdir -p /var/elasticsearch/logs</span><br><span class="line"></span><br><span class="line">chown -R elasticsearch /var/elasticsearch/data</span><br><span class="line">chown -R elasticsearch /var/elasticsearch/logs</span><br></pre></td></tr></table></figure>

<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><code>vim config/elasticsearch.yml</code></p>
<h4 id="node-1"><a href="#node-1" class="headerlink" title="node-1"></a>node-1</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.131</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="node-2"><a href="#node-2" class="headerlink" title="node-2"></a>node-2</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.132</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="node-3"><a href="#node-3" class="headerlink" title="node-3"></a>node-3</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#配置文件配置相同的集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#各个节点需要有不同的结点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#节点存储数据目录  	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/elasticsearch/data</span></span><br><span class="line"><span class="comment">#节点存储日志目录 	生产环境不要使用默认目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/elasticsearch/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#开启引导检查的内存锁，关闭使用swapp分区，防止因为内存不足而使用swap分区造成机器性能下降,生产环境必须设置为true</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#把当前节点绑定到以下IP上，如果配置了该项，会触发ES的引导检查</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.243</span><span class="number">.133</span> </span><br><span class="line"><span class="comment">#默认可以不用配置，区间[9200,9300)</span></span><br><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#通讯端口，用于集群不同节点的通讯</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#当进行Master时，有哪些节点能参与竞选（node.master: true的节点）</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> <span class="string">["192.168.243.131:9300",</span> <span class="string">"192.168.243.132:9300"</span><span class="string">,</span> <span class="string">"192.168.243.133:9300"</span><span class="string">]</span></span><br><span class="line"><span class="comment">#设置集群启动时竞选Master的节点列表</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br><span class="line"><span class="comment">#绕过引导检查（生产环境不能配置该项）</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许跨域访问 *代表所有</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标记该节点具备竞争master的资格   </span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#该节点进行数据存储</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改完配置后,切换回root会用户关闭防火墙;</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">#或者开放9200、9300端口</span></span><br><span class="line">firewall-cmd --zone-public --add-port=9200/tcp --permanent</span><br><span class="line">firewall-cmd --zone-public --add-port=9300/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入bin目录启动 -d:表示后台启动  启动如果报错请参见下文解决问题</span></span><br><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure>

<p>如果克隆了服务器或者拷贝了多份elasticsearch目录，需要去<code>path.data:</code>配置的路径下删除节点信息，<strong>否则会造成ID重复的冲突。</strong></p>
<h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;_cat&#x2F;allocation      	#查看单节点的shard分配整体情况</span><br><span class="line">&#x2F;_cat&#x2F;shards          #查看各shard的详细情况</span><br><span class="line">&#x2F;_cat&#x2F;shards&#x2F;&#123;index&#125;  	#查看指定分片的详细情况</span><br><span class="line">&#x2F;_cat&#x2F;master          #查看master节点信息</span><br><span class="line">&#x2F;_cat&#x2F;nodes           #查看所有节点信息</span><br><span class="line">&#x2F;_cat&#x2F;indices         #查看集群中所有index的详细信息</span><br><span class="line">&#x2F;_cat&#x2F;indices&#x2F;&#123;index&#125; 	#查看集群中指定index的详细信息</span><br><span class="line">&#x2F;_cat&#x2F;segments        #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘</span><br><span class="line">&#x2F;_cat&#x2F;segments&#x2F;&#123;index&#125;#查看指定index的segment详细信息</span><br><span class="line">&#x2F;_cat&#x2F;count           #查看当前集群的doc数量</span><br><span class="line">&#x2F;_cat&#x2F;count&#x2F;&#123;index&#125;   #查看指定索引的doc数量</span><br><span class="line">&#x2F;_cat&#x2F;recovery        #查看集群内每个shard的recovery过程.调整replica。</span><br><span class="line">&#x2F;_cat&#x2F;recovery&#x2F;&#123;index&#125;#查看指定索引shard的recovery过程</span><br><span class="line">&#x2F;_cat&#x2F;health          #查看集群当前状态：红、黄、绿</span><br><span class="line">&#x2F;_cat&#x2F;pending_tasks   #查看当前集群的pending task</span><br><span class="line">&#x2F;_cat&#x2F;aliases         #查看集群中所有alias信息,路由配置等</span><br><span class="line">&#x2F;_cat&#x2F;aliases&#x2F;&#123;alias&#125; #查看指定索引的alias信息</span><br><span class="line">&#x2F;_cat&#x2F;thread_pool     #查看集群各节点内部不同类型的threadpool的统计信息,</span><br><span class="line">&#x2F;_cat&#x2F;plugins         #查看集群各个节点上的plugin信息</span><br><span class="line">&#x2F;_cat&#x2F;fielddata       #查看当前集群各个节点的fielddata内存使用情况</span><br><span class="line">&#x2F;_cat&#x2F;fielddata&#x2F;&#123;fields&#125;     #查看指定field的内存使用情况,里面传field属性对应的值</span><br><span class="line">&#x2F;_cat&#x2F;nodeattrs              #查看单节点的自定义属性</span><br><span class="line">&#x2F;_cat&#x2F;repositories           #输出集群中注册快照存储库</span><br><span class="line">&#x2F;_cat&#x2F;templates              #输出当前正在存在的模板信息</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于Docker"><a href="#基于Docker" class="headerlink" title="基于Docker"></a>基于Docker</h2><blockquote>
<p>不建议使用ES启动docker，因为很麻烦！！！</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># docker pull docker.elastic.co/elasticsearch/elasticsearch:7.10.1</span></span><br><span class="line">[root@localhost /]<span class="comment"># docker run -d -p 9200:9200 -p 9300:9300 --name es elasticsearch:7.10.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动命令参考</span></span><br><span class="line">[root@localhost /]<span class="comment"># docker run -d -p 9200:9200 -p 9300:9300 -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" -e discovery.type=single-node --name es elasticsearch:7.10.1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">问题1：error=<span class="string">'Cannot allocate memory'</span> </span><br><span class="line">原因：ES 5.x+堆内存大小默认配置为2G 		ES 7.x+默认4G </span><br><span class="line">解决：</span><br><span class="line">vi config/jvm.options</span><br><span class="line">-Xms4g  →  -Xms512m</span><br><span class="line">-Xmx4g  →  -Xmx512m</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题2：WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br><span class="line">解决：	vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.ip_forward&#x3D;1</span><br><span class="line">restart network &amp;&amp; systemctl restart docker</span><br><span class="line">sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题3: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span><br><span class="line">解释：	5.0以后,ES使用mmapfs作为默认的文件系统存储类型。可以通过配置index.store.type来设置ES默认的文件系统存储类型。</span><br><span class="line">Niofs(非阻塞文件系统)	mmapfs(内存映射文件系统)</span><br><span class="line">配置:index.store.type: niofs</span><br><span class="line">解决：sysctl -w vm.max_map_count&#x3D;262144</span><br><span class="line">查看是否生效：</span><br><span class="line">	或：vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">vm.max_map_count&#x3D;262144</span><br><span class="line">grep vm.max_map_count &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题4：max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</span><br><span class="line">解决：vi &#x2F;etc&#x2F;security&#x2F;limits.conf，最后添加以下内容。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题5：max number of threads [1024] for user [elasticsearch] is too low, increase to at least [2048]</span><br><span class="line">解决：</span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;90-nproc.conf </span><br><span class="line">修改如下内容（注意星号）：</span><br><span class="line">* soft nproc 1024  &#x3D;&gt;  * soft nproc 4096</span><br><span class="line"></span><br><span class="line">当引导检查报未开启内存锁时，需要修改一下配置：</span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf，最后添加以下内容。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 4096</span><br><span class="line">* hard nproc 4096</span><br><span class="line">* hard memlock unlimited</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">vi &#x2F;etc&#x2F;systemd&#x2F;system.conf ，分别修改以下内容。</span><br><span class="line">vi &#x2F;etc&#x2F;systemd&#x2F;system.conf </span><br><span class="line">注意 修改操作系统配置需要重启系统才能生效，如果宿主机内存过小，可能导致容器无法启动。开发模式内存建议4G以上，生产建议32G以上.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题6：docker中的es无法加入集群</span><br><span class="line">elasticsearch.yml配置中增加 network.publish_host:192.168.1.129</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他问题：如路径的权限问题、多网卡问题、引导检查问题</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/05/30/ELK/</url>
    <content><![CDATA[<h2 id="一、什么是ELK？"><a href="#一、什么是ELK？" class="headerlink" title="一、什么是ELK？"></a>一、什么是ELK？</h2><ul>
<li>E：Elasticsearch-数据存储、分析</li>
<li>L：LogStash-数据采集</li>
<li>K：Kibana-数据展示</li>
</ul>
<p>由于Logstash在数据采集方面性能堪忧，所以一般来说在传统的ELK基础上还会引入Beats相关组件，用于采集信息，之后再传输给Logstash进行操作；</p>
<img src="H:\hexo\source\_posts\ELK\elk-03.png" style="zoom:67%;" />

<a id="more"></a>

<p>为何不直接将Beats采集的数据存入es呢？直接存入es使用其过滤功能有点大材小用，浪费es性能，所以仍需要Logstash作为数据的过滤层，同时Logstash中集成了很多第三方的插件。</p>
<hr>
<h2 id="二、elastic产品下载"><a href="#二、elastic产品下载" class="headerlink" title="二、elastic产品下载"></a>二、<a href="https://www.elastic.co/cn/downloads/" target="_blank" rel="noopener">elastic产品下载</a></h2><p>​    elasticsearch的安装部署参见-<a href="https://yrlzero.gitee.io/2021/05/26/elasticsearch%EF%BC%88%E5%85%AB%EF%BC%89%E9%9B%86%E7%BE%A4/">elasticsearch(八)-集群</a>不在本文重新介绍，主要介绍ELK其余组件的安装部署</p>
<h2 id="三、Beats"><a href="#三、Beats" class="headerlink" title="三、Beats"></a>三、<a href="https://www.elastic.co/cn/beats/" target="_blank" rel="noopener">Beats</a></h2><p>基于golang语言开发，开源的、轻量级的日志收集器的统称。</p>
<h3 id="3-1、Filebeat"><a href="#3-1、Filebeat" class="headerlink" title="3.1、Filebeat"></a>3.1、<a href="https://www.elastic.co/cn/beats/filebeat" target="_blank" rel="noopener">Filebeat</a></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>文件日志监控采集 ，主要用于收集日志数据</p>
<img src="H:\hexo\source\_posts\ELK\elk-02.png" style="zoom: 67%;" />

<p>语法：yaml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">	<span class="string">-input_type:log</span></span><br><span class="line">	<span class="attr">paths:</span></span><br><span class="line">		<span class="string">-/var/log/apache/httpd-*.log</span></span><br><span class="line">	<span class="string">-input_type:log</span></span><br><span class="line">	<span class="attr">paths:</span></span><br><span class="line">		<span class="string">-var/log/messages</span></span><br><span class="line">		<span class="string">-var/log/*.log</span></span><br></pre></td></tr></table></figure>

<p> 支持的输入配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Azure Event Hub</span><br><span class="line">Cloud Foundry</span><br><span class="line">Container</span><br><span class="line">Docker</span><br><span class="line">Google Pub&#x2F;Sub</span><br><span class="line">HTTP JSON</span><br><span class="line">Kafka</span><br><span class="line">Log</span><br><span class="line">MQTT</span><br><span class="line">NetFlow</span><br><span class="line">Office 365 Management Activity API</span><br><span class="line">Redis</span><br><span class="line">S3</span><br><span class="line">Stdin</span><br><span class="line">Syslog</span><br><span class="line">TCP</span><br><span class="line">UDP</span><br></pre></td></tr></table></figure>

<p>输出配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a)支持的输出类型：</span><br><span class="line">Console</span><br><span class="line">Elasticsearch</span><br><span class="line">Logstash</span><br><span class="line">Kafka</span><br><span class="line">Redis</span><br><span class="line">File</span><br><span class="line">Elastic Cloud</span><br><span class="line"></span><br><span class="line">b)输出到Elasticsearch:</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;myEShost:9200&quot;]</span><br><span class="line">  username: &quot;filebeat_internal&quot;</span><br><span class="line">  password: &quot;YOUR_PASSWORD&quot; </span><br><span class="line">setup.kibana:</span><br><span class="line">  host: &quot;mykibanahost:5601&quot;</span><br><span class="line">  username: &quot;my_kibana_user&quot;  </span><br><span class="line">  password: &quot;YOUR_PASSWORD&quot;</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf filebeat-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">mv filebeat-7.7.0-linux-x86_64 filebeat-7.7.0</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#=========================== Filebeat inputs =============================</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="comment">#定义输入类型是log</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="comment"># 开启输入配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#配置输入log的来源路径,多个文件用-来分割</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line">  <span class="comment">#自定义当前采集的type的标签，可以用于logstash中进行逻辑归类输出到不同的目的地</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["test_tag"]</span></span><br><span class="line">  <span class="comment">#排除空行</span></span><br><span class="line">  <span class="attr">exclude_lines:</span> <span class="string">['^$']</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span> <span class="string">/usr/local/nginx/logs/access.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["nginx-tag"]</span></span><br><span class="line">  <span class="comment">#json的所有key都在一个大括号里</span></span><br><span class="line">  <span class="comment">#json.keys_under_root: true</span></span><br><span class="line">  <span class="comment">#当采集错误时增加一个error_key</span></span><br><span class="line">  <span class="comment">#json.add_error_key: true</span></span><br><span class="line">  <span class="comment">#当key值和系统key重复时覆盖</span></span><br><span class="line">  <span class="comment">#json.overwrite_keys: true</span></span><br><span class="line">  <span class="comment">#以json的格式输入日志</span></span><br><span class="line">  <span class="comment">#json.message_key: log</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span> <span class="string">/usr/local/mylog.log</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">["mylog-tag"]</span></span><br><span class="line">  <span class="comment"># Multiline options</span></span><br><span class="line">  <span class="comment">#配置组合 1</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">pattern</span></span><br><span class="line">    <span class="comment">#非匹配到的内容往后追加  可选:before</span></span><br><span class="line">    <span class="attr">match:</span> <span class="string">after</span></span><br><span class="line">    <span class="comment">#配置组合 1</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">'^\['</span></span><br><span class="line">    <span class="comment"># true表示和正则表达式匹配的作为第一行，false表示和正则不匹配的作为第一行</span></span><br><span class="line">    <span class="attr">negate:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#配置组合2</span></span><br><span class="line">    <span class="comment">#匹配以空格开头的内容</span></span><br><span class="line">    <span class="comment">#pattern: '^[[:space:]]'</span></span><br><span class="line">    <span class="comment">#negate: false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#================================ Outputs =====================================</span></span><br><span class="line"><span class="comment">#-------------------------- Elasticsearch output ------------------------------</span></span><br><span class="line"><span class="comment"># 第一种输出方式：将采集结果输出到elasticsearch</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.131:9200"]</span></span><br><span class="line">  <span class="comment">#动态索引名称</span></span><br><span class="line">  <span class="comment">#index: "%&#123;[fields.log_type]&#125;-%&#123;[agent.version]&#125;-%&#123;+yyyy.MM.dd&#125;"</span></span><br><span class="line">  <span class="attr">indices:</span></span><br><span class="line">  	<span class="comment">#按照日志输出的级别归档到不同的index中</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"warning-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">	  <span class="attr">when.contains:</span></span><br><span class="line">	  <span class="attr">message:</span> <span class="string">"WARN"</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"error-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">"ERR"</span></span><br><span class="line">  <span class="comment">#protocol: "https"</span></span><br><span class="line">  <span class="comment">#api_key: "id:api_key"</span></span><br><span class="line">  <span class="comment">#username: "elastic"</span></span><br><span class="line">  <span class="comment">#password: "changeme"</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#----------------------------- Logstash output --------------------------------</span></span><br><span class="line"><span class="comment"># 第二种输出方式（优先）：将采集结果输出到logstash</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.133:5044"]</span></span><br><span class="line">  <span class="comment">#有多节点则开启负载均衡</span></span><br><span class="line">  <span class="comment">#loadbalance: true</span></span><br><span class="line">  <span class="comment">#索引名称</span></span><br><span class="line">  <span class="comment">#index: filebeat</span></span><br><span class="line">  <span class="comment"># Optional SSL. By default is off.</span></span><br><span class="line">  <span class="comment"># List of root certificates for HTTPS server verifications</span></span><br><span class="line">  <span class="comment">#ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Certificate for SSL client authentication</span></span><br><span class="line">  <span class="comment">#ssl.certificate: "/etc/pki/client/cert.pem"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Client Certificate Key</span></span><br><span class="line">  <span class="comment">#ssl.key: "/etc/pki/client/cert.key"</span></span><br></pre></td></tr></table></figure>

<p><img src="H:%5Chexo%5Csource_posts%5CELK%5Cfilebeat-01.jpg" alt=""></p>
<p><img src="H:%5Chexo%5Csource_posts%5CELK%5Cfilebeat-02.jpg" alt=""></p>
<p>Filebeat是读取日志是会记录到读取日志的行号，当重启或者删除es的索引，他依旧会从记录的那一行之后开始读，曾经读取过的数据不会再次读取，若想要重新全量读取，则需要去把<code>data</code>文件夹的数据删除。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前台启动</span></span><br><span class="line">./filebeat -e -c ./filebeat.yml</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<h3 id="3-2Metricbeat"><a href="#3-2Metricbeat" class="headerlink" title="3.2Metricbeat"></a>3.2<a href="https://www.elastic.co/products/beats/metricbeat" target="_blank" rel="noopener">Metricbeat</a></h3><p>进行指标采集，指标可以是系统的，也可以是众多中间件产品的，主要用于监控系统和软件的性能</p>
<h3 id="3-3Packetbeat"><a href="#3-3Packetbeat" class="headerlink" title="3.3Packetbeat"></a>3.3<a href="https://www.elastic.co/products/beats/packetbeat" target="_blank" rel="noopener">Packetbeat</a></h3><p>通过网络抓包、协议分析，基于协议和端口对一些系统通信进行监控和数据收集。是一个实时网络数据包分析器，可以将其与Elasticsearch一起使用，以提供应用程序监视和性能分析系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ICMP (v4 and v6)</span><br><span class="line">DHCP (v4)</span><br><span class="line">DNS</span><br><span class="line">HTTP</span><br><span class="line">AMQP 0.9.1</span><br><span class="line">Cassandra</span><br><span class="line">Mysql</span><br><span class="line">PostgreSQL</span><br><span class="line">Redis</span><br><span class="line">Thrift-RPC</span><br><span class="line">MongoDB</span><br><span class="line">Memcache</span><br><span class="line">NFS</span><br><span class="line">TLS</span><br></pre></td></tr></table></figure>

<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf packetbeat-7.12.1-linux-x86_64.tar.gz</span><br><span class="line">mv packetbeat-7.12.1-linux-x86_64 packetbeat-7.12.1</span><br></pre></td></tr></table></figure>

<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># =========================== Transaction protocols ============================</span></span><br><span class="line"><span class="attr">packetbeat.protocols:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">icmp</span> <span class="comment"># Enable ICMPv4 and ICMPv6 monitoring. The default is true.</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">amqp</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5672]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">cassandra</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[9042]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dhcpv4</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[67,</span> <span class="number">68</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dns</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[53]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[80,</span> <span class="number">8080</span><span class="string">,</span> <span class="number">8000</span><span class="string">,</span> <span class="number">5000</span><span class="string">,</span> <span class="number">8002</span><span class="string">]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">memcache</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[11211]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[3306,3307]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">pgsql</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5432]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[6379]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">thrift</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[9090]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">mongodb</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[27017]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[2049]</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">443</span>   <span class="comment"># HTTPS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">993</span>   <span class="comment"># IMAPS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">995</span>   <span class="comment"># POP3S</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5223</span>  <span class="comment"># XMPP over SSL</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8883</span>  <span class="comment"># Secure MQTT</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9243</span>  <span class="comment"># Elasticsearch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">sip</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="string">[5060]</span></span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># ---------------------------- Elasticsearch Output ----------------------------</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="comment"># Array of hosts to connect to.</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["192.168.243.131:9200"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Protocol - either `http` (default) or `https`.</span></span><br><span class="line">  <span class="comment">#protocol: "https"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Authentication credentials - either API key or username/password.</span></span><br><span class="line">  <span class="comment">#api_key: "id:api_key"</span></span><br><span class="line">  <span class="comment">#username: "elastic"</span></span><br><span class="line">  <span class="comment">#password: "changeme"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------ Logstash Output -------------------------------</span></span><br><span class="line"><span class="comment">#output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="comment">#hosts: ["localhost:5044"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Optional SSL. By default is off.</span></span><br><span class="line">  <span class="comment"># List of root certificates for HTTPS server verifications</span></span><br><span class="line">  <span class="comment">#ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Certificate for SSL client authentication</span></span><br><span class="line">  <span class="comment">#ssl.certificate: "/etc/pki/client/cert.pem"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Client Certificate Key</span></span><br><span class="line">  <span class="comment">#ssl.key: "/etc/pki/client/cert.key"</span></span><br></pre></td></tr></table></figure>

<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./packetbeat -e -c packetbeat.yml -strict.perms=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Logstash"><a href="#四、Logstash" class="headerlink" title="四、Logstash"></a>四、<a href="https://www.elastic.co/cn/downloads/past-releases#logstash" target="_blank" rel="noopener">Logstash</a></h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Logstash是开源的流数据处理、转换（解析）和发送引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源。</p>
<p>Logstash的数据处理过程主要包括：<strong>Inputs</strong>, <strong>Filters</strong>, <strong>Outputs</strong> 三部分</p>
<p><img src="H:%5Chexo%5Csource_posts%5CELK%5Celk-01.png" alt=""></p>
<h4 id="Inputs"><a href="#Inputs" class="headerlink" title="Inputs"></a><strong>Inputs</strong></h4><p>用于从数据源获取数据，常见的插件如beats、file、kafka、rabbitmq、log4j、redis等。</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a><strong>Filters</strong></h4><p>筛选器是Logstash管道中的数据处理器，input时会触发事件，触发filter对数据进行transport，即转换解析各种格式的数据，常见的过滤器插件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grok：解析和构造任意文本。是Logstash过滤器的基础，广泛用于从非结构化数据中导出结构，当前，Grok是Logstash中将非结构化日志数据解析为结构化和可查询内容的最佳方法。</span><br><span class="line">mutate：对事件字段执行常规转换。支持对事件中字段进行重命名，删除，替换和修改。</span><br><span class="line">date：把字符串类型的时间字段转换成时间戳类型</span><br><span class="line">drop：完全删除事件，例如调试事件。</span><br><span class="line">clone：复制事件，可能会添加或删除字段。</span><br><span class="line">geoip：添加有关IP地址地理位置的信息。</span><br></pre></td></tr></table></figure>

<h4 id="Outputs"><a href="#Outputs" class="headerlink" title="Outputs"></a><strong>Outputs</strong></h4><p>用于数据输出，常见的插件如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elasticsearch：最高效、方便、易于查询的存储器，最有选择，官方推荐！</span><br><span class="line">file：将输出数据以文件的形式写入磁盘。stupid</span><br><span class="line">graphite：将事件数据发送到graphite，graphite是一种流行的开源工具，用于存储和绘制指标。http:&#x2F;&#x2F;graphite.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</span><br><span class="line">statsd：将事件数据发送到statsd，该服务“通过UDP侦听统计信息（如计数器和计时器），并将聚合发送到一个或多个可插拔后端服务”。</span><br></pre></td></tr></table></figure>

<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf logstash-7.12.1-linux-x86_64.tar.gz -C logstash-7.12.1</span><br><span class="line"></span><br><span class="line">vi config/jvm.option</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure>

<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sample Logstash configuration for creating a simple</span></span><br><span class="line"><span class="comment"># Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span></span><br><span class="line"><span class="comment"># ================================== input ===================================</span></span><br><span class="line"><span class="string">input</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">beats</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># ================================== output ===================================</span></span><br><span class="line"><span class="string">output</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="comment">#方式一</span></span><br><span class="line">  <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">    <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%&#123;[@metadata][beat]&#125;</span>-<span class="template-variable">%&#123;[@metadata][version]&#125;</span>-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="comment">#user =&gt; "elastic"</span></span><br><span class="line">    <span class="comment">#password =&gt; "changeme"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#方式二</span></span><br><span class="line">  <span class="comment">#除了输出到es中，还输出到控制台</span></span><br><span class="line">  <span class="string">stdout</span> <span class="string">&#123;codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span> <span class="string">&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#方式三</span></span><br><span class="line">  <span class="comment">#根据 beat中输入的数据携带的【tags】进行分类输出</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"test-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">  		<span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">    	<span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-test_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"nginx-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-nginx_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">"mylog-tag"</span> <span class="string">in</span> <span class="string">[tags]</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"logstash-mylog_tag-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span> </span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================================== filter ===================================</span></span><br><span class="line"><span class="string">filter</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">grok</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="comment"># IP:grok提供的正则 client：提取数据后作为key</span></span><br><span class="line">    <span class="string">match</span> <span class="string">=&gt;</span> <span class="string">&#123;</span> <span class="string">"message"</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%&#123;IP:client&#125;</span> <span class="template-variable">%&#123;WORD:method&#125;</span> <span class="template-variable">%&#123;URIPATHPARAM:request&#125;</span> <span class="template-variable">%&#123;NUMBER:bytes&#125;</span> <span class="template-variable">%&#123;NUMBER:duration&#125;</span>"</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./logstash -f ../config/logstash-test.conf</span><br><span class="line">nohup ./logstash -f ../config/logstash-test.conf&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<h2 id="五、Kibana"><a href="#五、Kibana" class="headerlink" title="五、Kibana"></a>五、<a href="https://www.elastic.co/cn/downloads/past-releases#kibana" target="_blank" rel="noopener">Kibana</a></h2><p>对 Elasticsearch 数据进行可视化，进行高效的搜索、可视化、分析等各种操作。</p>
<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"192.168.243.131"</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">["http://192.168.243.131:9200"]</span></span><br><span class="line"><span class="comment">#elasticsearch.username: "kibana_system"</span></span><br><span class="line"><span class="comment">#elasticsearch.password: "pass"</span></span><br></pre></td></tr></table></figure>

<h3 id="启动错误"><a href="#启动错误" class="headerlink" title="启动错误"></a>启动错误</h3><p>当使用root账户执行启动命令<code>./kibana</code>会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kibana should not be run as root.  Use --allow-root to continue.</span><br></pre></td></tr></table></figure>

<p>因为Kibana与es一样，不能使用root用户启动，因为需要向es一样需要切换子账户启动，此时会报权限问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> log   [22:28:17.934] [fatal][root] Error: Unable to write Kibana UUID file, please check the uuid.server configuration value in kibana.yml and ensure Kibana has sufficient permissions to read &#x2F; write to this file. Error was: EACCES</span><br><span class="line">   at writeUuidToFile (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;resolve_uuid.js:101:11)</span><br><span class="line">   at resolveInstanceUuid (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;resolve_uuid.js:66:5)</span><br><span class="line">   at EnvironmentService.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;environment&#x2F;environment_service.js:51:17)</span><br><span class="line">   at Server.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;server.js:167:30)</span><br><span class="line">   at Root.setup (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;root&#x2F;index.js:47:14)</span><br><span class="line">   at bootstrap (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;core&#x2F;server&#x2F;bootstrap.js:99:5)</span><br><span class="line">   at Command.&lt;anonymous&gt; (&#x2F;usr&#x2F;local&#x2F;kibana&#x2F;src&#x2F;cli&#x2F;serve&#x2F;serve.js:169:5)</span><br><span class="line"></span><br><span class="line">FATAL  Error: Unable to write Kibana UUID file, please check the uuid.server configuration value in kibana.yml and ensure Kibana has sufficient permissions to read &#x2F; write to this file. Error was: EACCES</span><br></pre></td></tr></table></figure>

<p>需要切换root账户对子账户进行授权<code>chown -R elasticsearch kibana</code>，再切换子账户启动</p>
<h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nohup ./kibana &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="杀死程序"><a href="#杀死程序" class="headerlink" title="杀死程序"></a>杀死程序</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lsof -i:端口</span><br><span class="line"><span class="built_in">kill</span> -9  进程号</span><br></pre></td></tr></table></figure>

<h2 id="六、Head插件"><a href="#六、Head插件" class="headerlink" title="六、Head插件"></a>六、<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">Head插件</a></h2><h3 id="安装head"><a href="#安装head" class="headerlink" title="安装head"></a>安装head</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.git</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head&#x2F;archive&#x2F;master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure>

<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/latest-v14.x/node-v14.6.0-linux-x64.tar.gz</span><br><span class="line">tar -zxvf  node-v14.6.0-linux-x64.tar.gz</span><br><span class="line">mv node-v10.14.1node-v14.6.0-linux-x64 node-v14.6.0</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/node-v14.6.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NODE_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><p>添加<code>hostname:&#39;*&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vi Gruntfile.js</span><br><span class="line">connect: &#123;</span><br><span class="line">	server: &#123;</span><br><span class="line">		options: &#123;</span><br><span class="line">			hostname:<span class="string">'*'</span>,</span><br><span class="line">			port: <span class="number">9100</span>,</span><br><span class="line">			base: <span class="string">'.'</span>,</span><br><span class="line">			keepalive: <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-head/</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 前台运行</span></span><br><span class="line">npm run start</span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">nohup npm run start&gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p><code>npm install</code>出错</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! phantomjs-prebuilt@2.1.16 install: `node install.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Failed at the phantomjs-prebuilt@2.1.16 install script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2021-05-31T15_13_24_681Z-debug.log</span><br></pre></td></tr></table></figure>

<p>执行<code>npm install phantomjs-prebuilt@2.1.14 --ignore-scripts</code>之后再重新<code>npm install</code></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
</search>
