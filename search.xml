<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多线程-AQS</title>
    <url>/2020/12/05/AQS/</url>
    <content><![CDATA[<h2 id="AQS-AbstractQueuedSynchronizer-抽象的队列式同步器"><a href="#AQS-AbstractQueuedSynchronizer-抽象的队列式同步器" class="headerlink" title="AQS (AbstractQueuedSynchronizer)抽象的队列式同步器"></a>AQS (AbstractQueuedSynchronizer)抽象的队列式同步器</h2><p><img src="http://yrlzero.gitee.io/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E7%B1%BB%E4%B8%8Eaqs%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt=""></p>
<p>其中Sync及其子类NonfairSync、FairSync和node均为ReentrantLock的静态内部类</p>
<a id="more"></a>

<h3 id="AQS内部结构"><a href="#AQS内部结构" class="headerlink" title="AQS内部结构"></a>AQS内部结构</h3><h4 id="state："><a href="#state：" class="headerlink" title="state："></a>state：</h4><p>​        同步器状态，被volatile修饰，通过cas争抢状态</p>
<h4 id="exclusiveOwnerThread："><a href="#exclusiveOwnerThread：" class="headerlink" title="exclusiveOwnerThread："></a>exclusiveOwnerThread：</h4><p>​        互斥锁持有的线程（AbstractOwnableSynchronizer的属性，aqs的父类）</p>
<h4 id="head："><a href="#head：" class="headerlink" title="head："></a>head：</h4><p>​        同步等待队列的头部，被volatile修饰</p>
<h4 id="tail："><a href="#tail：" class="headerlink" title="tail："></a>tail：</h4><p>​        同步等待队列的尾部，被volatile修饰</p>
<h4 id="node："><a href="#node：" class="headerlink" title="node："></a>node：</h4><p>​        AQS的静态内部类，CLH的基础节点</p>
<h3 id="Node内部结构"><a href="#Node内部结构" class="headerlink" title="Node内部结构"></a>Node内部结构</h3><h4 id="prev："><a href="#prev：" class="headerlink" title="prev："></a>prev：</h4><p>​        指向前一个node节点，被volatile修饰</p>
<h4 id="next："><a href="#next：" class="headerlink" title="next："></a>next：</h4><p>​        指向后一个node节点，被volatile修饰</p>
<h4 id="waitStatus："><a href="#waitStatus：" class="headerlink" title="waitStatus："></a>waitStatus：</h4><p>​        信号状态，默认是0，被volatile修饰</p>
<h5 id="CANCELLED-1："><a href="#CANCELLED-1：" class="headerlink" title="CANCELLED = 1："></a>CANCELLED = 1：</h5><p>​                        取消状态，当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后，节点将不会再变化</p>
<h5 id="SIGNAL-1："><a href="#SIGNAL-1：" class="headerlink" title="SIGNAL = -1："></a>SIGNAL = -1：</h5><p>​                        等待触发状态，后继节点在等待当前节点唤醒。后继节点入队后，会将前继节点的状态更新为SGNAL</p>
<h5 id="CONDITION-2："><a href="#CONDITION-2：" class="headerlink" title="CONDITION = -2："></a>CONDITION = -2：</h5><p>​                        节点等待在confition上，当其他线程调用confition的signal()方法后，CONDITION状态的节点将从等待队列转移到同步队列中</p>
<h5 id="PROPAGATE-3："><a href="#PROPAGATE-3：" class="headerlink" title="PROPAGATE = -3："></a>PROPAGATE = -3：</h5><p>​                        共享模式下，前继节点不仅会唤醒后继节点，同时也可能会唤醒后继节点的后继节点</p>
<h4 id="thread：当前节点关联的客户线程，被volatile修饰"><a href="#thread：当前节点关联的客户线程，被volatile修饰" class="headerlink" title="thread：当前节点关联的客户线程，被volatile修饰"></a>thread：当前节点关联的客户线程，被volatile修饰</h4><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="http://yrlzero.gitee.io/images/多线程/AQS.png" style="zoom:200%;" />

<h4 id="lock-流程"><a href="#lock-流程" class="headerlink" title="lock()流程"></a>lock()流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sync的lock()</span><br><span class="line">	1 NonfairSync.lock() 非公平锁</span><br><span class="line">		2 调用父类aqs的compareAndSetState（第一次）cas争抢同步器状态，</span><br><span class="line">			1.1 成功，调用父类aos的setExclusiveOwnerThread(Thread.currentThread())，修改exclusiveOwnerThread为当前线程</span><br><span class="line">			1.2 失败，调用aqs的acquire()尝试争抢和排队  if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">				2.1 调用aqs的tryAcquire，进入子类reentrantLock的tryAcquire(arg)</span><br><span class="line">					2.1.1 调用NonfairSync的tryAcquire里面的nonfairTryAcquire(acquires)，尝试获取同步器状态</span><br><span class="line">						2.1.1.1 同步器状态为0，（第二次）cas争抢同步器状态</span><br><span class="line">							2.1.1.1.1 成功，设置AOS的exclusiveOwnerThread为当前线程，返回true，不进行排队</span><br><span class="line">							2.1.1.1.2 失败，返回false，进入排队</span><br><span class="line">						2.1.1.2 同步器状态不为0，AOS的exclusiveOwnerThread等于当前线程（一般为重入）</span><br><span class="line">							2.1.1.2.1 符合，同步器状态加1，返回true，不进行排队</span><br><span class="line">							2.1.1.2.2 不符合，返回false，进行排队</span><br><span class="line">				2.2 调用父类aqs的addWaiter(Node mode)，为当前线程创建排他的node节点</span><br><span class="line">					2.2.1 （旧）尾结点是否为空</span><br><span class="line">						2.2.1.1 （旧）尾结点不为空，当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">							2.2.1.1.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">								2.2.1.1.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点，等待加入队列</span><br><span class="line">								2.2.1.1.1.2 失败，往下执行，进入aqs的enq(node)</span><br><span class="line">						2.2.1.2 （旧）尾结点为空，往下执行，进入aqs的enq(node)</span><br><span class="line">					2.2.2 进入父类aqs的enq(node)，死循环</span><br><span class="line">						2.2.2.1 （旧）尾结点为空（说明该队列还没有初始化）</span><br><span class="line">							2.2.2.1.1 新创建node节点，cas设置为头结点</span><br><span class="line">								2.2.2.1.1 设置成功，尾结点等于头结点，相互指向，形成哨兵节点</span><br><span class="line">								2.2.2.1.2 设置失败，重新循环，进入2.2.2</span><br><span class="line">							2.2.2.1.2 （旧）尾结点不为空</span><br><span class="line">								2.2.2.1.2.1 当前线程节点的上一节点等于（旧）尾结点</span><br><span class="line">								2.2.2.1.2.1 cas设置当前线程节点为（新）尾结点</span><br><span class="line">									2.2.2.1.2.1.1 成功，（旧）尾结点的下一节点等于当前线程节点，返回当前线程节点的上一节点（旧的尾结点），这里的返回只是为了退出2.2.2，等待加入队列</span><br><span class="line">									2.2.2.1.2.1.2 失败，重新循环，进入2.2.2</span><br><span class="line">									</span><br><span class="line">					2.2.3 返回当前线程节点，等待加入队列	</span><br><span class="line">				2.3 调用父类aqs的acquireQueued()，死循环</span><br><span class="line">					2.3.1 获取当前节点的前置节点</span><br><span class="line">					2.3.2 前置节点为头节点 &amp;&amp; 当前节点再次尝试获取同步器状态，tryAcquire(arg)参见2.1</span><br><span class="line">						2.3.2.1 成功，</span><br><span class="line">							2.3.2.1.1 调用父类aqs的setHead(node)当前节点设置为头节点，当前节点关联的线程赋值null，上一节点赋值null</span><br><span class="line">							2.3.2.1.2 前置节点的下一节点赋值null，辅助gc回收； 不执行finally &#123;if (failed)&#123;cancelAcquire(node);&#125;&#125;，返回false（也就是不中断），退出2.3</span><br><span class="line">					2.3.3 调用父类aqs的shouldParkAfterFailedAcquire(p, node)和parkAndCheckInterrupt()</span><br><span class="line">						2.3.3.1 shouldParkAfterFailedAcquire(p, node) 获取失败后park之前重置等待状态的方法</span><br><span class="line">							2.3.3.1.1 获取前置节点（当前节点的上一节点）的等待状态</span><br><span class="line">							2.3.3.1.2 等待状态等于-1时，返回true，前置节点还没有被触发，当前节点可以被park</span><br><span class="line">							2.3.3.1.3等待状态大于0时，前置节点处于取消状态，获取前置节点的上一节点作为当前节点的上一节点，再次判断状态，重复循环，等待状态不大于0是，此时的前置节点的下一节点为当前线程节点，返回false，继续2.3</span><br><span class="line">							2.3.3.1.4 等待状态不为以上两种时，cas将状态置为signal也就是-1，返回false，继续2.3</span><br><span class="line">						2.3.3.2 前者返回true，进入parkAndCheckInterrupt()</span><br><span class="line">							2.3.3.2.1 LockSupport.park(this);阻塞当前线程，等待唤醒，正式入队</span><br><span class="line">							2.3.3.2.2 return Thread.interrupted(); 检查被唤醒的线程有没有被中断</span><br><span class="line">								2.3.3.2.2.1 返回false，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">								2.3.3.2.2.2 返回true，循环2.3-&gt;进入2.3.2尝试获取锁或进入2.3.3入队继续等待</span><br><span class="line">				2.4 最终：当2.3.3.2.2之后的流程进入2.3.2尝试获取锁成功时，返回值决定是否调用selfInterrupt();</span><br></pre></td></tr></table></figure>



<h3 id="CLH双向队列"><a href="#CLH双向队列" class="headerlink" title="CLH双向队列"></a>CLH双向队列</h3><img src="http://yrlzero.gitee.io/images/多线程/CLH.png" style="zoom:150%;" />]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot国际化（i18n）</title>
    <url>/2020/12/12/Spring%20Boot%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88i18n%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>i18n是internationalization（国际化单词的缩写，i和n之间有18个字母）</p>
<a id="more"></a>

<h3 id="二、依赖"><a href="#二、依赖" class="headerlink" title="二、依赖"></a>二、依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只需要导入web包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三、语言配置文件"><a href="#三、语言配置文件" class="headerlink" title="三、语言配置文件"></a>三、语言配置文件</h3><p>创建配置文件存放不同语言的消息文本:</p>
<p><img src="http://yrlzero.gitee.io/images/spring/message%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<h4 id="message-properties（此默认配置是必须的，兜底的配置）："><a href="#message-properties（此默认配置是必须的，兜底的配置）：" class="headerlink" title="message.properties（此默认配置是必须的，兜底的配置）："></a>message.properties（此默认配置是必须的，兜底的配置）：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">默认</span></span><br><span class="line"><span class="attr">abc</span>=<span class="string">默认abc</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">默认第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<h4 id="message-en-US-properties-英文配置-："><a href="#message-en-US-properties-英文配置-：" class="headerlink" title="message_en_US.properties(英文配置)："></a>message_en_US.properties(英文配置)：</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">test&#123;0&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="message-zh-CN-properties-中文配置"><a href="#message-zh-CN-properties-中文配置" class="headerlink" title="message_zh_CN.properties(中文配置):"></a>message_zh_CN.properties(中文配置):</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">test</span>=<span class="string">中文</span></span><br><span class="line"><span class="attr">arg</span>=<span class="string">第&#123;0&#125;个参数</span></span><br></pre></td></tr></table></figure>

<p>当指定的语言文件中找不到对应的key时，会查询默认文件，如abc找到默认abc；默认文件也不存在时，会报<code>org.springframework.context.NoSuchMessageException: No message found under code &#39;a&#39; for locale &#39;&#39;.</code>这里的a就是操作的key</p>
<h3 id="四、yml配置"><a href="#四、yml配置" class="headerlink" title="四、yml配置"></a>四、yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-i18n</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">static/i18n/message</span> <span class="comment">#语言配置文件的基础名称（注意，message为语言配置文件的前缀）</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<h3 id="五、session默认解析器-指定默认的locale"><a href="#五、session默认解析器-指定默认的locale" class="headerlink" title="五、session默认解析器(指定默认的locale)"></a>五、session默认解析器(指定默认的locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	默认解析器 其中locale表示默认语言,当请求中未包含语种信息，则设置默认语种</span></span><br><span class="line"><span class="comment">     *	当前默认为CHINA,zh_CN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionLocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.CHINA);</span><br><span class="line">        <span class="keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、拦截器-设置客户端语言locale"><a href="#六、拦截器-设置客户端语言locale" class="headerlink" title="六、拦截器(设置客户端语言locale)"></a>六、拦截器(设置客户端语言locale)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String lang = request.getHeader(<span class="string">"lang"</span>);</span><br><span class="line">        <span class="comment">//拦截客户端传送的语言标识，获取对应的语言locale，没有传送则走默认</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(lang))&#123;</span><br><span class="line">            LocaleContextHolder.setLocale(<span class="keyword">new</span> Locale(lang));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、注册拦截器"><a href="#七、注册拦截器" class="headerlink" title="七、注册拦截器"></a>七、注册拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、控制器"><a href="#八、控制器" class="headerlink" title="八、控制器"></a>八、控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I18nController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/in"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数是语言配置的key、第二个参数是对象数组，对应语言包中的变量如&#123;0&#125;进行填充、第三个参数是语言区域对象</span></span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(param,<span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、工具类"><a href="#九、工具类" class="headerlink" title="九、工具类"></a>九、工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleMessageUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key和指定的区域语言获取国际语言配置文件中对应的值，并填充参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 语言配置文件中的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locale 区域语言对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args values值中对应的填充参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String key, Object[] args, Locale locale)</span> </span>&#123;</span><br><span class="line">        MessageSource messageSource = SpringContextHolder.getBean(<span class="string">"messageSource"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, args, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前区域上下文对应的语言</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前环境语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLanguage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocaleContextHolder.getLocale().getLanguage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h3><p>通过拦截器截取客户端放入head中的语言标识，生成对应的locale放入LocaleContextHolder中，线程走对应方法操作时，通过LocaleContextHolder.getLocale()可以获取其对应的语言区域，再从对应的语言配置文件获取文本。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>i18n</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>JackJson和FastJson常见操作</title>
    <url>/2020/11/29/JackJson%E5%92%8CFastJson%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="jackjson"><a href="#jackjson" class="headerlink" title="jackjson"></a>jackjson</h3><a id="more"></a>

<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//Include.ALWAYS  是序列化对像所有属性</span></span><br><span class="line"><span class="comment">//Include.NON_NULL 只有不为null的字段才被序列化</span></span><br><span class="line"><span class="comment">//Include.NON_EMPTY 如果为null或者 空字符串和空集合都不会被序列化</span></span><br><span class="line">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line"><span class="comment">//取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式</span></span><br><span class="line">objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//如果是空对象的时候,设置为false不抛异常,也就是对应的属性没有get方法,默认是true,即会抛异常</span></span><br><span class="line">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//反序列化的时候如果多了其他属性,不抛出异常  </span></span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">      <span class="comment"># 设置属性命名策略,对应jackson下PropertyNamingStrategy中的常量值，SNAKE_CASE-返回的json驼峰式转下划线，json body下划线传到后端自动转驼峰式</span></span><br><span class="line">      <span class="attr">property-naming-strategy:</span> <span class="string">SNAKE_CASE</span></span><br><span class="line">      <span class="comment"># 全局设置@JsonFormat的格式pattern</span></span><br><span class="line">      <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">      <span class="comment"># 当地时区</span></span><br><span class="line">      <span class="attr">locale:</span> <span class="string">zh</span></span><br><span class="line">      <span class="comment"># 设置全局时区</span></span><br><span class="line">      <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">      <span class="comment"># 常用，全局设置pojo或被@JsonInclude注解的属性的序列化方式</span></span><br><span class="line">      <span class="attr">default-property-inclusion:</span> <span class="string">NON_NULL</span> <span class="comment">#不为空的属性才会序列化,具体属性可看JsonInclude.Include</span></span><br><span class="line">      <span class="comment"># 常规默认,枚举类SerializationFeature中的枚举属性为key，值为boolean设置jackson序列化特性,具体key请看SerializationFeature源码</span></span><br><span class="line">      <span class="attr">serialization:</span></span><br><span class="line">        <span class="attr">WRITE_DATES_AS_TIMESTAMPS:</span> <span class="literal">true</span> <span class="comment"># 返回的java.util.date转换成timestamp</span></span><br><span class="line">        <span class="attr">FAIL_ON_EMPTY_BEANS:</span> <span class="literal">true</span> <span class="comment"># 对象为空时是否报错，默认true</span></span><br><span class="line">      <span class="comment"># 枚举类DeserializationFeature中的枚举属性为key，值为boolean设置jackson反序列化特性,具体key请看DeserializationFeature源码</span></span><br><span class="line">      <span class="attr">deserialization:</span></span><br><span class="line">        <span class="comment"># 常用,json中含pojo不存在属性时是否失败报错,默认true</span></span><br><span class="line">        <span class="attr">FAIL_ON_UNKNOWN_PROPERTIES:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 枚举类MapperFeature中的枚举属性为key，值为boolean设置jackson ObjectMapper特性</span></span><br><span class="line">      <span class="comment"># ObjectMapper在jackson中负责json的读写、json与pojo的互转、json tree的互转,具体特性请看MapperFeature,常规默认即可</span></span><br><span class="line">      <span class="attr">mapper:</span></span><br><span class="line">        <span class="comment"># 使用getter取代setter探测属性，如类中含getName()但不包含name属性与setName()，传输的vo json格式模板中依旧含name属性</span></span><br><span class="line">        <span class="attr">USE_GETTERS_AS_SETTERS:</span> <span class="literal">true</span> <span class="comment">#默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonParser.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonParser特性</span></span><br><span class="line">      <span class="comment"># JsonParser在jackson中负责json内容的读取,具体特性请看JsonParser.Feature，一般无需设置默认即可</span></span><br><span class="line">      <span class="attr">parser:</span></span><br><span class="line">        <span class="attr">ALLOW_SINGLE_QUOTES:</span> <span class="literal">true</span> <span class="comment"># 是否允许出现单引号,默认false</span></span><br><span class="line">      <span class="comment"># 枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonGenerator特性，一般无需设置默认即可</span></span><br><span class="line">      <span class="comment"># JsonGenerator在jackson中负责编写json内容,具体特性请看JsonGenerator.Feature</span></span><br></pre></td></tr></table></figure>



<p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将对象写成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map);</span><br><span class="line">System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//json串转换成json节点对象</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;json节点对象  ====="</span>);</span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(jsonStr);</span><br><span class="line">System.out.println(jsonNode);</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"name"</span>).asText());</span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"age"</span>).asInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Map param = objectMapper.readValue(jsonStr, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Person person = objectMapper.readValue(jsonStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(param);</span><br><span class="line">System.out.println(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line">String listStr = objectMapper.writeValueAsString(list);</span><br><span class="line"><span class="comment">//no.1</span></span><br><span class="line">JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List<span class="class">.<span class="keyword">class</span>, <span class="title">Person</span>.<span class="title">class</span>)</span>;</span><br><span class="line">List&lt;Person&gt; persons =  (List&lt;Person&gt;)objectMapper.readValue(listStr, javaType);</span><br><span class="line">System.out.println(persons);</span><br><span class="line"><span class="comment">//no.2</span></span><br><span class="line">List&lt;Person&gt; persons2 = objectMapper.readValue(listStr, <span class="keyword">new</span> TypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//xml转成对象</span></span><br><span class="line"><span class="comment">//对象需加上注解映射@JacksonXmlRootElement、@JacksonXmlProperty、@JacksonXmlElementWrapper、@JacksonXmlCData、@JacksonXmlText</span></span><br><span class="line">System.out.println(<span class="string">"==== xml串 --&gt; 对象 ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">User user = xmlMapper.readValue(xml, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//对象转成xml</span></span><br><span class="line">System.out.println(<span class="string">"==== 对象 --&gt; xml ====="</span>);</span><br><span class="line">XmlMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line">String xmlStr = xmlMapper.writeValueAsString(user)</span><br></pre></td></tr></table></figure>

<h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><p>各种转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将对象转换成json串</span></span><br><span class="line">System.out.println(<span class="string">"====  对象-&gt;json串  ====="</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">24</span>);</span><br><span class="line">String jsonString = JSON.toJSONString(p);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成实体对象(map)</span></span><br><span class="line">System.out.println(<span class="string">"====  json串--&gt;实体对象(map)  ====="</span>);</span><br><span class="line">Person person = JSON.parseObject(jsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Map map = JSON.parseObject(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonString);</span><br><span class="line">System.out.println(person);</span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(jsonObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json串转换成集合对象</span></span><br><span class="line">System.out.println(<span class="string">"==== json串 --&gt; 集合对象 ====="</span>);</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(p);</span><br><span class="line">String listStr = JSON.toJSONString(list);</span><br><span class="line">List&lt;Person&gt; peoples = JSON.parseArray(listStr, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">JSONArray jsonArray = JSON.parseArray(listStr);</span><br><span class="line">System.out.println(peoples);</span><br><span class="line">System.out.println(jsonArray);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConverterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">fastJsonHttpMessageConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.定义一个converters转换消息的对象</span></span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="comment">// 2.添加fastjson的配置信息，比如: 是否需要格式化返回的json数据</span></span><br><span class="line">        FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</span><br><span class="line">        <span class="comment">// 3.在converter中添加配置信息</span></span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        <span class="comment">// 4.将converter赋值给HttpMessageConverter</span></span><br><span class="line">        HttpMessageConverter&lt;?&gt; converter = fastConverter;</span><br><span class="line">        <span class="comment">// 5.返回HttpMessageConverters对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>json</category>
      </categories>
  </entry>
  <entry>
    <title>VMware创建centos7虚拟机</title>
    <url>/2020/11/29/VMware%E5%88%9B%E5%BB%BAcentos7%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<img src="http://yrlzero.gitee.io/images/linux/centos/1.png" style="zoom:75%;" />

<a id="more"></a>

<img src="http://yrlzero.gitee.io/images/linux/centos/2.png" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/3.png" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/4.jpg" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/5.jpg" style="zoom:75%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/6.jpg" style="zoom:55%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/7.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/8.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/9.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/10.jpg" style="zoom:65%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/11.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/12.jpg" style="zoom:50%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/13.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/14.jpg" style="zoom:67%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/15.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/16.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/17.jpg" style="zoom:67%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/18.jpg" style="zoom:60%;" />

<img src="http://yrlzero.gitee.io/images/linux/centos/19.jpg" style="zoom:75%;" />]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>admin监控</title>
    <url>/2020/12/06/admin/</url>
    <content><![CDATA[<h2 id="admin服务端"><a href="#admin服务端" class="headerlink" title="admin服务端"></a>admin服务端</h2><a id="more"></a>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">       &lt;spring-boot-admin.version&gt;2.3.1&lt;&#x2F;spring-boot-admin.version&gt;</span><br><span class="line">       &lt;spring-cloud.version&gt;Hoxton.SR9&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">   &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-starter-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--admin--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-admin-server-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--健康检查--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">      </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 邮件--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 加入密码认证 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;&#x2F;exclusion&gt;</span><br><span class="line">           &lt;&#x2F;exclusions&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-admin-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;&#x2F;dependencies&gt;</span><br><span class="line">   &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br><span class="line">       &lt;&#x2F;plugins&gt;</span><br><span class="line">   &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9304</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-admin</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">        <span class="attr">mail:</span></span><br><span class="line">          <span class="comment">#收邮件</span></span><br><span class="line">          <span class="attr">to:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">          <span class="comment"># 发件邮箱（要与邮件配置的username相同）</span></span><br><span class="line">          <span class="attr">from:</span> <span class="number">619876453</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="comment"># 邮件设置</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">619876453</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">abc</span> <span class="comment">#授权码</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smpt:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka:eureka@localhost:9999/eureka</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不注册到eureka</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#服务监控</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">show-components:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="security安全认证"><a href="#security安全认证" class="headerlink" title="security安全认证"></a>security安全认证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String adminContextPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSecurityConfig</span><span class="params">(AdminServerProperties adminServerProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">        successHandler.setTargetUrlParameter( <span class="string">"redirectTo"</span> );</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/assets/**"</span> ).permitAll()</span><br><span class="line">                .antMatchers( adminContextPath + <span class="string">"/login"</span> ).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().loginPage( adminContextPath + <span class="string">"/login"</span> ).successHandler( successHandler ).and()</span><br><span class="line">                .logout().logoutUrl( adminContextPath + <span class="string">"/logout"</span> ).and()</span><br><span class="line">                .httpBasic().and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span><br><span class="line">                .ignoringAntMatchers(</span><br><span class="line">                        adminContextPath + <span class="string">"/instances"</span>,</span><br><span class="line">                        adminContextPath + <span class="string">"/actuator/**"</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="admin客户端（eureka服务端）"><a href="#admin客户端（eureka服务端）" class="headerlink" title="admin客户端（eureka服务端）"></a>admin客户端（eureka服务端）</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Admin 服务 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://admin:admin@localhost:9304</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="安全认证，放行健康检查"><a href="#安全认证，放行健康检查" class="headerlink" title="安全认证，放行健康检查"></a>安全认证，放行健康检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().antMatchers(<span class="string">"/actuator/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><img src="G:%5C%E7%AC%94%E8%AE%B0%5Ccloud%5Cadmin%5Cadmin%E7%9B%91%E6%8E%A7.jpg" alt=""></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><h3 id="邮件通知，查看上面配置"><a href="#邮件通知，查看上面配置" class="headerlink" title="邮件通知，查看上面配置"></a>邮件通知，查看上面配置</h3><h3 id="钉钉通知"><a href="#钉钉通知" class="headerlink" title="钉钉通知"></a>钉钉通知</h3><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DingDingNotifier <span class="title">dingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DingDingNotifier(repository);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingNotifier</span> <span class="keyword">extends</span> <span class="title">AbstractStatusChangeNotifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DingDingNotifier</span><span class="params">(InstanceRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">doNotify</span><span class="params">(InstanceEvent event, Instance instance)</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String serviceName = instance.getRegistration().getName();</span><br><span class="line">        String serviceUrl = instance.getRegistration().getServiceUrl();</span><br><span class="line">        String status = instance.getStatusInfo().getStatus();</span><br><span class="line">        Map&lt;String, Object&gt; details = instance.getStatusInfo().getDetails();</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.append(<span class="string">"系统警告 : 【"</span> + serviceName + <span class="string">"】"</span>);</span><br><span class="line">        str.append(<span class="string">"【服务地址】"</span> + serviceUrl);</span><br><span class="line">        str.append(<span class="string">"【状态】"</span> + status);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str.append(<span class="string">"【详情】"</span> + objectMapper.writeValueAsString(details));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            DingDingMessageUtil.sendTextMessage(str.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送工具类"><a href="#发送工具类" class="headerlink" title="发送工具类"></a>发送工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingDingMessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String access_token = <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setMsgtype(<span class="string">"text"</span>);</span><br><span class="line">            message.setText(<span class="keyword">new</span> MessageInfo(msg));</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"https://oapi.dingtalk.com/robot/send?access_token="</span> + access_token);</span><br><span class="line">            <span class="comment">// 建立 http 连接</span></span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">            conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/Json; charset=UTF-8"</span>);</span><br><span class="line">            conn.connect();</span><br><span class="line">            OutputStream out = conn.getOutputStream();</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            String textMessage = objectMapper.writeValueAsString(message);</span><br><span class="line">            <span class="keyword">byte</span>[] data = textMessage.getBytes();</span><br><span class="line">            out.write(data);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            InputStream in = conn.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] data1 = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data1);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data1));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息类"><a href="#消息类" class="headerlink" title="消息类"></a>消息类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageInfo</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msgtype;</span><br><span class="line">    <span class="keyword">private</span> MessageInfo text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgtype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgtype</span><span class="params">(String msgtype)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgtype = msgtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageInfo <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(MessageInfo text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钉钉群配置机器人"><a href="#钉钉群配置机器人" class="headerlink" title="钉钉群配置机器人"></a>钉钉群配置机器人</h4><p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA2.jpg" alt=""></p>
<p><img src="http://yrlzero.gitee.io/images/cloud/admin/%E9%92%89%E9%92%89%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E4%BA%BA3.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>admin</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka原理解析</title>
    <url>/2020/12/26/eureka%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、Server启动原理"><a href="#一、Server启动原理" class="headerlink" title="一、Server启动原理"></a>一、Server启动原理</h2><ol>
<li>springboot会去加载META-INF下面的spring.factories自动装配<code>org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</code>这个类</li>
</ol>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/eureka%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E7%B1%BB.jpg" alt=""></p>
<ol start="2">
<li><p>此类的判断条件注解标识需要有Mark这个类存在才会加载</p>
</li>
<li><p>而启动类加上<code>@EnableEurekaServer</code>时，会加载Mark类，从而使自动配置类生效，所以当我们需要使用eureka-server时，必须要在启动类加上此注解</p>
</li>
</ol>
<img src="http://yrlzero.gitee.io/images/cloud/eureka/eurekaServer注解.jpg" style="zoom:100%;" />

<h2 id="二、Eureka-Sever缓存"><a href="#二、Eureka-Sever缓存" class="headerlink" title="二、Eureka Sever缓存"></a>二、Eureka Sever缓存</h2><h3 id="1-三级缓存"><a href="#1-三级缓存" class="headerlink" title="1.三级缓存"></a>1.三级缓存</h3><h4 id="1-1（ConcurrentHashMap）registry"><a href="#1-1（ConcurrentHashMap）registry" class="headerlink" title="1.1（ConcurrentHashMap）registry"></a>1.1（ConcurrentHashMap）registry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry= <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>​        第一层的 ConcurrentHashMap 的 <code>key=spring.application.name</code> 也就是客户端实例注册的应用名；value 为嵌套的 ConcurrentHashMap。</p>
<p>​        第二层嵌套的 ConcurrentHashMap 的 <code>key=instanceId</code> 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="1-2-ReadOnlyMap（ConcurrentHashMap）"><a href="#1-2-ReadOnlyMap（ConcurrentHashMap）" class="headerlink" title="1.2  ReadOnlyMap（ConcurrentHashMap）"></a>1.2  ReadOnlyMap（ConcurrentHashMap）</h4><p>​        <strong>周期更新</strong>，类ResponseCacheImpl成员变量，默认每<strong>30s</strong>从readWriteCacheMap更新</p>
<p>​        ReadOnlyMap是一个只读缓存，供客户端获取注册信息时使用，默认情况下，定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。</p>
<h4 id="1-3-readWriteCacheMap（guava-LoadingCache）"><a href="#1-3-readWriteCacheMap（guava-LoadingCache）" class="headerlink" title="1.3  readWriteCacheMap（guava#LoadingCache）"></a>1.3  readWriteCacheMap（guava#LoadingCache）</h4><p>​        <strong>实时更新</strong>，类AbstractInstanceRegistry成员变量</p>
<p>​        readWriteCacheMap，本质上是 Guava 缓存，数据主要同步于registry。当获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。</p>
<p>​        定时器每60s清理超过90s未续约的节点。</p>
<p>​        缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。</p>
<h3 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h3><h4 id="2-1-注册一个服务实例"><a href="#2-1-注册一个服务实例" class="headerlink" title="2.1 注册一个服务实例"></a>2.1 注册一个服务实例</h4><p>​        向注册表中写入服务实例信息，并使得readWriteCacheMap缓存失效</p>
<h4 id="2-2-寻找一个服务"><a href="#2-2-寻找一个服务" class="headerlink" title="2.2 寻找一个服务"></a>2.2 寻找一个服务</h4><p>​        从ReadOnlyMap缓存中找，如果有则返回，如果没有则去ReadWriteMap缓存拿并更新，如果ReadWriteMap缓存已经失效，触发guava的回调函数从注册表中同步。</p>
<h4 id="2-3-数据同步定时器"><a href="#2-3-数据同步定时器" class="headerlink" title="2.3 数据同步定时器"></a>2.3 数据同步定时器</h4><p>​        默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而UI则从registry更新服务注册信息。</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.jpg" alt=""></p>
<h3 id="3-缓存相关配置"><a href="#3-缓存相关配置" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span> <span class="comment"># 续约到期时间，服务端收到最后一次心跳后等待的时间上限，默认90s，超时剔除服务</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#Client是否从readOnlyCacheMap更新数据，false则跳过readOnlyCacheMap直接从readWriteCacheMap更新，默认true</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>



<h3 id="4-多级缓存的优点"><a href="#4-多级缓存的优点" class="headerlink" title="4. 多级缓存的优点"></a>4. 多级缓存的优点</h3><p>​        尽可能保证了内存注册表中的数据不会出现频繁的读写冲突问题，进一步保证了对eurekaServer的大量请求，都是快速读取内存，提供性能</p>
<h3 id="5-优化eureka服务端"><a href="#5-优化eureka服务端" class="headerlink" title="5. 优化eureka服务端"></a>5. 优化eureka服务端</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false # 心跳保护机制，默认开启，自我保护机制，服务可用数量少于85%时默认开启自我保护机制，不会再剔除服务微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span><br><span class="line">    eviction-interval-timer-in-ms: 1000 # 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span><br><span class="line">    renewal-percent-threshold: 0.85 #自我保护机制触发的阈值，默认0.85</span><br><span class="line">    use-read-only-response-cache: false #是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span><br><span class="line">    response-cache-update-interval-ms: 1000 # readwrite 和readOnly 同步时间间隔，默认30 * 1000</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="三-、Eureka-Client缓存"><a href="#三-、Eureka-Client缓存" class="headerlink" title="三 、Eureka Client缓存"></a>三 、Eureka Client缓存</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h3><p>​        Eureka Client存在两种角色：<strong>服务提供者</strong>和<strong>服务消费者</strong>，作为服务消费者一般配合Ribbon（Feign内部使用Ribbon）使用。</p>
<p>​        Client启动后，作为服务提供者立即向Server注册，默认情况下每30s续约(renew)；作为服务消费者立即向Server全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon延时1s向Client获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。</p>
<h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h3><p>2.1 localRegionApps(Eureka Client缓存)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</span><br></pre></td></tr></table></figure>

<p>​        <strong>周期更新</strong>，类DiscoveryClient成员变量，Eureka Client保存服务注册信息，启动后立即向Server全量更新，默认每<strong>30s</strong>增量更新</p>
<p>2.2 upServerListZoneMap(ConcurrentHashMap,Ribbon缓存)</p>
<p>​        <strong>周期更新</strong>，类LoadBalancerStats成员变量，Ribbon保存使用且状态为<strong>UP</strong>的服务注册信息，启动后延时1s向Client更新，默认每<strong>30s</strong>更新</p>
<h3 id="3-缓存相关配置-1"><a href="#3-缓存相关配置-1" class="headerlink" title="3. 缓存相关配置"></a>3. 缓存相关配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span> <span class="comment"># 客户端向服务端发送心跳（续约）的时间间隔，默认30s</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka集群安装</title>
    <url>/2020/12/06/eureka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 服务端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 安全配置，服务之间注册需要校验 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查，用于服务之间的心跳检测 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-启动类添加注解"><a href="#2-启动类添加注解" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-节点一的yml配置"><a href="#3-1-节点一的yml配置" class="headerlink" title="3.1 节点一的yml配置"></a>3.1 节点一的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9991</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka1.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9991 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-节点二的yml配置"><a href="#3-2-节点二的yml配置" class="headerlink" title="3.2 节点二的yml配置"></a>3.2 节点二的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9992</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka2.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9992 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">456</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka3.com:9993/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-节点三的yml配置"><a href="#3-3-节点三的yml配置" class="headerlink" title="3.3 节点三的yml配置"></a>3.3 节点三的yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9993</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">yrl-eureka</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">eureka</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka3.com</span> <span class="comment">#eureka服务端主机名称，每个启动的实例应该配置不同，不配置的时候将根据操作系统的主机名来获取</span></span><br><span class="line"><span class="comment">#    instance-id: yrl-eureka9993 # 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span> <span class="comment"># 不加的话，默认是主机名+服务名+端口，加上之后屏蔽服务器相关信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">false</span> <span class="comment">#是否优先使用 IP 地址作为主机名的标识，测试环境下使用false，生产情况下使用true</span></span><br><span class="line">    <span class="attr">metadata-map:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="number">789</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#false 本身就是注册中心，不需要抓取服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#设置与注册中心交互的地址</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka1.com:9991/eureka/,http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@eureka2.com:9992/eureka/</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> <span class="comment">#表示eureka客户端间隔多久去拉取服务注册信息，默认30s，如果要迅速获取服务注册状态，可以减小该值</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 心跳保护机制，默认开启，微服务少的情况下关闭，剔除挂掉的节点；微服务多的情况下开启，防止网络抖动节点心跳丢失而被剔除</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 逐出实例时间,默认60 * 1000（清理无效节点的时间间隔）</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment">#自我保护机制触发的阈值，默认0.85</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span> <span class="comment">#是否使用从readOnly读取注册表，默认true,三级缓存机制保证高可用，但是一致性减弱了</span></span><br><span class="line">    <span class="attr">response-cache-update-interval-ms:</span> <span class="number">1000</span> <span class="comment"># readwrite 和readOnly 同步时间间隔，默认30 * 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="二、-客户端"><a href="#二、-客户端" class="headerlink" title="二、 客户端"></a>二、 客户端</h2><h3 id="1-依赖-1"><a href="#1-依赖-1" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka 客户端依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--健康检查--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-启动类添加注解-1"><a href="#2-启动类添加注解-1" class="headerlink" title="2. 启动类添加注解"></a>2. 启动类添加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h3 id="3-yml配置"><a href="#3-yml配置" class="headerlink" title="3. yml配置"></a>3. yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9302</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-pay</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="string">service‐url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span></span><br><span class="line">        <span class="string">http://eureka:eureka@eureka1.com:9991/eureka/,http://eureka:eureka@eureka2.com:9992/eureka/,http://eureka:eureka@eureka3.com:9993/eureka/</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<h2 id="三、控制台"><a href="#三、控制台" class="headerlink" title="三、控制台"></a>三、控制台</h2><p>当服务出现在available-replicas中才算搭建成功</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/eureka/eureka%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt=""></p>
<h2 id="四、健康检查"><a href="#四、健康检查" class="headerlink" title="四、健康检查"></a>四、健康检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">managementUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator</span><br><span class="line">healthUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;actuator&#x2F;health</span><br><span class="line">serviceUrl&#x3D;http:&#x2F;&#x2F;192.168.243.1:9993&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="五、cap原则"><a href="#五、cap原则" class="headerlink" title="五、cap原则"></a>五、cap原则</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一致性（Consistency）</span><br><span class="line">可用性（Availability）</span><br><span class="line">分区容错性（Partition tolerance）</span><br><span class="line">1.eureka是ap，去中心化，每个节点是平等的，15分钟内，可用实例低于85%,开启心跳保护，不会剔除心跳异常的实例，保证可用性，仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用），所以实例调用需要有熔断机制保证</span><br><span class="line">2.zookpeer是cp，由leader提供服务，ZooKeeper选举Leader时候会造成服务一定时间内的不可用，保证了一致性，不保证可用性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
        <tag>注册中心</tag>
        <tag>netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载与创建</title>
    <url>/2021/01/03/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-01.png" alt="jvm"></p>
<a id="more"></a>

<h2 id="Class格式"><a href="#Class格式" class="headerlink" title="Class格式"></a>Class格式</h2><p>Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。</p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a><strong>无符号数</strong></h3><p>属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a><strong>表</strong></h3><p>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。表主要用于描述有层次关系的复合结构的数据，比如方法、字段。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的。具体的顺序定义如下：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-03.png" alt="jvm"></p>
<p>从二进制的数据来看：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-02.png" alt="jvm"></p>
<p>通过<code>javap</code>编译成可视化语言来看：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-06.png" alt="jvm"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cafe babe 0000 0034 000f 0a00 0300 0c07</span><br><span class="line">000d 0700 0e01 0006 3c69 6e69 743e 0100</span><br><span class="line">0328 2956 0100 0443 6f64 6501 000f 4c69</span><br><span class="line">6e65 4e75 6d62 6572 5461 626c 6501 0004</span><br><span class="line">6d61 696e 0100 1628 5b4c 6a61 7661 2f6c</span><br><span class="line">616e 672f 5374 7269 6e67 3b29 5601 000a</span><br><span class="line">536f 7572 6365 4669 6c65 0100 134a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 742e 6a61 7661</span><br><span class="line">0c00 0400 0501 0013 6b75 726f 2f4a 766d</span><br><span class="line">436c 6173 7346 6f72 6d61 7401 0010 6a61</span><br><span class="line">7661 2f6c 616e 672f 4f62 6a65 6374 0021</span><br><span class="line">0002 0003 0000 0000 0002 0001 0004 0005</span><br><span class="line">0001 0006 0000 001d 0001 0001 0000 0005</span><br><span class="line">2ab7 0001 b100 0000 0100 0700 0000 0600</span><br><span class="line">0100 0000 0300 0900 0800 0900 0100 0600</span><br><span class="line">0000 1900 0000 0100 0000 01b1 0000 0001</span><br><span class="line">0007 0000 0006 0001 0000 0006 0001 000a</span><br><span class="line">0000 0002 000b</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">魔法数字： cafe babe</span><br><span class="line">次版本号： 0000</span><br><span class="line">主版本号： 0034			JDK1.8</span><br><span class="line">常量数量： 000f			从1开始</span><br><span class="line">#1常量 ： 0a			 表示表中第十项（CONSTANT_Methodref_info）</span><br><span class="line">      :  00 03		   指向#3常量</span><br><span class="line">      ： 00 0c		  指向#13常量</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-04.png" alt="jvm"></p>
<p>详情可查阅查阅：</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-05.png" alt="jvm"></p>
<h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><p>​        使用new关键字创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>​        使用Class类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = A<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>​        使用Constructor类的newInstance方法(反射机制)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;A&gt; constructor = A<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">A a = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>​        使用Clone方法创建对象</p>
<p>​        使用(反)序列化机制创建对象</p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-07.png" alt="jvm"></p>
<h3 id="加载-class-loading"><a href="#加载-class-loading" class="headerlink" title="加载(class loading)"></a>加载(class loading)</h3><blockquote>
<p>1.通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2.将这个字节流所代表的的静态存储结构转化成访问区的运行时数据结构。</p>
<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
</blockquote>
<h3 id="验证-class-verification"><a href="#验证-class-verification" class="headerlink" title="验证(class verification)"></a>验证(class verification)</h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证等等。</p>
<p>如验证是否以0xCAFEBABE开头</p>
<h3 id="准备-class-preparation"><a href="#准备-class-preparation" class="headerlink" title="准备(class preparation)"></a>准备(class preparation)</h3><p>为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p><strong>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中。</strong></p>
<p><strong>正常情况下，这里初始化的值是静态变量的数据类型的默认值，而不是属性指定的值，如果它还被final修饰了，那么将会在这个阶段直接初始化成属性指定的值。</strong></p>
<h3 id="解析-class-resolution"><a href="#解析-class-resolution" class="headerlink" title="解析(class resolution)"></a>解析(class resolution)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="类初始化-class-initalizing"><a href="#类初始化-class-initalizing" class="headerlink" title="类初始化(class initalizing)"></a>类初始化(class initalizing)</h3><p>类初始化就是执行<code>&lt;clinit&gt;()</code>方法，<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，<strong>静态语句块中只能访问到定义在静态语句之前的变量</strong>。</p>
<p>也就是说，静态属性和静态代码块的赋值和调用在<strong>初始化</strong>过程中执行，先执行父类的，再执行子类的。</p>
<h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><p>实例初始化过程，就是执行<code>&lt;init&gt;()</code>方法<br>         <code>&lt;init&gt;()</code>方法可能重载有多个，有几个构造器就有几个<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>         非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>         每次创建实例对象，调用对应构造器，执行的就是对应的<code>&lt;init&gt;</code>方法<br>         <code>&lt;init&gt;()</code>方法的首行是surper(或super(实参列表),即对应父类的<code>&lt;init&gt;</code>方法</p>
<h3 id="类初始化与实例初始化，在子父类内部执行顺序"><a href="#类初始化与实例初始化，在子父类内部执行顺序" class="headerlink" title="类初始化与实例初始化，在子父类内部执行顺序"></a>类初始化与实例初始化，在子父类内部执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类静态成员</span><br><span class="line">父类静态代码块</span><br><span class="line">	-&gt;子类静态成员</span><br><span class="line">	-&gt;子类静态代码块</span><br><span class="line">		-&gt;父类代码块</span><br><span class="line">		-&gt;父类成员变量</span><br><span class="line">		-&gt;父类构造器</span><br><span class="line">			-&gt;子类代码块</span><br><span class="line">			-&gt;子类成员变量</span><br><span class="line">			-&gt;子类构造器</span><br><span class="line">类初始化</span><br><span class="line">	静态成员赋值的代码、静态代码块（两者先后看顺序）</span><br><span class="line">实例初始化</span><br><span class="line">	super()</span><br><span class="line">	非静态赋值的代码、非静态代码块（两者先后看顺序）</span><br><span class="line">	无参构造</span><br></pre></td></tr></table></figure>

<p>​        样例：</p>
<img src="http://yrlzero.gitee.io/images/jvm/jvm-base/类实例化和类初始化.jpg" style="zoom:95%;" />

<p>上图执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、1、10、6、9、3、2、9、8、7</span><br><span class="line">9、3、2、9、8、7</span><br><span class="line"></span><br><span class="line">类初始化与实例初始化</span><br><span class="line">5  父类静态成员j调用父类的静态方法method()，静态方法不可重写，所以不会调用子类的</span><br><span class="line">1  父类静态代码块</span><br><span class="line">10 子类静态成员j调用子类的静态方法method()</span><br><span class="line">6  子类静态代码块</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br><span class="line"></span><br><span class="line">再次实例初始化</span><br><span class="line">9  父类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">3  父类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">2  父类构造器</span><br><span class="line">9  子类成员变量i调用子类的test(),非静态方法默认的调用对象是this,this对象在构造器或者说&lt;init&gt;方法中就是正在创建的对象</span><br><span class="line">8  子类代码块，与成员变量之前的执行先后取决于位置的前后</span><br><span class="line">7  子类构造器</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 count = 2; T t = new T();---&gt;调用构造方法--&gt;count++;</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ClassLoader加载T对象：</span></span><br><span class="line">        <span class="comment">//1.加载(loading)</span></span><br><span class="line">        <span class="comment">//2.验证(verification)</span></span><br><span class="line">        <span class="comment">//3.准备(preparation)--初始化静态变量默认值count = 0; T t = null</span></span><br><span class="line">        <span class="comment">//4.解析(resolution)</span></span><br><span class="line">        <span class="comment">//5.初始化(initalizing)--按照顺序赋值静态变量 T t = new T();---&gt;调用构造方法--&gt;count++; count = 1;</span></span><br><span class="line">        <span class="comment">//--按照顺序赋值静态变量 count = 2;（覆盖掉之前的值）</span></span><br><span class="line">        System.out.println(T.count); <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果是<code>Object o = new Object()</code>，有以下几步：</strong></p>
<p>1、申请内存空间，这时候成员变量均是默认值</p>
<p>2、调用构造方法，初始化成员变量值</p>
<p>3、建立栈上和堆内存对象的关联关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们调用构造方法时，java的底层的字节码指令如下：</span></span><br><span class="line">0: new           #2                  // class java/lang/Object		申请内存空间</span><br><span class="line"><span class="number">3</span>: dup								 <span class="comment">// 复制内存空间地址，供以调用构造方法时出栈使用</span></span><br><span class="line">4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V    调用构造方法</span><br><span class="line"><span class="number">7</span>: astore_1							 <span class="comment">// Object o 指向开辟的内存地址</span></span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-08.png" alt="jvm"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-base/jvm-09.png" alt="jvm"></p>
<p>如果一个类加载器收到了类加载的请求，它不会先尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载。</p>
<p><strong>这里的父-子是通过使用组合关系，成员变量有个叫做parent的属性记录上层的类加载器，而不是继承关系。</strong></p>
<p><strong>父类加载器不是类加载器的加载器，也不是类加载器的父类加载器。双亲委派是一个孩子向父亲方向，然后父亲向孩子方向的双亲委派过程。</strong></p>
<blockquote>
<p>为什么用双亲委派机制？</p>
<p>安全，保证了Java程序的稳定运行。避免核心类库被用户覆盖。</p>
</blockquote>
<p>查看各个类加载器加载的路径及信息可以查阅<code>Launcher.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BootStrap ClassLoader:sun.boot.class.path</span><br><span class="line">ExtClassLoader:java.ext.dirs</span><br><span class="line">AppClassLoader：java.class.path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK破坏双亲委派机制的历史</p>
<p>双亲委派模型的第一次被破坏发生在双亲委派模型出现之前，由于双亲委派模型在JDK1.2之后才被引入，为了向前兼容，JDK1.2之后添加了一个findClass()方法。</p>
<p>双亲委派模型的第二次被破坏是由于模型自身的缺陷导致的，有些标准服务是由启动类加载器（Bootstrap）去加载的，但它又需要调用独立厂商实现并部署在应用程序的ClassPath下的代码，为了解决这个问题，引入了<strong>线程上下文类加载器</strong>，如果有了线程上下文类加载器，父类加载器将会请求子类加载器去完成类加载动作。</p>
<p>双亲委派模型的第三次被破坏是由于用户对程序动态性的追求导致的。如热替换、热部署。</p>
<p>假设每个程序都有一个自己的类加载器，当需要更换一个代码片段时，就把这个代码片段连同类加载器一起换掉实现代码的热替换。</p>
</blockquote>
<p>当我们需要定义自己的类加载器时，继承ClassLoad，重写findClass()方法，当调用loadClass()加载class，找不到时会调用我们自定义的findClass()，读取要加载的文件流，调用defineClass()去真正加载，保证了双亲委派机制</p>
<p>若要破坏双亲委派模型，我们可以直接重写loadClass()方法，直接加载指定的class，没有的情况下再走parent的loadClass()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//File To byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(<span class="string">"xxx"</span>));</span><br><span class="line">        <span class="comment">//调用父类的defineClass装载</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h2><p>Java默认采用混合模式，初期通过编译器编译Class文件的代码，当出现热点代码时，会通过<code>JIT</code>解释器把热点代码解释成本地代码，提高运行效率。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 热点代码的阈值频次</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CompileThreshold = 10000</span></span><br><span class="line"><span class="comment"># 使用编译器运行</span></span><br><span class="line"><span class="attr">-Xcomp</span></span><br><span class="line"><span class="comment">#使用解释器运行</span></span><br><span class="line"><span class="attr">-Xint</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8安装</title>
    <url>/2020/11/29/jdk1.8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、安装rz、sz命令"><a href="#一、安装rz、sz命令" class="headerlink" title="一、安装rz、sz命令"></a>一、安装rz、sz命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure>

<h2 id="二、rpm方式安装jdk"><a href="#二、rpm方式安装jdk" class="headerlink" title="二、rpm方式安装jdk"></a>二、rpm方式安装jdk</h2><a id="more"></a>

<h3 id="1-查看是否含有系统自带jdk"><a href="#1-查看是否含有系统自带jdk" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-上传安装包"><a href="#2-上传安装包" class="headerlink" title="2. 上传安装包"></a>2. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效"><a href="#3-安装jdk-默认安装在-usr-java下，不要去修改默认目录，否则软连接会失效" class="headerlink" title="3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)"></a>3. 安装jdk(默认安装在/usr/java下，不要去修改默认目录，否则软连接会失效)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh jdk-8u162-linux-x64.rpm</span><br></pre></td></tr></table></figure>

<img src="http://yrlzero.gitee.io/images/linux/jdk/rpm安装jdk.jpg" style="zoom:100%;" />

<h3 id="4-修改系统环境变量"><a href="#4-修改系统环境变量" class="headerlink" title="4. 修改系统环境变量"></a>4. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容"><a href="#5-追加以下内容" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_162&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/jdk/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%E5%86%85%E5%AE%B9.jpg" alt=""></p>
<h3 id="6-让修改生效"><a href="#6-让修改生效" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态"><a href="#7-查看系统环境状态" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/jdk/%E8%AE%A9%E4%BF%AE%E6%94%B9%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%9F%E6%95%88.jpg" alt=""></p>
<h3 id="8-删除rpm安装的jdk"><a href="#8-删除rpm安装的jdk" class="headerlink" title="8. 删除rpm安装的jdk"></a>8. 删除rpm安装的jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br><span class="line">yum -y remove xxx</span><br></pre></td></tr></table></figure>

<h2 id="三、tar-gz包安装jdk"><a href="#三、tar-gz包安装jdk" class="headerlink" title="三、tar.gz包安装jdk"></a>三、tar.gz包安装jdk</h2><h3 id="1-查看是否含有系统自带jdk-1"><a href="#1-查看是否含有系统自带jdk-1" class="headerlink" title="1. 查看是否含有系统自带jdk"></a>1. 查看是否含有系统自带jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e --nodeps xxxx</span><br></pre></td></tr></table></figure>

<h3 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2. 创建文件夹"></a>2. 创建文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure>

<h3 id="3-上传安装包"><a href="#3-上传安装包" class="headerlink" title="3. 上传安装包"></a>3. 上传安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<h3 id="4-解压"><a href="#4-解压" class="headerlink" title="4. 解压"></a>4. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>-z　通过gzip指令处理备份文件<br>-x　从备份文件中还原文件<br>-v　显示指令执行过程<br>-f　指定备份文件</p>
<h3 id="5-修改系统环境变量"><a href="#5-修改系统环境变量" class="headerlink" title="5. 修改系统环境变量"></a>5. 修改系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="5-追加以下内容-1"><a href="#5-追加以下内容-1" class="headerlink" title="5. 追加以下内容"></a><strong>5. 追加以下内容</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<h3 id="6-让修改生效-1"><a href="#6-让修改生效-1" class="headerlink" title="6. 让修改生效"></a><strong>6. 让修改生效</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="7-查看系统环境状态-1"><a href="#7-查看系统环境状态-1" class="headerlink" title="7. 查看系统环境状态"></a><strong>7. 查看系统环境状态</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020/12/06/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一、下载地址："><a href="#一、下载地址：" class="headerlink" title="一、下载地址："></a>一、下载地址：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/1.png" alt=""></p>
<a id="more"></a>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/2.png" alt=""></p>
<h2 id="二、-删除旧有版本"><a href="#二、-删除旧有版本" class="headerlink" title="二、 删除旧有版本"></a>二、 删除旧有版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看MySql与mariadb安装情况</span><br><span class="line"># grep -i是不分大小写字符查询，只要含有mysql就显示</span><br><span class="line">rpm -qa | grep -i mysql </span><br><span class="line">rpm -qa | grep mariadb</span><br><span class="line"></span><br><span class="line"># 卸载mariadb(会与mysql冲突)</span><br><span class="line">rpm -e --nodeps xxxxx</span><br></pre></td></tr></table></figure>

<h2 id="三、-rpm安装新MySQL"><a href="#三、-rpm安装新MySQL" class="headerlink" title="三、 rpm安装新MySQL"></a>三、 rpm安装新MySQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建新文件夹</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line"></span><br><span class="line"># 上传文件</span><br><span class="line"></span><br><span class="line"># 对”mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar”解包，不是压缩文件不需要解压缩</span><br><span class="line">tar -xvf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/mysql/%E8%A7%A3%E5%8E%8Bmysqltar%E5%8C%85.jpg" alt=""></p>
<p>执行如下安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、安装 mysql-community-common</span><br><span class="line">rpm -ivh mysql-community-common-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 2、安装 mysql-community-libs</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 3、安装 mysql-community-client </span><br><span class="line">rpm -ivh mysql-community-client-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 4、安装 mysql-community-server</span><br><span class="line">yum -y install perl</span><br><span class="line">rpm -ivh mysql-community-server-5.7.21-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 5、安装 mysql-community-devel</span><br><span class="line">rpm -ivh mysql-community-devel-5.7.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>安装完成。MySql默认安装文件位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;    #数据库目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;mysql   #配置文件目录</span><br><span class="line">&#x2F;usr&#x2F;bin             #相关命令目录</span><br><span class="line">&#x2F;etc&#x2F;my.cnf         #核心配置文件</span><br></pre></td></tr></table></figure>

<h2 id="四、配置MySQL"><a href="#四、配置MySQL" class="headerlink" title="四、配置MySQL"></a>四、配置MySQL</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动mysql </span><br><span class="line">service mysqld start</span><br><span class="line">#重启mysql </span><br><span class="line">service mysqld restart</span><br><span class="line">#停止mysql</span><br><span class="line">service mysqld stop</span><br><span class="line">#查看mysql状态</span><br><span class="line">service mysqld status</span><br><span class="line"></span><br><span class="line"># 设置开机启动Mysql</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"># 设置开机不启动Mysql</span><br><span class="line">systemctl disable mysqld</span><br></pre></td></tr></table></figure>

<p>修改root密码</p>
<p>MySQL安装成功后，会生成一个临时密码，我们第一次登录需要输入这个密码，所以查看该临时密码，然后修改密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看临时密码(&#x2F;var&#x2F;log&#x2F;mysqld.log)</span><br><span class="line">grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line"></span><br><span class="line"># 使用root登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line">#然后输入&#x2F;var&#x2F;log&#x2F;mysqld.log文件中的临时密码</span><br><span class="line"></span><br><span class="line">#登录后；修改密码为Root_123</span><br><span class="line">set password &#x3D; password(&#39;Root_123&#39;);</span><br><span class="line"></span><br><span class="line">注意：密码必须包含大小写字母、数字、特殊符号</span><br></pre></td></tr></table></figure>

<h2 id="五、设置允许远程访问"><a href="#五、设置允许远程访问" class="headerlink" title="五、设置允许远程访问"></a>五、设置允许远程访问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录，密码为新修改的密码Root_123</span><br><span class="line">mysql -uroot –p</span><br><span class="line"></span><br><span class="line">#设置远程访问（使用root密码）：</span><br><span class="line">mysql&gt; grant all privileges on  *.*  to  &#39;root&#39; @&#39;%&#39;  identified by &#39;Root_123&#39;; </span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>设置3306端口可以被访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 退出mysql</span><br><span class="line"># 防火墙中打开3306端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;3306&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -P 3306 -h 127.0.0.1 -p&#39;password&#39;</span><br></pre></td></tr></table></figure>

<h2 id="七、备份"><a href="#七、备份" class="headerlink" title="七、备份"></a>七、备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份命令mysqldump格式</span><br><span class="line">   格式：mysqldump -h主机名  -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql </span><br><span class="line">还原MySQL数据库的命令</span><br><span class="line">	mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>maven安装</title>
    <url>/2020/11/29/maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="1-下载地址：http-maven-apache-org-download-cgi"><a href="#1-下载地址：http-maven-apache-org-download-cgi" class="headerlink" title="1. 下载地址：http://maven.apache.org/download.cgi"></a>1. 下载地址：<code>http://maven.apache.org/download.cgi</code></h3><a id="more"></a>

<h3 id="2-解压："><a href="#2-解压：" class="headerlink" title="2. 解压："></a>2. 解压：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-重命名："><a href="#3-重命名：" class="headerlink" title="3. 重命名："></a>3. 重命名：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-maven-3.6.3 maven3.6.3</span><br></pre></td></tr></table></figure>



<h3 id="4-添加环境变量："><a href="#4-添加环境变量：" class="headerlink" title="4. 添加环境变量："></a>4. 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$M2_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<h3 id="5-让修改生效："><a href="#5-让修改生效：" class="headerlink" title="5. 让修改生效："></a>5. 让修改生效：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h3 id="6-验证："><a href="#6-验证：" class="headerlink" title="6. 验证："></a>6. 验证：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

<h3 id="7-修改配置文件"><a href="#7-修改配置文件" class="headerlink" title="7. 修改配置文件"></a>7. 修改配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;local&#x2F;maven&#x2F;maven3.6.3&#x2F;conf&#x2F;settings.xml</span><br><span class="line">	&lt;!-- 本地仓库 --&gt;</span><br><span class="line">	&lt;localRepository&gt;&#x2F;usr&#x2F;local&#x2F;mvn_repository&lt;&#x2F;localRepository&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--使用阿里云，速度比官方快很多行指定中央仓库的镜像。--&gt;</span><br><span class="line">	&lt;mirror&gt;</span><br><span class="line">		&lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">		&lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;</span><br><span class="line">	&lt;&#x2F;mirror&gt;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&lt;!--更改Maven的默认jdk版本 --&gt;</span><br><span class="line">	&lt;profile&gt;</span><br><span class="line">		&lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;activation&gt;</span><br><span class="line">			&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">			&lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;</span><br><span class="line">		&lt;&#x2F;activation&gt;</span><br><span class="line">		&lt;properties&gt;</span><br><span class="line">			&lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">			&lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">			&lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;</span><br><span class="line">		&lt;&#x2F;properties&gt;</span><br><span class="line">   &lt;&#x2F;profile&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>JVM（一） 运行时数据区域</title>
    <url>/2021/01/03/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>​        <strong>Java 虚拟机在执行 Java 程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-1.png" alt="memory-1"></p>
<a id="more"></a>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​        程序计数器（<code>Program Counter Register</code>）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>​        <strong>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。</strong></p>
<p>​        因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”</strong>的内存。</p>
<p>​        如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <code>Native</code> 方法，这个计数器值则为空（<code>Undefined</code>）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何<code>OutOfMemoryError</code> 情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​        与程序计数器一样，Java 虚拟机栈（<code>Java Virtual Machine Stacks</code>）也是线程私有的，它的生命周期与线程相同。</p>
<p>​        <strong>虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧（<code>Stack Frame</code>）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></p>
<p>​        每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>​        经常有人把Java内存区分为<strong>堆内存</strong>（<code>Heap</code>）和<strong>栈内存</strong>（<code>Stack</code>），这种划分方式的流行只能说明大多数程序员最关注的、域对象内存分配关系最密切的内存区是这两块。Java 内存区域的划分实际上远比这复杂。</p>
<p>​        其中所指的“<strong>栈</strong>”就是虚拟机栈，或者说是虚拟机栈中的局部变量表。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-2.png" alt="memory-2"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>​        局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。</p>
<p>​        基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p>
<p>​        对象引用：<code>reference</code>类型，它不等同于对象本身，可能是个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他于此对象相关的位置</p>
<p>​        <code>returnAddress</code>类型：指向了一条字节码指令的地址</p>
<p>​        其中64位长度的 <code>long</code> 和 <code>double</code> 类型的数据会占用2个局部变量空间（<code>Slot</code>），其余的数据类型只占用1个。<code>Slot</code>是栈帧中的局部变量表的最小单位。</p>
<p>​        局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>​    虚拟机栈规定了两种异常情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常。</li>
<li>如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，将抛出<code>OutOfMemoryError</code>(<code>OOM</code>)异常。</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>​        Java 虚拟机的解释执行引擎被称为“ 基于栈的执行引擎 ”，其中所指的栈就是指－操作数栈。 <strong>操作数栈也常被称为操作栈</strong>，<strong>它是一个后入先出栈</strong>。</p>
<p>​        和局部变量表一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作( <strong>压栈和出栈</strong> )来访问的。</p>
<p>​        比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</p>
<p>​        虚拟机在操作数栈中存储数据的方式和在局部变量表中是一样的。</p>
<p>​        虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>​        举例来说，在JVM中执行 <code>a = b + c</code>的字节码执行过程中操作数栈以及局部变量表的变化如下图所示。</p>
<p>​        局部变量表中存储着 <code>a、b、c</code> 三个局部变量，首先将 <code>b</code> 和 <code>c</code> 分别压入栈中，如下图<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-3.png" alt="memory-3"><br>​        将栈顶的两个数<strong>出栈执行求和操作，并将结果再次压入栈顶中</strong>，之后将栈顶的数出栈赋值给 <code>a</code>，如下图<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-4.png" alt="memory-4"></p>
<p>看一个比较经典的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncrementTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="keyword">int</span> j = i++;</span><br><span class="line">        <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">k = <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>代码分析：</strong></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-5.png" alt="memory-5"></p>
<p>​        如上图，代码 <code>i = i++</code>，自增操作是在局部变量表中的，而不是在操作数栈中，因为是后++操作，所以i的值进入操作数栈之后自身才在局部变量表中自增，然后操作数栈的值会赋值回局部变量表，此时自增的结果被覆盖。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>i</code> 变量，此时 <code>i</code> 的值又变为了 <strong>1</strong></p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-6.png" alt="memory-6"></p>
<p>​        如上图，代码 <code>int j = i++</code>，因为是后++操作，i的值先进入操作数栈，自身再在局部变量表进行自增，操作数栈的值赋值给j。</p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>1</strong> 压入操作数栈中</p>
</li>
<li><p>把操作数栈中的值 <code>1</code> 赋值给局部变量表中的 <code>j</code> 变量，此时 <code>j</code> 的值为 <strong>1</strong></p>
</li>
<li><p>把局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code> 的值为 <strong>2</strong></p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-7.png" alt="memory-7"></p>
<p>​        如上图，代码 <code>int k = i + ++i * i++</code></p>
<ul>
<li><p>把局部变量表中的 <code>i</code> 的值 <strong>2</strong> 压入操作数栈中</p>
</li>
<li><p>++i是先++，所以局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，再压入操作数栈中，此时 <code>i</code> 的值为 <strong>3</strong>，</p>
</li>
</ul>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-8.png" alt="memory-8"></p>
<p>如上图</p>
<ul>
<li>i++是后自增，i的值先进入操作数栈，而后局部变量表中的 <code>i</code> 变量自增 <strong>1</strong>，此时 <code>i</code>的值为 <strong>4</strong></li>
<li>把操作数栈中前两个弹出求乘积<strong>（3 * 3 = 9）</strong>，将结果再次压入操作数栈中</li>
<li>把操作数栈中前两个弹出求和<strong>（9 + 2 = 11）</strong>，将结果再次压入操作数栈中</li>
<li>将操作数栈中的值 <strong>11</strong> 赋值给局部变量表中的 <code>k</code> 变量，此时 <code>k</code> 的值为 <strong>11</strong></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>赋值 =，最后计算</li>
<li>= 右边的从左到右加载值依次压入操作数栈</li>
<li>根据运算符的优先级判断先算哪个</li>
<li><strong>自增和自减操作都是直接修改变量的值，不经过操作数栈</strong></li>
<li>最后赋值之前，临时结果都是保存在操作数栈中的</li>
</ul>
<p>值得提醒的是，<code>i++</code>和<code>++i</code>都不是原子操作，因为它并不会作为一个不可分割的操作来执行，实际上它包含三个独立的操作：</p>
<ul>
<li>读取<code>i</code>的值</li>
<li>将值加<code>1</code></li>
<li>然后将计算结果写入<code>i</code><br>这是一个<strong>读取-修改-写入</strong>的操作序列，并且其结果状态依赖于之前的状态。</li>
</ul>
<p>即使使用 <code>volatile</code> 修饰，保证了多个线程多<code>i</code>的可见性，每次从局部变量表读取的都是最新的值，也不是线程安全的。</p>
<p>如果假设 <strong>i=9</strong>，在某些情况下，多个线程读到的值都为 <strong>9</strong>，接着执行递增操作，并且都将<code>i</code>设置成 <strong>10</strong> ，显然不是线程安全的。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>​        每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p>
<p>​        Class 文件中存放了大量的符号引用，这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析，如静态方法、私有方法等等，另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。<br><strong>栈帧中保存了一个引用，指向该方法在运行时常量池中的位置，通过运行时常量池的符号引用（指向堆），完成将符号引用转化为直接引用</strong>。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>方法执行时有两种退出情况：</p>
<ul>
<li><p>正常退出，即正常执行到任何方法的返回字节码指令，如 <code>return</code>等</p>
</li>
<li><p>异常退出，即某些指令导致了 Java 虚拟机抛出异常并且没有处理</p>
</li>
</ul>
<p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p>
<ul>
<li><p>返回值压入上层调用栈帧。</p>
</li>
<li><p>异常信息抛给能够处理的栈帧。</p>
</li>
<li><p>PC计数器指向方法调用后的下一条指令。</p>
</li>
</ul>
<p>当方法执行正常退出时，当前栈帧承担着恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器、跳过刚才执行的方法调用指令等。调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​        本地方法栈（<code>Native Method Stack</code>）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <code>Native</code> 方法服务。<code>Sun HotSpot</code>虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<p>​        与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>​        对于大多数应用来说，Java 堆（<code>Java Heap</code>）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>​        Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做 “ <code>GC</code>堆 ”（<code>Garbage Collected Heap</code>）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 <code>Eden</code> 空间、<code>From Survivor</code> 空间、<code>To Survivor</code> 空间等。</p>
<p>​        从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（<code>Thread Local Allocation Buffer,TLAB</code>）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。</p>
<p>​        Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutOfMemoryError</code>异常。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-9.png" alt="memory-9"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-17.png" alt="memory"></p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>​        TLAB（Thread Local Allocation Buffer）是在Hotspot1.6引入的新技术，目的是提升在堆上创建对象的性能。</p>
<p>​        如果一个对象被创建到堆上时，需要在堆上申请指定大小的内存供新创建的对象使用，在这个过程中，堆会通过加锁或指针碰撞的方式防止同一块被重复申请，在JVM中，内存分配是一个非常频繁的动作，而给堆加锁或者校验碰撞指针的方式必定会影响内存创建效率，TLAB的出现就是为了优化这个问题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">TLAB是线程的一块私有内存:</span><br><span class="line"></span><br><span class="line">1.在线程启动的时候会在堆中为其申请一块指定大小的内存，这块内存只给当前线程使用，属于线程私有的.</span><br><span class="line">如果线程需要为线程内的对象分配内存，就在自己的空间上分配，这样就不存在内存分配竞争的情况了，大大的提升了分配效率。</span><br><span class="line"></span><br><span class="line">2.当TLAB空间容量不足时，就新申请一个TLAB，原来的那个TLAB区里的对象还维持现状，因为对象只能感知到自己在Eden区。</span><br><span class="line"></span><br><span class="line">3.TLAB空间的内存非常小，默认大小仅有Eden区的1%，一般用默认的就可以。</span><br><span class="line">也可以通过JVM参数-XX:TLABWasteTargetPercent设置TLAB空间占Eden空间的百分比大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭TLAB</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">-UseTLAB</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置每个TLAB区域占Eden区的大小比例</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">TLABWasteTargetPercent</span></span><br></pre></td></tr></table></figure>

<p>​        每一个TLAB空间大小都是固定的，默认的是Eden区大小的的1%，既然大小是固定的，那么肯定会出现空间浪费的情况，比如TLAB大小是100kb，已经被使用了90kb，此时有一个12kb的对象来申请空间，但是TLAB的剩余空间已经不足以分配给这个对象了，此时怎么办？</p>
<p>​        是新申请一个TLAB，还是直接分配到Eden区？在设计TLAB的时候就已经考虑到这种情况了，<strong>使用变量refill_waste_limit来控制一个TLAB允许被浪费的空间大小</strong>。</p>
<p>​        当申请了新的TLAB后，旧的TLAB交由Eden管理。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-16.png" alt="memory"></p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-18.png" alt="memory"></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        方法区（<code>Method Area</code>）与 Java 堆一样，<strong>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。虽然<br><strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <code>Non-Heap</code>（非堆），目的应该是与 Java 堆区分开来。</p>
<p>​        Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<h4 id="HotSpot-虚拟机"><a href="#HotSpot-虚拟机" class="headerlink" title="HotSpot 虚拟机"></a><code>HotSpot</code> 虚拟机</h4><p>​        它是<code>Sun JDK</code>和<code>OpenJDK</code>中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。<br>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，Oracle同时拥有了两款优秀的Java虚拟机：<code>JRockit VM</code>和<code>HotSpot VM</code>。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-10.png" alt="memory-10"></p>
<h4 id="永久代、元空间"><a href="#永久代、元空间" class="headerlink" title="永久代、元空间"></a>永久代、元空间</h4><p>​        方法区只是 <code>JVM</code> 的一种规范，不同的虚拟机实现的原理不一样，只有JDK1.7及以下才有永久代的概念，JDK1.8称为元空间。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="class常量池"><a href="#class常量池" class="headerlink" title="class常量池"></a>class常量池</h4><p>​        我们写的每一个 Java 类被编译后，就会形成一份<code>class</code> 文件。<code>class</code> 文件中除了包含类的<strong>版本、字段、方法、接口等描述信息外，还有一项信息就是常量池</strong>(<code>constant pool table</code>)，用于存放编译器生成的各种<strong>字面量</strong>(<code>Literal</code>)和<strong>符号引用</strong>(<code>Symbolic References</code>)。</p>
<p>​        每个class文件都有一个class常量池。</p>
<p>字面量包括：</p>
<ul>
<li>文本字符串</li>
<li>八大基本类型的值</li>
<li>被申明为<code>final</code>的常量</li>
</ul>
<p>符号引用包括：</p>
<ul>
<li>类和方法的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        运行时常量池（<code>Runtime Constant Pool</code>）是方法区的一部分。<strong>class文件常量池将在类加载后进入方法区的运行时常量池中存放</strong>。</p>
<p>​        一般来说，除了保存 <code>Class</code> 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​        <strong>运行时常量池相对于 <code>Class</code> 文件常量池的另外一个重要特征是具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 <code>Class</code> 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</p>
<p>​        既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，<strong>当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常</strong>。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>​        在<code>HotSpot</code>虚拟机里实现的字符串常量池(<code>string pool</code>)功能的是一个<code>StringTable</code>类，它是一个<code>Hash</code>表，这个<code>StringTable</code>在每个<code>HotSpot</code>虚拟机的实例<strong>只有一份</strong>，被所有的类共享。字符串常量由一个一个字符组成，放在了<code>StringTable</code>上。</p>
<h4 id="JDK版本变化"><a href="#JDK版本变化" class="headerlink" title="JDK版本变化"></a>JDK版本变化</h4><p>​        <strong>JDK1.6及以前的版本，字符串常量池是存放在永久代中。</strong></p>
<p>​        <strong>在JDK1.7的版本中，字符串常量池从永久代移出到正常的Java 堆(Java Heap)中，原因是因为永久代空间太小，容易造成OOM。</strong></p>
<p>​        <strong>在JDK1.8的版本中，Hotspot虚拟机废除了永久代，开始使用元空间（Metaspace）实现方法区，字符串常量池依旧保留在堆内存中，其他内容移至元空间，元空间直接在本地内存分配，而不需要占用堆内存，所以不会造成OOM现象。</strong></p>
<p>​        <strong>值得注意的是，方法区只是Jvm的一种规范，Hotspot通过废除永久代，使用元空间实现方法区，并不存在废除方法区、方法区被元空间代替这种说法。</strong></p>
<p>​        <strong>为什么要使用元空间取代永久代的实现？</strong></p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为 <code>GC</code> 带来不必要的复杂度，并且回收效率偏低</li>
<li>将 <code>HotSpot</code> 与 <code>JRockit</code> 合二为一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"String"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        str.intern();</span><br><span class="line">        str = str + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-11.png" alt="memory-11"><br>        使用<strong>JDK1.7 或者 1.8</strong> 能够看到，往字符串常量池中无限增加，最终 <code>OOM</code> 的位置是在Java 堆（<code>Java heap</code>）中。</p>
<p>​        <strong><code>String.intern()</code>用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。</strong></p>
<p>​        看一道比较常见的面试题，在不考虑 <code>GC</code> 的情况下，下面的代码创建了多少个 <code>String</code> 对象，输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure>
<p><strong>答案：</strong></p>
<ul>
<li>在 JDK 1.6 下输出是 <strong><code>false</code></strong>，<strong>创建了 6 个对象</strong></li>
<li>在 JDK 1.7 之后的版本输出是 <strong><code>true</code></strong>，<strong>创建了 5 个对象</strong></li>
</ul>
<p><strong>代码分析：</strong></p>
<p>​        为什么输出会有这些变化呢？主要还是字符串池从永久代中脱离、移入堆区的原因， <code>intern()</code> 方法也相应发生了变化：</p>
<ul>
<li><p>在 <code>JDK 1.6</code> 中，调用 <code>intern()</code> 首先会在字符串池中寻找<code>equal()</code> 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用；假如字符串不存在，<strong>虚拟机会重新在永久代上创建一个实例</strong>，将 <code>StringTable</code> 的一个表项指向这个新创建的实例。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-12.png" alt="memory-12"></p>
</li>
<li><p>在 <code>JDK 1.7</code> 中，由于字符串池不在永久代了，<code>intern()</code> 做了一些修改，更方便地利用堆中的对象。字符串存在时和 <code>JDK 1.6</code>一样返回常量池的引用，不存在时如果堆中存在，那也不需要再拷贝字符串的实例到常量池，既然字符串常量池已经移到Java堆中，只需要在常量池里记录一下首次出现的实例引用即可。<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-13.png" alt="memory-13"></p>
</li>
</ul>
<p>我们基于JDK1.7版本，来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>由于字符串常量池中已存在<code>abc</code>，所以返回了字符串常量池中的引用，如下图所示<br><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-14.png" alt="memory-14"></p>
<p>再来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"he"</span>) + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">str1.intern();</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>​        该结果等于<code>true</code>应该是能够理解的，不理解的可以查看上文针对该代码的实例分析图</p>
<p>​        这里扩展一点，若是把<code>str1.intern();</code>代码注释掉，则产生的结果为<code>false</code>。</p>
<p>​        其原因在于<code>str1</code>对象是通过<code>new</code>对象拼接产生的，字符串常量池中并不存在字符串<code>hello</code>，当调用<code>String str2=&quot;hello&quot;;</code>代码时字符串常量池中产生才该字符串，所以他们并不是同一个地址引用。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>​        <strong>直接内存（<code>Direct Memory</code>）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</strong>。</p>
<p>​        在 <code>JDK 1.4</code> 中新加入了 <code>NIO</code>，引入了一种基于通道（<code>Channel</code>）与缓冲区（<code>Buffer</code>）的 <code>I/O</code> 方式，它可以使用 <code>Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>​        显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p>
<p><img src="http://yrlzero.gitee.io/images/jvm/jvm-memory/memory-15.png" alt="memory-15"></p>
<hr>
<blockquote>
<p>“本篇文章主要摘自《深入理解Java虚拟机_JVM高级特性与最佳实践 第2版》”</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx安装</title>
    <url>/2020/11/29/nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><img src="http://yrlzero.gitee.io/images/linux/nginx/nginx版本介绍.jpg" style="zoom: 67%;" />

<a id="more"></a>

<h3 id="1-下载安装包方式"><a href="#1-下载安装包方式" class="headerlink" title="1. 下载安装包方式"></a>1. 下载安装包方式</h3><ul>
<li><p>官网直接下载<code>http://nginx.org/en/download.html</code></p>
</li>
<li><p>使用<code>wget</code>命令下载（推荐）。确保系统已经安装了<code>wget</code>，如果没有安装，执行 <code>yum install wget</code> 安装<code>wget -c https://nginx.org/download/nginx-1.18.0.tar.gz</code></p>
</li>
</ul>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-yum安装依赖项"><a href="#3-yum安装依赖项" class="headerlink" title="3. yum安装依赖项"></a>3. yum安装依赖项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gcc安装，nginx源码编译需要；pcre-devel 安装，nginx 的 http 模块使用 pcre 来解析正则表达式；zlib安装，nginx 使用zlib对http包的内容进行gzip</span><br><span class="line"></span><br><span class="line">yum install gcc pcre-devel zlib-devel</span><br></pre></td></tr></table></figure>

<h3 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx-1.18.0</span><br><span class="line"></span><br><span class="line">#使用默认配置</span><br><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>

<h3 id="5-编译安装"><a href="#5-编译安装" class="headerlink" title="5. 编译安装"></a>5. 编译安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="6-启动、停止nginx"><a href="#6-启动、停止nginx" class="headerlink" title="6. 启动、停止nginx"></a>6. 启动、停止nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx </span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line">.&#x2F;nginx -s quit</span><br><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>nacos集群安装</title>
    <url>/2020/12/06/nacos%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载稳定版本1-3-1（July-10-2020）"><a href="#1-下载稳定版本1-3-1（July-10-2020）" class="headerlink" title="1. 下载稳定版本1.3.1（July 10, 2020）"></a>1. 下载稳定版本<a href="https://github.com/alibaba/nacos/releases/tag/1.3.1" target="_blank" rel="noopener">1.3.1（July 10, 2020）</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他版本参考：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos&#x2F;releases</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-官方文档："><a href="#2-官方文档：" class="headerlink" title="2. 官方文档："></a>2. 官方文档：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nacos.io&#x2F;zh-cn&#x2F;docs&#x2F;quick-start.html</span><br></pre></td></tr></table></figure>

<h2 id="3-sql脚本导入"><a href="#3-sql脚本导入" class="headerlink" title="3. sql脚本导入"></a>3. sql脚本导入</h2><p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6.jpg" alt=""> <img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E6%89%A7%E8%A1%8Cnaocs%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.jpg" alt=""></p>
<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建安装目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nacos</span><br><span class="line"># 上传压缩包</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf nacos-server-1.3.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="5-修改集群配置"><a href="#5-修改集群配置" class="headerlink" title="5. 修改集群配置"></a>5. 修改集群配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入配置文件</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf</span><br><span class="line"># 拷贝集群配置</span><br><span class="line">cp cluster.conf.example  cluster.conf</span><br><span class="line"># 修改配置文件</span><br><span class="line">vi cluster.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.jpg" alt=""> </p>
<h2 id="6-远程拷贝集群配置文件"><a href="#6-远程拷贝集群配置文件" class="headerlink" title="6. 远程拷贝集群配置文件"></a>6. 远程拷贝集群配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从第一台机器拷贝配置文件都其他机器</span><br><span class="line">scp root@192.168.243.131:&#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;cluster.conf &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D.jpg" alt=""></p>
<h2 id="7-修改启动配置"><a href="#7-修改启动配置" class="headerlink" title="7. 修改启动配置"></a>7. 修改启动配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取JAVA_HOME</span><br><span class="line">echo $JAVA_HOME</span><br><span class="line"></span><br><span class="line"># 修改jdk，新增jdk配置，原有的注释</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="8-修改naocs自身配置"><a href="#8-修改naocs自身配置" class="headerlink" title="8. 修改naocs自身配置"></a>8. 修改naocs自身配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nacos&#x2F;nacos&#x2F;conf&#x2F;application.properties</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/cloud/alibaba/nacos/nacos%E9%85%8D%E7%BD%AE.jpg" alt=""></p>
<h2 id="9-异常情况"><a href="#9-异常情况" class="headerlink" title="9. 异常情况"></a>9. 异常情况</h2><p>如果出现JAVA服务无法连接nacos集群的情况，可以修改nacos.inetutils.ip-address为本机ip(一般情况下不加)</p>
<h2 id="10-开放防火墙"><a href="#10-开放防火墙" class="headerlink" title="10. 开放防火墙"></a>10. 开放防火墙</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开8848端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8848&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>alibaba</tag>
        <tag>配置中心</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq系列-amqp</title>
    <url>/2020/06/03/rabbitmq%E7%B3%BB%E5%88%97-amqp/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>​         AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。</p>
<a id="more"></a>

<h2 id="二、spring-boot的应用"><a href="#二、spring-boot的应用" class="headerlink" title="二、spring boot的应用"></a><strong>二、spring boot的应用</strong></h2><h4 id="1-消息生产者"><a href="#1-消息生产者" class="headerlink" title="1.消息生产者"></a><strong>1.消息生产者</strong></h4><h5 id="1）导入maven依赖："><a href="#1）导入maven依赖：" class="headerlink" title="1）导入maven依赖："></a><strong>1）导入maven依赖：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2）配置application-yml"><a href="#2）配置application-yml" class="headerlink" title="2）配置application.yml"></a><strong>2）配置application.yml</strong></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">yrl_test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test123</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 后续消息确认使用</span></span><br></pre></td></tr></table></figure>

<h5 id="3）controller发送消息"><a href="#3）controller发送消息" class="headerlink" title="3）controller发送消息"></a><strong>3）controller发送消息</strong></h5><p>​    实际使用，应抽取rabbitTemplate注入序列化器，不应该每个方法设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange、routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsgUser</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(param.get(<span class="string">"msg"</span>));</span><br><span class="line">        user.setBirthday(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不指定exchange，根据routing key发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDefault"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDefault</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"key"</span>),msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定exchange,不指定routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendHeader"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeader</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),<span class="string">""</span>,msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"key-one"</span>, <span class="string">"1"</span>);</span><br><span class="line">            properties.setHeader(<span class="string">"key-two"</span>, <span class="string">"2"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延迟消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"sendDelay"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelay</span><span class="params">(@RequestBody Map&lt;String,String&gt; param)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">"message"</span>,param.get(<span class="string">"msg"</span>));</span><br><span class="line">        msg.put(<span class="string">"time"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>)));</span><br><span class="line">        <span class="comment">//设置消息序列化</span></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">        rabbitTemplate.convertAndSend(param.get(<span class="string">"exchange"</span>),param.get(<span class="string">"key"</span>),msg,message -&gt; &#123;</span><br><span class="line">            MessageProperties properties = message.getMessageProperties();</span><br><span class="line">            properties.setHeader(<span class="string">"x-delay"</span>, <span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-消息消费者"><a href="#2-消息消费者" class="headerlink" title="2. 消息消费者"></a><strong>2. 消息消费者</strong></h4><h5 id="1-配置"><a href="#1-配置" class="headerlink" title="1) 配置"></a><strong>1) 配置</strong></h5><h6 id="a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"><a href="#a-第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定"></a>a. 第一种方式，通过实体配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> *   durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line"><span class="comment"> *   exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line"><span class="comment"> *   autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line"><span class="comment"> *   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">testDirectQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"testDirectQueue"</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建直连交换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">testDirectExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"testDirectExchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将exchange和queue进行绑定，并设置匹配的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(testDirectQueue()).to(testDirectExchange()).with(<span class="string">"testDirectRouting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建监听器容器工厂，设置连接工厂、序列化方式（解决实体序列化问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">	factory.setConnectionFactory(connectionFactory);</span><br><span class="line">	factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">	<span class="comment">//开启手动Ack（后续使用配置消息确认使用）</span></span><br><span class="line">	<span class="comment">//factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span></span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	args.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">"delayExchangeCus"</span>, <span class="string">"x-delayed-message"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">"delayCusQueue"</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">queueBinding</span><span class="params">(Queue delayQueue, CustomExchange delayExchange)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(delayQueue).to(delayExchange).with(<span class="string">"cusDelayKey"</span>).noargs();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"><a href="#b-第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定" class="headerlink" title="b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定"></a>b. 第二种方式，通过注解配置，进行消费者与queue、exchange之间的绑定</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,routingKey为queue的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(<span class="string">"myDefaultQueue"</span>))</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultDirectReceiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"默认交换器，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.2"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直连交换器3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 消息内容,当只有一个参数的时候可以不加<span class="doctag">@Payload</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"testDirectQueue3"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"myExchange"</span>,type = ExchangeTypes.DIRECT),</span><br><span class="line">					key = <span class="string">"myDirectRouting.3"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct3Receiver</span><span class="params">(User param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"直连交换器3，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.1"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题交换器2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"topicQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"topicExchange"</span>,type = ExchangeTypes.TOPIC),</span><br><span class="line">					key = <span class="string">"topicRouting.*"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"主题交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器1</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout1Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器1，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扇形交换器2</span></span><br><span class="line"><span class="comment"> *  key不起作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"fanoutQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanoutExchange"</span>,type = ExchangeTypes.FANOUT),</span><br><span class="line">					key = <span class="string">"fanoutRouting"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanout2Receiver</span><span class="params">(Map param)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"扇形交换器2，消费者接收到消息："</span> + param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，任意匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue1"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"any"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">								 <span class="meta">@Argument</span>(name = <span class="string">"key-three"</span>,value = <span class="string">"3"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，任意匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * headers交换器，全匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(<span class="string">"headerQueue2"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(value = <span class="string">"headerExchange"</span>,type = ExchangeTypes.HEADERS),</span><br><span class="line">					arguments = &#123;<span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>,value = <span class="string">"all"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-one"</span>,value = <span class="string">"1"</span>),</span><br><span class="line">							<span class="meta">@Argument</span>(name = <span class="string">"key-two"</span>,value = <span class="string">"2"</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allMatchReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"header交换器，全匹配消费者接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"delayCusQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayReceiver</span><span class="params">(@Payload Map param, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">		bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">				exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">				value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">				key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">		)</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">	Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">	System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-开启手动应答模式"><a href="#2-开启手动应答模式" class="headerlink" title="2) 开启手动应答模式"></a><strong>2) 开启手动应答模式</strong></h5><h6 id="a-添加application-yml配置"><a href="#a-添加application-yml配置" class="headerlink" title="a. 添加application.yml配置"></a>a. 添加application.yml配置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="b-连接工厂设置参数"><a href="#b-连接工厂设置参数" class="headerlink" title="b. 连接工厂设置参数"></a>b. 连接工厂设置参数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启手动Ack</span></span><br><span class="line"><span class="keyword">new</span> SimpleRabbitListenerContainerFactory().setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br></pre></td></tr></table></figure>

<h6 id="c-监听器"><a href="#c-监听器" class="headerlink" title="c. 监听器"></a>c. 监听器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">           bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                   exchange = <span class="meta">@Exchange</span>(value = <span class="string">"delayExchangeCus2"</span>,delayed = <span class="string">"true"</span> ,type = ExchangeTypes.DIRECT,arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-delayed-type"</span>,value=<span class="string">"direct"</span>)),</span><br><span class="line">                   value = <span class="meta">@Queue</span>(value = <span class="string">"delayCusQueue2"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">                   key = <span class="string">"cusDelayKey2"</span></span><br><span class="line">           )</span><br><span class="line">   )</span><br><span class="line">   <span class="meta">@RabbitHandler</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay2Receiver</span><span class="params">(@Payload Map param, Channel channel, @Headers Map headers)</span></span>&#123;</span><br><span class="line">       Long amqpDeliveryTag = (Long) headers.get(<span class="string">"amqp_deliveryTag"</span>);</span><br><span class="line">       System.out.println(<span class="string">"延迟消息交换器2，"</span>+ LocalDateTime.now()+<span class="string">"接收到消息："</span> + param + <span class="string">",头部信息:"</span> + headers);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String message = (String) param.get(<span class="string">"message"</span>);</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">"延迟消息1"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息1拒绝"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"延迟消息2"</span>.equals(message))&#123;</span><br><span class="line">               channel.basicReject(amqpDeliveryTag,<span class="keyword">true</span>);</span><br><span class="line">               System.out.println(<span class="string">"延迟消息2拒绝,重新放入队列"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               channel.basicAck(amqpDeliveryTag,<span class="keyword">false</span>);</span><br><span class="line">               System.out.println(<span class="string">"正常提交"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>rabbitmq系列-基础篇</title>
    <url>/2020/06/02/rabbitmq%E7%B3%BB%E5%88%97-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现</p>
<a id="more"></a>

<h4 id="exchange"><a href="#exchange" class="headerlink" title="exchange:"></a>exchange:</h4><p>​        生产者将消息发送到 Exchange（交换器），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。Exchange 并不存储消息。RabbitMQ 中的 Exchange 有 direct、fanout、topic、headers 四种类型，每种类型对应不同的路由规则。</p>
<h4 id="queue："><a href="#queue：" class="headerlink" title="queue："></a>queue：</h4><p>​        队列是 RabbitMQ 的内部对象，用于存储消息。消息消费者就是通过订阅队列<br>来获取消息的，RabbitMQ 中的消息都只能存储在 Queue 中，生产者生产消息并最终投递到Queue 中，消费者可以从 Queue 中获取消息并消费。多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<h4 id="connection："><a href="#connection：" class="headerlink" title="connection："></a>connection：</h4><p>connection就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。程序的起始处就是建立这个TCP连接。</p>
<h4 id="channels："><a href="#channels：" class="headerlink" title="channels："></a>channels：</h4><p>​        虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p>
<p>那么，为什么使用Channel，而不是直接使用TCP连接？<br>    对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive。</p>
<h4 id="VirtualHost："><a href="#VirtualHost：" class="headerlink" title="VirtualHost："></a>VirtualHost：</h4><p>​        权限控制的基本单位，一个 VirtualHost 里面有若干 Exchange 和MessageQueue，以及指定被哪些 user 使用</p>
<h4 id="routing-key："><a href="#routing-key：" class="headerlink" title="routing key："></a>routing key：</h4><p>​        生产者在将消息发送给exchange的时候，一般会指定一个routing key，来匹配这个消息的路由规则。其实是匹配exchnage与queue绑定的bbinding key</p>
<h4 id="binding-key-："><a href="#binding-key-：" class="headerlink" title="binding key ："></a>binding key ：</h4><p>​        用于绑定exchange与queue之间的关系</p>
<h2 id="二、windows安装"><a href="#二、windows安装" class="headerlink" title="二、windows安装"></a><strong>二、windows安装</strong></h2><p>1）下载安装erlang</p>
<p>2）下载安装rabbitmq</p>
<p>3）安装管理界面（插件）</p>
<p>进入rabbitmq安装目录sbin中，调起cmd界面输入：rabbitmq-plugins enable rabbitmq_management</p>
<p>4）重启rabbitmq服务</p>
<p>5）访问地址127.0.0.1:15672，默认账号密码都为guest</p>
<h2 id="三、docker启动"><a href="#三、docker启动" class="headerlink" title="三、docker启动"></a>三、docker启动</h2><p>1)     搜索镜像：docker search rabbitmq</p>
<p>2)    下载镜像：docker pull rabbitmq:management</p>
<p>3)    创建容器，rabbitmq 需要有映射以下端口: 5671 5672 4369 15671 15672<br>25672</p>
<ul>
<li>15672  management管理端监听端口</li>
<li>5672、5671 AMQP使用端口</li>
<li>4369 epmd代表erlang守护进程的端口</li>
<li>25672 (Erlang distribution)</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -di --name=my_rabbitmq -p 5671:5617 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span></span><br></pre></td></tr></table></figure>

<h2 id="四、exchange-type"><a href="#四、exchange-type" class="headerlink" title="四、exchange type"></a><strong>四、exchange type</strong></h2><h4 id="1）直连模式-direct："><a href="#1）直连模式-direct：" class="headerlink" title="1）直连模式-direct："></a>1）直连模式-direct：</h4><p>​        direct类型的exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的queue中 。</p>
<p>​        默认交换器（名称为空字符串的直连交换机）,一个queue若不指定binding的交换机,就被绑定到默认交换机上,binding key为queue的名称。</p>
<img src="http://yrlzero.gitee.io/images/直连模式.jpg" style="zoom:67%;" />

<h4 id="2）主题模式-topic"><a href="#2）主题模式-topic" class="headerlink" title="2）主题模式-topic"></a>2）主题模式-topic</h4><p> topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同， 可以根据某些规则进行匹配，如果 exchange 没有发现能够与 routing Key 匹配的 queue，则会抛弃此消息</p>
<img src="http://yrlzero.gitee.io/images/主题模式.jpg" style="zoom:67%;" />

<p>符号 # 匹配一个或多个词，符号 * 匹配一个词</p>
<h4 id="3）分裂模式-fanout"><a href="#3）分裂模式-fanout" class="headerlink" title="3）分裂模式-fanout"></a><strong>3）分裂模式-fanout</strong></h4><p> fanout类型的exchange路由规则非常简单，它会把所有发送到该exchange的消息路由到所有与它绑定的queue中 </p>
<img src="http://yrlzero.gitee.io/images/分裂模式.jpg" style="zoom:67%;" />



<h4 id="4）头部模式-headers"><a href="#4）头部模式-headers" class="headerlink" title="4）头部模式-headers"></a><strong>4）头部模式-headers</strong></h4><p>​         headers类型的exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定queue与exchange时指定一组键值对；当消息发送到exchange时，rabbitMq会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配queue与exchange绑定时指定的键值对；如果完全匹配则消息会路由到该queue，否则不会路由到该queue </p>
<h4 id="5）延迟消息（特殊模式需要安装插件）"><a href="#5）延迟消息（特殊模式需要安装插件）" class="headerlink" title="5）延迟消息（特殊模式需要安装插件）"></a><strong>5）延迟消息（特殊模式需要安装插件）</strong></h4><p>​         需要在这个页面：<a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">http://www.rabbitmq.com/community-plugins.html</a> 中找到<code>rabbitmq_delayed_message_exchange</code>插件，根据您使用的RabbitMQ版本选择对应的插件版本下载即可 。 在下载好之后，解压得到<code>.ez</code>结尾的插件包，将其复制到RabbitMQ安装目录下的<code>plugins</code>文件夹 。</p>
<pre><code>然后通过命令行启用该插件： </code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mq</category>
      </categories>
  </entry>
  <entry>
    <title>redis安装</title>
    <url>/2020/12/12/redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="一、下载地址"><a href="#一、下载地址" class="headerlink" title="一、下载地址"></a>一、<a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></h3><p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%B8%8B%E8%BD%BD.jpg" alt=""></p>
<a id="more"></a>

<h3 id="二、安装gcc依赖"><a href="#二、安装gcc依赖" class="headerlink" title="二、安装gcc依赖"></a>二、安装gcc依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看gcc版本是否在9.3以上，centos7.6默认安装4.8.5</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/linux/redis/%E6%9F%A5%E7%9C%8Bgcc%E7%89%88%E6%9C%AC.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis6以上,gcc版本不能低于5,升级gcc到9.3及以上,如下：</span><br><span class="line">升级到gcc 9.3：</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。</span><br><span class="line">如果要长期使用gcc 9.3的话：</span><br><span class="line"></span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">这样退出shell重新打开就是新版的gcc了</span><br><span class="line">以下其他版本同理，修改devtoolset版本号即可。</span><br></pre></td></tr></table></figure>

<h3 id="三、上传安装"><a href="#三、上传安装" class="headerlink" title="三、上传安装"></a>三、上传安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#上传安装包、解压、编译</span><br><span class="line">tar zxf redis-6.0.9.tar.gz </span><br><span class="line">cd redis-6.0.9</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">#安装并指定安装目录</span><br><span class="line">make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>

<h3 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h3><h4 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>

<h4 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h4><h5 id="1-从-redis-的源码目录中复制-redis-conf-到-redis-的安装目录"><a href="#1-从-redis-的源码目录中复制-redis-conf-到-redis-的安装目录" class="headerlink" title="1.从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录"></a>1.从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis-6.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="2-修改-redis-conf-文件，把-daemonize-no-改为-daemonize-yes"><a href="#2-修改-redis-conf-文件，把-daemonize-no-改为-daemonize-yes" class="headerlink" title="2.修改 redis.conf 文件，把 daemonize no 改为 daemonize yes"></a>2.修改 redis.conf 文件，把 daemonize no 改为 daemonize yes</h5><p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%AE%88%E6%8A%A4%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h5 id="3-注释掉-bind-127-0-0-1，并修改-protected-mode-yes-改为-protected-mode-no"><a href="#3-注释掉-bind-127-0-0-1，并修改-protected-mode-yes-改为-protected-mode-no" class="headerlink" title="3.注释掉 # bind 127.0.0.1，并修改 protected-mode yes 改为 protected-mode no"></a>3.注释掉 # bind 127.0.0.1，并修改 protected-mode yes 改为 protected-mode no</h5><p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt=""></p>
<h5 id="4-设置密码"><a href="#4-设置密码" class="headerlink" title="4.设置密码"></a>4.设置密码</h5><p><img src="http://yrlzero.gitee.io/images/linux/redis/%E4%BF%AE%E6%94%B9conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.jpg" alt=""></p>
<h5 id="5-启动命令"><a href="#5-启动命令" class="headerlink" title="5.启动命令"></a>5.启动命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">.&#x2F;redis-server redis.conf</span><br><span class="line"># 停止</span><br><span class="line">.&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure>

<h3 id="五、开放防火墙"><a href="#五、开放防火墙" class="headerlink" title="五、开放防火墙"></a>五、开放防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 防火墙中打开6379端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent</span><br><span class="line"></span><br><span class="line">–zone：作用域</span><br><span class="line">–add-port&#x3D;6379&#x2F;tcp：添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">–permanent：永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"># 停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"># 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"># 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h3 id="六、远端登录"><a href="#六、远端登录" class="headerlink" title="六、远端登录"></a>六、远端登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.243.131 -p 6379 -a passsword</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>restTemplate常见操作</title>
    <url>/2020/11/29/restTemplate%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>常见的restTemplate操作</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种方式 xxForObject、xxForEntity、exchange</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装请求头</span></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);<span class="comment">//封装请求类型</span></span><br><span class="line">headers.add(<span class="string">"Accept"</span>, MediaType.APPLICATION_JSON.toString());<span class="comment">//封装可接收类型,"Accept", MediaType.APPLICATION_JSON_VALUE</span></span><br><span class="line"><span class="comment">//封装请求参数</span></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String jsonStr = objectMapper.writeValueAsString(map); </span><br><span class="line"><span class="comment">//封装请求实体（请求参数、请求头）</span></span><br><span class="line">HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(jsonStr, headers);</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">Map result = restTemplate.postForObject(expressUrl, entity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送携带query参数的uri，使用此api进行编码生成uri</span></span><br><span class="line">UriComponentsBuilder builder = UriComponentsBuilder</span><br><span class="line">                .fromUriString(getUsersUrl)</span><br><span class="line">                .queryParam(<span class="string">"nameOrEmail"</span>, nameOrEmail);</span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(builder.build().encode().toUri(), HttpMethod.PUT, <span class="keyword">new</span> HttpEntity&lt;&gt;(headers), String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送文件</span></span><br><span class="line">httpHeaders.setAccept(Arrays.asList(MediaType.MULTIPART_FORM_DATA));</span><br><span class="line">httpHeaders.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line"><span class="comment">//设置请求体，注意是LinkedMultiValueMap</span></span><br><span class="line">FileSystemResource fileSystemResource = <span class="keyword">new</span> FileSystemResource(filePath+<span class="string">"/"</span>+fileName);<span class="comment">//获取文件资源</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; form = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();<span class="comment">//一个key可以存多个value</span></span><br><span class="line">form.add(<span class="string">"file"</span>, fileSystemResource);<span class="comment">//封装资源文件 </span></span><br><span class="line">form.add(<span class="string">"filename"</span>,fileName);<span class="comment">//封装文件名称</span></span><br><span class="line"><span class="comment">//用HttpEntity封装整个请求报文</span></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = <span class="keyword">new</span> HttpEntity&lt;&gt;(form, headers);</span><br><span class="line">String s = restTemplate.postForObject(url, files, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>https请求报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.web.client.ResourceAccessException: I/O error on GET request <span class="keyword">for</span> <span class="string">"https://ecs.gac.com.cn:3351/ecs-console/api/bill/searchBillCount"</span>: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; nested exception is javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">    </span><br><span class="line">cn.kjjk.kjpayservice.KjPayServiceApplicationTests.main(KjPayServiceApplicationTests.java:<span class="number">58</span>)</span><br><span class="line">Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	</span><br><span class="line">Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure>

<p>处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate  = <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> HttpsClientRequestFactory());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsClientRequestFactory</span> <span class="keyword">extends</span> <span class="title">SimpleClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareConnection</span><span class="params">(HttpURLConnection connection, String httpMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(connection <span class="keyword">instanceof</span> HttpsURLConnection)) &#123;<span class="comment">// http协议</span></span><br><span class="line">                <span class="comment">//throw new RuntimeException("An instance of HttpsURLConnection is expected");</span></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(connection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;<span class="comment">// https协议，修改协议版本</span></span><br><span class="line">                SSLContext ctx = SSLContext.getInstance(<span class="string">"TLSv1.2"</span>);</span><br><span class="line">                X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line">                org.apache.http.conn.ssl.SSLSocketFactory ssf = <span class="keyword">new</span> org.apache.http.conn.ssl.SSLSocketFactory(ctx, org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line">                ((HttpsURLConnection) connection).setSSLSocketFactory(ctx.getSocketFactory());</span><br><span class="line">                HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">super</span>.prepareConnection(httpsConnection, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>spring security oauth2搭建</title>
    <url>/2020/11/29/spring%20security%20oauth2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>OAuth2是一套开放标准，Spring Cloud Security Oauth2是对它的一种实现。</p>
<a id="more"></a>

<h3 id="1-1-角色定义"><a href="#1-1-角色定义" class="headerlink" title="1.1 角色定义"></a>1.1 角色定义</h3><h4 id="1-1-1-客户端"><a href="#1-1-1-客户端" class="headerlink" title="1.1.1 客户端"></a>1.1.1 客户端</h4><p>​        本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，如：移动端、pc端等。</p>
<h4 id="1-1-2-资源拥有者"><a href="#1-1-2-资源拥有者" class="headerlink" title="1.1.2 资源拥有者"></a>1.1.2 资源拥有者</h4><p>​        通常为用户、也可为应用程序，即资源的拥有者。</p>
<h4 id="1-1-3-资源服务器"><a href="#1-1-3-资源服务器" class="headerlink" title="1.1.3  资源服务器"></a>1.1.3  资源服务器</h4><p>​        存储资源的服务器，一般为提供业务接口服务的程序。</p>
<h4 id="1-1-4-授权服务器"><a href="#1-1-4-授权服务器" class="headerlink" title="1.1.4 授权服务器"></a>1.1.4 授权服务器</h4><p>​        用于对资源拥有者的身份进行认证、对访问资源进行授权，认证成功发放令牌（access_token）给客户端，作为客户端访问资源服务器的凭证；授权服务器就是对客户端和资源拥有着进行认证授权，使其可以访问资源服务器获取资源。</p>
<h3 id="1-2-四种模式"><a href="#1-2-四种模式" class="headerlink" title="1.2 四种模式"></a>1.2 四种模式</h3><h4 id="1-2-1-授权码模式"><a href="#1-2-1-授权码模式" class="headerlink" title="1.2.1 授权码模式"></a>1.2.1 授权码模式</h4><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式，code保证了token的安全性，即使code被拦截，由于没有app_secret，也是无法通过code获得token的。</p>
<h4 id="1-2-2-隐式授权模式-简化模式"><a href="#1-2-2-隐式授权模式-简化模式" class="headerlink" title="1.2.2 隐式授权模式/简化模式"></a>1.2.2 隐式授权模式/简化模式</h4><p>和授权码模式类似，少了获取code的步骤，是直接获取令牌token的，适用于公开的浏览器单页应用，令牌直接从授权服务器返回，不支持刷新令牌，且没有code安全保证，令牌容易因为被拦截窃听而泄露。</p>
<h4 id="1-2-3-密码模式"><a href="#1-2-3-密码模式" class="headerlink" title="1.2.3 密码模式"></a>1.2.3 密码模式</h4><p>使用用户名/密码作为授权方式从授权服务器上获取令牌，一般不支持刷新令牌。</p>
<h4 id="1-2-4-客户端凭证模式"><a href="#1-2-4-客户端凭证模式" class="headerlink" title="1.2.4 客户端凭证模式"></a>1.2.4 客户端凭证模式</h4><p>一般用于资源服务器是应用的一个后端模块，客户端向认证服务器验证身份来获取令牌。</p>
<h2 id="二、授权服务搭建"><a href="#二、授权服务搭建" class="headerlink" title="二、授权服务搭建"></a>二、授权服务搭建</h2><h3 id="2-1-maven依赖"><a href="#2-1-maven依赖" class="headerlink" title="2.1 maven依赖"></a>2.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-配置类"><a href="#2-2-配置类" class="headerlink" title="2.2 配置类"></a>2.2 配置类</h3><h4 id="2-2-1-鉴权服务配置"><a href="#2-2-1-鉴权服务配置" class="headerlink" title="2.2.1 鉴权服务配置"></a>2.2.1 鉴权服务配置</h4><p>配置类添加@EnableAuthorizationServer，继承org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter类</p>
<p>需重写以下三个方法</p>
<h5 id="2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-："><a href="#2-2-1-1-configure-ClientDetailsServiceConfigurer-clients-：" class="headerlink" title="2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ："></a>2.2.1.1 configure(ClientDetailsServiceConfigurer clients) ：</h5><p>客户端详情信息服务配置，能够使用内存、jdbc方式来实现clientDetailsService（客户端详情服务），负责查找clientDetails。clientDetails能够在应用程序运行时进行更新，通过访问存储服务（如jdbcClientDetailsService）或自己实现ClientRegistrationService接口进行管理</p>
<p>关于clientDetails的几个属性如下：</p>
<ul>
<li>clientId:用来表示客户的id</li>
<li>secret：用来限制客户端的访问访问，如果为空（默认为空）的话，客户端拥有全部的访问范围</li>
<li>authorizedGrantType：客户端可以使用的授权类型，默认为空（client_credentials,password,authorization_code,implicit,refresh_token）</li>
<li>authorities：客户端可以使用的权限</li>
</ul>
<h5 id="2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-："><a href="#2-2-1-2-configure-AuthorizationServerEndpointsConfigurer-endpoints-：" class="headerlink" title="2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)："></a>2.2.1.2 configure(AuthorizationServerEndpointsConfigurer endpoints)：</h5><p>令牌访问端点，用来配置令牌的访问端点和令牌服务</p>
<h5 id="2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-："><a href="#2-2-1-3-configure-AuthorizationServerSecurityConfigurer-security-：" class="headerlink" title="2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)："></a>2.2.1.3 configure(AuthorizationServerSecurityConfigurer security)：</h5><p>令牌访问端点安全策略，用来配置令牌端点的安全约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfiguration</span>  <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizationCodeServices authorizationCodeServices;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.客户端详情信息服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂时使用内存方式</span></span><br><span class="line"><span class="comment">/*        clients.inMemory()</span></span><br><span class="line"><span class="comment">                //client_id</span></span><br><span class="line"><span class="comment">                .withClient("c1")</span></span><br><span class="line"><span class="comment">                //客户端秘钥</span></span><br><span class="line"><span class="comment">                .secret(passwordEncoder.encode("secret"))</span></span><br><span class="line"><span class="comment">                //可访问资源列表</span></span><br><span class="line"><span class="comment">                .resourceIds("r1")</span></span><br><span class="line"><span class="comment">                //允许该client授权的类型</span></span><br><span class="line"><span class="comment">                .authorizedGrantTypes("authorization_code","password","client_credentials","implicit","refresh_token")</span></span><br><span class="line"><span class="comment">                //允许授权范围</span></span><br><span class="line"><span class="comment">                .scopes("all")</span></span><br><span class="line"><span class="comment">                //如果使用授权码模式，false跳转到授权页面让用户进行授权，true直接发放令牌</span></span><br><span class="line"><span class="comment">                .autoApprove(false)</span></span><br><span class="line"><span class="comment">                //验证回调地址</span></span><br><span class="line"><span class="comment">                .redirectUris("http://baidu.com");*/</span></span><br><span class="line">        <span class="comment">//使用数据库方式</span></span><br><span class="line">        clients.withClientDetails(clientDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.1令牌管理服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices defaultTokenServices = <span class="keyword">new</span> DefaultTokenServices();</span><br><span class="line">        <span class="comment">//客户端信息服务</span></span><br><span class="line">        defaultTokenServices.setClientDetailsService(clientDetailsService);</span><br><span class="line">        <span class="comment">//是否产生刷新令牌</span></span><br><span class="line">        defaultTokenServices.setSupportRefreshToken(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//令牌存储策略</span></span><br><span class="line">        defaultTokenServices.setTokenStore(tokenStore);</span><br><span class="line">        <span class="comment">//令牌增强</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        defaultTokenServices.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">        <span class="comment">//令牌默认有效时间2小时</span></span><br><span class="line">        defaultTokenServices.setAccessTokenValiditySeconds(<span class="number">7200</span>);</span><br><span class="line">        <span class="comment">//刷新令牌默认有效时间</span></span><br><span class="line">        defaultTokenServices.setRefreshTokenValiditySeconds(<span class="number">259200</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultTokenServices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.2令牌访问端点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                <span class="comment">//密码模式需要(此处注入的管理类为security所配置)</span></span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                <span class="comment">//授权码模式需要</span></span><br><span class="line">                .authorizationCodeServices(authorizationCodeServices)</span><br><span class="line">                <span class="comment">//令牌管理服务</span></span><br><span class="line">                .tokenServices(tokenService())</span><br><span class="line">            	<span class="comment">//注入自己重写的userDetailsService进行自定义用户信息查询</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                <span class="comment">//允许post提交访问服务</span></span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.令牌访问端点安全策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> </span>&#123;</span><br><span class="line">        security</span><br><span class="line">                <span class="comment">//提供公有秘钥端点，用于jwt令牌 公开/oauth/token_key</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">// /oauth/check_token端点公开</span></span><br><span class="line">                .checkTokenAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">//允许表单认证</span></span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置授权码模式的授权码存储，暂时使用内存方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*    @Bean</span></span><br><span class="line"><span class="comment">    public AuthorizationCodeServices authorizationCodeServices()&#123;</span></span><br><span class="line"><span class="comment">        //设置授权码模式，暂时使用内存方式</span></span><br><span class="line"><span class="comment">        return new InMemoryAuthorizationCodeServices();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置授权码模式，暂时使用数据库方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDetailsService <span class="title">clientDetailsService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        JdbcClientDetailsService clientDetailsService = <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">        clientDetailsService.setPasswordEncoder(passwordEncoder);</span><br><span class="line">        <span class="keyword">return</span> clientDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-令牌存储策略配置"><a href="#2-2-2-令牌存储策略配置" class="headerlink" title="2.2.2 令牌存储策略配置"></a>2.2.2 令牌存储策略配置</h4><p>这里编写了三种令牌生成后的存储方式，根据自己的需求进行修改，后面的配置以jwt策略为准，在AuthorizationServerConfiguration类中的tokenService()进行令牌注入配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 令牌存储策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储时使用</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/*@Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore()&#123;</span></span><br><span class="line"><span class="comment">        //内存方式生成普通令牌</span></span><br><span class="line"><span class="comment">        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String SIGNING_KEY = <span class="string">"uaa123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jwt存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">accessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">//对称秘钥，资源服务器使用此秘钥来校验</span></span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis存储策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">        RedisTokenStore tokenStore = new RedisTokenStore(redisConnectionFactory);</span></span><br><span class="line"><span class="comment">        //配置redis存储的key前缀</span></span><br><span class="line"><span class="comment">        tokenStore.setPrefix("myOauth2:");</span></span><br><span class="line"><span class="comment">        return tokenStore;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-security配置"><a href="#2-2-3-security配置" class="headerlink" title="2.2.3 security配置"></a>2.2.3 security配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">                .and().csrf().disable()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(web);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">       <span class="comment">/* BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();</span></span><br><span class="line"><span class="comment">        auth.inMemoryAuthentication().withUser("111").password(bCryptPasswordEncoder.encode("222")).authorities("user")</span></span><br><span class="line"><span class="comment">                .and().withUser("admin").password(bCryptPasswordEncoder.encode("admin")).authorities("admin");*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * oauth2 的密码模式需要在令牌访问端点注入此配置，管理security操作的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不使用加密方式的编码器，字符串比较</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="comment">//使用加密密码编码器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-四种模式的认证请求"><a href="#2-2-4-四种模式的认证请求" class="headerlink" title="2.2.4 四种模式的认证请求"></a>2.2.4 四种模式的认证请求</h4><h5 id="2-2-4-1-授权码模式（较安全模式）："><a href="#2-2-4-1-授权码模式（较安全模式）：" class="headerlink" title="2.2.4.1 授权码模式（较安全模式）："></a>2.2.4.1 授权码模式（较安全模式）：</h5><ul>
<li><p>申请授权码-GET：</p>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="http://yrlzero.gitee.io/images/oauth2/用户登录授权.jpg" alt="授权码模式 用户登录授权" style="zoom: 50%;" />



</li>
</ul>
<p>客户端进行授权请求（此处授权的客户端信息为oauth2表格维护的客户端信息），用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，通过回调url返回code（授权码）<a href="https://www.baidu.com/?code=m4aOtl" target="_blank" rel="noopener">https://www.baidu.com/?code=m4aOtl</a></p>
<ul>
<li><p>申请token-POST:</p>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com&amp;code=m4aOtl</a></p>
</li>
</ul>
<p>根据授权码和客户端secret等信息获取token(此处的token使用的是jwt)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2MjY0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiMDQ1N2ZiNTgtMmY0Ny00NGJmLTk0NzMtMTRiNWU2ZmI4M2ZmIiwiY2xpZW50X2lkIjoiYzEifQ.EjYisjGOtqrTJQc7nqWBtaStphF1PxTe07_pC0oireM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiIwNDU3ZmI1OC0yZjQ3LTQ0YmYtOTQ3My0xNGI1ZTZmYjgzZmYiLCJleHAiOjE2MDY4Nzg0NTcsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNGQ4NjMxM2YtYjI3Zi00NTZiLWJlYzItMjc1NDY2N2UwMjIwIiwiY2xpZW50X2lkIjoiYzEifQ.1qItJNh8cGEiTEGJY1b2gBeeGq904lx8sZB7GaRMPmk"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"0457fb58-2f47-44bf-9473-14b5e6fb83ff"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-2-隐式授权模式-简化模式"><a href="#2-2-4-2-隐式授权模式-简化模式" class="headerlink" title="2.2.4.2 隐式授权模式/简化模式"></a>2.2.4.2 隐式授权模式/简化模式</h5><ul>
<li>申请token-GET：</li>
</ul>
<p><a href="http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:9305/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=ROLE_API&amp;redirect_uri=http://www.baidu.com</a></p>
<img src="http://yrlzero.gitee.io/images/oauth2/用户登录授权.jpg" style="zoom:50%;" />

<p>此模式不需要获取授权码，用户登录后进行登录（此处登录使用的是userDetailService查回的信息，即security管理的用户）后进行授权，回调url返回token</p>
<p><a href="https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906" target="_blank" rel="noopener">https://www.baidu.com/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjc3NzUsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNjhiOTkyMjYtNTI3NC00MmI5LTk1MTMtNzA5NzE2OWE2OTA2IiwiY2xpZW50X2lkIjoiYzEifQ.3jVUpS6o_zmRRF0eHjjCRHHwYncbaaZg4zIBt-0Jz_s&amp;token_type=bearer&amp;expires_in=7199&amp;jti=68b99226-5274-42b9-9513-7097169a6906</a></p>
<h5 id="2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险"><a href="#2-2-4-3-密码模式-一般用于自有开发的客户端使用，否则有密码泄露风险" class="headerlink" title="2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)"></a>2.2.4.3 密码模式(一般用于自有开发的客户端使用，否则有密码泄露风险)</h5><ul>
<li>申请token-POST:</li>
</ul>
<p><a href="http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret" target="_blank" rel="noopener">http://localhost:9300/auth/oauth/token?username=zhangsan&amp;password=123&amp;grant_type=password&amp;scope=ROLE_API&amp;client_id=c1&amp;client_secret=secret</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJleHAiOjE2MDY2Mjg0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNDRjZjNlN2QtNjIwYi00M2FhLThjMWItMGZkMWVkZjE3YTMwIiwiY2xpZW50X2lkIjoiYzEifQ.N_Wd2DKyEpzGBmnvnDrP-vx4lSzIjiInQRNTsJtxMkM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FQSSJdLCJhdGkiOiI0NGNmM2U3ZC02MjBiLTQzYWEtOGMxYi0wZmQxZWRmMTdhMzAiLCJleHAiOjE2MDY4ODA0MjYsImF1dGhvcml0aWVzIjpbInAxIiwicDMiXSwianRpIjoiNmJiOWQ5YTAtYzhiYi00ZDk4LTgwMGYtMzY1NGY5ZjU1MDgxIiwiY2xpZW50X2lkIjoiYzEifQ.AL2ODdEhSKwuzrkYCvikY6UBrljFBroPtFiI9UT5xs4"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"44cf3e7d-620b-43aa-8c1b-0fd1edf17a30"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token"><a href="#2-2-4-4-客户端模式-这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token" class="headerlink" title="2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)"></a>2.2.4.4 客户端模式(这种方式最简便也最不安全，需要对客户端完全信任，用于合作系统的对接，没有刷新token)</h5><ul>
<li>申请token-POST</li>
</ul>
<p><a href="http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials" target="_blank" rel="noopener">http://localhost:9305/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicjEiXSwic2NvcGUiOlsiUk9MRV9BRE1JTiIsIlJPTEVfVVNFUiIsIlJPTEVfQVBJIl0sImV4cCI6MTYwNjYyODU2MSwianRpIjoiZDBmODBjNTEtMWU5Ny00ODA5LThjNmEtYmEzYjYzNTZhMGE5IiwiY2xpZW50X2lkIjoiYzEifQ.I7KIvzQLYqlkzMQqw2hOPZ-ev8cV4ehoDU9LsP4qAAM"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">7199</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"ROLE_ADMIN ROLE_USER ROLE_API"</span>,</span><br><span class="line">    <span class="attr">"jti"</span>: <span class="string">"d0f80c51-1e97-4809-8c6a-ba3b6356a0a9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"><a href="#三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）" class="headerlink" title="三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）"></a>三、资源服务（学习过渡，之后的资源服务不这么配置，参考目录五）</h2><h3 id="3-1-maven依赖（同鉴权服务）"><a href="#3-1-maven依赖（同鉴权服务）" class="headerlink" title="3.1 maven依赖（同鉴权服务）"></a>3.1 maven依赖（同鉴权服务）</h3><h3 id="3-2-配置类"><a href="#3-2-配置类" class="headerlink" title="3.2 配置类"></a>3.2 配置类</h3><h4 id="3-2-1-资源服务配置"><a href="#3-2-1-资源服务配置" class="headerlink" title="3.2.1 资源服务配置"></a>3.2.1 资源服务配置</h4><p>对于token的校验可以请求远程auth服务，也可以使用其他tokenStore进行自我校验，本次使用jwt方式进行自我校验，不请求远程资源服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源服务配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//符合对应的scope才能访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不用记录session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//资源id</span></span><br><span class="line">        resources.resourceId(RESOURCE_ID)</span><br><span class="line">                <span class="comment">//验证令牌服务(远程校验)</span></span><br><span class="line"><span class="comment">//                .tokenServices(tokenService())</span></span><br><span class="line">                <span class="comment">//本服务自身校验jwt令牌</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .stateless(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//权限不足处理类</span></span><br><span class="line">                .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程请求校验令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResourceServerTokenServices <span class="title">tokenService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="string">"http://localhost:9305/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="string">"c1"</span>);</span><br><span class="line">        services.setClientSecret(<span class="string">"secret"</span>);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-令牌存储策略（同鉴权服务2-2-2）"><a href="#3-2-2-令牌存储策略（同鉴权服务2-2-2）" class="headerlink" title="3.2.2 令牌存储策略（同鉴权服务2.2.2）"></a>3.2.2 令牌存储策略（同鉴权服务2.2.2）</h4><h4 id="3-2-3-security配置"><a href="#3-2-3-security配置" class="headerlink" title="3.2.3 security配置"></a>3.2.3 security配置</h4><p>将方法权限的控制交给security</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/order/r1"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"order/r2"</span>).hasAuthority(<span class="string">"p2"</span>)</span><br><span class="line">                <span class="comment">//所有/order/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/order/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/order/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、网关资源校验服务"><a href="#四、网关资源校验服务" class="headerlink" title="四、网关资源校验服务"></a>四、网关资源校验服务</h2><p>网关进行token校验，合法后对用户和权限信息封装，再下发下游服务，下游服务可以不再集成oauth2依赖，获取网关封装的权限信息，再次封装入security的上下文中，通过security完成权限校验</p>
<ul>
<li>网关对鉴权服务的认证请求放行</li>
<li>网关的资源服务会对用户的请求进行合法性校验</li>
<li>网关过滤器对token进行封装自定义用户信息json格式下发下游服务</li>
<li>下游服务过滤器对自定义用户权限信息封装的security安全上下文中</li>
<li>security接管下游服务的权限控制</li>
</ul>
<h3 id="4-1-maven依赖"><a href="#4-1-maven依赖" class="headerlink" title="4.1 maven依赖"></a>4.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网关依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 此依赖包含security，所以不需要额外导入security --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 健康检查 oauth2会使用到一些端点信息需要加上此依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;!-- 使用redis存储token才需要引入，其他方式存储可以不配置 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-配置类"><a href="#4-2-配置类" class="headerlink" title="4.2 配置类"></a>4.2 配置类</h3><h4 id="4-2-1-资源服务配置"><a href="#4-2-1-资源服务配置" class="headerlink" title="4.2.1 资源服务配置"></a>4.2.1 资源服务配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oauth2资源服务配置类</span></span><br><span class="line"><span class="comment"> *      网关整合都有的微服务资源拦截</span></span><br><span class="line"><span class="comment"> *      此类用于配置每个微服务的资源配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源id(实际使用时，每个服务对应自己的资源id)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">"r1"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceAuthExceptionEntryPoint resourceAuthExceptionEntryPoint;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * auth微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//权限不足处理类</span></span><br><span class="line">                    .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                    <span class="comment">//各种AuthenticationException细化处理</span></span><br><span class="line">                    .authenticationEntryPoint(resourceAuthExceptionEntryPoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                	<span class="comment">//需要放行，否则用户无法获取token</span></span><br><span class="line">                    .antMatchers(<span class="string">"/auth/**"</span>).permitAll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pay微服务资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableResourceServer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            resources</span><br><span class="line">                    .tokenStore(tokenStore)</span><br><span class="line">                    .resourceId(RESOURCE_ID)</span><br><span class="line">                    .stateless(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">"/api/**"</span>).access(<span class="string">"#oauth2.hasScope('ROLE_API')"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-令牌存储策略配置（同鉴权服务2-2-2）"><a href="#4-2-2-令牌存储策略配置（同鉴权服务2-2-2）" class="headerlink" title="4.2.2 令牌存储策略配置（同鉴权服务2.2.2）"></a>4.2.2 令牌存储策略配置（同鉴权服务2.2.2）</h3><h3 id="4-2-3-security配置"><a href="#4-2-3-security配置" class="headerlink" title="4.2.3 security配置"></a>4.2.3 security配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * security拦截配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-过滤器封装token用户及权限信息"><a href="#4-2-4-过滤器封装token用户及权限信息" class="headerlink" title="4.2.4 过滤器封装token用户及权限信息"></a>4.2.4 过滤器封装token用户及权限信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该过滤器进行权限信息解析，封装到header路由转发都下级微服务</span></span><br><span class="line"><span class="comment"> *      下级微服务将权限信息放入security上下文中，从而可以使用security的权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取令牌内容</span></span><br><span class="line">        RequestContext currentContext = RequestContext.getCurrentContext();</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是oauth认证信息，无法访问</span></span><br><span class="line">        <span class="keyword">if</span> (!(authentication <span class="keyword">instanceof</span> OAuth2Authentication)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication;</span><br><span class="line">        Authentication userAuthentication = oAuth2Authentication.getUserAuthentication();</span><br><span class="line">        Object principal = userAuthentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装明文token，转发给微服务，放入header，名称为json-token</span></span><br><span class="line">        List&lt;String&gt; authList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        userAuthentication.getAuthorities().forEach(auth-&gt; authList.add(auth.getAuthority()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        OAuth2Request oAuth2Request = oAuth2Authentication.getOAuth2Request();</span><br><span class="line">        Map&lt;String, String&gt; requestParameters = oAuth2Request.getRequestParameters();</span><br><span class="line">        Map&lt;String,Object&gt; jsonToken = <span class="keyword">new</span> HashMap&lt;&gt;(requestParameters);</span><br><span class="line">        jsonToken.put(<span class="string">"principal"</span>,principal);</span><br><span class="line">        jsonToken.put(<span class="string">"authorities"</span>,authList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String jsonTokenStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonTokenStr = objectMapper.writeValueAsString(jsonToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将身份信息和权限信息放在json中，加入header中，转发给下级微服务</span></span><br><span class="line">        currentContext.addZuulRequestHeader(<span class="string">"json-token"</span>, Base64.getEncoder().encodeToString(jsonTokenStr.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-自定义处理类"><a href="#4-2-5-自定义处理类" class="headerlink" title="4.2.5 自定义处理类"></a>4.2.5 自定义处理类</h3><h4 id="4-2-5-1-权限不足处理类"><a href="#4-2-5-1-权限不足处理类" class="headerlink" title="4.2.5.1 权限不足处理类"></a>4.2.5.1 权限不足处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权拒绝处理器，覆盖默认的OAuth2AccessDeniedHandler</span></span><br><span class="line"><span class="comment"> * 当权限不足时走此类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">extends</span> <span class="title">OAuth2AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 授权拒绝处理，使用R包装</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request       request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response      response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> authException authException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException authException)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"授权失败，禁止访问 &#123;&#125;"</span>, request.getRequestURI());</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		response.setStatus(HttpStatus.FORBIDDEN.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(<span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足，禁止访问"</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-2-各种AuthenticationException细化处理"><a href="#4-2-5-2-各种AuthenticationException细化处理" class="headerlink" title="4.2.5.2 各种AuthenticationException细化处理"></a>4.2.5.2 各种AuthenticationException细化处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以根据 AuthenticationException 不同细化异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceAuthExceptionEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ResourceAuthExceptionEntryPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">		response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">		response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">		Result result = <span class="keyword">new</span> Result();</span><br><span class="line">		result.setCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		<span class="keyword">if</span> (authException != <span class="keyword">null</span>) &#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			result.setData(authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(authException.getCause() == <span class="keyword">null</span>)&#123;</span><br><span class="line">			result.setMsg(<span class="string">"error"</span>);</span><br><span class="line">			logger.error(<span class="string">"no right to access or token invalid!,msg:&#123;&#125;"</span>,authException.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			String exceptionStr = authException.getCause().toString();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"unauthorized"</span>)) &#123;<span class="comment">//oauth2.0认证,用户不存在</span></span><br><span class="line">				result.setCode(<span class="number">11</span>);</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_USER_NOTEXIST.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_grant"</span>)) &#123;<span class="comment">//oauth2.0认证,密码错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_PASSWORD_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.contains(exceptionStr, <span class="string">"invalid_token"</span>)) &#123;<span class="comment">//oauth2.0认证,token无效</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getIndex());</span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_TOKEN_ERROR.getText(),authException);</span><br><span class="line"></span><br><span class="line">		 	&#125;  <span class="keyword">else</span> &#123;<span class="comment">//其他错误</span></span><br><span class="line">				result.setCode(BusinessErrorEnum.LOGIN_ERROR.getIndex());</span><br><span class="line"></span><br><span class="line">				result.setMsg(BusinessErrorEnum.LOGIN_ERROR.getText());</span><br><span class="line">				logger.info(BusinessErrorEnum.LOGIN_ERROR.getText(),authException);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">		PrintWriter printWriter = response.getWriter();</span><br><span class="line">		printWriter.append(objectMapper.writeValueAsString(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、下游资源微服务"><a href="#五、下游资源微服务" class="headerlink" title="五、下游资源微服务"></a>五、下游资源微服务</h2><h3 id="5-1-maven依赖"><a href="#5-1-maven依赖" class="headerlink" title="5.1 maven依赖"></a>5.1 maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2 配置"></a>5.2 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>, prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限不足处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来解决匿名用户访问无权限资源时的异常处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/pay/r1"</span>).hasAuthority(<span class="string">"p3"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"pay/r2"</span>).hasAuthority(<span class="string">"p1"</span>)</span><br><span class="line">                <span class="comment">//所有/pay/**的请求必须认证通过</span></span><br><span class="line">                .antMatchers(<span class="string">"/pay/**"</span>).authenticated()</span><br><span class="line">                <span class="comment">//除了/pay/**，其他请求可以访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line">        http.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line">    http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-自定义异常处理"><a href="#5-3-自定义异常处理" class="headerlink" title="5.3 自定义异常处理"></a>5.3 自定义异常处理</h3><h4 id="5-3-1-权限不足"><a href="#5-3-1-权限不足" class="headerlink" title="5.3.1 权限不足"></a>5.3.1 权限不足</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 权限不足效验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"权限不足"</span>);</span><br><span class="line">        HttpResponseUtil.responseJsonWriter(httpServletResponse,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-匿名用户无权限处理"><a href="#5-3-2-匿名用户无权限处理" class="headerlink" title="5.3.2 匿名用户无权限处理"></a>5.3.2 匿名用户无权限处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationEntryPoint</span>  <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Result result = <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="number">403</span>,<span class="string">"超过登录有效期，请重新登录！"</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        HttpResponseUtil.responseJsonWriter(response, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-封装自定义权限到security安全上下文"><a href="#5-4-封装自定义权限到security安全上下文" class="headerlink" title="5.4 封装自定义权限到security安全上下文"></a>5.4 封装自定义权限到security安全上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将网关下发的权限信息放入security上下文中，交由security进行权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析header中的token</span></span><br><span class="line">        String token = httpServletRequest.getHeader(<span class="string">"json-token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(token))&#123;</span><br><span class="line">            String jsonTokenStr = <span class="keyword">new</span> String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8);</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            JsonNode jsonNode = objectMapper.readTree(jsonTokenStr);</span><br><span class="line">            String principal = jsonNode.get(<span class="string">"principal"</span>).asText();</span><br><span class="line">            UserPo userPo = <span class="keyword">new</span> UserPo();</span><br><span class="line">            userPo.setUsername(principal);</span><br><span class="line">            Iterator&lt;JsonNode&gt; authorities = jsonNode.get(<span class="string">"authorities"</span>).iterator();</span><br><span class="line">            List&lt;String&gt; authList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (authorities.hasNext())&#123;</span><br><span class="line">                authList.add(authorities.next().asText());</span><br><span class="line">            &#125;</span><br><span class="line">            String[] authArr = authList.toArray(<span class="keyword">new</span> String[authList.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装新的权限token</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken =</span><br><span class="line">                    <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userPo,<span class="keyword">null</span>, AuthorityUtils.createAuthorityList(authArr));</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(httpServletRequest));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入security上下文</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-自定义security权限注解校验"><a href="#5-5-自定义security权限注解校验" class="headerlink" title="5.5 自定义security权限注解校验"></a>5.5 自定义security权限注解校验</h3><h4 id="5-5-1-处理类"><a href="#5-5-1-处理类" class="headerlink" title="5.5.1 处理类"></a>5.5.1 处理类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限判断工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"pms"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断接口是否有xxx:xxx权限</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> permission 权限</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isEmpty(permission))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> (authentication == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		UserPo userPo = (UserPo) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">		<span class="keyword">return</span> authorities.stream()</span><br><span class="line">			.map(GrantedAuthority::getAuthority)</span><br><span class="line">			.filter(StringUtils::hasText)</span><br><span class="line">			.anyMatch(x -&gt; PatternMatchUtils.simpleMatch(permission, x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-注解"><a href="#5-5-2-注解" class="headerlink" title="5.5.2 注解"></a>5.5.2 注解</h4><p>方法上添加注解进行权限控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"@pms.hasPermission('p1')"</span> )</span><br></pre></td></tr></table></figure>

<h2 id="六、数据库表格"><a href="#六、数据库表格" class="headerlink" title="六、数据库表格"></a>六、数据库表格</h2><p><a href="https://www.cnblogs.com/zxy-come-on/p/14047791.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxy-come-on/p/14047791.html</a></p>
]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>oauth2 - cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖一（图解）</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%80%EF%BC%88%E5%9B%BE%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>指的是DefaultSingletonBeanRegistry类中的三个Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存，存放初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存，存放已经被实例化，但是未初始化完成的Bean</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三级缓存，存储创建Bean的匿名内部类工厂对象（() -&gt; getEarlyBeanReference(beanName, mbd, bean)），解决创建动态代理逻辑性能，解耦 bean动态代理问题</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>spring通过三级缓存来解决循环依赖问题</p>
<a id="more"></a>

<h2 id="不含aop的流程图"><a href="#不含aop的流程图" class="headerlink" title="不含aop的流程图"></a>不含aop的流程图</h2><p><img src="http://yrlzero.gitee.io/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg" alt=""></p>
<h2 id="含aop的流程图"><a href="#含aop的流程图" class="headerlink" title="含aop的流程图"></a>含aop的流程图</h2><p><img src="http://yrlzero.gitee.io/images/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%ABaop2.jpg" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1：使用三级缓存的作用？"><a href="#1：使用三级缓存的作用？" class="headerlink" title="1：使用三级缓存的作用？"></a>1：使用三级缓存的作用？</h3><p>在三个级别的缓存中防止的对象是有区别的<br>    一级缓存存放的是：实例化和初始化都完成的对象<br>    二级缓存存放的是：实例化完成、初始化未完成的对象<br>    三级缓存存放的是：实例化和初始化都未完成，存放的是创建bean的匿名内部类（函数是接口ObjectFactory传入）</p>
<h3 id="2：只使用一级缓存？"><a href="#2：只使用一级缓存？" class="headerlink" title="2：只使用一级缓存？"></a>2：只使用一级缓存？</h3><p>​    在并发的情况下，可能取到实例化但是未初始化的对象</p>
<h3 id="3：只使用二级缓存？"><a href="#3：只使用二级缓存？" class="headerlink" title="3：只使用二级缓存？"></a>3：只使用二级缓存？</h3><p>​    三级缓存存放的是生成具体对象的一个匿名内部类，这个类可能是代理类，也可能是普通的实例对象，使用三级缓存就保证了不管是否需要代理，用的都是一个对象</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 过滤器链</title>
    <url>/2021/02/08/spring%20security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/</url>
    <content><![CDATA[<h3 id="过滤器链介绍"><a href="#过滤器链介绍" class="headerlink" title="过滤器链介绍"></a>过滤器链介绍</h3><p>spring security采用的是责任链的设计模式，它有一条很长的过滤器链。</p>
<p>客户端向服务端发送请求，然后应用根据请求的 <strong>URI</strong> 的路径来确定该请求的过滤器链（<strong>Filter</strong>）以及最终的具体 <strong>Servlet</strong> 控制器（<strong>Controller</strong>）</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E5%9F%BA%E7%A1%80%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg" alt=""></p>
<a id="more"></a>

<p>从上图我们可以看出 <strong>Spring Security</strong> 以一个单 <strong>Filter（FilterChainProxy）</strong> 存在于整个过滤器链中，而这个 <code>FilterChainProxy</code> 实际内部代理着众多的 <strong>Spring Security Filter（过滤器链）</strong> ，过滤器链的每个元素都是一组URL对应一组过滤器</p>
<h3 id="过滤器链形成"><a href="#过滤器链形成" class="headerlink" title="过滤器链形成"></a>过滤器链形成</h3><p>首先 众多的<strong>Filter</strong> 按照一定的顺序被 <code>SecurityBuilder</code> 的实现来组装为 <code>SecurityFilterChain</code> ，然后通过 <code>WebSecurity</code> 注入到 <code>FilterChainProxy</code> 中去，接着 <code>FilterChainProxy</code> 又在 <code>WebSecurityConfiguration</code> 中以 <code>springSecurityFilterChain</code> 的名称注册为 <strong>Spring Bean</strong> 。实际上还有一个隐藏层 <code>DelegatingFilterProxy</code> 代理了 <code>springSecurityFilterChain</code> 注入到最后整个 <strong>Servlet</strong> 过滤器链中，如下图</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<p><strong>Spring Security</strong> 允许有多条过滤器链并行，<strong>Spring Security</strong> 的 <code>FilterChainProxy</code> 可以代理多条过滤器链并根据不同的 <strong>URI</strong> 匹配策略进行分发。但是每个请求每次只能被分发到一条过滤器链，实际每条过滤链就是一个 <code>SecurityFilterChain</code>。如下图所示：</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/url%E5%8C%B9%E9%85%8D%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg" alt=""></p>
<h3 id="过滤器链中的过滤器"><a href="#过滤器链中的过滤器" class="headerlink" title="过滤器链中的过滤器"></a>过滤器链中的过滤器</h3><p><img src="http://yrlzero.gitee.io/images/security/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%9B%BE.jpg" alt=""></p>
<p>过滤器说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1） WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</span><br><span class="line"></span><br><span class="line">（2） SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder 中，然后在该次请求处理完成之后，将SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder 中的信息清除，例如在 Session 中维护一个用户的安全信息就是这个过滤器处理的。</span><br><span class="line"></span><br><span class="line">（3） HeaderWriterFilter：用于将头信息加入响应中。</span><br><span class="line"></span><br><span class="line">（4） CsrfFilter：用于处理跨站请求伪造。</span><br><span class="line"></span><br><span class="line">（5）LogoutFilter：用于处理退出登录。</span><br><span class="line"></span><br><span class="line">（6）UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 &#x2F;login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。</span><br><span class="line"></span><br><span class="line">（7）DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</span><br><span class="line"></span><br><span class="line">（8）BasicAuthenticationFilter：检测和处理 http basic 认证。</span><br><span class="line"></span><br><span class="line">（9）RequestCacheAwareFilter：用来处理请求的缓存。</span><br><span class="line"></span><br><span class="line">（10）SecurityContextHolderAwareRequestFilter：主要是包装请求对象 request。 </span><br><span class="line"></span><br><span class="line">（11）AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在Authentication 对象，如果不存在为其提供一个匿名 Authentication。 </span><br><span class="line"></span><br><span class="line">（12）SessionManagementFilter：管理 session 的过滤器</span><br><span class="line"></span><br><span class="line">（13）ExceptionTranslationFilter：处理 AccessDeniedException 和AuthenticationException 异常。</span><br><span class="line"></span><br><span class="line">（14）FilterSecurityInterceptor：可以看做过滤器链的出口。</span><br><span class="line"></span><br><span class="line">（15）RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 鉴权</title>
    <url>/2021/02/08/spring%20security%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>FilterSecurityInterceptor</code>是过滤链的最后一环，一个请求完成了认证，且没有抛出异常之后就会到达<code>FilterSecurityInterceptor</code>所负责的鉴权部分，也就是说鉴权的入口就在<code>FilterSecurityInterceptor</code>。</p>
<p>​        它实现了<code>Filter</code>接口，我们一般直接继承这个过滤器或者继承他的父类，目的是为了注入自定义的授权管理器<code>AccessDecisionManager</code>、和权限元数据<code>FilterInvocationSecurityMetadataSource</code></p>
<p>​        它是在<code>WebSecurityConfigurerAdapter</code>的<code>init()</code>里配置的。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="进入FilterSecurityInterceptor的doFilter-、invoke-方法"><a href="#进入FilterSecurityInterceptor的doFilter-、invoke-方法" class="headerlink" title="进入FilterSecurityInterceptor的doFilter()、invoke()方法"></a>进入<code>FilterSecurityInterceptor</code>的doFilter()、invoke()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个FilterInvocation对象，这个FilterInvocation对象你可以当作它封装了request，它的主要工作就是拿请求里面的信息，比如请求的URI。</span></span><br><span class="line">		FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">		<span class="comment">//调用了自身的invoke方法，并将FilterInvocation对象传入。</span></span><br><span class="line">		invoke(fi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((fi.getRequest() != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">			<span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line">			<span class="comment">// once-per-request handling, so don't re-do security checking</span></span><br><span class="line">			fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">			<span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">				fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//根据资源权限配置来判断当前请求是否有权限访问对应的资源。</span></span><br><span class="line">			<span class="comment">//如果不能访问，则抛出相应的异常</span></span><br><span class="line">			InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//访问相关资源，通过SpringMvc的核心组件DispatcherServlet进行访问</span></span><br><span class="line">				fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用父类AbstractSecurityInterceptor的beforeInvocation-方法"><a href="#调用父类AbstractSecurityInterceptor的beforeInvocation-方法" class="headerlink" title="调用父类AbstractSecurityInterceptor的beforeInvocation()方法"></a>调用父类<code>AbstractSecurityInterceptor</code>的beforeInvocation()方法</h4><p>​                1、获取当前资源权限（我们自己定义的规则权限）</p>
<p>​                2、获取认证的authentication身份信息</p>
<p>​                3、调用决策器尝试进行认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationEventPublisherAware</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(object, <span class="string">"Object was null"</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">					<span class="string">"Security invocation attempted for object "</span></span><br><span class="line">							+ object.getClass().getName()</span><br><span class="line">							+ <span class="string">" but AbstractSecurityInterceptor only configured to support secure objects of type: "</span></span><br><span class="line">							+ getSecureObjectClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用子类的FilterInvocationSecurityMetadataSource.getAttributes(object)获取当前资源所需权限</span></span><br><span class="line">		Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">				.getAttributes(object);</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果Authentication.isAuthenticated()返回false或属性alwaysReauthenticate已设置为true，则检查当前身份验证令牌并将其传递给AuthenticationManager进行认证</span></span><br><span class="line">		<span class="comment">//返回认证的authentication身份信息，并放入安全上下文</span></span><br><span class="line">		Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Attempt authorization</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用访问决策器进行决策，尝试进行鉴权</span></span><br><span class="line">			<span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">			publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">					accessDeniedException));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​        <code>AccessDecisionManager</code>访问决策管理器是一个接口，它声明了三个方法，除了第一个鉴权方法以外，还有两个是辅助性的方法，其作用都是甄别 decide方法中参数的有效性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 解决传递参数的访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">            InsufficientAuthenticationException</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//指示此AccessDecisionManager是否能够处理通过传递的ConfigAttribute提出的授权请求。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//指示AccessDecisionManager实现是否能够为指示的安全对象类型提供访问控制决策</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://yrlzero.gitee.io/images/security/%E9%89%B4%E6%9D%83/%E5%86%B3%E7%AD%96%E5%99%A8.jpg" alt=""></p>
<p>​    从图中我们可以看到它主要有三个实现类，分别代表了三种不同的鉴权逻辑：</p>
<ul>
<li>AffirmativeBased：一票通过，只要有一票通过就算通过，默认是它。</li>
<li>UnanimousBased：一票反对，只要有一票反对就不能通过。</li>
<li>ConsensusBased：少数票服从多数票。</li>
</ul>
<p><code>这三个实现类，其实还不是真正判断请求能不能通过的类，真正判断请求是否通过的是投票器，然后实现类把投票器的结果综合起来来决定到底能不能通过。</code></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>以<code>AffirmativeBased</code>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="keyword">extends</span> <span class="title">AbstractAccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AffirmativeBased</span><span class="params">(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(decisionVoters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException </span>&#123;</span><br><span class="line">		<span class="comment">//拒绝数量</span></span><br><span class="line">		<span class="keyword">int</span> deny = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//遍历从构造传入的决策投票器集合</span></span><br><span class="line">		<span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">			<span class="comment">//调用该投票器的投票逻辑方法进行判断（AffirmativeBased默认传入WebExpressionVoter）</span></span><br><span class="line">			<span class="keyword">int</span> result = voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (result) &#123;</span><br><span class="line">				<span class="comment">//赞成</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//拒绝</span></span><br><span class="line">                <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">                    deny++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拒绝数量大于0，抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(messages.getMessage(</span><br><span class="line">					<span class="string">"AbstractAccessDecisionManager.accessDenied"</span>, <span class="string">"Access is denied"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果全部都弃权，进入此方法，判断此决策器是否允许全部弃权，不允许则抛出AccessDeniedException异常</span></span><br><span class="line">		<span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">		checkAllowIfAllAbstainDecisions();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当走完决策流程没有抛出<code>AccessDeniedException</code>异常，则权限校验通过</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>通过实现<code>AccessDeniedHandler</code>接口的handle()可以对<code>AccessDeniedException</code>异常抛出的权限被拒信息作出友好提示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line"><span class="comment">//WebSecurityConfigurerAdapter配置</span></span><br><span class="line">http.exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint).accessDeniedHandler(myAccessDeniedHandler);</span><br></pre></td></tr></table></figure>



<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="http://yrlzero.gitee.io/images/security/%E9%89%B4%E6%9D%83/%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt=""></p>
<h2 id="自定义鉴权"><a href="#自定义鉴权" class="headerlink" title="自定义鉴权"></a>自定义鉴权</h2><h3 id="方式一-访问决策管理器实现鉴权"><a href="#方式一-访问决策管理器实现鉴权" class="headerlink" title="方式一 访问决策管理器实现鉴权"></a>方式一 访问决策管理器实现鉴权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionManager访问决策管理器实现类，直接在决策器decide()方法实现鉴权逻辑，空参构造，不注入投票器</span><br><span class="line">2、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">3、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​        总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>走自定义的鉴权规则</p>
<h3 id="方式二-投票器实现鉴权逻辑"><a href="#方式二-投票器实现鉴权逻辑" class="headerlink" title="方式二 投票器实现鉴权逻辑"></a>方式二 投票器实现鉴权逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自定义AccessDecisionVoter&lt;FilterInvocation&gt;投票器实现类，vote()方法中实现鉴权逻辑</span><br><span class="line">2、自定义AccessDecisionManager访问决策管理器实现类，有参构造，注入自定义投票器</span><br><span class="line">3、覆写FilterInvocationSecurityMetadataSource自定义权限规则逻辑，AbstractSecurityInterceptor.beforeInvocation()方法中需用到决策器的权限规则信息</span><br><span class="line">4、覆写AbstractSecurityInterceptor实现类，使用第一步的自定义访问决策器、第二步的自定义安全元数据；将自定义的过滤器配置在FilterSecurityInterceptor之前 http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br></pre></td></tr></table></figure>

<p>​    总结：请求经过<code>自定义安全过滤器</code>后，根据<code>自定义安全元数据</code>获取权限规则，来到<code>自定义访问决策器</code>调用<code>自定义投票器</code>走自定义的投票鉴权逻辑；这种方式较完整的仿照security流程</p>
<h3 id="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"><a href="#以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态" class="headerlink" title="以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态"></a>以上自定义方式之前都需增加额外过滤器，用来拦截检测token状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 UsernamePasswordAuthenticationFilter之前添加自定义OncePerRequestFilter过滤器实现类，目的是检查token状态是否正常(过期、系统已清除等)</span></span><br><span class="line">http.addFilterBefore(myJwtAuthenticationTokenRequestFilter,UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security 认证</title>
    <url>/2021/02/08/spring%20security%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h3 id="认证流程图"><a href="#认证流程图" class="headerlink" title="认证流程图"></a>认证流程图</h3><p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<a id="more"></a>

<h3 id="认证解析"><a href="#认证解析" class="headerlink" title="认证解析"></a>认证解析</h3><h4 id="用户发起认证"><a href="#用户发起认证" class="headerlink" title="用户发起认证"></a>用户发起认证</h4><p>​        经过<code>UsernamePasswordAuthenticationFilter</code>，调用其父类<code>AbstractAuthenticationProcessingFilter</code>的doFilter()方法</p>
<p>​        调用<code>UsernamePasswordAuthenticationFilter</code>的attemptAuthentication()方法尝试进行认证</p>
<p>​        将新构建的未认证的token（Authentication）交给AuthenticationManager接口的子类进行认证</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/1-attemptAuthentication.jpg" alt=""></p>
<h4 id="认证管理器处理认证"><a href="#认证管理器处理认证" class="headerlink" title="认证管理器处理认证"></a>认证管理器处理认证</h4><p>​    <code>AuthenticationManager</code>本身不包含任何的认证逻辑，其核心是管理所有的<code>AuthenticationProvider</code>，本质上认证是由<code>AuthenticationProvider</code>来实现认证。</p>
<p>​    用户认证调用了<code>AuthenticationManager</code>的authenticate()方法，由此进入 AbstractUserDetailsAuthenticationProvider（AuthenticationManager的实现类）的authenticate()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.根据自定义方式获取数据库用户信息</span><br><span class="line">	1.根据用户名从缓存寻找用户信息</span><br><span class="line">	2.没有缓存，调用子类DaoAuthenticationProvider.retrieveUser()-&gt;调用userDetailService的loadUserByUsername()走我们自定义的查询用户方法返回用户信息</span><br><span class="line">	</span><br><span class="line">b.校验用户状态(前置校验、额外校验、后置校验)</span><br><span class="line">	3.preAuthenticationChecks.check(user)对账号状态（isAccountNonLocked、isEnabled、isAccountNonExpired）进行校验	</span><br><span class="line">	4.additionalAuthenticationChecks(user,authenticationToken) 对其他认证信息进行检查（密码校验）</span><br><span class="line">	5.postAuthenticationChecks.check(user)对账号状态（isCredentialsNonExpired）进行校验</span><br><span class="line">	6.存在用户缓存信息的情况下需要更新缓存</span><br><span class="line">	</span><br><span class="line">c.生成用户认证信息authentication</span><br><span class="line">	7.createSuccessAuthentication()返回Authentication</span><br></pre></td></tr></table></figure>

<p>​        a.根据自定义方式获取数据库用户信息，如下图：</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/4-authenticate.jpg" alt=""></p>
<p>​        b.校验用户状态(前置校验、额外校验、后置校验)</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/5-authencation.jpg" alt=""></p>
<p>c.生成用户认证信息authentication</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/6-authencation.jpg" alt=""></p>
<h4 id="认证成功、失败handler"><a href="#认证成功、失败handler" class="headerlink" title="认证成功、失败handler"></a>认证成功、失败handler</h4><p>最后认证信息会传回<code>UsernamePasswordAuthenticationFilter</code>，并在其父类<code>AbstractAuthenticationProcessingFilter</code>的<code>doFilter()</code>中，根据认证成功设置SecurityContextHolder安全上下文用户信息，失败清除上下文用户信息，并设置调用相应的<code>handler</code>。</p>
<p><img src="http://yrlzero.gitee.io/images/security/%E8%AE%A4%E8%AF%81/7-handler.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.自定义登录过滤器</span><br><span class="line">​	不同的登录形式我们可以继承AbstractAuthenticationProcessingFilter定义自己的登录过滤器（默认UsernamePasswordAuthenticationFilter）</span><br><span class="line">​	根据指定的url匹配到该过滤器，目的是生成自定义继承AbstractAuthenticationToken的子类token(默认UsernamePasswordAuthenticationToken)</span><br><span class="line"></span><br><span class="line">2.认证管理器</span><br><span class="line">​	调用环境指定的认证管理器对未认真的Authentication进行认证处理（默认ProviderManager）</span><br><span class="line"></span><br><span class="line">3.覆写provider、abstractAuthenticationToken、userDetailServicec</span><br><span class="line">​	实现AuthenticationProvider自定义自己的provider（默认DaoAuthenticationProvider），认证管理器根据我们重写的public boolean supports(Class&lt;?&gt; authentication)方法对当前环境的authentication进行判断，选取合适我的provider进行认证处理</span><br><span class="line">​	provider会调用自定义的userDerailService查询用户信息进行校验</span><br><span class="line"></span><br><span class="line">4.覆写成功、失败的handler</span><br><span class="line">​	认证期间，失败，会抛出对应的异常；成功，则生成已认证的Authentication返回</span><br><span class="line">​	覆写AuthenticationFailureHandler、AuthenticationSuccessHandler可以在认证成功或失败时进行自定义处理</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>四种引用-强软弱虚</title>
    <url>/2020/12/12/%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A/</url>
    <content><![CDATA[<h2 id="一、强引用"><a href="#一、强引用" class="headerlink" title="一、强引用"></a>一、强引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</span><br><span class="line">在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。</span><br><span class="line">当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，及时该对象以后永远都不会被用到jvm也不会回收。</span><br><span class="line">因此强引用时造成java内存泄露的主要原因之一。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="二、软引用"><a href="#二、软引用" class="headerlink" title="二、软引用"></a>二、软引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一种相对强引用弱化了一些的引用，需要java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</span><br><span class="line">当系统内存充足时，它不会被回收，当系统内存不足时，会被回收。</span><br><span class="line">通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用时候就保留，不够用就回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如有一个应用需要读取大量的本地图片,如果每次读取图片都从硬盘读取则会严重影响性能,如果一次性全部加载到内存中有可能造成内存溢出</span><br><span class="line"></span><br><span class="line">此时可以使用软引用解决这个问题。</span><br><span class="line">思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，</span><br><span class="line">在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM的问题。</span><br><span class="line">Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="三、弱引用"><a href="#三、弱引用" class="headerlink" title="三、弱引用"></a>三、弱引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.WeakReference类来实现。</span><br><span class="line">它比软引用的生存期更短，只要垃圾回收机制一运行，不管内存空间是否充足，都会被回收。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;M&gt; tl &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">tl.set(new M());</span><br><span class="line">tl.remove();</span><br><span class="line"></span><br><span class="line">ThreadLocal的应用中，每个线程有自己的ThreadLocalMap，根据ThreadLocal对象找到其对应的值。</span><br><span class="line">ThreadLocalMap里面存放的Entry继承了WeakReference，当创建Entry是会调用super(key)方法进行创建，key指向tl对象，也就是说这个key是一个弱引用。</span><br><span class="line">若是强引用，即使tl&#x3D;null,但是key的引用依然指向ThreadLocal对象，只要ThreadLocalMap在就不会被回收，所以会有内存泄漏，而是用弱引用则不会。</span><br><span class="line">当tl没有额外的强引用指向时，即使key引用了tl，因为key是弱引用，遇到GC时tl也会开始回收。</span><br><span class="line"></span><br><span class="line">注意：当key被回收时，无法根据key找到对应的value，只要ThreadLocalMap在就不会被回收，也会存在泄漏，所以必须使用tl.remove()进行移除</span><br></pre></td></tr></table></figure>

<h2 id="四、虚引用"><a href="#四、虚引用" class="headerlink" title="四、虚引用"></a>四、虚引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要java.lang.ref.PhantomRefrnce类来实现，如果一个对象仅持有虚引用，那么它和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</span><br><span class="line">它不能单独使用，也不能单独访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</span><br><span class="line">主要作用是跟踪对象被垃圾回收的状态，提供一种确保对象被finalize以后做某些事情的机制，一般是来管理堆外内存的。</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NIO有个DirectByteBuffer是用来操作堆外内存的，堆外内存由操作系统管理，gc无法回收，当DirectByteBuffer为null时，可以通过虚引用的方式检测到，此时Reference&lt;? extends M&gt; poll &#x3D; QUEUE.poll();可以获得GC回收的通知，进而去执行自定义的逻辑清理堆外内存。</span><br><span class="line"></span><br><span class="line">堆外内存操作：</span><br><span class="line">Unsafe类</span><br><span class="line">	&#x2F;&#x2F;分配内存</span><br><span class="line">	public long allocateMemory(long bytes)&#123;</span><br><span class="line">		return theInternalUnsafe.allocateMemory(bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;回收内存</span><br><span class="line">	public void freeMemory(long address)&#123;</span><br><span class="line">		theInternalUnsafe.freeMemory(address);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>强软弱虚</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>spring循环依赖二-源码跟踪</title>
    <url>/2020/12/10/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%8C%EF%BC%88%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="第一步：最初的入口"><a href="#第一步：最初的入口" class="headerlink" title="第一步：最初的入口"></a>第一步：最初的入口</h3><p>ClassPathXmlApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//第一步，最初的入口</span></span><br><span class="line"><span class="number">144</span>			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="第二步：实例化所有剩余的-非延迟-init-单例"><a href="#第二步：实例化所有剩余的-非延迟-init-单例" class="headerlink" title="第二步：实例化所有剩余的(非延迟-init)单例"></a>第二步：实例化所有剩余的(非延迟-init)单例</h3><p>AbstractApplicationContext： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// 第二步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">517</span>				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>AbstractApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三步，实例化所有剩余的(非延迟-init)单例.</span></span><br><span class="line"><span class="number">879</span>		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：调用子类的doGetBean"><a href="#第四步：调用子类的doGetBean" class="headerlink" title="第四步：调用子类的doGetBean"></a>第四步：调用子类的doGetBean</h3><p>DefaultListableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 触发所有非惰性单例bean的初始化...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 略</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第四步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">897</span>					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"><a href="#第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）" class="headerlink" title="第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）"></a>第五（获取Bean的缓存）、七（创建实例）、九步（执行createBean方法）</h3><p>AbstractBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    	<span class="comment">// 第五步 获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="number">250</span>		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">                <span class="comment">//标记当前bean处于正在创建状态</span></span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">                </span><br><span class="line">				<span class="comment">// Create bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 第七步 创建实例</span></span><br><span class="line"><span class="number">322</span>					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//第九步，在第八步调用singletonFactory.getObject()执行此lambda方法</span></span><br><span class="line"><span class="number">324</span>							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							<span class="keyword">throw</span> ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No scope name defined for bean ´"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">								<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">								<span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"><a href="#第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）" class="headerlink" title="第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）"></a>第六（获取不到Bean的缓存）、十八步（获取到Bean的三级缓存生成对象放入二级缓存）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第六步，获取Bean的缓存（其中包括从一级、二级、三级缓存中获取）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">	    <span class="comment">//1.先从一级缓存中获取对象，若存在则返回</span></span><br><span class="line"><span class="number">182</span>		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">//2.若对象不存在，则从二级缓存中查找该对象</span></span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="comment">//3.若对象不存在一级、二级缓存中时，并且存在于三级缓存中时</span></span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//4.调用工厂对象的getObject()方法【() -&gt; getEarlyBeanReference(beanName, mbd, bean)】</span></span><br><span class="line">                            	<span class="comment">// 提前，实际上是调用了【AnnotationAwareAspectJAutoProxyCreator】</span></span><br><span class="line">                            	<span class="comment">// 第十八步，最终返回一个动态代理对象Proxy</span></span><br><span class="line"><span class="number">194</span>								singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//将该动态代理对象存放到二级缓存中</span></span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">//把该bean的函数接口从三级缓存中移除</span></span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"><a href="#第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）" class="headerlink" title="第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）"></a>第八（执行第七步传入的lambda表达式）、二十一步（添加到一级缓存中，然后调用链将回到初始化实例的函数）</h3><p>DefaultSingletonBeanRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//1.从缓存中获取bean实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//2.如果bean实例不存在缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 省略部分源码 */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//第八步，调用第七步传入的lambda表达式() -&gt; &#123; return createBean(beanName, mbd, args);&#125;</span></span><br><span class="line"><span class="number">234</span>             singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            	<span class="comment">/* 省略部分源码 */</span>    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">//第二十步，添加到一级缓存中，然后调用链将回到初始化实例的函数</span></span><br><span class="line"><span class="number">260</span>             addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十步：创建一个bean实"><a href="#第十步：创建一个bean实" class="headerlink" title="第十步：创建一个bean实"></a>第十步：创建一个bean实</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="comment">// 略</span></span></span><br><span class="line"><span class="function">		<span class="keyword">try</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第十步，创建一个bean实例，填充bean实例、应用前置处理器等</span></span><br><span class="line"><span class="number">516</span>			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"><a href="#第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）" class="headerlink" title="第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）"></a>第十一（实例化对象，开辟内存空间）、十二步（添加Bean的工厂对象到三级缓存中）、十九步（获取到二级缓存中提前暴露的A）</h3><p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate the bean.</span></span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//第十一步,实例化对象，开辟内存空间</span></span><br><span class="line"><span class="number">556</span>			instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">//快速缓存单例，以便能够解决循环引用</span></span><br><span class="line">		<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    	<span class="comment">// 实例化完成后，判断是否需要提前暴露该对象，结果为true</span></span><br><span class="line">    	<span class="comment">// 满足条件：单例、开启允许循环依赖的配置、并且该Bean处于正在创建状态</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//第十二步，添加Bean的工厂对象到三级缓存中</span></span><br><span class="line"><span class="number">587</span>			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第十三步，填充属性，即给A的属性赋值（也就是属性B）</span></span><br><span class="line"><span class="number">593</span>			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">//第十九步，获取到二级缓存中提前暴露的A</span></span><br><span class="line"><span class="number">607</span>			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十三步：给给Bean的属性赋值"><a href="#第十三步：给给Bean的属性赋值" class="headerlink" title="第十三步：给给Bean的属性赋值"></a>第十三步：给给Bean的属性赋值</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">		<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">		<span class="comment">// to support styles of field injection.</span></span><br><span class="line">	    <span class="comment">//当像BeanFactoryAware这样的生命周期接口触发时，任何实例化的awarebeanpostprocessor都有机会在属性设置之前修改bean的状态</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">		PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">						&#125;</span><br><span class="line">						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					pvs = pvsToUse;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">			<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			&#125;</span><br><span class="line">			checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            <span class="comment">//第十三步，给Bean的属性赋值</span></span><br><span class="line"><span class="number">1442</span>			applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"><a href="#第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）" class="headerlink" title="第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）"></a>第十四（属性解析器获取property的实际内容）、二十一步（真正的属性赋值）</h3><p>AbstractAutowireCapableBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取属性名称</span></span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">				<span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">					Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">					<span class="keyword">if</span> (writeMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Autowire marker for property without write method: "</span> + pv);</span><br><span class="line">					&#125;</span><br><span class="line">					originalValue = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">new</span> MethodParameter(writeMethod, <span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">                	<span class="comment">//第十四步 使用解析器解析不同类型的值</span></span><br><span class="line"><span class="number">1697</span>				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				Object convertedValue = resolvedValue;</span><br><span class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">        <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第二十步，真正的属性赋值</span></span><br><span class="line"><span class="number">1730</span>		bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十五步："><a href="#第十五步：" class="headerlink" title="第十五步："></a>第十五步：</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">		<span class="comment">// to another bean to be resolved.</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">			RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">            <span class="comment">//第十五步</span></span><br><span class="line"><span class="number">113</span>			<span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十六步：调用子类的doGetBean"><a href="#第十六步：调用子类的doGetBean" class="headerlink" title="第十六步：调用子类的doGetBean"></a>第十六步：调用子类的doGetBean</h3><p>BeanDefinitionValueResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object bean;</span><br><span class="line">			Class&lt;?&gt; beanType = ref.getBeanType();</span><br><span class="line">			<span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String resolvedName;</span><br><span class="line">				<span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					NamedBeanHolder&lt;?&gt; namedBean = <span class="keyword">this</span>.beanFactory.resolveNamedBean(beanType);</span><br><span class="line">					bean = namedBean.getBeanInstance();</span><br><span class="line">					resolvedName = namedBean.getBeanName();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolvedName = String.valueOf(doEvaluate(ref.getBeanName()));</span><br><span class="line">                    <span class="comment">//第十六步,调用子类的doGetBean(name, null, null, false)</span></span><br><span class="line"><span class="number">330</span>					bean = <span class="keyword">this</span>.beanFactory.getBean(resolvedName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory.registerDependentBean(resolvedName, <span class="keyword">this</span>.beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				bean = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十七步-循环第五步创建B"><a href="#第十七步-循环第五步创建B" class="headerlink" title="第十七步:循环第五步创建B"></a>第十七步:循环第五步创建B</h3><p>AbstractBeanFactory</p>
<h2 id="归纳步骤："><a href="#归纳步骤：" class="headerlink" title="归纳步骤："></a>归纳步骤：</h2><h4 id="实例化A"><a href="#实例化A" class="headerlink" title="实例化A"></a>实例化A</h4><p>1.<code>第五步</code>getSingleton(beanName)从缓存获取<code>A</code>；</p>
<p>2.获取不到时，走<code>第七步</code>准备开始创建；</p>
<p>3.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>4.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>A</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取A的属性B"><a href="#获取A的属性B" class="headerlink" title="获取A的属性B"></a>获取A的属性B</h4><p>5.<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>；</p>
<p>6.走<code>第五步</code>获取<code>B</code>，返现<code>B</code>没有，继续重复流程创建<code>B</code>；</p>
<h4 id="实例化B"><a href="#实例化B" class="headerlink" title="实例化B"></a>实例化B</h4><p>7.走<code>第七步</code>准备开始创建B；</p>
<p>8.<code>第十一步</code>,实例化对象，开辟内存空间</p>
<p>9.到<code>第十二步</code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))将<code>B</code>的ObjectFactory放入<code>三级缓存</code>中；</p>
<h4 id="获取B的属性A"><a href="#获取B的属性A" class="headerlink" title="获取B的属性A"></a>获取B的属性A</h4><p>10.再次来到<code>第十三步</code>给<code>B</code>的赋值<code>属性A</code>时；</p>
<p>11.<code>第十六步</code>,调用子类的doGetBean(name, null, null, false)</p>
<p>11.再次走<code>第五步</code>获取<code>A</code></p>
<p>12.<code>十八步</code>获取到A的三级缓存生成对象放入<code>二级缓存</code>，如果有aop最终返回一个动态代理对象Proxy，移除三级缓存A的工厂；</p>
<p>13.<code>第二十步</code> 真正的属性赋值,将A赋值给B</p>
<p>14.<code>第二十一步</code>将<code>B</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<p>15.回到<code>第十三步</code>populateBean(beanName, mbd, instanceWrapper)，给<code>A</code>的赋值<code>属性B</code>时，走类似<code>10</code>之后的流程；</p>
<p>16.最终<code>A</code>放入addSingleton<code>一级缓存</code>，删除二级、三级缓存中的数据</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="getSingleton：获取各级缓存"><a href="#getSingleton：获取各级缓存" class="headerlink" title="getSingleton：获取各级缓存"></a>getSingleton：获取各级缓存</h3><h3 id="doCreateBean：创建bean主要方法"><a href="#doCreateBean：创建bean主要方法" class="headerlink" title="doCreateBean：创建bean主要方法"></a>doCreateBean：创建bean主要方法</h3><h3 id="populateBean：填充属性方法"><a href="#populateBean：填充属性方法" class="headerlink" title="populateBean：填充属性方法"></a>populateBean：填充属性方法</h3><h3 id="addSingleton：添加一级缓存方法"><a href="#addSingleton：添加一级缓存方法" class="headerlink" title="addSingleton：添加一级缓存方法"></a>addSingleton：添加一级缓存方法</h3><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>结合上面四个方法做个简单的总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.调用doGetBean()方法，想要获取A，于是调用getSingleton()方法，从缓存中查找A</span><br><span class="line">2.在getSingleton()方法中，从一级缓存中查找，没有，返回null</span><br><span class="line">3.doGet】Bean()方法中获取的A为null，于是走对应的处理逻辑，调用getSingleton()的重载方法(参数为ObjectFactory)</span><br><span class="line">4.在getSingleton()方法中，现将A的name添加到一个集合中，用于标记该bean正常创建中；然后回调匿名内部类的createBean方法</span><br><span class="line">5.进入AbstractAutowireCapableBeanFactory#doCreateBean，先反射调用构造器创建出A的实例，然后判断是否为单例、是否允许提前曝光引用（单例一般为true）、是否正在创建中（第四步的集合）；判断为true则将A添加到三级缓存中</span><br><span class="line">6.对A进行属性填充，此时检测到A依赖于B，于是开始查找B</span><br><span class="line">7.调用doGetBean()方法和上面A的过程一样，到缓存中查找B，没有则创建，然后给B填充属性</span><br><span class="line">8.此时B依赖于A，调用getSingle()获取A，依次从缓存中茶渣，此时从三级缓存中获取到A的工厂，通过公办工厂获取singletonObject，此时这个singleton指向就是上面在doCreate()方法中实例化的A（第七步）</span><br><span class="line">9.这样B就获取到了A的依赖，于是B顺利完成实例化，并将A从三级缓存移动到二级缓存中</span><br><span class="line">10.随后A继续它的属性填充工作，此时也获取到B，A也随之完成创建，回到getSingleton()方法中继续向下执行，将A从二级缓存移动到一级缓存中</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>配置centos固定ip</title>
    <url>/2020/11/29/%E9%85%8D%E7%BD%AEcentos%E5%9B%BA%E5%AE%9Aip/</url>
    <content><![CDATA[<h2 id="a-修改-etc-sysconfig-network配置文件："><a href="#a-修改-etc-sysconfig-network配置文件：" class="headerlink" title="a. 修改/etc/sysconfig/network配置文件："></a>a. 修改/etc/sysconfig/network配置文件：</h2><p>vi /etc/sysconfig/network</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Created by anaconda</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件："><a href="#b-修改-etc-sysconfig-network-scripts-ifcfg-ens33配置文件：" class="headerlink" title="b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件："></a>b. 修改/etc/sysconfig/network-scripts/ifcfg-ens33配置文件：</h2><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line"></span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">IPADDR&#x3D;192.168.243.131</span><br><span class="line">GATEWAY&#x3D;192.168.243.2</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line"></span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">UUID&#x3D;193e7f5e-e25b-40ef-b292-0fe5c8970af5</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">ZONE&#x3D;public</span><br></pre></td></tr></table></figure>

<h2 id="c-重启网关"><a href="#c-重启网关" class="headerlink" title="c. 重启网关:"></a>c. 重启网关:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/12/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="一、常见线程池"><a href="#一、常见线程池" class="headerlink" title="一、常见线程池"></a>一、常见线程池</h2><h3 id="1-Executors-newFixedThreadPool"><a href="#1-Executors-newFixedThreadPool" class="headerlink" title="1.Executors.newFixedThreadPool()"></a>1.Executors.newFixedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值是相等的，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造方法</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-Executors-newSingleThreadExecutor"><a href="#2-Executors-newSingleThreadExecutor" class="headerlink" title="2.Executors.newSingleThreadExecutor()"></a>2.Executors.newSingleThreadExecutor()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</span><br><span class="line">创建线程池corePoolSize和maximumPoolSize的值为1，它使用的队列是LinkedBlockingQueue</span><br><span class="line">构造</span><br><span class="line">	return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure>

<h3 id="3-Executors-newCachedThreadPool"><a href="#3-Executors-newCachedThreadPool" class="headerlink" title="3.Executors.newCachedThreadPool()"></a>3.Executors.newCachedThreadPool()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程corePoolSize的值为0，maximumPoolSize的值为Integer,MAX_VALUE，使用的队列是SynchronousQueue。有任务时就创建线程运行，当线程空闲60s就销毁线程</span><br><span class="line">构造</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="二、线程池底层调用"><a href="#二、线程池底层调用" class="headerlink" title="二、线程池底层调用"></a>二、线程池底层调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line">--&gt; 调用自身七参构造方法public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br><span class="line">	 int corePoolSize:线程池中常驻核心线程数</span><br><span class="line">	 int maximumPoolSize：线程池能够容纳同时执行你的最大线程数，此值必须大于等于1</span><br><span class="line">	 long keepAliveTime：多余的空闲线程存活时间，当前线程池超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止</span><br><span class="line">	 TimeUnit unit：keepAliveTime的单位</span><br><span class="line">	 BlockingQueue&lt;Runnable&gt; workQueue：任务队列，被提交但尚未被执行的任务</span><br><span class="line">	 ThreadFactory threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认即可</span><br><span class="line">	 RejectedExecutionHandler handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize）时如何来拒绝</span><br></pre></td></tr></table></figure>

<h2 id="三、线程池底层原理"><a href="#三、线程池底层原理" class="headerlink" title="三、线程池底层原理"></a>三、线程池底层原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）在创建了线程池后，等待提交过来的任务请求</span><br><span class="line">2）当调用execute()方法添加一个请求任务时，线程会做如下判断</span><br><span class="line">	2.1）如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</span><br><span class="line">	2.2）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</span><br><span class="line">	2.3）如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</span><br><span class="line">	2.4）如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</span><br><span class="line">3）当一个线程完成任务时，它会从队列中取下一个任务来执行</span><br><span class="line">4）当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</span><br><span class="line">	4.1) 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</span><br><span class="line">	4.2）所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小</span><br></pre></td></tr></table></figure>

<h2 id="四、线程池拒绝策略"><a href="#四、线程池拒绝策略" class="headerlink" title="四、线程池拒绝策略"></a>四、线程池拒绝策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行</span><br><span class="line"></span><br><span class="line">CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低任务流量</span><br><span class="line"></span><br><span class="line">DiscardOldestPolicy:抛弃任务中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</span><br><span class="line"></span><br><span class="line">DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案</span><br></pre></td></tr></table></figure>

<h2 id="五、自定义创建线程"><a href="#五、自定义创建线程" class="headerlink" title="五、自定义创建线程"></a>五、自定义创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">		<span class="number">2</span>,</span><br><span class="line">		<span class="number">5</span>,</span><br><span class="line">		<span class="number">1L</span>,</span><br><span class="line">		TimeUnit.SECONDS,</span><br><span class="line">		<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">		Executors.defaultThreadFactory(),</span><br><span class="line">		<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么不能使用常见的这三个线程池？</span><br><span class="line">因为newFixedThreadPool和newSingleThreadExecutor允许创建的队列长度Integer.MAX_VALUE，长度为21亿，可能会堆积大量请求，容易造成OOM；</span><br><span class="line">而newCachedThreadPool 和 newScheduledThreadPool允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，容易造成OOM</span><br><span class="line"></span><br><span class="line">如何设置线程数？</span><br><span class="line">CPU密集型，该任务需要大量的运算，而没有阻塞，CPU一直全速运行，尽可能少的线程数量，CPU核数+1个线程</span><br><span class="line">IO密集型 该任务需要大量的IO，即大量的阻塞，</span><br><span class="line">	由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，</span><br><span class="line">	1.常见公式：CPU核数*2</span><br><span class="line">	2. CPU核数 &#x2F; （1 - 阻塞系数）  阻塞系数0.8-09之间</span><br><span class="line"></span><br><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</span><br><span class="line">的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line">说明： Executors 返回的线程池对象的弊端如下：</span><br><span class="line">	1） FixedThreadPool 和 SingleThreadPool :</span><br><span class="line">			允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。</span><br><span class="line">	2） CachedThreadPool 和 ScheduledThreadPool :</span><br><span class="line">			允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>链路追踪</title>
    <url>/2020/12/06/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>sleuth收集跟踪信息通过http请求发送给zipkin server，zipkin将跟踪信息存储，以及提供RESTful API接口，zipkin ui通过调用api进行数据展示。默认内存存储，可以用mysql，ES等存储。</p>
<a id="more"></a>

<h2 id="二、Sleuth"><a href="#二、Sleuth" class="headerlink" title="二、Sleuth"></a>二、Sleuth</h2><p>Sleuth是Spring cloud的分布式跟踪解决方案。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>span(跨度)，基本工作单元。一次链路调用，创建一个span，</p>
<p>span用一个64位id唯一标识。包括：id，描述，时间戳事件，spanId,span父id。</p>
<p>span被启动和停止时，记录了时间信息，初始化span叫：root span，它的span id和trace id相等。</p>
</li>
<li><p>trace(跟踪)，一组共享“root span”的span组成的树状结构 称为 trace，trace也有一个64位ID，trace中所有span共享一个trace id。类似于一颗 span 树。</p>
</li>
<li><p>annotation（标签），annotation用来记录事件的存在，其中，核心annotation用来定义请求的开始和结束。</p>
<ul>
<li>CS(Client Send客户端发起请求)。客户端发起请求描述了span开始。</li>
<li>SR(Server Received服务端接到请求)。服务端获得请求并准备处理它。SR-CS=网络延迟。</li>
<li>SS（Server Send服务器端处理完成，并将结果发送给客户端）。表示服务器完成请求处理，响应客户端时。SS-SR=服务器处理请求的时间。</li>
<li>CR（Client Received 客户端接受服务端信息）。span结束的标识。客户端接收到服务器的响应。CR-CS=客户端发出请求到服务器响应的总时间。</li>
</ul>
</li>
</ol>
<p>taceId标识是同一条链路<br>spanId标识是一个服务的一次请求<br>parentId将当前请求与上一请求串联，被调用方的parentId是调用方的spanId</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg" alt=""></p>
<h2 id="三、zipkin"><a href="#三、zipkin" class="headerlink" title="三、zipkin"></a>三、zipkin</h2><p>zipkin是twitter开源的分布式跟踪系统</p>
<p>下载最新的稳定版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;search.maven.org&#x2F;remote_content?g&#x3D;io.zipkin&amp;a&#x3D;zipkin-server&amp;v&#x3D;LATEST&amp;c&#x3D;exec</span><br></pre></td></tr></table></figure>

<p>命令下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;zipkin.io&#x2F;quickstart.sh | bash -s</span><br></pre></td></tr></table></figure>

<p>启动 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.22</span><span class="number">.2</span>-exec.jar</span><br></pre></td></tr></table></figure>

<h2 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--链路追踪--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- zipkin --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#链路跟踪</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://admin:admin@localhost:9411/</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">rate:</span> <span class="number">1</span> <span class="comment">#采样比例1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、服务调用"><a href="#五、服务调用" class="headerlink" title="五、服务调用"></a>五、服务调用</h2><p>通过user服务调用pay服务</p>
<p>调用情况：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8.jpg" alt=""></p>
<p>调用详情：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%A6%E6%83%85.jpg" alt=""></p>
<p>依赖情况：</p>
<p><img src="http://yrlzero.gitee.io/images/cloud/sleuth/%E4%BE%9D%E8%B5%96%E6%83%85%E5%86%B5.jpg" alt=""></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>链路追踪</tag>
        <tag>sleuth</tag>
        <tag>zipkin</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（queue）</title>
    <url>/2020/12/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="各种队列介绍"><a href="#各种队列介绍" class="headerlink" title="各种队列介绍"></a>各种队列介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue 由数组结构组成的有界阻塞队列</span><br><span class="line">LinkedBlockingQueue 由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE 21亿）阻塞队列</span><br><span class="line">PriorityBlockingQueue 支持优先级排序的无界阻塞队列</span><br><span class="line">DelayQueue 使用时间优先级队列实现的延迟无界阻塞队列</span><br><span class="line">SynchronousQueue 不存储、匀速的阻塞队列，容量为零的队列（用于一个线程给另一个线程下达任务）</span><br><span class="line">LinkedTransferQueue 由链表结构组成的无界阻塞队列 transfer将元素放入队列之后会阻塞，等待元素被拿走</span><br><span class="line">LinkedBlockingDeque 由链表结构组成的双向阻塞队列</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><h4 id="操作失败会抛出异常的方法（add、remove、element）"><a href="#操作失败会抛出异常的方法（add、remove、element）" class="headerlink" title="操作失败会抛出异常的方法（add、remove、element）"></a>操作失败会抛出异常的方法（add、remove、element）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean add(E e)：添加元素，当阻塞队列满的时候再进行add会抛Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line"></span><br><span class="line">E remove()：移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line"></span><br><span class="line">E element()：获取队列排头的元素，没有值时Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br></pre></td></tr></table></figure>

<h4 id="操作失败返回false-null的方法（offer、poll、peek）"><a href="#操作失败返回false-null的方法（offer、poll、peek）" class="headerlink" title="操作失败返回false null的方法（offer、poll、peek）"></a>操作失败返回false null的方法（offer、poll、peek）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean offer(E e)：当阻塞队列满的时候再进行offer会返回false</span><br><span class="line"></span><br><span class="line">boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException：当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span><br><span class="line"></span><br><span class="line">E poll()：移除值并返回，当阻塞队列空的时候再进行poll会返回null</span><br><span class="line"></span><br><span class="line">E peek()：获取队列排头的元素，没有值时为null</span><br></pre></td></tr></table></figure>

<h4 id="一直阻塞的方法（put、take）"><a href="#一直阻塞的方法（put、take）" class="headerlink" title="一直阻塞的方法（put、take）"></a>一直阻塞的方法（put、take）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void put(E e) throws InterruptedException：当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span><br><span class="line"></span><br><span class="line">E take() throws InterruptedException：当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span><br></pre></td></tr></table></figure>

<h4 id="以ArrayBlockingQueue为例"><a href="#以ArrayBlockingQueue为例" class="headerlink" title="以ArrayBlockingQueue为例"></a>以ArrayBlockingQueue为例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockIngQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞队列，先进先出</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会抛异常的方法：add、element、remove</span></span><br><span class="line">        exceptionBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//会阻塞的方法：put、take</span></span><br><span class="line">        block(blockingQueue);</span><br><span class="line">		<span class="comment">//返回true、false、null的方法：offer、peek、poll</span></span><br><span class="line">        booleanBlockQueue(blockingQueue);</span><br><span class="line">		<span class="comment">//超时返回true、false的方法：offer</span></span><br><span class="line">        timeout(blockingQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作d失败等待超时返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer时，会阻塞2S，仍然阻塞则会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">2L</span>, TimeUnit.SECONDS));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">block</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//当阻塞队列满的时候会一直阻塞直到put数据或响应中断</span></span><br><span class="line">        <span class="comment">//blockingQueue.put("d");</span></span><br><span class="line">        <span class="comment">//获取并移除队列的值</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//当阻塞队列空的时候会一直阻塞直到take数据或响应中断</span></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.take());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败返回false null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">booleanBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行offer会返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"d"</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时为null</span></span><br><span class="line">        System.out.println(blockingQueue.peek());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行poll会返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.poll());<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作失败会抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionBlockQueue</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//######### 抛异常方法 ###########</span></span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//当阻塞队列满的时候再进行add会抛Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列排头的元素，没有值时Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.element());<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除值并返回，当阻塞队列空的时候再进行remove会抛 Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//a</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//b</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">//c</span></span><br><span class="line">        System.out.println(blockingQueue.remove());<span class="comment">// Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性——时间类</title>
    <url>/2021/03/13/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<p><font size='6.5px'>JDK8新特性——时间类</font></p>
<h1 id="为什么需要使用新的时间类"><a href="#为什么需要使用新的时间类" class="headerlink" title="为什么需要使用新的时间类"></a>为什么需要使用新的时间类</h1><p>1、Date如果不格式化，打印出的日期可读性差【Tue Sep 10 09:34:04 CST 2019】；</p>
<p>2、使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的；</p>
<p>3、获取时间一些参数需要转换为calendar类获取……</p>
<a id="more"></a>

<h1 id="JDK8新特性提供的时间操作类"><a href="#JDK8新特性提供的时间操作类" class="headerlink" title="JDK8新特性提供的时间操作类"></a>JDK8新特性提供的时间操作类</h1><p>1、LocalDate    【日期】</p>
<p>2、LocalTime    【时间】</p>
<p>3、LocalDateTime    【日期时间】</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的年月日"><a href="#构造指定的年月日" class="headerlink" title="构造指定的年月日"></a>构造指定的年月日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时分秒"><a href="#构造指定的时分秒" class="headerlink" title="构造指定的时分秒"></a>构造指定的时分秒</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">12</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取当前时日"><a href="#获取当前时日" class="headerlink" title="获取当前时日"></a>获取当前时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<h2 id="构造指定的时日"><a href="#构造指定的时日" class="headerlink" title="构造指定的时日"></a>构造指定的时日</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2019</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取时间的某一个值"><a href="#获取时间的某一个值" class="headerlink" title="获取时间的某一个值"></a>获取时间的某一个值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDateTime1.getYear();   <span class="comment">//2020  年份</span></span><br><span class="line">Month month = localDateTime1.getMonth();   <span class="comment">//JUNE  月份</span></span><br><span class="line"><span class="keyword">int</span> monthValue = localDateTime1.getMonthValue();   <span class="comment">//6  月份数值</span></span><br><span class="line"><span class="keyword">int</span> day = localDateTime1.getDayOfMonth();   <span class="comment">//28  日期</span></span><br><span class="line">DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek();   <span class="comment">//SUNDAY  周</span></span><br><span class="line"><span class="keyword">int</span> dayOfYear = localDateTime1.getDayOfYear();   <span class="comment">//180  年的第几天</span></span><br><span class="line"><span class="keyword">int</span> hour = localDateTime1.getHour();   <span class="comment">//13 小时</span></span><br><span class="line"><span class="keyword">int</span> minute = localDateTime1.getMinute();   <span class="comment">//51  分钟</span></span><br><span class="line"><span class="keyword">int</span> second = localDateTime1.getSecond();   <span class="comment">//19  秒</span></span><br></pre></td></tr></table></figure>

<h2 id="LocalDateTime、LocalDate、LocalTime的转换"><a href="#LocalDateTime、LocalDate、LocalTime的转换" class="headerlink" title="LocalDateTime、LocalDate、LocalTime的转换"></a>LocalDateTime、LocalDate、LocalTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime = localTime.atDate(localDate);</span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<h2 id="将某个时间增加"><a href="#将某个时间增加" class="headerlink" title="将某个时间增加"></a>将某个时间增加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.plus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//增加2年</span></span><br><span class="line">localDateTime = localDateTime.plusYears(<span class="number">2</span>);  <span class="comment">//增加2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间减少"><a href="#将某个时间减少" class="headerlink" title="将某个时间减少"></a>将某个时间减少</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime = localDateTime.minus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//减少2年</span></span><br><span class="line">localDateTime = localDateTime.minusYears(<span class="number">2</span>);  <span class="comment">//减少2年</span></span><br></pre></td></tr></table></figure>

<h2 id="将某个时间参数指定"><a href="#将某个时间参数指定" class="headerlink" title="将某个时间参数指定"></a>将某个时间参数指定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime1 = localDateTime1.with(ChronoField.MONTH_OF_YEAR,<span class="number">1</span>);  <span class="comment">//指定月份为1月</span></span><br><span class="line">localDateTime1 = localDateTime1.withHour(<span class="number">2</span>);  <span class="comment">//指定小时为2时</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime.with(firstDayOfYear());  <span class="comment">//获取当年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfMonth());  <span class="comment">//获取当月的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextYear());  <span class="comment">//获取下年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextMonth());  <span class="comment">//获取下月的第一天</span></span><br><span class="line">localDateTime.with(firstInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月第一个星期一的时间</span></span><br><span class="line">localDateTime.with(lastDayOfYear());  <span class="comment">//获取上年的第一天</span></span><br><span class="line">localDateTime.with(lastDayOfMonth());  <span class="comment">//获取上月的第一天</span></span><br><span class="line">localDateTime.with(lastInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月最后一个星期一的时间</span></span><br></pre></td></tr></table></figure>

<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认提供了几种格式时间的方式【一般不用】</span></span><br><span class="line">String s1 = localDateTime.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDateTime.format(DateTimeFormatter.ISO_DATE_TIME);</span><br><span class="line"><span class="comment">//自定义格式化时间的方式</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy/hh/mm/ss"</span>);</span><br><span class="line">String s3 = localDateTime.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="字符串解析时间"><a href="#字符串解析时间" class="headerlink" title="字符串解析时间"></a>字符串解析时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 &#x3D; LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 &#x3D; LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&#x2F;hh&#x2F;mm&#x2F;ss&quot;);</span><br><span class="line">LocalDate localDate3 &#x3D; LocalDate.parse(&quot;28&#x2F;06&#x2F;2020&#x2F;02&#x2F;28&#x2F;46&quot;, dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h2 id="Timestamp与LocalDateTime的转换"><a href="#Timestamp与LocalDateTime的转换" class="headerlink" title="Timestamp与LocalDateTime的转换"></a>Timestamp与LocalDateTime的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toLocalDateTime();</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime与Long（时间戳）的转换"><a href="#LocalDateTime与Long（时间戳）的转换" class="headerlink" title="LocalDateTime与Long（时间戳）的转换"></a>LocalDateTime与Long（时间戳）的转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = (<span class="keyword">new</span> Timestamp(System.currentTimeMillis())).toLocalDateTime();</span><br><span class="line"><span class="keyword">long</span> time = localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br></pre></td></tr></table></figure>

<h2 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.isBefore(localDateTime4));</span><br><span class="line">System.out.println(localDateTime.isAfter(localDateTime4));</span><br></pre></td></tr></table></figure>

<h2 id="计算时间间隔（Duration类和Period类）"><a href="#计算时间间隔（Duration类和Period类）" class="headerlink" title="计算时间间隔（Duration类和Period类）"></a>计算时间间隔（Duration类和Period类）</h2><p>使用场景【计算年龄、合同时间等。。。】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">Duration duration = Duration.between(localDateTime,localDateTime4);</span><br><span class="line"><span class="comment">//间隔多少天</span></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();</span><br><span class="line"><span class="comment">//间隔多少小时</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line"><span class="comment">//间隔多少分钟</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">Period period2 = Period.between(localDateTime.toLocalDate(),localDateTime4.toLocalDate());</span><br><span class="line"><span class="comment">//间隔多少年</span></span><br><span class="line"><span class="keyword">int</span> years = period2.getYears();</span><br><span class="line"><span class="comment">//间隔多少月（只计算月份，不计年）</span></span><br><span class="line"><span class="keyword">int</span> months = period2.getMonths();</span><br><span class="line"><span class="comment">//间隔多少月（计算年）</span></span><br><span class="line"><span class="keyword">long</span> toTotalMonths = period2.toTotalMonths();</span><br></pre></td></tr></table></figure>

<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter YEAR_MONTH_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter LONG_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss SSS"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyMMddHHmmss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDateTime</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">       LocalDateTime localDateTime = LocalDateTime.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDateTime.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDate</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDate.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将字符串日期转换成date类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">dateStrConvertDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(dateStr, dateTimeFormatter);</span><br><span class="line">        <span class="comment">// 获得 Instant</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(parse.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将date类型转换成字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateConvertDateStr</span><span class="params">(Date date,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localdate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">dateConvertLocalDate</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">dateConvertLocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localdate转换成date(时分秒为零)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateConvertDate</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        Instant instant = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localDateTime转换成date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTimeConvertDate</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">getCurrentLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">getCurrentLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getCurrentLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM-dd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyMMdd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(SHORT_DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentMonthStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(YEAR_MONTH_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss SSS”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentLongDateTimeStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(LONG_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyMMddHHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(SHORT_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间字符串以“HHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now().format(TIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间日期字符串以指定的字符串格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String dateStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String dateTimeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">parseLocalTime</span><span class="params">(String timeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate date, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime datetime, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datetime.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalTime</span><span class="params">(LocalTime time, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">formatLocalDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">formatLocalDateTime</span><span class="params">(String dateTimeStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">formatLocalTime</span><span class="params">(String longDateTimeStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(longDateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodHours</span><span class="params">(LocalDateTime startDateTime,LocalDateTime endDateTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Duration.between(startDateTime, endDateTime).get(ChronoUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodDays</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔周数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodWeeks</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.WEEKS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔月数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodMonths</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.MONTHS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔年数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodYears</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.YEARS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCurrentLocalDate().equals(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取时间日期的毫秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">localDateTimeToEpochMilli</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间毫秒数获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">epochMilliToLocalDateTime</span><span class="params">(Long timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Timestamp(timeMillis)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取Timestamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">localDateTimeToTimestamp</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Timestamp(dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Timestamp获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">localDateTimeToTimestamp</span><span class="params">(Timestamp timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp.toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为闰年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate.isLeapYear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBefore</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isBefore(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAfter</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isAfter(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间（整数年）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByYear</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusYears(years).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间(非整数年)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByMonth</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> monthValues)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusMonths(monthValues).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间相应注解"><a href="#时间相应注解" class="headerlink" title="时间相应注解"></a>时间相应注解</h1><h2 id="将返回时间转为指定字符串格式"><a href="#将返回时间转为指定字符串格式" class="headerlink" title="将返回时间转为指定字符串格式"></a>将返回时间转为指定字符串格式</h2><p>@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”, timezone = “GMT+8”)</p>
<h2 id="时间入参格式化"><a href="#时间入参格式化" class="headerlink" title="时间入参格式化"></a>时间入参格式化</h2><p>@DateTimeFormat(pattern = “yyyy-MM-dd”)</p>
<p>@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)</p>
]]></content>
      <categories>
        <category>JDK8新特性</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>时间</tag>
      </tags>
  </entry>
</search>
