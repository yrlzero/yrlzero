<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yrlzero.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="常见命令12345678redis-cli #链接客户端select dbnum #选择数据库flushdb #清除当前数据库数据flushall #清除所有数据库数据scan #游标扫描匹配的keyKEYS  # 查找所有符合给定模式 pattern 的 keydbsize #返回当前数据库的 key 的数量del # 删除给定的一个或多个 key">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-命令">
<meta property="og:url" content="http://yrlzero.github.io/2021/04/10/redis%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="yrl&#39;s blog">
<meta property="og:description" content="常见命令12345678redis-cli #链接客户端select dbnum #选择数据库flushdb #清除当前数据库数据flushall #清除所有数据库数据scan #游标扫描匹配的keyKEYS  # 查找所有符合给定模式 pattern 的 keydbsize #返回当前数据库的 key 的数量del # 删除给定的一个或多个 key">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-10T09:30:55.335Z">
<meta property="article:modified_time" content="2021-06-10T13:56:20.333Z">
<meta property="article:author" content="yrl">
<meta property="article:tag" content="db">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="nosql">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yrlzero.github.io/2021/04/10/redis%E5%91%BD%E4%BB%A4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis-命令 | yrl's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yrl's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yrlzero.github.io/2021/04/10/redis%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="yrl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yrl's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis-命令
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 17:30:55" itemprop="dateCreated datePublished" datetime="2021-04-10T17:30:55+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-10 21:56:20" itemprop="dateModified" datetime="2021-06-10T21:56:20+08:00">2021-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli #链接客户端</span><br><span class="line">select dbnum #选择数据库</span><br><span class="line">flushdb #清除当前数据库数据</span><br><span class="line">flushall #清除所有数据库数据</span><br><span class="line">scan #游标扫描匹配的key</span><br><span class="line">KEYS  # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">dbsize #返回当前数据库的 key 的数量</span><br><span class="line">del # 删除给定的一个或多个 key</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">      summary: Append a value to a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。</span><br><span class="line">      # 如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。</span><br><span class="line">      # 返回追加 value 之后， 键 key 的值的长度。</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">      summary: Count set bits in a string</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 对指定的bit索引位置区间的bit值进行统计</span><br><span class="line">  </span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">      summary: Perform bitwise operations between strings</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 在多个键（包含字符串值）之间执行按位操作并将结果存储在目标键中，operation支持四个按位运算：AND，OR，XOR和NOT</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">      summary: Find first bit set or clear in a string</span><br><span class="line">      since: 2.8.7</span><br><span class="line">      # 查找字符串中第一个设置为1或0的bit的索引位，从指定索引的左边开始寻找</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">      summary: Decrement the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值减去一。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行减一操作之后的值。</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">      summary: Decrement the integer value of a key by the given number</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 储存的整数值减去减量 decrement 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键在执行减法操作之后的值。</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">      summary: Get the value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值</span><br><span class="line">      # 如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">      summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回指定bit索引偏移量的值</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">      summary: Get a substring of the string stored at a key</span><br><span class="line">      since: 2.4.0</span><br><span class="line">      # 返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。</span><br><span class="line">      # 负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</span><br><span class="line">      # GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">      summary: Set the string value of a key and return its old value</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。</span><br><span class="line">      # 返回给定键 key 的旧值。</span><br><span class="line">      # 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil </span><br><span class="line">      # 当键 key 存在但不是字符串类型时， 命令返回一个错误。</span><br><span class="line">      </span><br><span class="line">  INCR key</span><br><span class="line">      summary: Increment the integer value of a key by one</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上一。</span><br><span class="line">      # 如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回键 key 在执行加一操作之后的值。</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">      summary: Increment the integer value of a key by the given amount</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为键 key 储存的数字值加上增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</span><br><span class="line">      # 如果键 key 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</span><br><span class="line">      # 本操作的值限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      # 返回在加上增量 increment 之后， 键 key 当前的值。</span><br><span class="line">      </span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">      summary: Increment the float value of a key by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为键 key 储存的值加上浮点数增量 increment 。</span><br><span class="line">      # 如果键 key 不存在， 那么 INCRBYFLOAT 会先将键 key 的值设为 0 ， 然后再执行加法操作。</span><br><span class="line">      # 如果命令执行成功， 那么键 key 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</span><br><span class="line">      # 无论是键 key 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</span><br><span class="line">      # 此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</span><br><span class="line">      # 当以下任意一个条件发生时， 命令返回一个错误：1）键 key 的值不是字符串类型。 2）键 key 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</span><br><span class="line">      </span><br><span class="line">  MGET key [key ...]</span><br><span class="line">      summary: Get the values of all the given keys</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回给定的一个或多个字符串键的值</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 同时为多个键设置值。</span><br><span class="line">      # 如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</span><br><span class="line">      # MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</span><br><span class="line">      # MSET 命令总是返回 OK </span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">      summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">      since: 1.0.1</span><br><span class="line">      # 当且仅当所有给定键都不存在时， 为所有给定键设置值。</span><br><span class="line">      # 即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</span><br><span class="line">      # MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</span><br><span class="line">      # 当所有给定键都设置成功时， 命令返回 1 ； 如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">      summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</span><br><span class="line">      # 命令在设置成功时返回 OK </span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">      summary: Set the string value of a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将字符串值 value 关联到 key 。</span><br><span class="line">      # 如果 key 已经持有其他值， SET 就覆写旧值， 无视类型</span><br><span class="line">      # 当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</span><br><span class="line">      #从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</span><br><span class="line">            EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</span><br><span class="line">            PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</span><br><span class="line">            NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</span><br><span class="line">            XX ： 只在键已经存在时， 才对键进行设置操作。</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">      summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">      since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">      summary: Set the value and expiration of a key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。</span><br><span class="line">      # 如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。</span><br><span class="line">      # SETEX 和SET EXPIRE这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">      summary: Set the value of a key, only if the key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。</span><br><span class="line">      # 若键 key 已经存在， 则 SETNX 命令不做任何动作</span><br><span class="line">      # SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</span><br><span class="line">      # 设置成功时返回 1 ， 设置失败时返回 0 。</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">      summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。</span><br><span class="line">      # 不存在的键 key 当作空白字符串处理。</span><br><span class="line">      # SETRANGE 命令会确保字符串足够长以便将 value 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, &quot;\x00&quot; )进行填充。</span><br><span class="line">      # 因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。</span><br><span class="line">      </span><br><span class="line">  STRLEN key</span><br><span class="line">      summary: Get the length of the value stored in a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回键 key 储存的字符串值的长度。</span><br><span class="line">      # 当键 key 不存在时， 命令返回 0 。</span><br><span class="line">      # 当 key 储存的不是字符串值时， 返回一个错误。</span><br></pre></td></tr></table></figure>

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">      summary: Delete one or more hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</span><br><span class="line">      # 被成功移除的域的数量，不包括被忽略的域。</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">      summary: Determine if a hash field exists</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 检查给定域 field 是否存在于哈希表 hash 当中。</span><br><span class="line">      # 在给定field存在时返回 1 ， 在给定field不存在时返回 0 。</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">      summary: Get the value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表中给定域的值。</span><br><span class="line">      # 如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">      summary: Get all the fields and values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，所有的域和值</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">      summary: Increment the integer value of a hash field by the given number</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 为哈希表 key 中的域 field 的值加上增量 increment 。</span><br><span class="line">      # 增量也可以为负数，相当于对给定域进行减法操作。</span><br><span class="line">      # 如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</span><br><span class="line">      # 如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</span><br><span class="line">      # 对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</span><br><span class="line">      # 本操作的值被限制在 64 位(bit)有符号数字表示之内。</span><br><span class="line">      </span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">      summary: Increment the float value of a hash field by the given amount</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 为哈希表 key 中的域 field 加上浮点数增量 increment </span><br><span class="line">      # 如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</span><br><span class="line">      # 如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</span><br><span class="line">      # 当以下任意一个条件发生时，返回一个错误：1)域 field 的值不是字符串类型 2)域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数</span><br><span class="line">      </span><br><span class="line">  HKEYS key</span><br><span class="line">      summary: Get all the fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中的所有域。</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">      summary: Get the number of fields in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中域的数量。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">      summary: Get the values of all the given hash fields</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中，一个或多个给定域的值。</span><br><span class="line">      # 如果给定的域不存在于哈希表，那么返回一个 nil 值。</span><br><span class="line">      # 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">      summary: Set multiple hash fields to multiple values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 同时将多个 field-value (域-值)对设置到哈希表 key 中</span><br><span class="line">      # 此命令会覆盖哈希表中已存在的域。</span><br><span class="line">      # 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate hash fields and associated values</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代哈希键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line">      # 返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">      summary: Set the string value of a hash field</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 将哈希表 hash 中域 field 的值设置为 value 。</span><br><span class="line">      # 如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</span><br><span class="line">      # 如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。</span><br><span class="line">      # 当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 </span><br><span class="line">      </span><br><span class="line">  HSETNX key field value</span><br><span class="line">      summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。</span><br><span class="line">      # 如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</span><br><span class="line">      # 如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</span><br><span class="line">      # 在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">      summary: Get the length of the value of a hash field</span><br><span class="line">      since: 3.2.0</span><br><span class="line">      # 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</span><br><span class="line">      # 如果给定的键或者域不存在， 那么命令返回 0 。</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">      summary: Get all the values in a hash</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回哈希表 key 中所有域的值。</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BLPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</span><br><span class="line">      # 如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值</span><br><span class="line">      </span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">      summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # BRPOP 是列表的阻塞式(blocking)弹出原语。</span><br><span class="line">      # 它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</span><br><span class="line">      # 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">      summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</span><br><span class="line">      # 当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</span><br><span class="line">      # 超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</span><br><span class="line">      # 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">      summary: Get an element from a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中，下标为 index 的元素。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">      summary: Insert an element before or after another element in a list</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后 。</span><br><span class="line">      # 当 pivot 不存在于列表 key 时，不执行任何操作，返回 -1 。</span><br><span class="line">      # 当 key 不存在时， key 被视为空列表，不执行任何操作，返回 0 。</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">      summary: Get the length of a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 的长度。</span><br><span class="line">      # 如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</span><br><span class="line">      # 如果 key 不是列表类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">      summary: Remove and get the first element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的头元素。</span><br><span class="line">      # 列表的头元素。 当 key 不存在时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">      summary: Prepend one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表头</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">      summary: Prepend a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">      summary: Get a range of elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</span><br><span class="line">      # 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</span><br><span class="line">      # 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span><br><span class="line">      # 如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表</span><br><span class="line">      # 如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">      summary: Remove elements from a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 根据参数 count 的值，移除列表中与参数 value 相等的元素。</span><br><span class="line">      # count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</span><br><span class="line">      # count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</span><br><span class="line">      # count &#x3D; 0 : 移除表中所有与 value 相等的值。</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">      summary: Set the value of an element in a list by its index</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将列表 key 下标为 index 的元素的值设置为 value 。</span><br><span class="line">      # 当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">      summary: Trim a list to the specified range</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">      summary: Remove and get the last element in a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回列表 key 的尾元素。</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">      summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</span><br><span class="line">      #     将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</span><br><span class="line">      #     将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</span><br><span class="line">      # 如果 source 不存在，值 nil 被返回，并且不执行其他动作。</span><br><span class="line">      # 如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">      summary: Append one or multiple values to a list</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个值 value 插入到列表 key 的表尾(最右边)。</span><br><span class="line">      # 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</span><br><span class="line">      # 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</span><br><span class="line">      # 当 key 存在但不是列表类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">      summary: Append a value to a list, only if the list exists</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</span><br><span class="line">      # 和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">      summary: Add one or more members to a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</span><br><span class="line">      # 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</span><br><span class="line">      # 当 key 不是集合类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">      summary: Get the number of members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 的基数(集合中元素的数量)。</span><br><span class="line">      # 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">      summary: Subtract multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合之间的差集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">      summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">      summary: Intersect multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的交集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line">      # 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">      summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 集合已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">      summary: Determine if a given value is a member of a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 判断 member 元素是否集合 key 的成员。</span><br><span class="line">      # 如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">      summary: Get all the members in a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回集合 key 中的所有成员。</span><br><span class="line">      # 不存在的 key 被视为空集合。</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">      summary: Move a member from one set to another</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 member 元素从 source 集合移动到 destination 集合。</span><br><span class="line">      # 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</span><br><span class="line">      # 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</span><br><span class="line">      # 当 source 或 destination 不是集合类型时，返回一个错误。</span><br><span class="line">      # 如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</span><br><span class="line"></span><br><span class="line">  SPOP key</span><br><span class="line">      summary: Remove and return a random member from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除并返回集合中的一个随机元素。</span><br><span class="line">      # 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</span><br><span class="line">      # 被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">      summary: Get one or multiple random members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</span><br><span class="line">      # 从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</span><br><span class="line">      #     如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</span><br><span class="line">      #     如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</span><br><span class="line">      # 该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</span><br><span class="line">      # 当 key 不是集合类型，返回一个错误。</span><br><span class="line">      # 被成功移除的元素的数量，不包括被忽略的元素。</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate Set elements</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代set键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">      summary: Add multiple sets</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回一个集合的全部成员，该集合是所有给定集合的并集。</span><br><span class="line">      # 不存在的 key 被视为空集。</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">      summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</span><br><span class="line">      # 如果 destination 已经存在，则将其覆盖。</span><br><span class="line">      # destination 可以是 key 本身。</span><br><span class="line">      # 结果集中的元素数量。</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">      summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 将一个或多个 member 元素及其 score 值加入到有序集 key 当中</span><br><span class="line">      # 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数。</span><br><span class="line">      # 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">      summary: Get the number of members in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">      summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">      summary: Increment the score of a member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 为有序集 key 的成员 member 的 score 值加上增量 increment 。</span><br><span class="line">      # 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</span><br><span class="line">      # 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</span><br><span class="line">      # 当 key 不是有序集类型时，返回一个错误。</span><br><span class="line">      # score 值可以是整数值或双精度浮点数</span><br><span class="line">      # member 成员的新 score 值，以字符串形式表示。</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</span><br><span class="line">      # WEIGHTS指定对应key的权重，redis该key对应值得分值乘上权重系数，再根据AGGREGATE聚合函数统计，默认相加</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">      summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递增(从小到大)来排序。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order )来排列。</span><br><span class="line">      # 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</span><br><span class="line">      # 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</span><br><span class="line">      # 如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</span><br><span class="line">      # 命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</span><br><span class="line">      # 可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</span><br><span class="line">      # 合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</span><br><span class="line">      # 特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX &lt;zset&gt; - + ， 命令将返回有序集合中的所有元素。</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score</span><br><span class="line">      since: 1.0.5</span><br><span class="line">      # 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</span><br><span class="line">      # 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</span><br><span class="line">      # 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</span><br><span class="line">      # min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</span><br><span class="line">      # 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</span><br><span class="line">      # 使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</span><br><span class="line">      # 如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">      summary: Remove one or more members from a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</span><br><span class="line">      # 当 key 存在但不是有序集类型时，返回一个错误。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">      summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      # 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</span><br><span class="line">      # 这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">      summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 移除有序集 key 中，指定排名(rank)区间内的所有成员。</span><br><span class="line">      # 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</span><br><span class="line">      # 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">      summary: Remove all members in a sorted set within the given scores</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</span><br><span class="line">      # 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</span><br><span class="line">      # 返回被移除的元素数量。</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">      summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，指定区间内的成员。</span><br><span class="line">      # 其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">      since: 2.8.9</span><br><span class="line">      #参见ZRANGEBYLEX，列表排列从大到小</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">      summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</span><br><span class="line">      # 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</span><br><span class="line">      # 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">      summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</span><br><span class="line">      # 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</span><br><span class="line">      # 使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # 用于迭代zset键中的键值对</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">      summary: Get the score associated with the given member in a sorted set</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 返回有序集 key 中，成员 member 的 score 值。</span><br><span class="line">      # 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">      summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</span><br><span class="line">      # 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</span><br><span class="line">      # 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</span><br><span class="line">      # 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</span><br><span class="line">      #     默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</span><br><span class="line">      # 保存到 destination 的结果集的基数。</span><br></pre></td></tr></table></figure>

<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @generic</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">      summary: Delete a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 删除给定的一个或多个 key 。</span><br><span class="line">      # 不存在的 key 会被忽略。</span><br><span class="line">      # 被删除 key 的数量。</span><br><span class="line">   </span><br><span class="line">  DUMP key</span><br><span class="line">      summary: Return a serialized version of the value stored at the specified key.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</span><br><span class="line">      # 序列化生成的值有以下几个特点：</span><br><span class="line">      #     它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</span><br><span class="line">      #     值的编码格式和 RDB 文件保持一致。</span><br><span class="line">      #     RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</span><br><span class="line">      # 序列化的值不包括任何生存时间信息。</span><br><span class="line">      # 如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">      summary: Determine if a key exists</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 检查给定 key 是否存在。</span><br><span class="line">      # 若 key 存在，返回 1 ，否则返回 0 。</span><br><span class="line"></span><br><span class="line">  EXPIRE key seconds</span><br><span class="line">      summary: Set a key&#39;s time to live in seconds</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</span><br><span class="line">      # 在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</span><br><span class="line">      # 可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</span><br><span class="line">      # 在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</span><br><span class="line">      # 使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</span><br><span class="line"></span><br><span class="line">  EXPIREAT key timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</span><br><span class="line">      # 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</span><br><span class="line">      # 如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</span><br><span class="line"></span><br><span class="line">  KEYS pattern</span><br><span class="line">      summary: Find all keys matching the given pattern</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 查找所有符合给定模式 pattern 的 key</span><br><span class="line">      #     KEYS * 匹配数据库中所有 key 。</span><br><span class="line">      #     KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span><br><span class="line">      #     KEYS h*llo 匹配 hllo 和 heeeeello 等。</span><br><span class="line">      #     KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</span><br><span class="line">      # KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</span><br><span class="line"></span><br><span class="line">  MIGRATE host port key destination-db timeout [COPY] [REPLACE]</span><br><span class="line">      summary: Atomically transfer a key from a Redis instance to another one.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</span><br><span class="line">      # 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</span><br><span class="line">      # 命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</span><br><span class="line">      # timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</span><br><span class="line">      # MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。当 IOERR 出现时，有以下两种可能：</span><br><span class="line">      #     key 可能存在于两个实例</span><br><span class="line">      #     key 可能只存在于当前实例</span><br><span class="line">      # 唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</span><br><span class="line">      # 如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）</span><br><span class="line"></span><br><span class="line">  MOVE key db</span><br><span class="line">      summary: Move a key to another database</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将当前数据库的 key 移动到给定的数据库 db 当中。</span><br><span class="line">      # 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</span><br><span class="line">      # 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</span><br><span class="line">      # 移动成功返回 1 ，失败则返回 0 。</span><br><span class="line">      </span><br><span class="line">  OBJECT subcommand [arguments [arguments ...]]</span><br><span class="line">      summary: Inspect the internals of Redis objects</span><br><span class="line">      since: 2.2.3</span><br><span class="line">      # OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</span><br><span class="line">      # OBJECT 命令有多个子命令：</span><br><span class="line">      #     OBJECT REFCOUNT &lt;key&gt; 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</span><br><span class="line">      #     OBJECT ENCODING &lt;key&gt; 返回给定 key 锁储存的值所使用的内部表示(representation)。</span><br><span class="line">      #     OBJECT IDLETIME &lt;key&gt; 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。</span><br><span class="line">      # 对象可以以多种方式编码：</span><br><span class="line">      #     字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</span><br><span class="line">      #     列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</span><br><span class="line">      #     集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</span><br><span class="line">      #     哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</span><br><span class="line">      #     有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</span><br><span class="line">      # 假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</span><br><span class="line">      # REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</span><br><span class="line"></span><br><span class="line">  PERSIST key</span><br><span class="line">      summary: Remove the expiration from a key</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</span><br><span class="line">      # 当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 </span><br><span class="line"></span><br><span class="line">  PEXPIRE key milliseconds</span><br><span class="line">      summary: Set a key&#39;s time to live in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PEXPIREAT key milliseconds-timestamp</span><br><span class="line">      summary: Set the expiration for a key as a UNIX timestamp specified in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</span><br><span class="line">      # 设置成功，返回 1 key 不存在或设置失败，返回 0</span><br><span class="line"></span><br><span class="line">  PTTL key</span><br><span class="line">      summary: Get the time to live for a key in milliseconds</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</span><br><span class="line">      #     当 key 不存在时，返回 -2 。</span><br><span class="line">      #     当 key 存在但没有设置剩余生存时间时，返回 -1 。</span><br><span class="line">      #     否则，以毫秒为单位，返回 key 的剩余生存时间。</span><br><span class="line">      # 在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</span><br><span class="line"></span><br><span class="line">  RANDOMKEY -</span><br><span class="line">      summary: Return a random key from the keyspace</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 从当前数据库中随机返回(不删除)一个 key 。</span><br><span class="line">      # 当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</span><br><span class="line"></span><br><span class="line">  RENAME key newkey</span><br><span class="line">      summary: Rename a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</span><br><span class="line">      # 当 newkey 已经存在时， RENAME 命令将覆盖旧值。</span><br><span class="line">      # 改名成功时提示 OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line">  RENAMENX key newkey</span><br><span class="line">      summary: Rename a key, only if the new key does not exist</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 当且仅当 newkey 不存在时，将 key 改名为 newkey 。</span><br><span class="line">      # 当 key 不存在时，返回一个错误。</span><br><span class="line">      # 修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</span><br><span class="line">     </span><br><span class="line">  RESTORE key ttl serialized-value [REPLACE]</span><br><span class="line">      summary: Create a key using the provided serialized value, previously obtained using DUMP.</span><br><span class="line">      since: 2.6.0</span><br><span class="line">      # 反序列化给定的序列化值，并将它和给定的 key 关联。</span><br><span class="line">      # 参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</span><br><span class="line">      # RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</span><br><span class="line">      # 如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</span><br><span class="line"></span><br><span class="line">  SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class="line">      summary: Incrementally iterate the keys space</span><br><span class="line">      since: 2.8.0</span><br><span class="line">      # SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</span><br><span class="line">      #     SCAN 命令用于迭代当前数据库中的数据库键。</span><br><span class="line">      #     SSCAN 命令用于迭代集合键中的元素。</span><br><span class="line">      #     HSCAN 命令用于迭代哈希键中的键值对。</span><br><span class="line">      #     ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</span><br><span class="line">      # 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</span><br><span class="line">      # 不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</span><br><span class="line"></span><br><span class="line">  SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]</span><br><span class="line">      summary: Sort the elements in a list, set or sorted set</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</span><br><span class="line">      # 排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</span><br><span class="line">      # 最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</span><br><span class="line">      #     SORT key 返回键值从小到大排序的结果。</span><br><span class="line">      #     SORT key DESC 返回键值从大到小排序的结果。</span><br><span class="line">      # 因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符。</span><br><span class="line">      # 如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</span><br><span class="line">      # 排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</span><br><span class="line">      #     offset 指定要跳过的元素数量。</span><br><span class="line">      #     count 指定跳过 offset 个指定的元素之后，要返回多少个对象。</span><br><span class="line">      # 其他玩法请自行查阅资料</span><br><span class="line"></span><br><span class="line">  TTL key</span><br><span class="line">      summary: Get the time to live for a key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</span><br><span class="line">      # 当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</span><br><span class="line"></span><br><span class="line">  TYPE key</span><br><span class="line">      summary: Determine the type stored at key</span><br><span class="line">      since: 1.0.0</span><br><span class="line">      # 返回 key 所储存的值的类型。</span><br><span class="line"></span><br><span class="line">  WAIT numslaves timeout</span><br><span class="line">      summary: Wait for the synchronous replication of all the write commands sent in the context of the current connection</span><br><span class="line">      since: 3.0.0</span><br><span class="line">      # 等待在当前连接上下文中发送的所有写命令的同步复制</span><br></pre></td></tr></table></figure>

<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">      summary: Discard all commands issued after MULTI</span><br><span class="line">      since: 2.0.0</span><br><span class="line">      # 取消事务，放弃执行事务块内的所有命令。</span><br><span class="line">      # 如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">      summary: Execute all commands issued after MULTI</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 执行所有事务块内的命令。</span><br><span class="line">      # 假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">      summary: Mark the start of a transaction block</span><br><span class="line">      since: 1.2.0</span><br><span class="line">      # 标记一个事务块的开始。</span><br><span class="line">      # 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">      summary: Forget about all watched keys</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 取消 WATCH 命令对所有 key 的监视。</span><br><span class="line">      # 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</span><br><span class="line">      # 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">      summary: Watch the given keys to determine execution of the MULTI&#x2F;EXEC block</span><br><span class="line">      since: 2.2.0</span><br><span class="line">      # 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br></pre></td></tr></table></figure>

<h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD key ...options...</span><br><span class="line">    # 添加key到bloom中</span><br><span class="line"></span><br><span class="line">BF.EXISTS key ...options...</span><br><span class="line">	# 判断是否存在对应的key</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/db/" rel="tag"># db</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
              <a href="/tags/nosql/" rel="tag"># nosql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/31/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACHashMap-ConcurrentHashMap%E5%8C%BA%E5%88%AB/" rel="prev" title="不同版本HashMap和ConcurrentHashMap区分">
      <i class="fa fa-chevron-left"></i> 不同版本HashMap和ConcurrentHashMap区分
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/10/redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="next" title="redis-布隆过滤器">
      redis-布隆过滤器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见命令"><span class="nav-text">常见命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sorted-Set"><span class="nav-text">Sorted Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generic"><span class="nav-text">Generic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactions"><span class="nav-text">Transactions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BloomFilter"><span class="nav-text">BloomFilter</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yrl"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">yrl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yrl</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
</body>
</html>
